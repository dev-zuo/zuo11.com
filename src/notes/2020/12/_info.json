[
  {
    "source": "xx.github.io仓库配置Github pages后对其他仓库Github pages的影响.md",
    "staticFileName": "github-io.html",
    "author": "guoqzuo",
    "createDate": "2020/12/07",
    "description": "在 github 中，假设我们创建了 'github用户名.github.io' 仓库，开启 Github Pages 后，访问该域名，就指向了这个仓库的文件。这时如果你的其他仓库也开启了 Github Pages，那么对于的目录解析可能会有问题。以我的 github 账号 zuoxiaobai 为例，如果 zuoxiaobai.github.io 这个仓库开启 pages，再把另一个仓库 zuo-blog 也开启 pages，那么访问 `https://zuoxiaobai.github.io/zuo-blog/` 并不能自动跳转到对应的 index.html，而是提示 404。需要访问 `https://zuoxiaobai.github.io/zuo-blog/index.html` 才行。这里我直接把 zuoxiaobai.github.io 的仓库关掉了 Github Pages。这样 `https://zuoxiaobai.github.io/zuo-blog/` 才能自动解析目录下的 index.html。",
    "keywords": "github.io仓库开启pages后对其他仓库pages的影响",
    "category": "运维部署与版本控制"
  },
  {
    "source": "GitHub Pages使用自定义域名开启HTTPS，配置CNAME解析.md",
    "staticFileName": "github_pages_https.html",
    "author": "guoqzuo",
    "createDate": "2020/12/07",
    "description": "一般在仓库的 Setting 中，开启 Github Pages 会生成一个 `xxx.github.io/xx/` 的地址，地址有点长，我们可以使用自定义域名，这里我将 vue-chart 这个仓库设置成了自定义域名 vuechart.zuo11.com。然后，我们需要把自定义的域名解析到 github.com 地址。可以使用 ping github.com 来获取它的服务器 IP。",
    "keywords": "github pages https",
    "category": "运维部署与版本控制"
  },
  {
    "source": "docsify嵌入vue echarts组件无法显示图表的问题.md",
    "staticFileName": "dosify_vue_echarts.html",
    "author": "guoqzuo",
    "createDate": "2020/12/07",
    "description": "在使用 docsify 自带的 vue 功能加载 echarts 相关的 vue 组件时，图表都无法正常显示。后来打印 log 发现，最终渲染到页面的 echarts div并不是 vue 初始化之后，进行绘制的 div，而是一个拷贝后的副本，所以图片显示不出来。 需要使用 vuep 插件才行。实例参考 https://vuechart.zuo11.com，效果如下图:",
    "keywords": "docsify echarts vue组件无法正常显示",
    "category": "Vue"
  },
  {
    "source": "vscode配置了自动fix突然失效了，或者一直生效不了，怎么看对应的log.md",
    "staticFileName": "vscode_eslint_log.html",
    "author": "guoqzuo",
    "createDate": "2020/12/07",
    "description": "你是否会遇到下面的问题：在 vscode 里面安装了 eslint 插件后，正确设置了保存后自动 fix 参数，但没有生效。或者之前是生效的。忽然就不生效了。只要你的配置是没有问题的，那就是插件以来的包加载异常了，一般都重启几次就Ok了。那怎么看 eslint 对应的log呢？可以分下面两步 1. 点击 vscode 右下角的错误信息、警告信息图标，看是信息里是否有 eslint 相关报 2. 点击 输出 - 选择 ESLint 就可以看 ESLint 相关 log 了。",
    "keywords": "vscode eslit log",
    "category": "计算机基础与开发工具"
  },
  {
    "source": "两种方法解决Error: Cannot find module 'webpack-cli-bin-config-yargs'.md",
    "staticFileName": "webpack_dev_server_err.html",
    "author": "guoqzuo",
    "createDate": "2020/12/07",
    "description": "两种方法解决Error: Cannot find module 'webpack-cli/bin/config-yargs', 在运行 webpack-dev-server 这个命令时，如果出现了 Error: Cannot find module 'webpack-cli/bin/config-yargs' 这个错误，是因为默认情况下 webpack-dev-server 执行依赖 webpack-cli 包目录下的 bin/config-yargs，但 webpack-cli 4.1.0 的版本，做了一些调整，删除了这个文件，导致了这个错误。",
    "keywords": "Error: Cannot find module 'webpack-cli/bin/config-yargs'",
    "category": "前端工程化"
  },
  {
    "source": "console.log 打印带样式的文字、图片.md",
    "staticFileName": "console_style_img.html",
    "author": "guoqzuo",
    "createDate": "2020/12/07",
    "description": "console.log 的第一个参数中，如果有 '%c'，表示设置样式，会将第二个参数的 css 样式字符串应用到第一个参数的内容中 console.log('%c文字', 'css样式') 这样可以打印绿色的文字 console.log('%cSuccess!', 'color: green')，不仅可以设置文字颜色，还可以通过设置 background-color 在控制台显示图片",
    "keywords": "console.log打印样式文字,console.log打印图片",
    "category": "JavaScript"
  },
  {
    "source": "JS 判断两个日期是否是同一周，带单元测试.md",
    "staticFileName": "js_same_week.html",
    "author": "guoqzuo",
    "createDate": "2020/12/07",
    "description": "给定两个日期，怎么判断他们是同一周呢？核心是 **所有时间都是从 1970年1月1日(周4) 开始，计算出当前时间距离该日期的天数，再用 (天数 + 4)/7 就是周数，如果相同则是同一周**，这里会有一个特殊情况，就是周日的时候，需要特殊处理。判断时只需要日期，不要输入时间，默认都是以 '08:00:00' 为准。",
    "keywords": "判断两个时间是否是同一周,判断两个日期是否是同一周",
    "category": "JavaScript"
  },
  {
    "source": "JS 使用 localeCompare 函数对中文进行首字母排序.md",
    "staticFileName": "js_chinese_sort.html",
    "author": "guoqzuo",
    "createDate": "2020/12/07",
    "description": "String.prototype.localeCompare(compareString[, locales[, options]]) 该方法用于对字符串进行排序。第二个参数 locales 可以指定语言，中文排序传 'ch' 即可。它的返回值为 -1, 1, 0 ，与 sort 自定义排序的返回值基本一致。来看一个例子",
    "keywords": "js中文按首字母排序,前端中文按首字母排序,前端中文排序",
    "category": "JavaScript"
  },
  {
    "source": "使用 VuePress 生成静态网站并部署到 Github Pages.md",
    "staticFileName": "vuepress.html",
    "author": "guoqzuo",
    "createDate": "2020/12/15",
    "description": "VuePress 是一个静态网站生成器，诞生初衷是为了支持 Vue 及其子项目的文档需求。目前 Vue 相关文档都是由 vuepress 搭建。相比其他静态站点生成工具，Docsify 是运行时驱动，通过 JS 加载内容，对 SEO 不够友好。VuePress 类似于 Hexo，主要区别是 VuePress 是由 Vue 驱动。",
    "keywords": "VuePress,VuePress 创建网站,vuepress 使用",
    "category": "Vue"
  },
  {
    "source": "VuePress 复选框、任务列表不生效怎么处理.md",
    "staticFileName": "vuepress_tasklist.html",
    "author": "guoqzuo",
    "createDate": "2020/12/15",
    "description": "在写 markdown 笔记时，复选框、任务列表（task list）功能在本地 Typora 是生效的，但在 VuePress 中无法正常显示。于是在 Github 对应的 issue 里面搜索 Task lists，找到了解决方法：需要安装一个 markdown 插件 `markdown-it-task-lists`",
    "keywords": "VuePress复选框显示不正常,VuePress任务列表,VuePress Task list",
    "category": "Vue"
  },
  {
    "source": "外部链接 a 标签为什么要加 noreferer 与 noopener ？.md",
    "staticFileName": "a_noreferrer.html",
    "author": "guoqzuo",
    "createDate": "2020/12/15",
    "description": "一般页面的外部链接 a 标签都会加上 ref='noreferrer noopener'，这样可以避免一些安全问题，下面通过几个问题来具体看看 1. a 标签加上 noreferrer 和 noopener 后会有什么效果？2. Referer 是什么？有什么应用场景? 3. window.opener 可以做什么？",
    "keywords": "noreferrer和noopener,noreferrer,noopener",
    "category": "http与https"
  },
  {
    "source": "防盗链时需要注意搜索引擎 Referer，百度和 Google 搜索内容跳转链接之间的区别.md",
    "staticFileName": "search_referer.html",
    "author": "guoqzuo",
    "createDate": "2020/12/15",
    "description": "一般搜索引擎为了方便网页做来源分析，不会使用 noreferer，因此从搜索引擎进入页面时，会携带对应的 Referer。当首页 index.html 也放在 CDN 的情况时，做防盗链 Referer 白名单时，要记得放开搜索引擎的相关 Referer。下面分两个部分介绍搜索引擎跳转链接的处理 1. 百度搜索结果链接的跳转方式 2. Google搜索结构链接的跳转方式",
    "keywords": "防盗链需要注意搜索引擎,百度和Google搜索跳转链接区别",
    "category": "http与https"
  },
  {
    "source": "JS 数据类型有多少种，有哪些细节需要注意的？.md",
    "staticFileName": "js_data_type.html",
    "author": "guoqzuo",
    "createDate": "2020/12/15",
    "description": "ES3 有 5 种基本数据类型：null、undefined、boolean、number、string；1 种复杂数据类型 object。ES6+ 后面新增了两种基本数据类型：Symbol, Bigint。如果把函数 function 也算作一种数据类型，就是 9 种。需要注意的是：- typeof 数组值为 `object`，typeof 函数值为 `function`, typeof null 值为 `object`，本质上其实有 9 种数据类型。- new String('12') 是字符串对象，不是 string，new Number(1) 是数字对象，不是 number，new Boolean(false) 是对象，不是 boolean",
    "keywords": "js数据类型有多少种,js数据类型,js data type",
    "category": "JavaScript"
  },
  {
    "source": "getElementsByTagName 结果为什么不可以 forEach ？和 querySelectorAll 有什么区别.md",
    "staticFileName": "dom_arr_forEach.html",
    "author": "guoqzuo",
    "createDate": "2020/12/15",
    "description": "在 JS DOM 编程艺术的例子中，看到 `document.getElementsByTagName` 后使用了 `Array.from(xx)` 将其结果转为标准数组后再使用 `forEach`。下面写个例子来验证为什么？从上面的例子中，我们可以看到 `getElementsByTagName` 函数返回的数据类型是 `HTMLCollection`，类数组对象，并没有实现 forEach 方法，但它内部实现了迭代 for...of（Symbol.iterator）方法，因此可以使用 for、for...of 来遍历",
    "keywords": "getElementsByTagName,querySelectorAll",
    "category": "JavaScript"
  },
  {
    "source": "Promise.all、race 实现，函数作为参数时的简写.md",
    "staticFileName": "promise_all_abbr.html",
    "author": "guoqzuo",
    "createDate": "2020/12/15",
    "description": "一般函数当参数时，有一种情况可以直接简写，例子如下 func(data => { console.log(data) })，可以简写为 func(console.log) 下面来看看在 Promise.all 和 Promise.race 实现中的应用",
    "keywords": "Promise.all实现,Promise.race实现,函数参数简写",
    "category": "JavaScript"
  },
  {
    "source": "JS 事件循环, Promise.then 与 setTimeout 执行顺序问题.md",
    "staticFileName": "js_eventloop.html",
    "author": "guoqzuo",
    "createDate": "2020/12/15",
    "description": "来看一个 demo 的执行顺序，执行顺序是：2 3 5 4 1，我们知道 setTimeout 与 Promise.then 的回调都是异步的。setTimeout 的执行函数是先 push 到任务队列的，而 Promise.then 的回调是后面 push 的。为什么 Promise.then 的回调先执行呢？这里涉及到 JS 事件循环中 **宏任务** 与 **微任务**。- 宏任务：同步任务、I/O(比如文件读写等)、setTimeout、setInterval、requestAnimationFrame 等 - 微任务：Promise.then/catch/finally、generator、async/await、MutationObserver 等。某个宏任务执行 ok 后，会先看微任务事件队列里是否有任务，有就执行，然后才是宏任务队列。",
    "keywords": "宏任务与微任务,JS 事件循环",
    "category": "JavaScript"
  },
  {
    "source": "DOMContentLoaded 与白屏, performance timing.md",
    "staticFileName": "white-screen.html",
    "author": "guoqzuo",
    "createDate": "2020/12/30",
    "description": "白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素，首屏时间 = 地址栏输入网址后回车 - 浏览器第一屏渲染完成。一般页面白屏结束的时间节点在 head 结束，body 开始执行时。可以通过 `window.performance.timing` 这个对象来看具体时间。",
    "keywords": "白屏时间计算,DOMContentLoaded与白屏",
    "category": "JavaScript"
  },
  {
    "source": "通过 performance.timing 简单理解浏览器输入 url 到页面显示全过程.md",
    "staticFileName": "performance-timing.html",
    "author": "guoqzuo",
    "createDate": "2020/12/30",
    "description": "performance.timing 记录了在浏览器中输入 url 到页面显示整个过程中各个关键节点的时间。包括：网页重定向的耗时、检查本地缓存的耗时、DNS查询的耗时、TCP连接的耗时、dom 加载完成的时间、页面 load 的总耗时等。performance.timing 是 PerformanceTiming 对象的实例。下面我们通过了解 performance.timing 各个字段的意思来实现下面图片的功能。",
    "keywords": "浏览器输入 url 到页面显示全过程,performance.timing各字段详解",
    "category": "JavaScript"
  },
  {
    "source": "字符串原始类型不是对象，为什么可以使用点语法运行方法.md",
    "staticFileName": "string-base.html",
    "author": "guoqzuo",
    "createDate": "2020/12/30",
    "description": "理论上，原始值本身不是对象，逻辑上是不能有属性、方法的。那为什么字符串可以使用点语法执行 substring 等方法呢？下面的例子中，第 2 行可以正常执行。主要是 JS 内部在后台进行了一些处理。在执行到第 2 行时 1. 临时创建一个 String 类型的实例 `let t = new String('some text')` 2. 调用实例上的特定方法 `s2 = t.substring(2)` 3. 销毁实例 `t = null`",
    "keywords": "基本包装类型,原始类型不是对象为什么可以执行方法",
    "category": "JavaScript"
  },
  {
    "source": "element.childNodes 和 element.children 有什么区别.md",
    "staticFileName": "childNodes-children.html",
    "author": "guoqzuo",
    "createDate": "2020/12/30",
    "description": "元素的 childNodes 和 children 属性都是用于获取元素子节点，他们返回值都是类数组对象，且都是活动对象（当节点变更后，值也会动态变更）。但有以下区别：1. childNodes 获取的子节点包含所有节点类型，比如注释节点、文本节点、换行空白符文本节点，而 children 仅包含元素类型的子节点。2. childNodes 类型是 NodeList，HTMLCollection 类型是 HTMLCollection",
    "keywords": "childNodes与children,childNodes children区别",
    "category": "JavaScript"
  },
  {
    "source": "HTMLCollection 和 NodeList 有什么区别.md",
    "staticFileName": "HTMLCollection-NodeList.html",
    "author": "guoqzuo",
    "createDate": "2020/12/30",
    "description": "在获取 dom 节点结集合时，有的 API 返回的是 HTMLCollection 类型，有的是 NodeList 类型。他们有什么区别呢？下来看看具体的 API。HTMLCollection 和 NodeList 的相同点：1. 它们都是表示节点集合的类数组对象，都可以是活动对象（实时监听 dom 变化并修改值） 2. 它们都有 length 属性，都可以通过 item() 和数组下标的方式访问内部元素。都实现了 Symbol.iterator 迭代器方法（可以被 for...of 遍历）",
    "keywords": "HTMLCollection,NodeList,HTMLCollection与NodeList区别",
    "category": "JavaScript"
  },
  {
    "source": "使用 hash 滚动页面时，被顶部 fixed 区域遮挡怎么解决.md",
    "staticFileName": "hash_scroll_fixed.html",
    "author": "guoqzuo",
    "createDate": "2020/12/30",
    "description": "一般页面 URL 的 hash 值变化后，如果当前页面中存在 id 为该 hash 值的元素，页面会滚动到该区域。下面的例子中，点击跳转到h1，页面会滚动到 h1 元素，元素对齐到顶部。**这里有一个问题，如果顶部导航栏是 fixed 固定的，那使用这种方法滚动时，h1 标题会被导航栏遮挡。**后来使用 VuePress 时，发现跳转的时候没有遮挡，于是审查元素，看了下样式。发现使用一个 css 就可以解决这个问题。 **给需要定位到该 id 的元素加一个超过导航栏高度的 padding-top，再加一个保持元素位置的 margin-top，这样使用 hash 滚动到该 id 元素时，就不会有遮挡，会与顶部保持 padding 的距离**",
    "keywords": "hash滚动被fixed区域遮挡,fixed遮挡a标签滚动怎么解决",
    "category": "CSS"
  },
  {
    "source": "前端低代码框架 amis，通过 JSON 配置生成页面.md",
    "staticFileName": "low-code-amis.html",
    "author": "guoqzuo",
    "createDate": "2020/12/30",
    "description": "什么是低代码开发平台？ (LCDP，Low-Code Development Platform)，是无需编码（0代码）或通过少量代码就可以快速生成应用程序的开发平台。对于比较简单的、通用的页面可以自动生成代码。amis 就是这样的一个框架。可以根据 JSON 配置，自动生成页面，而且还支持在线可视化编辑。对于简单、通用、不需要定制化开发的情况，可以直接使用。",
    "keywords": "低代码开发平台,amis,根据json生成页面",
    "category": "计算机基础与开发工具"
  },
  {
    "source": "git 修改文件内容后误删了该文件，再使用 git 还原该文件，修改的文件内容丢失怎么办？.md",
    "staticFileName": "git_edit_loss.html",
    "author": "guoqzuo",
    "createDate": "2020/12/30",
    "description": "最近修改某个文件后，还没将改动提交到 git，中途不小心删了该文件。然后想着恢复文件，就使用 git 恢复该文件。这个时候发现未提交的修改内容都丢失了，文件内容是 git 上最近的内容。这种情况，理论上 git 是无法还原的。因为没有提交，git 不会记录对应的内容。我们不能总是想着使用 git 怎么恢复，需要换一下思路。**修改的文件删除后，默认会存在废纸篓(回收站)，去里面找即可。**",
    "keywords": "git修改内容丢失怎么恢复,git修改内容未提交误删后怎么恢复",
    "category": "运维部署与版本控制"
  }
]








