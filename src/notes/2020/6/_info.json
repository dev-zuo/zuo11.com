[
    {
      "source": "使用new Date()在前端获取当期时间是不准确的.md",
      "staticFileName": "new_date_fe.html",
      "author": "guoqzuo",
      "createDate": "2020/06/21",
      "description": "一般我们在前端开发中，经常会用到new Date()来获取当前时间，但我们要知道：new Date()是获取的当前操作系统的时间，它是不准确的？",
      "keywords": "前端获取当前时间是不准确的,new Date()获取当前时间不准确,new Date()获取当前时间是当前操作系统的时间",
      "category": "计算机基础与开发工具"
    },
    {
      "source": "开发个人微信小程序前必看，个人主体可以做什么内容.md",
      "staticFileName": "mp_personal_cando.html",
      "author": "guoqzuo",
      "createDate": "2020/06/21",
      "description": "微信小程序很早就已经开放个人主体了，也就是个人也可以上传发布小程序。但现在个人主体小程序可以做的内容越来越少了，相信很多微信小程序的开发者都遇到过这种情况：好不容易做好了小程序，结果准备提交审核上线时，由于类目问题，审核被拒，无法上线的情况。",
      "keywords": "开发个人微信小程序前必看,小程序个人主体可以做什么内容,个人小程序审核被拒",
      "category": "微信开发"
    },
    {
      "source": "github tag标签图片以及npm badge图片生成.md",
      "staticFileName": "github_badge_img.html",
      "author": "guoqzuo",
      "createDate": "2020/06/21",
      "description": "在github写readme时，最开始一般会贴一些tab标签(徽章图片)，比如 build passing，license MIT 等，注意这些都是引入的图片，npm badge也是类似的情况下面来看看",
      "keywords": "github tag标签图片,readme badge,npm badge",
      "category": "计算机基础与开发工具"
    },
    {
      "source": "利用koa来彻底理解web前端跨域问题.md",
      "staticFileName": "koa_web_cros.html",
      "author": "guoqzuo",
      "createDate": "2020/06/21",
      "description": "JS高程3中在Ajax那一章里有详细的讲解跨域的问题，由于是纯理论，之前看时只是了解个大概。之后学会了koa后，用koa来写测试接口模拟跨域的场景，对跨域问题有了更深层次的理解，下面来对跨域的相关知识点进行整理、回顾，并写demo做一些测试",
      "keywords": "web前端跨域问题,web跨域,前端跨域,请求预检,cros,跨域资源共享",
      "category": "http与https"
    },
    {
      "source": "Invalid character in header content ['Content-Disposition'].md",
      "staticFileName": "content-dispositon.html",
      "author": "guoqzuo",
      "createDate": "2020/06/21",
      "description": "在koa中，如果Content-Disposition里设置文件名有中文会提示错误，需要用类似 encodeURIComponent 转码的函数转码后才行，这里顺便介绍下encodeURIComponent和encodeURI的区别",
      "keywords": "Invalid character in header content ['Content-Disposition'],URI和URL的区别,encodeURIComponent和encodeURI的区别,encodeURI和encodeURIComponent区别",
      "category": "http与https"
    },
    {
      "source": "windows下nginx部署https服务实战.md",
      "staticFileName": "nginx_https.html",
      "author": "guoqzuo",
      "createDate": "2020/06/21",
      "description": "这里复盘下将koa写的接口服务部署到`https://api.zuo11.com`上，相关nginx配置的全流程",
      "keywords": "nginx部署https服务,nginx https",
      "category": "运维部署与版本控制"
    },
    {
      "source": "css hover后改变其他元素样式.md",
      "staticFileName": "css_hover.html",
      "author": "guoqzuo",
      "createDate": "2020/06/29",
      "description": "css中某个元素hover后，可以对其他元素设置样式，但注意：只限定于改变他的子元素, 以及其后面的元素，下面我们写demo来看看",
      "keywords": "css hover后改变其他元素样式,css 元素hover后设置其他元素样式",
      "category": "css"
    },
    {
      "source": "vue封装组件时预留install函数便于Vue.use全局引入.md",
      "staticFileName": "vue_use_install.html",
      "author": "guoqzuo",
      "createDate": "2020/06/29",
      "description": "在element组件中，我们使用el-input等element元素时，不需要在components里引入。为什么呢？在引入element时，我们有在mian.js里我们使用了Vue.use(elemnt组件)，这样进行了全局注入组件，相当于组件做成了一个vue插件，如果我们自己封装组件如何能够在Vue.use后直接可以全局调用呢？",
      "keywords": "vue封装组件时预留install函数,element组件为什么use后可以直接使用",
      "category": "vue"
    },
    {
      "source": "vue自定义组件使用v-model指令实现dialog组件的二次封装.md",
      "staticFileName": "v_model_dialog.html",
      "author": "guoqzuo",
      "createDate": "2020/06/29",
      "description": "当某个组件是对element的dialog组件进行二次封装时，我们需要对dialog进行隐藏显示，当子组件里的dialog关闭时，需要修改父组件传入的值，尽管不是表单组件也可以使用v-model来解决，先来看看怎么调用",
      "keywords": "v-model属性实现dialog组件的二次封装,element dialog组件的二次封装",
      "category": "vue"
    },
    {
      "source": "vue封装组件方式的思考.md",
      "staticFileName": "vue_component_think.html",
      "author": "guoqzuo",
      "createDate": "2020/06/29",
      "description": "在封装组件时，一般我们使用的方法是：把组件单独放到一个xx.vue，然后需要引入时在components使用懒加载引入再使用，我就在想，每次引入组件都需要三步：1. 把组件通过 components 引入 2. 在template中写对应的代码 3. 在data中写对应的数据，methods里写绑定的事件。会不会太麻烦了，我希望像element的组件那样，通过 this.$message.error(e.message) 这样直接调用一个组件",
      "keywords": "vue封装组件思考,vue封装组件总结",
      "category": "vue"
    },
    {
      "source": "他人提交了package-lock.json的更新导致拉取时和本地冲突的问题.md",
      "staticFileName": "git_package_lock.html",
      "author": "guoqzuo",
      "createDate": "2020/06/29",
      "description": "一般在npm install 时会修改package-lock.json文件，我一般不会提交这个更新，但今天发现有人提交。我拉取时，提示这个文件冲突，导致拉取不下来，我又不想提交更新，所以尝试用下面的命令，将工作区该文件的修改丢弃，再拉取",
      "keywords": "是否要提交package-lock.json",
      "category": "运维部署与版本控制"
    },
    {
      "source": "git commit提交信息有误怎么修改.md",
      "staticFileName": "git_comit_amend.html",
      "author": "guoqzuo",
      "createDate": "2020/06/29",
      "description": "如果不小心提交了，但没有push，可以使用--amend参数来修改上一次的commit信息，命令如下：git commit --amend -m 'xxx', 注意，一般是修改没有push前的提交信息",
      "keywords": "git commit提交信息修改,commit备注信息有误怎么修改",
      "category": "运维部署与版本控制"
    },
    {
      "source": "webpack与parcel区别.md",
      "staticFileName": "webpack_parcel_difference.html",
      "author": "guoqzuo",
      "createDate": "2020/06/29",
      "description": "webpack与parcel都是打包工具, webpack功能强大，但比较重，配置项比较多, 有点繁琐。而parcel就是为了解决配置项太多这个问题的，它默认集成了通用的常规功能，零配置，如果自定义较多，还是推荐webpack",
      "keywords": "webpack与parcel区别,parcel与webpack区别,webpack parcel difference",
      "category": "前端工程化"
    },
    {
      "source": "Node.js的核心用处及应用场景.md",
      "staticFileName": "nodejs_uses.html",
      "author": "guoqzuo",
      "createDate": "2020/06/29",
      "description": "Node.js是一个基于chrome v8引擎的js运行时，那他一般有什么用处呢，下面来看看。node三个核心应用场景：1.打包构建、工程化 2.写后台接口 3.综合应用：获取数据+渲染页面(高并发、高性能)",
      "keywords": "Node.js的核心用处及应用场景,node使用场景,node应用场景,node应用",
      "category": "前端工程化"
    }
]









