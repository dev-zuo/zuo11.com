
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">

        <meta name="application name" content="http_download_progress.html">
        <meta name="author" content="guoqzuo">
        <meta name="description" content="在前端做导出功能的时候，需要请求一个接口去导出数据，一般是execl，然后接口会返回execl的文件数据。对于比较大的文件，我们怎么获取文件的下载进度呢？前端怎么用koa来mock导出的接口呢？下面来看看">
        <meta name="keywords" content="下载文件进度,axios下载文件进度,下载接口mock,koa导出文件接口,前端下载进度,进度信息total为0，只有loaded的情况">

        <title>下载文件进度显示以及koa下载接口mock - 左小白的技术日常</title>
        <link rel="shortcut icon" href="/images/favicon.ico">
        <link href="/lib/prismjs/prism_default.css" rel="stylesheet" />
        <link href="/lib/notes.css" rel="stylesheet" />
        
      </head>
      <body>
        <header>
          <div>
            <img src="/images/logo.png" width="24" height="24" class="pointer" onclick="gotoIndex()" />
            <span class="pointer" onclick="gotoIndex()">左小白的技术日常</span>
            <span class="hidden"> | </span>
            <a href="/blog/category.html#http与https" class="hidden">http与https</a>
          </div>
          <div>
            
          <a href="https://www.yuque.com/guoqzuo" target="_black" class="hidden">语雀</a>
        
          <a href="https://github.com/zuoxiaobai" target="_black" class="">Github</a>
        
          </div>
        </header>
        <section class="content">
          <article>
            
    <div class="article-top">
      <div>2019/10/18</div> 
      <div class="article-top-right">Author: guoqzuo</div>
    </div>
  
            <h1 id="下载文件进度显示以及koa下载接口mock">下载文件进度显示以及koa下载接口mock</h1>
<p>在前端做导出功能的时候，需要请求一个接口去导出数据，一般是execl，然后接口会返回execl的文件数据。对于比较大的文件，我们怎么获取文件的下载进度呢？前端怎么用koa来mock导出的接口呢？下面来看看</p>
<h2 id="前端代码">前端代码</h2>
<p>用input写一个导出按钮，用progress div来显示进度信息</p>
<pre><code class="language-html">&lt;input type=&quot;button&quot; value=&quot;导出&quot; id=&quot;export&quot;&gt;
&lt;div id=&quot;progress&quot;&gt;&lt;/div&gt;</code></pre>
<p>再用js来监听导出的点击事件，如果用传统的window.open来打开文件，这样会没有进度信息，我们为了获取进度信息，还是直接用axios来发起请求进行下载文件，下面来看代码:</p>
<pre><code class="language-html">&lt;!-- 利用axios来做请求 --&gt;
&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  let exportBtn = document.getElementById(&#39;export&#39;)
  let progress = document.getElementById(&#39;progress&#39;)
  // 导出事件点击
  exportBtn.onclick = async (e) =&gt; {
    try {
      let res = await axios.get(&#39;/download&#39;, {
        // 参考: https://github.com/axios/axios#request-config
        onDownloadProgress: function (progressEvent) {
          // Do whatever you want with the native progress event
          console.log(progressEvent)
          progress.innerHTML = `
          下载百分比:
          ${ Math.floor((progressEvent.loaded / progressEvent.total) * 100)} %
          ${progressEvent.loaded} / ${progressEvent.total}
          `
        },
      })
      console.log(res)

      // res.data 为文件的buffer数据，将buffer数据转为Blob对象，然后再下载
      // 假设下载的是一个x-tar文件
      // 下载文件
      downloadFile(res.data, &#39;application/x-tar&#39;, &#39;这是一个文件&#39;)
    } catch(e) {
      console.error(e)
    }
  }
&lt;/script&gt;</code></pre>
<h2 id="通用下载函数">通用下载函数</h2>
<p>一般使用a便签来下载，IE进行特殊处理</p>
<pre><code class="language-js">// data 后端返回的文件数据
function downloadFile(data, fileType, fileName) {
  // window.open(dataUrl)

  // fileType 文件的MIME类型
  // 参考: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types
  const blobData = new Blob([data], {
    type: fileType 
  })
  console.log(blobData) // 检查数据是否正常

  //如果是IE，特殊处理，防止IE下提提示 &quot;拒绝访问&quot;
  if (window.navigator.msSaveBlob) {
    try {
      // 根据实际情况加后缀名
      window.navigator.msSaveBlob(blobData, fileName, + &#39;.tar&#39;)
    } catch(e) {
      console.log(&#39;msSaveBlob异常&#39;, e)
    }
    return
  }

  // 创建下载链接，并触发下载
  // https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a#浏览器兼容性
  // &lt;a&gt; download attribute not support IE, iOS safari
  const dataUrl = window.URL.createObjectUrl(blobData)
  const downloadElement = document.createElement(&#39;a&#39;)
  downloadElement.href = dataUrl
  downloadElement.download = fileName // download文件名

  // 触发点击，下载
  document.body.appendChild(downloadElement)
  documentElement.click()

  // 移除辅助下载DOM及对象URL
  document.body.removeChild(downloadElement)
  window.URL.revokeObjectURL(dataUrl)
}</code></pre>
<h2 id="后端koa代码">后端koa代码</h2>
<p>利用koa来mock下载接口，读取文件内容，返回buffer后，直接用ctx.body返回给前端即可</p>
<pre><code class="language-js">
const Koa = require(&#39;koa&#39;)
const Router = require(&#39;koa-router&#39;)
const  static = require(&#39;koa-static&#39;)
const app = new Koa()
const router = new Router()
const uitl = require(&#39;util&#39;)
const fs = require(&#39;fs&#39;)

app.use(static(__dirname + &#39;/public&#39;))

router.get(&#39;/download&#39;, async (ctx, next) =&gt; {

  let filePath = [
    &#39;/upload/ffe73f4c-c160-49ff-b01d-53da5c544714.mongodb-macos-x86_64-4.2.2.tar&#39;,
    // &#39;/upload/35f17dcc-9f87-40cf-968d-8880951440d8.屏幕快照 2020-02-28 23.19.02.png&#39;
  ]
  let readFilePromise = uitl.promisify(fs.readFile)
  let res = await readFilePromise(__dirname + filePath[0])
  console.log(res)
  const fileName = encodeURIComponent(&#39;这是一一个文件&#39;)
  ctx.set({
    // &#39;Content-Type&#39;: &#39;image/png&#39;,
    &#39;Content-Type&#39;: &#39;application/x-tar&#39;,
    &#39;Content-Disposition&#39;: `attachment; filename=&quot;${fileName}.tar&quot;`
  })
  ctx.body = res
})

app.use(router.routes())

app.listen(3000, () =&gt; {
  console.log(&#39;服务开启成功，3000端口&#39;)
})</code></pre>
<h2 id="进度信息total为0，只有loaded的情况">进度信息total为0，只有loaded的情况</h2>
<p>我们在koa文档里，可以找到ctx.body 的值可以是buffer与流，流类似管道。<strong>当接口返回的数据不是buffer，而是流时，就会有这种情况</strong></p>
<pre><code class="language-js">// 可以用下面的代码改写上面的koa，不使用fs.readFile，而创建一个读的流，直接响应给前端
let res = fs.createReadStream(__dirname + filePath[0])
ctx.body = res</code></pre>
<p><strong>对于这种情况，前端怎么判断进度事件呢？建议每触发一次进度事件，加10个百分点，加到90停止，直到加载完成。10%的粒度可以自己调整</strong></p>
<h2 id="注意事项">注意事项</h2>
<ol>
<li><p>理论上filename 不需要后缀名，可以根据fileType的MIME类型自动生成后缀，但有些情况比如execl 2003可能是没有后缀的，所以最好还是filename里加上后缀名</p>
</li>
<li><p>上面可以看到需要自己设置文件类型，后缀名，但一般情况后端会在响应头 Content-Type里设置好文件类型</p>
</li>
<li><p>window.open 虽然没有进度，但优点是前端不用处理文件名这种问题，都是后端来处理</p>
</li>
<li><p>上面的例子写的比较糙，实际情况对于文件种类比较多的需要进行判断，做一些适配处理</p>
</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><p><a href="https://github.com/axios/axios#request-config">axios onDownloadProgress config参数 - github</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types">fileType 文件的MIME类型 - MDN</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7">a标签download属性兼容性 - MDN</a></p>
</li>
</ul>

          </article>
          <aside>
            <div>
              <ul><li><span class="ul-span" data-id="下载文件进度显示以及koa下载接口mock" style="padding-left:1em">下载文件进度显示以及koa下载接口mock<span></li><ul><li><span class="ul-span" data-id="前端代码" style="padding-left:2em">前端代码<span></li></ul><ul><li><span class="ul-span" data-id="通用下载函数" style="padding-left:2em">通用下载函数<span></li></ul><ul><li><span class="ul-span" data-id="后端koa代码" style="padding-left:2em">后端koa代码<span></li></ul><ul><li><span class="ul-span" data-id="进度信息total为0，只有loaded的情况" style="padding-left:2em">进度信息total为0，只有loaded的情况<span></li></ul><ul><li><span class="ul-span" data-id="注意事项" style="padding-left:2em">注意事项<span></li></ul><ul><li><span class="ul-span" data-id="参考" style="padding-left:2em">参考<span></li></ul></ul>
            <div>
          </aside>
        </section>
        <footer>
          <div class="footer_content">
            <div class="footer_right">Copyright © 2016-2020 zuo11.com. <a href='http://www.beian.miit.gov.cn/'>鄂ICP备16014741号-1</a></div>
            <div>Powered by <a href='https://github.com/zuoxiaobai/zuo-blog' target='_black'>zuo-blog</a></div>
          </div>
        </footer>
        <script src="/lib/prismjs/prism_default.js"></script>
        <script src="/lib/notes.js"></script> 
        <script src="/lib/global.js"></script>
        <script>
          
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?183281668cc3440449274d1f93c04de6";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    
        </script>
      </body>
    </html>
  