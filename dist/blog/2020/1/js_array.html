
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">

        <meta name="application name" content="js_array.html">
        <meta name="author" content="guoqzuo">
        <meta name="description" content="在ES5中新增了很多方便操作数组的方法，包括新5种数组的迭代方法：forEach, map, filter, some, every；缩小方法：reduce()；检测数组方法Array.isArray()等，这些方法让操作数组更加优雅，趋近于函数式编程. 在ES6中又增加了for..of以及values,entres,keys等，下面来详细看看">
        <meta name="keywords" content="js遍历数组方法总结,es5 es6遍历数组方法,forEach的缺点以及与for..of和for...in的区别">

        <title>JS遍历数组方法总结，forEach的缺点以及与for..of和for...in的区别 - 左小白的技术日常</title>
        <link rel="shortcut icon" href="/images/favicon.ico">
        <link href="/lib/prismjs/prism_default.css" rel="stylesheet" />
        <link href="/lib/notes.css" rel="stylesheet" />
        <link rel="stylesheet" href="/lib/global.css">
        
      </head>
      <body>
        <header>
          <div>
            <img src="/images/logo.png" width="24" height="24" class="pointer" onclick="gotoIndex()" />
            <span class="pointer" onclick="gotoIndex()">左小白的技术日常</span>
            <span class="hidden"> | </span>
            <a href="/blog/category.html#javascript" class="hidden">JavaScript</a>
          </div>
          <div>
            
          <a href="http://fe.zuo11.com" target="_black" class="hidden">我的笔记</a>
        
          <a href="https://github.com/zuoxiaobai" target="_black" class="">Github</a>
        
          </div>
        </header>
        <section class="content">
          <article>
            <h1 id="js遍历数组方法总结，foreach的缺点以及与forof和forin的区别">JS遍历数组方法总结，forEach的缺点以及与for..of和for...in的区别</h1>
            
    <div class="article-top">
      <div class="flex">
        这篇文章发布于 2020/01/09，归类于 <a href="/blog/category.html#javascript" class="hidden">JavaScript</a>
        <!-- ，阅读 11 次，今日 1 次 <div class="top-comment">4 条评论</div> -->
        <div id="readAndComment" class="flex"></div>
      </div> 
      <div class="flex keywords" style="flex-wrap: nowrap;">
        <div style="flex-shrink:0; align-self: flex-start;">标签：</div>
        <div class="flex" style="flex-wrap: wrap;"><span>js遍历数组方法总结</span>，<span>es5 es6遍历数组方法</span>，<span>forEach的缺点以及与for..of和for...in的区别</span></div>
      </div>
    </div>
    
  
            
<p>在ES5中新增了很多方便操作数组的方法，包括新5种数组的迭代方法：forEach, map, filter, some, every；缩小方法：reduce()；检测数组方法Array.isArray()等，这些方法让操作数组更加优雅，趋近于函数式编程. 在ES6中又增加了for..of以及values,entres,keys等，下面来详细看看</p>
<h2 id="es5-array5种迭代方法">ES5 Array5种迭代方法</h2>
<p>ES5定义了5个迭代方法，每个方法都接收两个参数，运行函数及作用域对象(this)，IE9+支持</p>
<ul>
<li>检测数组里的元素是否满足条件。every()、some() 返回Boolean值<ul>
<li>every() 对数组的每一项运行给定函数，函数对每一项都返回true，则返回true</li>
<li>some() 对数组的每一项运行给定函数, 如果函数对数组的任一项返回的true，return true</li>
</ul>
</li>
<li>只做遍历，不返回任何值<ul>
<li>forEach()  对数组的每一项运行给定函数, 不返回任何值，只做函数操作 类似于 for () { do something }</li>
</ul>
</li>
<li>返回数组<ul>
<li>filter()  对数组的每一项运行给定函数, 返回该函数会返回true的项组成的数组</li>
<li>map()  对数组的每一项运行给定函数, 返回每次函数调用结果组成的数组</li>
</ul>
</li>
</ul>
<pre><code class="language-js">var numbers = [1,2,3,4,5];

var isGreaterThan2 = function (item, index, array) {
    return (item &gt; 2)
};

var everyResult = numbers.every(isGreaterThan2);
var someResult = numbers.some(isGreaterThan2);
var filterResult = numbers.filter(isGreaterThan2);

alert(everyResult); // false   是否所有值都大于2
alert(someResult); // true 是否有一个值大于2
alert(filterResult); // [3,4,5]  返回所有大于2的项

var mapResult = numbers.map(function (item, index, array) {
    return (item * 2);
});
alert(mapResult); // [2,3,6,8,10] 返回每个元素执行完*2后的数组

numbers.foreach(function(item, index, array) {
  cosnole.log(item)  // 依次打印数组的值
})</code></pre>
<h2 id="es5-arrayprototypereduce">ES5 Array.prototype.reduce()</h2>
<p>ES5新增了两个缩小数组的方法reduce()和reduceRight(), 会迭代数组的所有项，然后构建一个最终返回的值。reduce从数组的第一项开始，逐个遍历到最后。reduceRight则从数组的最后一项开始，向前遍历到第一项。</p>
<ul>
<li>该方法接收两个参数：一个在每一项上调用的函数，和（可选的）作为归并基础的初始值。</li>
<li>第一个参数的函数，接收4个参数：前一个值；当前值；项的索引；数组对象；这个函数返回的任何值，都会作为第一个参数传个下一项。第一次迭代发生在数组的第二项上，第一个参数是第一项，第二个参数为数组的第二项。</li>
</ul>
<pre><code class="language-js">// 一参的情况
var values = [1,2,3,4,5];
var sum = values.reduce(function(prev, cur, index, array) {
    return prev + cur;
});
alert(sum); // 15

// 二参的情况，reduce二参为初识值，然后函数第一个参数为初识值，第二个参数为数组第一个元素，再依次遍历
var numbers = [15.5, 2.3, 1.1, 4.7];
// 四舍五入相加
numbers.reduce(function(total, num) {
  return total + Math.round(num);
}, 0)

// 计算数组中每个元素出现的次数
// MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce
var names = [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Tiff&#39;, &#39;Bruce&#39;, &#39;Alice&#39;];

var countedNames = names.reduce(function (allNames, name) { 
  if (name in allNames) {
    allNames[name]++;
  }
  else {
    allNames[name] = 1;
  }
  return allNames;
}, {});
// countedNames is:
// { &#39;Alice&#39;: 2, &#39;Bob&#39;: 1, &#39;Tiff&#39;: 1, &#39;Bruce&#39;: 1 }</code></pre>
<h2 id="es5-arrayisarray-检测是否为数组">ES5 Array.isArray() 检测是否为数组</h2>
<p>在JS高程3中有讲过安全的类型检测，Object.prototype.toString.call(要检测类型的变量)，如果等于 &quot;[object Array]&quot;就是函数类型，ES5对这个方法进行了封装，我们直接使用Array.isArray(要检测类型的变量)即可</p>
<pre><code class="language-js">// 判断是否为数组，在进行后续操作
if (value instanceof Array) {
    // 对数组执行某些操作
}
// ES5之后可以用 Array.isArray(value) 来替代，解决多个框架不同版本的Array构造函数问题
// 当检测Array实例时, Array.isArray 优于 instanceof,因为Array.isArray能检测iframes.</code></pre>
<p>在mdn的官方文档里 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray">Array.isArray() Polyfill | MDN</a> 有描述, 假如不存在 Array.isArray()，则在其他代码之前运行下面的代码将创建该方法。</p>
<pre><code class="language-js">if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === &#39;[object Array]&#39;;
  };
}</code></pre>
<h2 id="foreach的缺点">forEach的缺点</h2>
<p>现在一般再项目中，我经常使用forEach方法，形成了习惯，后来发现当只需要遍历部分元素，达到具体条件后就退出的情况时，这才发现forEach貌似是无法continue或break的，这是它的一个缺陷。这时我们可以使用some或直接使用原始的for循环来代替</p>
<h3 id="实例场景">实例场景</h3>
<pre><code class="language-js">// 真实场景: 匹配路由数组里的路径，匹配到就结束遍历，发现无法结束遍历
// 遍历路由进行匹配，如果匹配到了则执行，停止往下执行下一个中间件，否则向下执行
stock.forEach((item) =&gt; {
  if (ctx.url === item.path &amp;&amp; item.methods.includes(ctx.method)) {
    return
  }
  await next()
})</code></pre>
<h3 id="使用some测试">使用some测试</h3>
<pre><code class="language-js">var arr = [1,2,3,4,5] // 为了好在termial执行，改为var
var result = arr.some(item =&gt; {
    console.log(&#39;遍历数组&#39;, item)
    return item === 2
}) 
console.log(&#39;result&#39;, result)
// 遍历数组 1
// 遍历数组 2
// result true</code></pre>
<p>some测试结果，可以阻断遍历执行，适用于遇到单一条件就直接结束遍历的情况</p>
<h3 id="使用最原始的for">使用最原始的for</h3>
<pre><code class="language-js">var arr = [1,2,3,4,5] 
// for里面的第二个语句每次循环结束后都会去执行比较
// ;i &lt; arr.length; 每次都计算arr.length，这个值每次会减一，如果把len在一个参数里计算好
// 复杂度会从O(n) =&gt; O(1)
// 参考：JS高程3 第24章 最佳实践 - 性能 - 选择正确的方法 - 优化循环
for (let i = 0, len = arr.length; i &lt; len; i++) {
    let item = arr[i]
    if (item === 2) continue
    if (item === 4) break
    console.log(&#39;遍历数组&#39;, item)
}
// 遍历数组 1
// 遍历数组 3</code></pre>
<p>使用原始的for循环，控制更加精准</p>
<h3 id="使用throw异常的方式结合try-catch终端foreach">使用throw异常的方式结合try catch终端forEach</h3>
<pre><code class="language-js">// 参考：https://www.cnblogs.com/Marydon20170307/p/8920775.html
try {
  var array = [&quot;first&quot;,&quot;second&quot;,&quot;third&quot;,&quot;fourth&quot;];

  // 执行到第3次，结束循环
  array.forEach(function(item,index){
      if (item == &quot;third&quot;) {
          throw new Error(&quot;EndIterative&quot;);
      }
      alert(item);// first,sencond
  });
} catch(e) {
    if(e.message!=&quot;EndIterative&quot;) throw e;
};</code></pre>
<h2 id="es6新增的数组迭代方法forofentries，keys和values">ES6新增的数组迭代方法for...of,entries()，keys()和values()</h2>
<p>可以用for...of循环进行遍历，它们都返回一个遍历器对象（具体细节参见《ES6入门 Iterator》一章）。<strong>唯一的区别是keys()是对键名(数组下标)的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</strong></p>
<pre><code class="language-js">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {  
  console.log(index);}
// 0
// 1
for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {
  console.log(elem);}
// &#39;a&#39;
// &#39;b&#39;
for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {
  console.log(index, elem);}
// 0 &quot;a&quot;
// 1 &quot;b&quot;</code></pre>
<p>相比forEach，for...of是可以使用break，continue中断的，而不需要像最普通的for那样写index，比较长度，自增1等</p>
<pre><code class="language-js">for (let item of [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) {console.log(item)}
// a
// b
// c</code></pre>
<h2 id="forin遍历数组">for...in遍历数组</h2>
<p>for...in一般是用来遍历对象的，他也可以遍历数组</p>
<pre><code class="language-js">for (let item in [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) {console.log(item)}
// 0, 1, 2 和for...of的区别是他遍历的是数组下标</code></pre>
<h2 id="遍历数组时对空格的处理">遍历数组时对空格的处理</h2>
<pre><code class="language-js">// ES5 对空位的处理
// forEach(), filter(), reduce(), every() 和some()都会跳过空位
// map()会跳过空位，但会保留这个值
// join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串

// forEach方法
[,&#39;a&#39;].forEach((x,i) =&gt; console.log(i)); // 1
// filter方法
[&#39;a&#39;,,&#39;b&#39;].filter(x =&gt; true) // [&#39;a&#39;,&#39;b&#39;]
// every方法
[,&#39;a&#39;].every(x =&gt; x===&#39;a&#39;) // true
// reduce方法
[1,,2].reduce((x,y) =&gt; x+y) // 3
// some方法
[,&#39;a&#39;].some(x =&gt; x !== &#39;a&#39;) // false
// map方法
[,&#39;a&#39;].map(x =&gt; 1) // [,1]
// join方法
[,&#39;a&#39;,undefined,null].join(&#39;#&#39;) // &quot;#a##&quot;
// toString方法
[,&#39;a&#39;,undefined,null].toString() // &quot;,a,,&quot;

// ES6 则是明确将空位转为undefined。
// entries()
[...[,&#39;a&#39;].entries()] // [[0,undefined], [1,&quot;a&quot;]]
// keys()
[...[,&#39;a&#39;].keys()] // [0,1]
// values()
[...[,&#39;a&#39;].values()] // [undefined,&quot;a&quot;]
// find()
[,&#39;a&#39;].find(x =&gt; true) // undefined
// findIndex()
[,&#39;a&#39;].findIndex(x =&gt; true) // 0</code></pre>
<p>参考：</p>
<ul>
<li><a href="https://www.yuque.com/guoqzuo/js_es6/ep07nf#b5608f9d">ES5 5种Array迭代方法 | JS高程3笔记</a></li>
<li><a href="https://www.yuque.com/guoqzuo/js_es6/xr0m8g#3dc09eb1">ES6数组的扩展 | ES6入门笔记</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript">ES2015(ES6)及之前的JS版本更新概要 | MDN</a></li>
</ul>

            
            <ins class='adsbygoogle' style='display:block;margin-top:1em;margin-bottom:0' data-ad-format='fluid' data-ad-layout-key='-gw-3+1f-3d+2z' data-ad-client='ca-pub-9527676606416641' data-ad-slot='8870245163'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            <!-- 评论系统占位 -->
            <div id="commentDiv"></div>
          </article>

          <aside>
            <div class="aside-wrap">
              <div class="top ">
                <ul><li><span class="ul-span" data-id="js遍历数组方法总结，foreach的缺点以及与forof和forin的区别" style="padding-left:1em">JS遍历数组方法总结，forEach的缺点以及与for..of和for...in的区别<span></li><ul><li><span class="ul-span" data-id="es5-array5种迭代方法" style="padding-left:2em">ES5 Array5种迭代方法<span></li></ul><ul><li><span class="ul-span" data-id="es5-arrayprototypereduce" style="padding-left:2em">ES5 Array.prototype.reduce()<span></li></ul><ul><li><span class="ul-span" data-id="es5-arrayisarray-检测是否为数组" style="padding-left:2em">ES5 Array.isArray() 检测是否为数组<span></li></ul><ul><li><span class="ul-span" data-id="foreach的缺点" style="padding-left:2em">forEach的缺点<span></li><ul><li><span class="ul-span" data-id="实例场景" style="padding-left:3em">实例场景<span></li></ul><ul><li><span class="ul-span" data-id="使用some测试" style="padding-left:3em">使用some测试<span></li></ul><ul><li><span class="ul-span" data-id="使用最原始的for" style="padding-left:3em">使用最原始的for<span></li></ul><ul><li><span class="ul-span" data-id="使用throw异常的方式结合try-catch终端foreach" style="padding-left:3em">使用throw异常的方式结合try catch终端forEach<span></li></ul></ul><ul><li><span class="ul-span" data-id="es6新增的数组迭代方法forofentries，keys和values" style="padding-left:2em">ES6新增的数组迭代方法for...of,entries()，keys()和values()<span></li></ul><ul><li><span class="ul-span" data-id="forin遍历数组" style="padding-left:2em">for...in遍历数组<span></li></ul><ul><li><span class="ul-span" data-id="遍历数组时对空格的处理" style="padding-left:2em">遍历数组时对空格的处理<span></li></ul></ul>
              </div>
              <ins class='adsbygoogle' style='display:block;width:300px;height:250px;' data-ad-client='ca-pub-9527676606416641' data-ad-slot='9476232907'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            </div>
          </aside>
        </section>
        <footer>
          <div class="footer_content">
            <div class="footer_right">Copyright © 2016-2020 zuo11.com. <a href='http://www.beian.miit.gov.cn/'>鄂ICP备16014741号-1</a></div>
            <div>Powered by <a href='https://github.com/zuoxiaobai/zuo-blog' target='_black'>zuo-blog</a></div>
          </div>
        </footer>
        <script src="/lib/prismjs/prism_default.js"></script>
        <script src="/lib/notes.js"></script> 
        <script src="/lib/global.js"></script>
        <script>
          
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?183281668cc3440449274d1f93c04de6";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    
        </script>
        <!-- Global site tag (gtag.js) - Google Analytics -->
<!-- <script async src="https://www.googletagmanager.com/gtag/js?id=UA-178732583-1"></script> -->
<script>
  // window.dataLayer = window.dataLayer || [];
  // function gtag(){dataLayer.push(arguments);}
  // gtag('js', new Date());
  // gtag('config', 'UA-178732583-1');

  window.onload = function() {
    setTimeout(function() {
      let script = document.createElement("script");
      script.setAttribute("data-ad-client", "ca-pub-9527676606416641");
      script.setAttribute("async", "");
      script.src = "//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js";
      document.body.appendChild(script);
    }, 200);
  }
</script>

      </body>
    </html>
  