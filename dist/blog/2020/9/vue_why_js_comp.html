
    <!DOCTYPE html>
    <html lang="zh-CN">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">

        <meta name="application name" content="vue_why_js_comp.html">
        <meta name="author" content="guoqzuo">
        <meta name="description" content="vue js直接调用组件,js调用vue组件,js加载vue组件,js vue组件，如果自己写一个组件。一般情况下，vue项目中在某个组件里调用另一个组件，至少需要修改三个位置 1. 在 template 里写引入组件，加上传参等 2. 在 components 里声明组件（如果全局引入了，可以省去这一步） 3. data 里面写对应的传参数 代码对应如下，这种组件对于使用地方比较多时候，我们就需要想办法直接使用js来调用组件，而不是每次都要在 template 里面声明对应的组件，这样会有很多重复代码，可维护性较差。">
        <meta name="keywords" content="vue js直接调用组件,js调用vue组件,js加载vue组件,js vue组件">

        <title>vue中为什么要使用js调用单文件组件？怎么实现js调用组件？ - 左小白的技术日常</title>
        <link rel="shortcut icon" href="/images/favicon.ico">
        <link href="/lib/prismjs/prism_default.css" rel="stylesheet" />
        <link href="/lib/notes.css" rel="stylesheet" />
        <link rel="stylesheet" href="/lib/global.css">
        
      </head>
      <body>
        <header>
          <div>
            <img src="/images/logo.png" width="24" height="24" class="pointer" onclick="gotoIndex()" />
            <span class="pointer" onclick="gotoIndex()">左小白的技术日常</span>
            <span class="hidden"> | </span>
            <a href="/blog/category.html#vue" class="hidden">Vue</a>
          </div>
          <div>
            
          <a href="http://fe.zuo11.com" target="_black" class="hidden">我的笔记</a>
        
          <a href="https://github.com/zuoxiaobai" target="_black" class="">Github</a>
        
          </div>
        </header>
        <section class="content">
          <article>
            <h1 id="vue中为什么要使用js调用单文件组件？怎么实现js调用组件？">vue中为什么要使用js调用单文件组件？怎么实现js调用组件？</h1>
            
    <div class="article-top">
      <div class="flex">
        这篇文章发布于 2020/09/12，归类于 <a href="/blog/category.html#vue" class="hidden">Vue</a>
        <!-- ，阅读 11 次，今日 1 次 <div class="top-comment">4 条评论</div> -->
        <div id="readAndComment" class="flex"></div>
      </div> 
      <div class="flex keywords" style="flex-wrap: nowrap;">
        <div style="flex-shrink:0; align-self: flex-start;">标签：</div>
        <div class="flex" style="flex-wrap: wrap;"><span>vue js直接调用组件</span>，<span>js调用vue组件</span>，<span>js加载vue组件</span>，<span>js vue组件</span></div>
      </div>
    </div>
    
  
            
<p>如果自己写一个组件。一般情况下，vue项目中在某个组件里调用另一个组件，至少需要修改三个位置</p>
<ol>
<li>在 template 里写引入组件，加上传参等</li>
<li>在 components 里声明组件（如果全局引入了，可以省去这一步）</li>
<li>data 里面写对应的传参数</li>
</ol>
<p>代码对应如下，这种组件对于使用地方比较多时候，我们就需要想办法直接使用js来调用组件，而不是每次都要在 template 里面声明对应的组件，这样会有很多重复代码，可维护性较差。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;el-button @click=&quot;showToast&quot;&gt;打开toast&lt;/el-button&gt;
  &lt;!-- template中使用组件 --&gt;
  &lt;toast v-model=&quot;showToast&quot;&gt;&lt;/toast&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  components: {
    Toast: () =&gt; import(&#39;./Toast.vue&#39;)
  }
  data() {
    return {
      showToast: false
    }
  }
}
&lt;/script&gt;</code></pre>
<h2 id="较早之前使用js加载组件尝试">较早之前使用js加载组件尝试</h2>
<p>在较早之前，用js写过一个直接挂载组件到当前dom上的一个方法，分三步：</p>
<ol>
<li>使用 Vue.extend，处理需要用js调用的vue单文件组件，返回该vue组件的一个子类</li>
<li>new对应的组件子类，生成对应的组件实例，并使用 <code>.$mount()</code> 挂载组件，返回对应组件的 vm</li>
<li>这样可以通过 vm.$el 拿到组件dom，append到当前组件dom里，即可完成加载</li>
</ol>
<p>具体写法如下</p>
<pre><code class="language-js">// 假设写好了 showInfo.vue 组件，执行clickShow函数直接显示dialog
// 组件中 dialog :visible.sync=&quot;dialogTableVisible&quot;初始值设置为true

// demo.vue 在需要调用的vue文件中引入该组件
import ShowInfo from &#39;showInfo.vue&#39;
// ...
clickShow() {
  const Component = Vue.extend(ShowInfo)

  // 挂载后返回对应组件的vm
  let showInfoVue = new Component().$mount() 

  // 将组件vm的dom，append到当前页面
  this.$el.appendChild(showInfoVue.$el) 
}
// ... </code></pre>
<p>具体参考：<a href="http://www.zuo11.com/blog/2020/2/js_vue_comp.html">使用js调用vue单文件组件</a></p>
<p>但它有一个缺点，常规调用组件时，我们会向子组件里面传入参数或事件。而这种情况不能向调用的子组件传入参数。下面来看另一种方法</p>
<h2 id="使用js将单文件组件挂载到body的通用方法">使用js将单文件组件挂载到body的通用方法</h2>
<p>我们来看看下面的create方法，其实和上面的方法流程基本一致，只是改变了创建对应vue单文件组件实例的方法。这里用render函数来替代之前的Vue.extend来创建对应组件实例，这样可以通过render函数的createElement函数向子组件内部传参数，传方法等。</p>
<pre><code class="language-js">// create.js
import Vue from &quot;vue&quot;;

export default function create(Component, props) {
  // 先创建实例
  const vm = new Vue({
    render(h) {
      // h就是createElement，它返回VNode
      return h(Component, { props });
    }
  }).$mount();

  // 手动挂载
  document.body.appendChild(vm.$el);

  // 销毁方法
  const comp = vm.$children[0];
  comp.remove = function() {
    document.body.removeChild(vm.$el);
    vm.$destroy();
  };
  return comp;
}</code></pre>
<p>上面的例子中，create函数参数接收一个单文件组件对象，以及在调用组件时需要传递给组件的参数，来看看具体使用例子</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;el-button @click=&quot;showToast&quot;&gt;打开toast&lt;/el-button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import Toast from &quot;./Toast.vue&quot;;
import create from &quot;./create&quot;;
export default {
  methods: {
    showToast() {
      console.log(&quot;show toast&quot;);
      let toast = create(Toast, {
        show: true,
        message: &quot;我是错误信息&quot;,
        type: &quot;error&quot;
      });
      // 等价于 &lt;toast :show=&quot;true&quot; message=&quot;xx&quot; :type=&quot;error&quot;&gt;&lt;/toast&gt;
      console.log(toast);
      setTimeout(() =&gt; {
        toast.remove();
      }, 2000);
    }
  }
};
&lt;/script&gt;</code></pre>
<p>Toast.vue 单文件组件代码如下</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;my-toast&quot; v-if=&quot;show&quot;&gt;
    &lt;div :class=&quot;type&quot;&gt;{{ message }}&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  props: {
    message: {
      type: String,
      required: true
    },
    type: {
      type: String,
      default: &quot;error&quot;
    }
    show: {
      type: Boolean,
    }
  }
};
&lt;/script&gt;
&lt;style lang=&quot;less&quot; scoped&gt;
.my-toast {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 300px;
  border: 1px solid #ccc;
  text-align: center;
  .error {
    color: red;
  }
  .success {
    color: green;
  }
}
&lt;/style&gt;</code></pre>
<h2 id="再进一步封装">再进一步封装</h2>
<p>上面的例子中，我们引入了 create.js 以及 对应的单文件组件。它还是不够简洁，我们可以再封装一次，只需要调用一个js就搞定。如果我们将它在main.js里面引入并挂载到vue实例属性，那么调用就非常方便了。</p>
<pre><code class="language-js">// 在main.js里注册实例属性
import showDialog from &#39;@/views/jsDialog/index.js&#39;
Vue.prototype.$showDialog = showDialog

// 其他地方直接使用 this.$showDialog(options) 即可调用组件</code></pre>
<p>下面来看看实现思路，关于render函数createElement的options的配置，参见 <a href="https://cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1">createElement 参数 - 深入数据对象</a></p>
<pre><code class="language-js">// showDialog/index.js
import Vue from &quot;vue&quot;;
import DialogComponent from &#39;@/views/jsDialog/src/index.vue&#39;

let TheDialog = null
export default function showDialog(options) {
  // 如果未移除，先移除
  TheDialog &amp;&amp; TheDialog.remove()

  TheDialog = create(DialogComponent, {
    on: {
      // 单文件组件内部可以emit该事件，销毁TheDialog组件
      &#39;close-dialog&#39;: () =&gt; {
        TheDialog.remove()
      }
    },
    props: {
      // 需要传入的属性，单文件组件需要使用props接收
      title: &#39;标题&#39;,
      content: &#39;内容&#39; 
    }
    // 其他参数
    ...options
  })

  function create(Component, options) {
    // 先创建实例
    const vm = new Vue({
      render(h) {
        // h就是createElement，它返回VNode
        return h(Component, options);
      }
    }).$mount();

    // 手动挂载
    document.body.appendChild(vm.$el);

    // 销毁方法
    const comp = vm.$children[0];
    comp.remove = function() {
      document.body.removeChild(vm.$el);
      vm.$destroy();
    };
    return comp;
  }
}</code></pre>
<p><strong>注意，虽然js调用更方便了，但js处理、render组件的传参复杂度会增加。它和普通组件各有各的优缺点。</strong></p>

            
            <ins class='adsbygoogle' style='display:block;margin-top:1em;margin-bottom:0' data-ad-format='fluid' data-ad-layout-key='-gw-3+1f-3d+2z' data-ad-client='ca-pub-9527676606416641' data-ad-slot='8870245163'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            <!-- 评论系统占位 -->
            <div id="commentDiv"></div>
          </article>

          <aside>
            <div class="aside-wrap">
              <div class="top ">
                <ul><li><span class="ul-span" data-id="vue中为什么要使用js调用单文件组件？怎么实现js调用组件？" style="padding-left:1em">vue中为什么要使用js调用单文件组件？怎么实现js调用组件？<span></li><ul><li><span class="ul-span" data-id="较早之前使用js加载组件尝试" style="padding-left:2em">较早之前使用js加载组件尝试<span></li></ul><ul><li><span class="ul-span" data-id="使用js将单文件组件挂载到body的通用方法" style="padding-left:2em">使用js将单文件组件挂载到body的通用方法<span></li></ul><ul><li><span class="ul-span" data-id="再进一步封装" style="padding-left:2em">再进一步封装<span></li></ul></ul>
              </div>
              <ins class='adsbygoogle' style='display:block;width:300px;height:250px;' data-ad-client='ca-pub-9527676606416641' data-ad-slot='9476232907'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            </div>
          </aside>
        </section>
        <footer>
          <div class="footer_content">
            <div class="footer_right">Copyright © 2016-2020 zuo11.com. <a href='http://beian.miit.gov.cn/'>鄂ICP备16014741号-1</a></div>
            <div>Powered by <a href='https://github.com/zuoxiaobai/zuo-blog' target='_black'>zuo-blog</a></div>
          </div>
        </footer>
        <script src="/lib/prismjs/prism_default.js"></script>
        <script src="/lib/notes.js"></script> 
        <script src="/lib/global.js"></script>
        <script>
          
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?183281668cc3440449274d1f93c04de6";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    
        </script>
        <!-- Global site tag (gtag.js) - Google Analytics -->
<!-- <script async src="https://www.googletagmanager.com/gtag/js?id=UA-178732583-1"></script> -->
<script>
  // window.dataLayer = window.dataLayer || [];
  // function gtag(){dataLayer.push(arguments);}
  // gtag('js', new Date());
  // gtag('config', 'UA-178732583-1');

  window.onload = function() {
    setTimeout(function() {
      let script = document.createElement("script");
      script.setAttribute("data-ad-client", "ca-pub-9527676606416641");
      script.setAttribute("async", "");
      script.src = "//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js";
      document.body.appendChild(script);
    }, 200);
  }
</script>

      </body>
    </html>
  