
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">

        <meta name="application name" content="koa_web_cros.html">
        <meta name="author" content="guoqzuo">
        <meta name="description" content="JS高程3中在Ajax那一章里有详细的讲解跨域的问题，由于是纯理论，之前看时只是了解个大概。之后学会了koa后，用koa来写测试接口模拟跨域的场景，对跨域问题有了更深层次的理解，下面来对跨域的相关知识点进行整理、回顾，并写demo做一些测试">
        <meta name="keywords" content="web前端跨域问题,web跨域,前端跨域,请求预检,cros,跨域资源共享">

        <title>利用koa来彻底理解web前端跨域问题 - 左小白的技术日常</title>
        <link rel="shortcut icon" href="/images/favicon.ico">
        <link href="/lib/prismjs/prism_default.css" rel="stylesheet" />
        <link href="/lib/notes.css" rel="stylesheet" />
        <link rel="stylesheet" href="/lib/global.css">
      </head>
      <body>
        <header>
          <div>
            <img src="/images/logo.png" width="24" height="24" class="pointer" onclick="gotoIndex()" />
            <span class="pointer" onclick="gotoIndex()">左小白的技术日常</span>
            <span class="hidden"> | </span>
            <a href="/blog/category.html#http与https" class="hidden">http与https</a>
          </div>
          <div>
            
          <a href="https://www.yuque.com/guoqzuo" target="_black" class="hidden">语雀</a>
        
          <a href="https://space.bilibili.com/486840111" target="_black" class="hidden">B站</a>
        
          <a href="https://github.com/zuoxiaobai" target="_black" class="">Github</a>
        
          </div>
        </header>
        <section class="content">
          <article>
            
    <div class="article-top">
      <div>2020/06/21</div> 
      <div class="article-top-right">Author: guoqzuo</div>
    </div>
  
            <h1 id="利用koa来彻底理解web前端跨域问题">利用koa来彻底理解web前端跨域问题</h1>
<p>JS高程3中在Ajax那一章里有详细的讲解跨域的问题，由于是纯理论，之前看时只是了解个大概。之后学会了koa后，用koa来写测试接口模拟跨域的场景，对跨域问题有了更深层次的理解，下面来对跨域的相关知识点进行整理、回顾，并写demo做一些测试</p>
<p><img src="../../../images/blog/node/koa_cros_1.png" alt="koa_cros_1.png"></p>
<h2 id="什么是跨域？会产生跨域的三种情况">什么是跨域？会产生跨域的三种情况</h2>
<p>跨域是浏览器同源策略引起的接口调用问题，<strong>只针对XMLHttpRequest发出的请求</strong>。</p>
<p><strong>协议、端口、host 三者有一个不同就会跨域</strong>，导致ajax请求接口失败</p>
<p>以 <a href="http://127.0.0.1:9000">http://127.0.0.1:9000</a> 为例</p>
<ul>
<li><code>http</code> 为协议，还可以是 <code>https</code></li>
<li><code>127.0.0.1</code> 为 host，还可以是 baidu.com、api.xx.com等</li>
<li><code>9000</code> 为端口，在不指定端口的情况下，默认http为80端口，https为443端口</li>
</ul>
<h2 id="本地模拟跨域场景">本地模拟跨域场景</h2>
<p>我们本地一般最简单的方式就是通过不同的端口来模拟出跨域的场景，现在我们用koa在本地创建两个服务，一个是在8000端口的静态文件服务，一个是在9000端口的接口服务</p>
<p>静态文件服务</p>
<pre><code class="language-js">// 8000_static_server.js
const Koa = require(&#39;koa&#39;)
const app = new Koa()

app.use(require(&#39;koa-static&#39;)(__dirname + &#39;/public&#39;)) // 静态服务

app.listen(8000, () =&gt; console.log(&#39;服务已开启，端口 8000&#39;))</code></pre>
<p>我们访问 <a href="http://127.0.0.1:8000">http://127.0.0.1:8000</a> 就可以访问public/index.html到这个页面，这个页面再请求 9000端口的接口，就算跨域了。</p>
<pre><code class="language-html">&lt;button id=&quot;send-get-request&quot;&gt;发送get请求&lt;/button&gt;
&lt;button id=&quot;send-post-request&quot;&gt;发送post请求&lt;/button&gt;
&lt;script src=&quot;axios.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  let sendGetRequest = document.getElementById(&#39;send-get-request&#39;)
  let sendPostRequest = document.getElementById(&#39;send-post-request&#39;)
  sendGetRequest.onclick = async () =&gt; {
    try {
      let res = await axios.get(&#39;http://127.0.0.1:9000/users&#39;)
      console.log(res)
    } catch(e) {
      console.error(e)
    }
  }
  sendPostRequest.onclick = async () =&gt; {
    try {
      let payload = { x: 1, y: 1}
      let res = await axios.post(&#39;http://127.0.0.1:9000/info&#39;, payload)
      console.log(res)
    } catch(e) {
      console.error(e)
    }
  }
&lt;/script&gt;</code></pre>
<p>接口服务</p>
<pre><code class="language-js">// 9000_api_server.js
const Koa = require(&#39;koa&#39;)
const Router = require(&#39;koa-router&#39;)
const app = new Koa()
const router = new Router()

// 路由
router.get(&#39;/users&#39;, ctx =&gt; ctx.body = &#39;users&#39;)
router.post(&#39;/info&#39;, ctx =&gt; ctx.body = { b: 1 })

app.use(router.routes()).use(router.allowedMethods())

app.listen(9000, () =&gt; console.log(&#39;服务已开启，端口 9000&#39;))</code></pre>
<p>点击发送get请求，chrome会报跨域限制的错误，请求失败</p>
<p><img src="../../../images/blog/node/koa_cros_2.png" alt="koa_cros_2.png"></p>
<pre><code class="language-js">Access to XMLHttpRequest at &#39;http://127.0.0.1:9000/users&#39; from origin &#39;http://127.0.0.1:8000&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code></pre>
<h2 id="跨域问题的解决方式">跨域问题的解决方式</h2>
<h3 id="img、link-元素">img、link 元素</h3>
<p>img和link元素都会给服务器发送get请求，因为这个并不属于ajax请求，所以浏览器不会阻止请求发送到服务端。我们可以利用这个特性来发送跨域请求，下面来看例子</p>
<pre><code class="language-html">&lt;button id=&quot;send-get-img&quot;&gt;使用img发送get请求&lt;/button&gt;
&lt;button id=&quot;send-get-link&quot;&gt;利用link发送get请求&lt;/button&gt;
&lt;script src=&quot;axios.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  let sendGetRequestByImg = document.getElementById(&#39;send-get-img&#39;)
  let sendGetRequestByLink = document.getElementById(&#39;send-get-link&#39;)
  sendGetRequestByImg.onclick = async () =&gt; {
    let img = document.createElement(&#39;img&#39;)
    img.src = &#39;http://127.0.0.1:9000/users&#39;
    img.style.display = &#39;none&#39;
    document.body.appendChild(img)
    setTimeout(() =&gt; {
      document.body.removeChild(img)
    }, 2000)
  }
  sendGetRequestByLink.onclick = async () =&gt; {
    let link = document.createElement(&#39;link&#39;)
    link.href = &#39;http://127.0.0.1:9000/users&#39;
    link.rel = &#39;stylesheet&#39;
    document.head.appendChild(link)
    setTimeout(() =&gt; {
      document.head.removeChild(link)
    }, 2000)
  }
&lt;/script&gt;</code></pre>
<p>img和link标签虽然都可以发送跨域的get请求，img常用于跟踪用户点击页面或动态广告曝光的次数。这种跨域方式都无法接收服务器响应的数据，请求是单向的。</p>
<h3 id="script元素与jsonp">script元素与JSONP</h3>
<p>上面利用link元素与img元素，做get请求，那script理论上也是可以发送跨域get请求的，而且script元素还可以利用JSONP，接收后台的响应</p>
<p>JSONP是JSON with padding(填充式JSON或参数式JSON)的简写，他由两部分组成:</p>
<ol>
<li>回调函数</li>
<li>数据</li>
</ol>
<pre><code class="language-js">callback({&quot;user&quot;: &quot;zhangsan&quot;})</code></pre>
<p>当script元素接收到后端响应的JSONP数据时，会调用页面中对应的callback函数，而callback函数名字一般是通过前端请求url的查询参数来决定的，来看看看下面的例子</p>
<pre><code class="language-html">&lt;button id=&quot;send-get-script&quot;&gt;使用script发送get请求&lt;/button&gt;
&lt;script&gt;
  let sendGetRequestByScript = document.getElementById(&#39;send-get-script&#39;)
  sendGetRequestByScript.onclick = async () =&gt; {
    let script = document.createElement(&#39;script&#39;);
    script.type=&quot;text/javascript&quot; 
    // script.src = &quot;http://127.0.0.1:9000/users&quot;
    script.src = &quot;http://127.0.0.1:9000/jsonpTest?callback=handleRes&quot;
    document.body.appendChild(script)
    setTimeout(() =&gt; {
      document.body.removeChild(script)
    }, 2000)
  }
  // 这里可以接收到对应的数据
  function handleRes(response) {
    console.log(&#39;利用jsonp接收到的响应数据&#39;, response)
  }
&lt;/script&gt;</code></pre>
<p>JSONP需要后端返回JSONP格式的数据，前端才能接收到响应，来看看node是怎么处理的</p>
<pre><code class="language-js">router.get(&#39;/jsonpTest&#39;, ctx =&gt; {
  console.log(`接收到get请求${ctx.url}`)
  let resdata = {
    user: &#39;zhangsan&#39;
  }
  let jsonpData = `${ctx.query.callback}(${JSON.stringify(resdata)})`
  console.log(&#39;ctx.query.callback&#39;, ctx.query.callback)
  console.log(&#39;jsonpData&#39;, jsonpData) // handleRes({&quot;user&quot;:&quot;zhangsan&quot;})
  ctx.body = jsonpData
})</code></pre>
<p>JSONP的缺点：</p>
<ol>
<li>不安全，后端返回的数据可以决定前端要执行的函数</li>
<li>不容易确定JSONP请求是否失败</li>
</ol>
<h3 id="cors跨域资源共享">CORS跨域资源共享</h3>
<p>一般限制跨域请求这种安全策略可以预防某些恶意行为，但实现合理的跨域请求对开发web应用也是至关重要的，因此W3C提出了 CORS（Cross-Origin Resource Sharing, 跨域资源共享）的解决方案，<strong>CORS 定义了浏览器与服务器应该如何沟通，背后的基本思想是，使用自定义的HTTP头部让浏览器与服务器沟通，从而决定请求或响应是否成功</strong></p>
<p>比如，前端在发送请求时，浏览器会自动附加一个额外的请求头 Origin，包含请求页面的源信息(协议、域名、端口)，下面是Origin头部的一个示例</p>
<pre><code class="language-js">Origin: http://127.0.0.1:8000</code></pre>
<p>如果服务器认为可以接受该请求，可以在响应头 Access-Control-Allow-Origin 中发相同的源信息（或者 *），例如</p>
<pre><code>Access-Control-Allow-Origin：http://127.0.0.1:8000</code></pre><p><strong>如果没有这个头部浏览器会驳回请求。也就是说，浏览器其实发送了请求，后端也接收到了请求，只是浏览器阻止了响应，并报错了，这一点很关键。</strong></p>
<p>后端只要加一个响应头就可以解决跨域的问题，我们来试试，通过写一个中间件来允许跨域请求</p>
<pre><code class="language-js">// allowCors.js
async function allowCORS(ctx, next) {
  console.log(ctx.headers[&#39;origin&#39;])
  ctx.set({
    &#39;Access-Control-Allow-Origin&#39;: &#39;http://127.0.0.1:8000&#39;
    // &#39;Access-Control-Allow-Origin&#39;: ctx.headers[&#39;origin&#39;]
    // &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;
  })
  next()
}

module.exports = allowCORS</code></pre>
<p>在路由前面加一行，引入该中间件即可</p>
<pre><code class="language-js">app.use(require(&#39;./allowCors&#39;))</code></pre>
<p>我们再来测试下发送请求，get请求可以了，没有提示跨域了，但post请求却还是提示跨域，这是为什么呢？这就涉及preflight，预检请求的概念了</p>
<p><img src="../../../images/blog/node/cors_error.png" alt="cors_error.png"></p>
<pre><code class="language-js">Access to XMLHttpRequest at &#39;http://127.0.0.1:9000/info&#39; from origin &#39;http://127.0.0.1:8000&#39; has been blocked by CORS policy: Request header field content-type is not allowed by Access-Control-Allow-Headers in preflight response.</code></pre>
<h4 id="为什么会有preflight预检请求">为什么会有preflight预检请求</h4>
<p>浏览器限制跨域有两种方式：</p>
<ol>
<li>浏览器限制发起跨域请求</li>
<li>跨域请求可以正常发起，但返回的结果被浏览器拦截了</li>
</ol>
<p>一般浏览器都是使用第二种方式限制跨域请求，<strong>跨域请求已经到达服务器，并可能对数据库里的数据进行了操作，但返回的结果被浏览器拦截了，对前端来讲这是一次失败的请求，但可能对数据库里的数据产生了影响</strong></p>
<p>为了防止这种情况发生，<strong>对于可能对服务器数据产生副作用的HTTP请求方法，浏览器会先使用OPTIONS方法发起一个预检请求</strong>，从而获知服务器是否允许跨域请求：如果允许，就发送带真实的数据请求，如果不允许，则阻止带数据的真实请求。</p>
<h4 id="什么情况会发触发cors预检请求">什么情况会发触发CORS预检请求?</h4>
<ul>
<li>使用了PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH请求方法</li>
<li>人为设置了CORS安全的请求头之外的其他请求头，下面是安全的请求头列表<ul>
<li>Accept </li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
<li>Content-Type值为 application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
</li>
</ul>
<p>现在知道刚才的POST请求为什么出错了吧，请求头里面Content-type为application/json，不是安全的请求头，需要加上一个请求头设置即可</p>
<pre><code class="language-js">&#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39; // 或 *</code></pre>
<p>同理，当我们使用 put请求时，需要加上</p>
<pre><code class="language-js">&#39;Access-Control-Allow-Methods&#39;: &#39;PUT&#39; // 或 *，注意PUT要大写</code></pre>
<p><img src="../../../images/blog/node/cors_preflight.png" alt="cors_preflight.png"></p>
<h4 id="跨域请求默认不会携带cookie怎么处理">跨域请求默认不会携带cookie怎么处理</h4>
<p>axios 跨域请求 默认不发送cookie，如果想发送的请求携带cookie需要将withCredentials设置为true</p>
<pre><code class="language-js">// `withCredentials` indicates whether or not cross-site Access-Control requests
// should be made using credentials
// withCredentials: false, // default
axios.defaults.withCredentials = true // 允许跨域请求发送cookie

// OPTIONS需要加一个设置
&#39;Access-Control-Allow-Credentials&#39;: &#39;true&#39;</code></pre>
<h4 id="终极后端允许跨域请求头设置">终极后端允许跨域请求头设置</h4>
<p>因此终极的后端允许跨域的请求头设置为</p>
<pre><code class="language-js">ctx.set({
  &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
  &#39;Access-Control-Allow-Headers&#39;: &#39;*&#39;,
  &#39;Access-Control-Allow-Methods&#39;: &#39;*&#39;,
  &#39;Access-Control-Allow-Credentials&#39;: &#39;true&#39;, // 允许携带cookie
  &#39;Access-Control-Max-Age&#39;: 3600 // 对于相同的请求，仅在第一次发送options预检请求，之后1小时内不需要预检请求
})</code></pre>
<h3 id="服务器代理-devserverproxy">服务器代理 devServer.proxy</h3>
<p>还有一种跨域方式就是通过服务器代理的方式来进行跨域请求。就是请求同源服务器，通过该服务器转发请求到目标服务器，得到结果再转发给前端。</p>
<pre><code class="language-js">// http-proxy-middleware
const express = require(&#39;express&#39;);
const { createProxyMiddleware } = require(&#39;http-proxy-middleware&#39;);

const app = express();
app.use(express.static(__dirname + &#39;/public&#39;))

app.use(&#39;/users&#39;, createProxyMiddleware({ 
    target: &#39;http://127.0.0.1:9000&#39;, changeOrigin: true 
  })
);
app.use(&#39;/info&#39;, createProxyMiddleware({ 
    target: &#39;http://127.0.0.1:9000&#39;, changeOrigin: true 
  })
);
app.listen(7000);</code></pre>
<p>有没有很熟悉？其实我们在vue.config.js里面配置devServer的proxy属性就是调用类似的方法</p>
<h2 id="参考">参考</h2>
<p>更多细节可以参考下面的文档</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX">Ajax - Web 开发者指南 | MDN</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest - Web APIs | MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">跨來源資源共用（CORS） - HTTP | MDN</a></li>
<li><a href="https://www.jianshu.com/p/b55086cbd9af">前端 | 浅谈preflight request - 简书</a></li>
<li><a href="https://www.yuque.com/guoqzuo/rdrqd5/pwlw7i#f5457f4a">前端跨域问题 - 网络编程 | Node笔记</a></li>
<li><a href="https://www.yuque.com/guoqzuo/js_es6/fcw53h#ac35dda4">跨域资源共享 | JS高程3笔记</a></li>
</ul>

          </article>
          <aside>
            <div>
              <ul><li><span class="ul-span" data-id="利用koa来彻底理解web前端跨域问题" style="padding-left:1em">利用koa来彻底理解web前端跨域问题<span></li><ul><li><span class="ul-span" data-id="什么是跨域？会产生跨域的三种情况" style="padding-left:2em">什么是跨域？会产生跨域的三种情况<span></li></ul><ul><li><span class="ul-span" data-id="本地模拟跨域场景" style="padding-left:2em">本地模拟跨域场景<span></li></ul><ul><li><span class="ul-span" data-id="跨域问题的解决方式" style="padding-left:2em">跨域问题的解决方式<span></li><ul><li><span class="ul-span" data-id="img、link-元素" style="padding-left:3em">img、link 元素<span></li></ul><ul><li><span class="ul-span" data-id="script元素与jsonp" style="padding-left:3em">script元素与JSONP<span></li></ul><ul><li><span class="ul-span" data-id="cors跨域资源共享" style="padding-left:3em">CORS跨域资源共享<span></li><ul><li><span class="ul-span" data-id="为什么会有preflight预检请求" style="padding-left:4em">为什么会有preflight预检请求<span></li></ul><ul><li><span class="ul-span" data-id="什么情况会发触发cors预检请求?" style="padding-left:4em">什么情况会发触发CORS预检请求?<span></li></ul><ul><li><span class="ul-span" data-id="跨域请求默认不会携带cookie怎么处理" style="padding-left:4em">跨域请求默认不会携带cookie怎么处理<span></li></ul><ul><li><span class="ul-span" data-id="终极后端允许跨域请求头设置" style="padding-left:4em">终极后端允许跨域请求头设置<span></li></ul></ul><ul><li><span class="ul-span" data-id="服务器代理-devserverproxy" style="padding-left:3em">服务器代理 devServer.proxy<span></li></ul></ul><ul><li><span class="ul-span" data-id="参考" style="padding-left:2em">参考<span></li></ul></ul>
            <div>
          </aside>
        </section>
        <footer>
          <div class="footer_content">
            <div class="footer_right">Copyright © 2016-2020 zuo11.com. <a href='http://www.beian.miit.gov.cn/'>鄂ICP备16014741号-1</a></div>
            <div>Powered by <a href='https://github.com/zuoxiaobai/zuo-blog' target='_black'>zuo-blog</a></div>
          </div>
        </footer>
        <script src="/lib/prismjs/prism_default.js"></script>
        <script src="/lib/notes.js"></script> 
        <script src="/lib/global.js"></script>
        <script>
          
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?183281668cc3440449274d1f93c04de6";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    
        </script>
      </body>
    </html>
  