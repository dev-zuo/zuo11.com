
    <!DOCTYPE html>
    <html lang="zh-CN">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">

        <meta name="application name" content="easy_throttle_debounce.html">
        <meta name="author" content="guoqzuo">
        <meta name="description" content="节流和防抖，手写节流和防抖，节流(throttle) 对应技能冷却时间，如果冷却(cooldown/cd)是 5 秒，使用技能后，5秒内，无法再次执行。用于控制事件执行一次后，多长时间内不允许再次执行。一般用于防止按钮多次点击，重复触发事件。防抖(去抖动 debounce、de + bounce) 对应 **回城**，在推塔游戏中，回城等待时间是 8 秒。可以理解为回城时，会开启一个定时任务，8 秒后执行完成回城的函数。防抖/去抖动，就是在定时任务等待执行的时间内，如果再次触发发了函数，会取消上一次的定时任务，重新开始一个定时任务。这样可以**将一段时间内连续的多次触发转化为一次触发，单位时间内仅执行最后一次**。一般用于 window 的 scroll、resize 事件、搜索框输入搜索内容后实时查询接口等。">
        <meta name="keywords" content="节流和防抖,手写节流和防抖,节流和防抖,throttle debounce">

        <title>用游戏中的场景理解节流与防抖，最简单的 js 实现 - 左小白的技术日常</title>
        <link rel="shortcut icon" href="/images/favicon.ico">
        <link href="/lib/prismjs/prism_default.css" rel="stylesheet" />
        <link href="/lib/notes.css" rel="stylesheet" />
        <link rel="stylesheet" href="/lib/global.css">
        
      </head>
      <body>
        <header>
          <div>
            <img src="/images/logo.png" width="24" height="24" class="pointer" onclick="gotoIndex()" />
            <span class="pointer" onclick="gotoIndex()">左小白的技术日常</span>
            <span class="hidden"> | </span>
            <a href="/blog/category.html#javascript" class="hidden">JavaScript</a>
          </div>
          <div>
            
          <a href="http://fe.zuo11.com" target="_black" class="hidden">我的笔记</a>
        
          <a href="https://github.com/zuoxiaobai" target="_black" class="">Github</a>
        
          </div>
        </header>
        <section class="content">
          <article>
            <h1 id="用游戏中的场景理解节流与防抖，最简单的-js-实现">用游戏中的场景理解节流与防抖，最简单的 js 实现</h1>
            
    <div class="article-top">
      <div class="flex">
        这篇文章发布于 2021/04/11，归类于 <a href="/blog/category.html#javascript" class="hidden">JavaScript</a>
        <!-- ，阅读 11 次，今日 1 次 <div class="top-comment">4 条评论</div> -->
        <div id="readAndComment" class="flex"></div>
      </div> 
      <div class="flex keywords" style="flex-wrap: nowrap;">
        <div style="flex-shrink:0; align-self: flex-start;">标签：</div>
        <div class="flex" style="flex-wrap: wrap;"><span>节流和防抖</span>，<span>手写节流和防抖</span>，<span>节流和防抖</span>，<span>throttle debounce</span></div>
      </div>
    </div>
    
  
            
<p>之前对节流(throttle) 和防抖（debounce）的理解有偏差，以为 <del>scroll 或 resize 时，为了减少执行事件函数频率，需要用节流，减少执行次数。而防抖在于点击某个按钮后，多长时间内不允许再次点击。防止多次重复提交表单，或执行下一步函数。</del></p>
<p>这种理解是反的。我们可以用游戏的中的场景来理解节流和防抖</p>
<h2 id="节流throttle">节流(throttle)</h2>
<p>对应 <strong>技能冷却时间</strong>，如果冷却(cooldown/cd)是 5 秒，使用技能后，5秒内，无法再次执行。用于控制事件执行一次后，多长时间内不允许再次执行。一般用于防止按钮多次点击，重复触发事件。</p>
<p><img src="../../../images/blog/js/throttle.gif" alt="throttle.gif"></p>
<p>来实现节流的功能，比较好的实现是，创建一个可复用的节流函数，它可以将普通函数转换为增加了节流功能的函数，基本结构如下</p>
<pre><code class="language-js">/**
 * throttle
 * @param { Function } func 执行函数
 * @param { Interger } time 多长时间内不能第二次执行
 * @returns function 返回经过节流处理的函数
 */
function throttle(func, time) {
  return (...args) =&gt; {
    // 返回一个可以正常执行的函数
    func.apply(this, args)
  }
}</code></pre>
<p>在基本的机构中，增加节流控制处理</p>
<pre><code class="language-js">/**
 * throttle
 * @param { Function } func 执行函数
 * @param { Interger } time 多长时间内不能第二次执行
 * @returns function 返回经过节流处理的函数
 */
function throttle(func, time) {
  let isLock = false // 是否冷却(cooldown)中
  // 返回一个经过节流处理的 func
  return function (...args) {
    if (isLock) { // 如果是冷却中，不执行函数
      console.log(&#39;冷却(cd)中...&#39;)
      return 
    }
    // 非冷却中
    func.apply(this, args) // 执行函数
    isLock = true // 执行函数后设置为冷却中
    setTimeout(() =&gt; {
      isLock = false // 经过 time 微秒后，设置为非冷却中
    }, time);
  }
}</code></pre>
<p>使用示例</p>
<pre><code class="language-html">&lt;button id=&quot;skillsABtn&quot;&gt;释放技能A&lt;/button&gt;
&lt;script&gt;
  let skillsABtn = document.querySelector(&#39;#skillsABtn&#39;)
  releaseASkills = () =&gt; {
    console.log(`释放A技能, ${+new Date()}`)
  }
  // 技能冷却时间 3 秒
  skillsABtn.onclick = throttle(releaseASkills, 3000)
&lt;/script&gt;</code></pre>
<h2 id="防抖去抖动-debounce、de--bounce">防抖(去抖动 debounce、de + bounce)</h2>
<p>对应 <strong>回城</strong>，在推塔游戏中，回城等待时间是 8 秒。可以理解为回城时，会开启一个定时任务，8 秒后执行完成回城的函数。</p>
<p>防抖/去抖动，就是在定时任务等待执行的时间内，如果再次触发发了函数，会取消上一次的定时任务，重新开始一个定时任务。这样可以<strong>将一段时间内连续的多次触发转化为一次触发，单位时间内仅执行最后一次</strong>。一般用于 window 的 scroll、resize 事件、搜索框输入搜索内容后实时查询接口等。</p>
<pre><code class="language-js">function debounce(func, time) {
  let timer = null // 定时任务计时器
  // 返回一个经过防抖处理的 func
  return function (...args) {
    if (timer) {
      // 如果上一次定时任务还在等待执行的过程中，取消定时任务
      clearTimeout(timer)
      console.log(&#39;取消上一次的计时任务&#39;)
    }

    console.log(`重新开启定时任务，${time} 毫秒后真正执行`)
    timer = setTimeout(() =&gt; {
      func.apply(this, args)
    }, time);
  }
}</code></pre>
<p>实例</p>
<pre><code class="language-html">&lt;button id=&quot;goBackBtn&quot;&gt;回城&lt;/button&gt;
&lt;script&gt;
  let goBackBtn = document.querySelector(&#39;#goBackBtn&#39;)
  goBack = () =&gt; {
    console.log(`成功回城, ${+new Date()}`)
  }
  // 3 秒之后回城
  goBackBtn.onclick = debounce(goBack, 3000) 
&lt;/script&gt;</code></pre>
<h2 id="代码下载">代码下载</h2>
<p>完整 demo 示例代码：<a href="https://github.com/zuoxiaobai/fedemo/tree/master/src/DebugDemo/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%E5%AE%9E%E7%8E%B0">节流和防抖实现 - fedemo | Github</a>，在线示例 <a href="https://zuoxiaobai.github.io/fedemo/src/DebugDemo/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%E5%AE%9E%E7%8E%B0/#/">节流与防抖简单实现 demo - 需要打开 console 看执行效果</a></p>

            
            <ins class='adsbygoogle' style='display:block;margin-top:1em;margin-bottom:0' data-ad-format='fluid' data-ad-layout-key='-gw-3+1f-3d+2z' data-ad-client='ca-pub-9527676606416641' data-ad-slot='8870245163'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            <!-- 评论系统占位 -->
            <div id="commentDiv"></div>
          </article>

          <aside>
            <div class="aside-wrap">
              <div class="top ">
                <ul><li><span class="ul-span" data-id="用游戏中的场景理解节流与防抖，最简单的-js-实现" style="padding-left:1em">用游戏中的场景理解节流与防抖，最简单的 js 实现<span></li><ul><li><span class="ul-span" data-id="节流throttle" style="padding-left:2em">节流(throttle)<span></li></ul><ul><li><span class="ul-span" data-id="防抖去抖动-debounce、de--bounce" style="padding-left:2em">防抖(去抖动 debounce、de + bounce)<span></li></ul><ul><li><span class="ul-span" data-id="代码下载" style="padding-left:2em">代码下载<span></li></ul></ul>
              </div>
              <ins class='adsbygoogle' style='display:block;width:300px;height:250px;' data-ad-client='ca-pub-9527676606416641' data-ad-slot='9476232907'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            </div>
          </aside>
        </section>
        <footer>
          <div class="footer_content">
            <div class="footer_right">Copyright © 2016-2021 zuo11.com. <a href='http://beian.miit.gov.cn/'>鄂ICP备16014741号-1</a></div>
            <div>Powered by <a href='https://github.com/zuoxiaobai/zuo-blog' target='_black'>zuo-blog</a></div>
          </div>
        </footer>
        <script src="/lib/prismjs/prism_default.js"></script>
        <script src="/lib/notes.js"></script> 
        <script src="/lib/global.js"></script>
        <script>
          
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?183281668cc3440449274d1f93c04de6";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    
        </script>
        <!-- Global site tag (gtag.js) - Google Analytics -->
<!-- <script async src="https://www.googletagmanager.com/gtag/js?id=UA-178732583-1"></script> -->
<script>
  // window.dataLayer = window.dataLayer || [];
  // function gtag(){dataLayer.push(arguments);}
  // gtag('js', new Date());
  // gtag('config', 'UA-178732583-1');

  window.onload = function() {
    setTimeout(function() {
      let script = document.createElement("script");
      script.setAttribute("data-ad-client", "ca-pub-9527676606416641");
      script.setAttribute("async", "");
      script.src = "//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js";
      document.body.appendChild(script);
    }, 200);
  }
</script>

      </body>
    </html>
  