
    <!DOCTYPE html>
    <html lang="zh-CN">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">

        <meta name="application name" content="sw-notification.html">
        <meta name="author" content="guoqzuo">
        <meta name="description" content="推送通知一般需要支持服务器推送，在常规网页中是不可能的。service worker 可以实现该行为 - service worker 可以显示通知 - service worker 可以处理这些通知的交互 - service worker 能够订阅服务器发送的推送通知 - service worker 能够处理推送消息，即使应用没有在前台运行或者根本没打开">
        <meta name="keywords" content="service worker接收服务器推送消息">

        <title>使用 Service Worker 接收服务器推送消息并显示通知 - 左小白的技术日常</title>
        <link rel="shortcut icon" href="/images/favicon.ico">
        <link href="/lib/prismjs/prism_default.css" rel="stylesheet" />
        <link href="/lib/notes.css" rel="stylesheet" />
        <link rel="stylesheet" href="/lib/global.css">
        
      </head>
      <body>
        <header>
          <div>
            <img src="/images/logo.png" width="24" height="24" class="pointer" onclick="gotoIndex()" />
            <span class="pointer" onclick="gotoIndex()">左小白的技术日常</span>
            <span class="hidden"> | </span>
            <a href="/blog/category.html#javascript" class="hidden">JavaScript</a>
          </div>
          <div>
            
          <a href="http://fe.zuo11.com" target="_black" class="hidden">我的笔记</a>
        
          <a href="https://github.com/zuoxiaobai" target="_black" class="">Github</a>
        
          </div>
        </header>
        <section class="content">
          <article>
            <h1 id="使用-service-worker-接收服务器推送消息并显示通知">使用 Service Worker 接收服务器推送消息并显示通知</h1>
            
    <div class="article-top">
      <div class="flex">
        这篇文章发布于 2021/01/12，归类于 <a href="/blog/category.html#javascript" class="hidden">JavaScript</a>
        <!-- ，阅读 11 次，今日 1 次 <div class="top-comment">4 条评论</div> -->
        <div id="readAndComment" class="flex"></div>
      </div> 
      <div class="flex keywords" style="flex-wrap: nowrap;">
        <div style="flex-shrink:0; align-self: flex-start;">标签：</div>
        <div class="flex" style="flex-wrap: wrap;"><span>service worker接收服务器推送消息</span></div>
      </div>
    </div>
    
  
            
<p>推送通知一般需要支持服务器推送，在常规网页中是不可能的。service worker 可以实现该行为</p>
<ul>
<li>service worker 可以显示通知</li>
<li>service worker 可以处理这些通知的交互</li>
<li>service worker 能够订阅服务器发送的推送通知</li>
<li>service worker 能够处理推送消息，即使应用没有在前台运行或者根本没打开</li>
</ul>
<p><img src="../../../images/blog/js/sw-push-img.png" alt="sw-push-img.png"></p>
<h2 id="1-显示通知">1. 显示通知</h2>
<p>在 service worker 中可以使用 ServcieWorkerRegistration 对象支持 showNotifications() 方法来显示通知，可以配置 title 和 options 配置</p>
<pre><code class="language-js">navigator.serviceWorker.register(&#39;./serviceWorker.js&#39;)
  .then((registration) =&gt; {
    Notification.requestPermission()
      .then(status =&gt; {
        if (status === &#39;granted&#39;) {
          registration.showNotification(&#39;title&#39;)
        }
      })
  })</code></pre>
<p>在 serviceWorker.js 中使用 self.registration 也可以显示通知</p>
<pre><code class="language-js">// 注意 onactivate 默认只触发一次
self.onactivate = () =&gt; self.registration.showNotification(&#39;bar&#39;)</code></pre>
<h2 id="2-处理通知事件">2. 处理通知事件</h2>
<p>ServiceWorkerRegistration 对象创建的通知会向 service worker 发送 notificationclick 和 notificationclose 事件</p>
<pre><code class="language-js">self.onnotificationclick = (event) =&gt; {
  // NotificationEvent {}, Notification {}
  console.log(&#39;notification click&#39;, event, event.notification)
  // 点击通知后，在新的 tab 打开网页
  clients.openWindow(&#39;http://www.zuo11.com&#39;)
}
self.onnotificationclose = (event) =&gt; {
  console.log(&#39;notification close&#39;, event, event.notification)
}</code></pre>
<h2 id="3订阅推送事件">3.订阅推送事件</h2>
<p>使用 registration.pushManager.subscribe() 可以对服务器推送消息发起订阅。注意这个过程中不会发送请求到我们的应用服务器。该函数包含两个参数：</p>
<ul>
<li><code>userVisibleOnly</code> 通常被设置为 true，用来表示后续信息是否展示给用户。</li>
<li><code>applicationServerKey</code> 秘钥，类型为 Uint8Array，用于加密服务端的推送信息，防止中间人攻击，会话被攻击者篡改。测试时，可以通过 <a href="https://web-push-codelab.glitch.me/">web-push-codelab</a> 网站获取秘钥并验证全流程，将该网站随机生产的 Application Server Keys 中的 Public Key 使用 urlBase64ToUint8Array() 转换后即可当做 applicationServerKey 使用</li>
</ul>
<p>urlBase64ToUint8Array() 函数代码</p>
<pre><code class="language-js">function urlBase64ToUint8Array(base64String) {
  const padding = &#39;=&#39;.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, &#39;+&#39;)
    .replace(/_/g, &#39;/&#39;);

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i &lt; rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}</code></pre>
<p><strong>registration.pushManager.subscribe() 函数返回一个 Promise，resolve 为 PushSubscription 对象，该对象包含服务器推送时必要的信息</strong> 不同的浏览器，对应的 endpoint 不一样。Chrome 和 Firefox 会不一样，如下图</p>
<p><img src="../../../images/blog/js/sw_push.png" alt="sw_push.png"></p>
<p><strong>如果一直卡在 registration.pushManager.subscribe()，不向下执行，状态一直时 pending，可能是因为 Chrome 浏览器关于推送消息的功能，被墙了，需要科学上网才能正常返回</strong></p>
<p>订阅代码如下：</p>
<pre><code class="language-js">// main.js
(async () =&gt; {
  try {
    const registration = await navigator.serviceWorker.register(&quot;sw.js&quot;);
    const status = await Notification.requestPermission()
    if (status === &#39;granted&#39;) {
      const vapidPublicKey = &#39;BF9WWlvQiKSOwziO4gVeBdMeuhDW2HU2aCWAmaSLgXqGCGZK3ho15l30oQ6pdavh8acsc1kiXJNK-DtaqbHaZCQ&#39;;
      const convertedVapidKey = urlBase64ToUint8Array(vapidPublicKey);
      // 防止 DOMException: Failed to execute &#39;subscribe&#39; on &#39;PushManager&#39;: Subscription failed - no active Service Worker
      if (!registration.active) {
        // 等待变为激活状态
        await new Promise(r =&gt; setTimeout(r, 500))
      }
      const pushSubscription = await registration.pushManager.subscribe({
        applicationServerKey: convertedVapidKey, // 来自服务器的公钥
        userVisibleOnly: true
      });
      console.log(pushSubscription) // PushSubscription
      console.log(JSON.stringify(pushSubscription)) // 这个消息可用于服务端发起推送
      // { 
      //   &quot;endpoint&quot;: &quot;https://fcm.googleapis.com/fcm/send/ecbqKLEnhB8:APA91bGvTW0x3k57bT9gDMLPPVkwLotGJyqJ1kk8yvNHyNAJ8Z0F6O74BuA8QxVNPIsgf1gWlGrUe0bYSs4L6fo-Fl18WkwGyHc3FEo2YvSUXBr5AA7KenaZBkL1D87WuAE7ERl-JCM4&quot;,
      //   &quot;expirationTime&quot;: null, 
      //   &quot;keys&quot;: { 
      //     &quot;p256dh&quot;: &quot;BIpKDNOPNQcBnfJVmdtZM2eJ0qS-FjicsiZK8jyUU07lGREwM_VZe2ulIWdrdlNlg7RFnHge8vJSe5y6TagW3Oc&quot;,
      //     &quot;auth&quot;: &quot;IlAite8VLBLWV5ubUXg91w&quot;
      //   }
      // }
    }
  } catch (err) {
    console.log(err);
  }
})()</code></pre>
<p>上面的例子中，成功拿到 JSON.stringify(pushSubscription) 后，就可以在服务端使用该信息进行推送通知了。</p>
<h2 id="4处理服务端推送消息">4.处理服务端推送消息</h2>
<pre><code class="language-js">// sw.js
// 当接收到服务端推送的消息时
self.onpush = pushEvent =&gt; {
  // 服务器推送的消息文本
  console.log(pushEvent.data.text())
  // 保持 service worker 活动到显示通知 resolve
  pushEvent.waitUntil(
    // 将服务器推送的消息作为通知显示
    self.registration.showNotification(pushEvent.data.text())
  )
}
// 点击消息时
self.onnotificationclick = (event) =&gt; {
  // NotificationEvent {}, Notification {}
  console.log(&#39;notification click&#39;, event, event.notification)
  // 点击通知后，在新的 tab 打开网页
  clients.openWindow(&#39;http://www.zuo11.com&#39;)
}</code></pre>
<p>现在来测试下，上面的例子中，我们使用 <a href="https://web-push-codelab.glitch.me/">web-push-codelab</a> 网站获取了 applicationServerKey 秘钥，我们同样可以在该网站发起服务端消息推送。将之前我们获取的 JSON.stringify(pushSubscription) 字符串拷贝到该网站的 Subscription to Send To 那一栏，然后在 Text to Send 中填写需要推送的消息。再点击 Send Push Message 按钮即可进行服务器推送。</p>
<p>这样就可以看到通知了。上面只是为了方便测试，如果需要使用程序化的方式来进行服务端推送，那就需要把 JSON.stringify(pushSubscription) 字符串传到后端，以 Node.js 为例，后端可以使用 <a href="https://github.com/web-push-libs/web-push">web-push</a> 来进行服务端推送。</p>
<p>参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/57225424">Service Worker学习与实践（三）——消息推送 - 知乎</a></li>
<li><a href="https://blog.csdn.net/weixin_33841722/article/details/88731760">Service Worker学习与实践（三）——消息推送 - CSDN</a></li>
<li><a href="https://w3c.github.io/push-api/#widl-PushManager-subscribe-Promise-PushSubscription--PushSubscriptionOptions-options">Push API - W3C Editor&#39;s Draft 07 October 2020</a></li>
</ul>

            
            <ins class='adsbygoogle' style='display:block;margin-top:1em;margin-bottom:0' data-ad-format='fluid' data-ad-layout-key='-gw-3+1f-3d+2z' data-ad-client='ca-pub-9527676606416641' data-ad-slot='8870245163'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            <!-- 评论系统占位 -->
            <div id="commentDiv"></div>
          </article>

          <aside>
            <div class="aside-wrap">
              <div class="top ">
                <ul><li><span class="ul-span" data-id="使用-service-worker-接收服务器推送消息并显示通知" style="padding-left:1em">使用 Service Worker 接收服务器推送消息并显示通知<span></li><ul><li><span class="ul-span" data-id="1-显示通知" style="padding-left:2em">1. 显示通知<span></li></ul><ul><li><span class="ul-span" data-id="2-处理通知事件" style="padding-left:2em">2. 处理通知事件<span></li></ul><ul><li><span class="ul-span" data-id="3订阅推送事件" style="padding-left:2em">3.订阅推送事件<span></li></ul><ul><li><span class="ul-span" data-id="4处理服务端推送消息" style="padding-left:2em">4.处理服务端推送消息<span></li></ul></ul>
              </div>
              <ins class='adsbygoogle' style='display:block;width:300px;height:250px;' data-ad-client='ca-pub-9527676606416641' data-ad-slot='9476232907'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            </div>
          </aside>
        </section>
        <footer>
          <div class="footer_content">
            <div class="footer_right">Copyright © 2016-2021 zuo11.com. <a href='http://beian.miit.gov.cn/'>鄂ICP备16014741号-1</a></div>
            <div>Powered by <a href='https://github.com/zuoxiaobai/zuo-blog' target='_black'>zuo-blog</a></div>
          </div>
        </footer>
        <script src="/lib/prismjs/prism_default.js"></script>
        <script src="/lib/notes.js"></script> 
        <script src="/lib/global.js"></script>
        <script>
          
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?183281668cc3440449274d1f93c04de6";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    
        </script>
        <!-- Global site tag (gtag.js) - Google Analytics -->
<!-- <script async src="https://www.googletagmanager.com/gtag/js?id=UA-178732583-1"></script> -->
<script>
  // window.dataLayer = window.dataLayer || [];
  // function gtag(){dataLayer.push(arguments);}
  // gtag('js', new Date());
  // gtag('config', 'UA-178732583-1');

  window.onload = function() {
    setTimeout(function() {
      let script = document.createElement("script");
      script.setAttribute("data-ad-client", "ca-pub-9527676606416641");
      script.setAttribute("async", "");
      script.src = "//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js";
      document.body.appendChild(script);
    }, 200);
  }
</script>

      </body>
    </html>
  