
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">

        <meta name="application name" content="apue_pwd.html">
        <meta name="author" content="guoqzuo">
        <meta name="description" content="了解了文件目录相关的系统调用后，就可以尝试模拟实现各种shell命令了。这里给出了ls -l的完成代码，加上pwd及mkdir -p的实现。里面用到了递归，也涉及到一些细节问题，如根目录的上一级目录还是根目录，chdir需要用户有目录的执行权限。">
        <meta name="keywords" content="apue笔记,pwd实现,ls -l实现,mkdir -p实现">

        <title>apue pwd命令实现 - 左小白的技术日常</title>
        <link rel="shortcut icon" href="/images/favicon.ico">
        <link href="/lib/prismjs/prism_default.css" rel="stylesheet" />
        <link href="/lib/notes.css" rel="stylesheet" />
        <link rel="stylesheet" href="/lib/global.css">
        
      </head>
      <body>
        <header>
          <div>
            <img src="/images/logo.png" width="24" height="24" class="pointer" onclick="gotoIndex()" />
            <span class="pointer" onclick="gotoIndex()">左小白的技术日常</span>
            <span class="hidden"> | </span>
            <a href="/blog/category.html#c与apue" class="hidden">C与APUE</a>
          </div>
          <div>
            
          <a href="http://fe.zuo11.com" target="_black" class="hidden">我的笔记</a>
        
          <a href="https://github.com/zuoxiaobai" target="_black" class="">Github</a>
        
          </div>
        </header>
        <section class="content">
          <article>
            <h1 id="apue-pwd命令实现">apue pwd命令实现</h1>
            
    <div class="article-top">
      <div class="flex">
        这篇文章发布于 2016/10/20，归类于 <a href="/blog/category.html#c与apue" class="hidden">C与APUE</a>
        <!-- ，阅读 11 次，今日 1 次 <div class="top-comment">4 条评论</div> -->
        <div id="readAndComment" class="flex"></div>
      </div> 
      <div class="flex keywords" style="flex-wrap: nowrap;">
        <div style="flex-shrink:0; align-self: flex-start;">标签：</div>
        <div class="flex" style="flex-wrap: wrap;"><span>apue笔记</span>，<span>pwd实现</span>，<span>ls -l实现</span>，<span>mkdir -p实现</span></div>
      </div>
    </div>
    
  
            
<blockquote>
<p>了解了文件目录相关的系统调用后，就可以尝试模拟实现各种shell命令了。这里给出了ls -l的完成代码，加上pwd及mkdir -p的实现。里面用到了递归，也涉及到一些细节问题，如根目录的上一级目录还是根目录，chdir需要用户有目录的执行权限。</p>
</blockquote>
<p><img src="../../../images/blog/apue/apue_pwd.png" alt="apue_pwd.png"></p>
<h2 id="pwd命令的实现，显示当前路径">pwd命令的实现，显示当前路径</h2>
<p>思路: 先获取当前目录的名字，然后chdir到上一级目录，重复..直到根目录  </p>
<pre><code class="language-c">/*  
 *  pwd的实现  
 *  Thu Oct 20 17:48:52 2016
 *  Create by Kevin Zuo
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;dirent.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

void pwd()
{
    struct stat buf;
    struct stat buf2;
    DIR* dirp = opendir(&quot;..&quot;);

    lstat(&quot;.&quot;, &amp;buf);
    lstat(&quot;..&quot;, &amp;buf2);
    if ( buf.st_ino == buf2.st_ino) // 如果当前目录和上一级目录的i节点相同
        return;

    chdir(&quot;..&quot;); // 先递归再打印
    pwd();

    struct dirent* p;
    while(1) {
        int err = errno;
        p = readdir(dirp);
        if (p == NULL &amp;&amp; errno != err) { // 错误提示
            perror(&quot;readdir()&quot;);
            return;
        }
        if (p == NULL) break; // 读完退出
        if (p-&gt;d_fileno == buf.st_ino) { // 找到文件名后结束
            printf(&quot;/%s&quot;, p-&gt;d_name);
            break;
        }
    }


int main(int argc, char* argv[])
{
    // 如果是在根目录，省略处理...; 某些出错判断，省略...
    pwd();
    printf(&quot;\n&quot;);

    exit(0);
}

// 运行效果:
// kevindeMacBook-Air:~ kevin$ ./a.out
// /Users/kevin
// kevindeMacBook-Air:~ kevin$ pwd
// /Users/kevin
// kevindeMacBook-Air:~ kevin$</code></pre>
<h2 id="ls--l-的完整实现">ls -l 的完整实现</h2>
<p>思路: 遍历当前目录的文件，过滤掉以.开头的文件，以一定格式打印</p>
<pre><code class="language-c">/*  
 *  ls -l的实现  
 *  Thu Oct 20 19:09:48 2016
 *  Create by Kevin Zuo
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;dirent.h&gt;
#include &lt;pwd.h&gt;
#include &lt;grp.h&gt;
#include &lt;errno.h&gt;

void print_mode(mode_t mode)
{
    //printf(&quot;%o &quot;, mode);
    switch (mode &amp; S_IFMT) { // 打印文件类型
        case S_IFIFO: putchar(&#39;p&#39;); break;
        case S_IFCHR: putchar(&#39;c&#39;); break;
        case S_IFDIR: putchar(&#39;d&#39;); break;
        case S_IFBLK: putchar(&#39;b&#39;); break;
        case S_IFREG: putchar(&#39;-&#39;); break;
        case S_IFLNK: putchar(&#39;l&#39;); break;
        case S_IFSOCK: putchar(&#39;s&#39;); break;
    }
    if (mode &amp; S_IRUSR) putchar(&#39;r&#39;); else putchar(&#39;-&#39;);
    if (mode &amp; S_IWUSR) putchar(&#39;w&#39;); else putchar(&#39;-&#39;);
    if (mode &amp; S_IXUSR) putchar(&#39;x&#39;); else putchar(&#39;-&#39;);

    if (mode &amp; S_IRGRP) putchar(&#39;r&#39;); else putchar(&#39;-&#39;);
    if (mode &amp; S_IWGRP) putchar(&#39;w&#39;); else putchar(&#39;-&#39;);
    if (mode &amp; S_IXGRP) putchar(&#39;x&#39;); else putchar(&#39;-&#39;);

    if (mode &amp; S_IROTH) putchar(&#39;r&#39;); else putchar(&#39;-&#39;);
    if (mode &amp; S_IWOTH) putchar(&#39;w&#39;); else putchar(&#39;-&#39;);
    if (mode &amp; S_IXOTH) putchar(&#39;x&#39;); else putchar(&#39;-&#39;);

    putchar(&#39; &#39;);
}

int main(int argc, char* argv[])
{
    DIR* dirp = opendir(&quot;.&quot;);
    struct dirent* p;

    while (1) {
        int err = errno;
        p = readdir(dirp);
        if (err != errno &amp;&amp; p == NULL) {
            perror(&quot;readdir()&quot;);
            return 1;
        }
        if (p == NULL) break;
        if (p-&gt;d_name[0] == &#39;.&#39;) continue; // 如果是隐藏文件，退出

        struct stat buf;
        struct passwd* t1;
        struct group* t2;
        struct tm* t;

        lstat(p-&gt;d_name, &amp;buf); // 获取当前目录(~)下文件1.c的信息存入变量buf
        t1 = getpwuid(buf.st_uid);
        t2 = getgrgid(buf.st_gid);
        t = localtime(&amp;buf.st_mtime);

        print_mode(buf.st_mode); // 打印前面的信息
        printf(&quot;%2d &quot;, buf.st_nlink); // 文件硬链接数
        printf(&quot;%s %s &quot;, t1-&gt;pw_name, t2-&gt;gr_name); // 文件的拥有者及所在用户组
        printf(&quot;%6lld &quot;, buf.st_size); //文件大小
        printf(&quot;%2d %2d %02d:%02d &quot;, t-&gt;tm_mon+1, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min);
        printf(&quot;%s\n&quot;, p-&gt;d_name);
    }

    exit(0);
}

// 运行效果：
// kevindeMacBook-Air:~ kevin$ ./a.out
// drwxr-xr-x 30 kevin staff   1020 10 20 19:19 1
// -rw-r--r--  1 kevin staff    143 10 17 17:31 1.txt
// -rw-r--r--  1 kevin staff 144313 10 15 16:27 1015.sql
// -rw-r--r--  1 kevin staff 143533 10 15 19:07 1015_2.sql
// -rw-r--r--  1 kevin staff    143 10 17 17:37 5.txt
// -rwxr-xr-x  1 kevin staff   9008 10 20 19:49 a.out
// drwx------ 17 kevin staff    578 10 20 18:56 Desktop
// drwx------  7 kevin staff    238 10 13 14:46 Documents
// drwx------ 15 kevin staff    510 10 18 15:04 Downloads
// drwx------ 53 kevin staff   1802  8  2 12:21 Library
// -rw-r--r--  1 kevin staff   2046 10 20 19:49 ls.c
// drwx------  3 kevin staff    102  6  1 12:08 Movies
// drwx------  5 kevin staff    170  6 25 15:49 Music
// drwx------  4 kevin staff    136 10 17 16:00 Pictures
// drwxr-xr-x  5 kevin staff    170  6  1 12:08 Public
// -rw-r--r--  1 kevin staff    918 10 20 19:28 pwd.c
// kevindeMacBook-Air:~ kevin$ ls -l
// total 632
// drwxr-xr-x  30 kevin  staff    1020 10 20 19:19 1
// -rw-r--r--   1 kevin  staff     143 10 17 17:31 1.txt
// -rw-r--r--   1 kevin  staff  144313 10 15 16:27 1015.sql
// -rw-r--r--   1 kevin  staff  143533 10 15 19:07 1015_2.sql
// -rw-r--r--   1 kevin  staff     143 10 17 17:37 5.txt
// drwx------+ 17 kevin  staff     578 10 20 18:56 Desktop
// drwx------+  7 kevin  staff     238 10 13 14:46 Documents
// drwx------+ 15 kevin  staff     510 10 18 15:04 Downloads
// drwx------@ 53 kevin  staff    1802  8  2 12:21 Library
// drwx------+  3 kevin  staff     102  6  1 12:08 Movies
// drwx------+  5 kevin  staff     170  6 25 15:49 Music
// drwx------+  4 kevin  staff     136 10 17 16:00 Pictures
// drwxr-xr-x+  5 kevin  staff     170  6  1 12:08 Public
// -rwxr-xr-x   1 kevin  staff    9008 10 20 19:49 a.out
// -rw-r--r--   1 kevin  staff    2046 10 20 19:49 ls.c
// -rw-r--r--   1 kevin  staff     918 10 20 19:28 pwd.c
// kevindeMacBook-Air:~ kevin$</code></pre>
<p>这里没有处理l符号链接，有时间可以扩展</p>
<h2 id="mkdir--p-功能模拟">mkdir -p 功能模拟</h2>
<pre><code class="language-c">int mkdir(const char *path, mode_t mode); -- make a directory file
int chdir(const char *path); -- change current working directory
In order for a directory to become the current directory, a process must have execute (search) access to the directory.</code></pre>
<p>这里可能是为什么文件权限为0644, 而目录的权限是0755的原因(都多了执行权限)</p>
<pre><code class="language-c">/*  
 *  mkdir -p 模拟  
 *  Thu Oct 20 20:23:01 2016
 *  Create by Kevin Zuo
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;

int main(int argc, char* argv[])
{
    if (argc != 2) { // 通过命令行传参 ./a.out 4/2/3, 乱传参数错误处理部分会忽略
        printf(&quot;argc error!&quot;);
        exit(1);
    }

    if (!access(argv[1], F_OK)) { // 如果该文件已存在
        printf(&quot;文件已存在!&quot;);
        exit(2);
    }
    if (argv[1][0] == &#39;/&#39;) // 如果是根目录下
        chdir(&quot;/&quot;);
    char* p = strtok(argv[1], &quot;/&quot;);
    if (mkdir(p, 0755)) { // 根目录下可能会出现权限限制 ./a.out /5
        perror(&quot;mkdir()&quot;);
        exit(3);
    }
    chdir(p);

    while (1) { // 循环切分
        char* q = strtok(NULL, &quot;/&quot;);

        if (q == NULL)
            break;
        if (!access(q, F_OK)) continue;
        mkdir(q, 0755);
        chdir(q);
    }

    exit(0);
}</code></pre>

            
            <ins class='adsbygoogle' style='display:block;margin-top:1em;margin-bottom:0' data-ad-format='fluid' data-ad-layout-key='-gw-3+1f-3d+2z' data-ad-client='ca-pub-9527676606416641' data-ad-slot='8870245163'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            <!-- 评论系统占位 -->
            <div id="commentDiv"></div>
          </article>

          <aside>
            <div class="aside-wrap">
              <div class="top ">
                <ul><li><span class="ul-span" data-id="apue-pwd命令实现" style="padding-left:1em">apue pwd命令实现<span></li><ul><li><span class="ul-span" data-id="pwd命令的实现，显示当前路径" style="padding-left:2em">pwd命令的实现，显示当前路径<span></li></ul><ul><li><span class="ul-span" data-id="ls--l-的完整实现" style="padding-left:2em">ls -l 的完整实现<span></li></ul><ul><li><span class="ul-span" data-id="mkdir--p-功能模拟" style="padding-left:2em">mkdir -p 功能模拟<span></li></ul></ul>
              </div>
              <ins class='adsbygoogle' style='display:block;width:300px;height:250px;' data-ad-client='ca-pub-9527676606416641' data-ad-slot='9476232907'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            </div>
          </aside>
        </section>
        <footer>
          <div class="footer_content">
            <div class="footer_right">Copyright © 2016-2020 zuo11.com. <a href='http://beian.miit.gov.cn/'>鄂ICP备16014741号-1</a></div>
            <div>Powered by <a href='https://github.com/zuoxiaobai/zuo-blog' target='_black'>zuo-blog</a></div>
          </div>
        </footer>
        <script src="/lib/prismjs/prism_default.js"></script>
        <script src="/lib/notes.js"></script> 
        <script src="/lib/global.js"></script>
        <script>
          
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?183281668cc3440449274d1f93c04de6";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    
        </script>
        <!-- Global site tag (gtag.js) - Google Analytics -->
<!-- <script async src="https://www.googletagmanager.com/gtag/js?id=UA-178732583-1"></script> -->
<script>
  // window.dataLayer = window.dataLayer || [];
  // function gtag(){dataLayer.push(arguments);}
  // gtag('js', new Date());
  // gtag('config', 'UA-178732583-1');

  window.onload = function() {
    setTimeout(function() {
      let script = document.createElement("script");
      script.setAttribute("data-ad-client", "ca-pub-9527676606416641");
      script.setAttribute("async", "");
      script.src = "//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js";
      document.body.appendChild(script);
    }, 200);
  }
</script>

      </body>
    </html>
  