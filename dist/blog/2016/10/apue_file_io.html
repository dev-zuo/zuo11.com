
    <!DOCTYPE html>
    <html lang="zh-CN">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">

        <meta name="application name" content="apue_file_io.html">
        <meta name="author" content="guoqzuo">
        <meta name="description" content=" UNIX系统中，文件I/O常用的5个函数: open,read,write,lseek,close。与标准I/O相比文件I/O通常称为不带缓冲的I/O(unbuffered)。一般所有I/O都要经过内核的块缓冲。read，write的数据也要被内核缓冲，这里不带缓冲的I/O指的是在用户进程用不会自动缓冲，每次都是系统调用。">
        <meta name="keywords" content="文件IO,标准IO,C语言文件处理,APUE文件IO,apue 文件io">

        <title>apue 文件IO - 左小白的技术日常</title>
        <link rel="shortcut icon" href="/images/favicon.ico">
        <link href="/lib/prismjs/prism_default.css" rel="stylesheet" />
        <link href="/lib/notes.css" rel="stylesheet" />
        <link rel="stylesheet" href="/lib/global.css">
        
      </head>
      <body>
        <header>
          <div>
            <img src="/images/logo.png" width="24" height="24" class="pointer" onclick="gotoIndex()" />
            <span class="pointer" onclick="gotoIndex()">左小白的技术日常</span>
            <span class="hidden"> | </span>
            <a href="/blog/category.html#c与apue" class="hidden">C与APUE</a>
          </div>
          <div>
            
          <a href="http://fe.zuo11.com" target="_black" class="hidden">我的笔记</a>
        
          <a href="https://github.com/zuoxiaobai" target="_black" class="">Github</a>
        
          </div>
        </header>
        <section class="content">
          <article>
            <h1 id="apue-文件io">apue 文件IO</h1>
            
    <div class="article-top">
      <div class="flex">
        这篇文章发布于 2016/10/18，归类于 <a href="/blog/category.html#c与apue" class="hidden">C与APUE</a>
        <!-- ，阅读 11 次，今日 1 次 <div class="top-comment">4 条评论</div> -->
        <div id="readAndComment" class="flex"></div>
      </div> 
      <div class="flex keywords" style="flex-wrap: nowrap;">
        <div style="flex-shrink:0; align-self: flex-start;">标签：</div>
        <div class="flex" style="flex-wrap: wrap;"><span>文件IO</span>，<span>标准IO</span>，<span>C语言文件处理</span>，<span>APUE文件IO</span>，<span>apue 文件io</span></div>
      </div>
    </div>
    
  
            
<blockquote>
<p>UNIX系统中，文件I/O常用的5个函数: open,read,write,lseek,close。与标准I/O相比文件I/O通常称为不带缓冲的I/O(unbuffered)。一般所有I/O都要经过内核的块缓冲。read，write的数据也要被内核缓冲，这里不带缓冲的I/O指的是在用户进程用不会自动缓冲，每次都是系统调用。</p>
</blockquote>
<p><img src="../../../images/blog/apue/apue_file_io_1.png" alt="apue_file_io_1.png"></p>
<h2 id="文件描述符-file-descriptor">文件描述符 (file descriptor)</h2>
<p>对内核而言，所有打开的文件都是通过fd来引用。</p>
<p>文件描述符0，1，2分别与进程的标准输入，输出，错误缓冲区相关联，分别对应宏STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO。这些宏都在unistd.h里定义，一般每个进程最多能打开64个文件</p>
<h2 id="io函数概述">I/O函数概述</h2>
<p>这里主要介绍open、create、read、write、lseek、close、fcntl等函数</p>
<h3 id="open函数">open函数</h3>
<p>类似printf，可变长参数，可以是2参或3参。打开文件，返回该文件的fd，错误返回-1，且修改errno值</p>
<pre><code class="language-c">int open(const char *path, int oflag, ...); // open or create a file for reading or writing</code></pre>
<p>函数参数：</p>
<ul>
<li>path: 文件路径</li>
<li>oflag: 文件打开的方式，只读O_RDONLY、只写O_WRONLY、读写O_RDWR、追加写入O_APPED等<ul>
<li>只读，只写，读写 三个中必选一个，其它的是可以追加的，一般标志位的定义都是以8进制来对应</li>
<li>只读为0，只写为1，追加写入为8，可以&quot;|&quot;的方式进行组合。</li>
<li>O_EXCL | O_CREAT，文件存在返回-1，否则正常执行，防止同名文件被修改</li>
<li>O_TRUNC | O_CREAT, 文件存在就清空，不存在就创建</li>
<li>open时如果文件不存在会返回错误，除非打开时加上标记位:O_CREAT, 文件不存在就创建</li>
</ul>
</li>
<li>创建文件时权限，O_CREAT 打开文件时，如果文件不存在，就需要使用参数3了，用来指定穿件文件时的默认权限，0644。<ul>
<li>以前只有两参后来加了一个参数，用来淘汰creat()函数，使打开文件和创建文件成为原子性操作</li>
</ul>
</li>
</ul>
<p>示例: open(&quot;1.c&quot;, O_RDONLY | O_CREAT, 0644) 打开文件，如果存在就打开，不存在创建，权限为0644，如果只用2参，写法如下    </p>
<pre><code class="language-c">if ((fd = open(&quot;1.c&quot;, O_RDONLY)) &lt; 0) {
    if (error == ENOENT) { // 如果文件打开失败，且错误为文件不存在
        creat(&quot;1.c&quot;, 0644);
    } else {
        perror(&quot;open()&quot;);
        return 1;
    }
}</code></pre>
<p><strong>系统调用函数一般是原子性(atomic operation)的，在执行的时候不会因为进程调度中断其执行而产生bug</strong></p>
<h3 id="create函数">create函数</h3>
<pre><code class="language-c">// DESCRIPTION   This interface is made obsolete by: open(2).
// The creat() function is the same as: open(path, O_CREAT | O_TRUNC | O_WRONLY, mode);
int creat(const char *path, mode_t mode);</code></pre>
<h3 id="read函数">read函数</h3>
<pre><code class="language-c">// 读取文件内容存入buf，返回读取的字节数，return 0 表示文件已读完
ssize_t read(int fildes, void *buf, size_t nbyte); // read input </code></pre>
<h3 id="write函数">write函数</h3>
<pre><code class="language-c">// 向文件写入内容
ssize_t write(int fildes, void *buf, size_t nbyte); // wirte output</code></pre>
<h3 id="lseek函数">lseek函数</h3>
<pre><code class="language-c">// 移动文件偏移位置，之前写一个取反加密时用过.  
// whence有3种情况0,1,2分别对应SEEK_SET、SEEK_CUR、SEEK_END, 宏和数字怎么方便就怎么用
off_t lseek(int fildes, off_t offset, int whence); // reposition read/write file offset</code></pre>
<h3 id="close函数">close函数</h3>
<pre><code class="language-c">// 关闭文件，官方解释为删除fd
int close(int fildes);  // delete a descriptor</code></pre>
<h3 id="fcntl函数">fcntl函数</h3>
<pre><code class="language-c">int fcntl(int fildes, int cmd, ...); // file control
// 可以修改已打开文件的fd标志，文件状态标志，复制fd，参数2决定它的功能
// cmd = F_GETFD/F_SETFD 获取或设置fd标志
// cmd = F_GETFL/F_SETFL 获取或设置文件状态标志，可追加O_APPED
// cmd = F_DUPFD，复制fd</code></pre>
<h2 id="内核io数据结构">内核I/O数据结构</h2>
<p>当打开一个文件，内核以什么形式来保持/操作相关数据？(以下UNIX系统适用，具体实现可能有差异）</p>
<p>当一个进程执行时：</p>
<ul>
<li>有一张进程表，里面包含一张打开文件表。每个打开的fd占一行，有两个属性:fd标志、文件指针</li>
<li>文件表里记录了文件状态标志(只读/写/追加等,用于指向该表所有fd)、当前偏移量、指向v结点表的指针</li>
<li>v结点表简化来讲包含了i节点表，里面记录了文件的基本信息，当前文件的长度等，如下图:    </li>
</ul>
<p><img src="../../../images/blog/apue/apue_file_io_2.png" alt="apue_file_io_2.png"></p>
<p>0、1、2为进程默认代开的文件</p>
<p><strong>每次write后，文件表里的文件偏移量会加入所写入的字节数，如国偏移量超过文件长度，i结点表的当前文件长度会修改为当前偏移量，文件增大。lseek没有进行任何I/O操作，只是修改了文件表中的当前文件偏移量</strong></p>
<h2 id="两个进程操作同一个文件">两个进程操作同一个文件</h2>
<p><img src="../../../images/blog/apue/apue_file_io_3.png" alt="apue_file_io_3.png"></p>
<ul>
<li><p>两个进程打开同一个文件，对应的文件表独立，但v结点是同一个</p>
</li>
<li><p>当两个进程同时open了一个文件，他们的文件偏移位置是独立的，进程1向文件写入数据，文件偏移，但此时进程2的文件偏移还是0，此时进程2写入数据，进程1写入的数据将被覆盖, O_APPEND可解决这个问题</p>
</li>
<li><p><strong>O_APPEND原理是当要写入数据到文件时，如果文件状态标志有O_APPEND，会先将文件的偏移量改为v结点里当前文件的长度，再write，就相当于每次write都要先lseek(fd, 0, SEEK_END); 但是这里是原子性的.</strong></p>
</li>
</ul>
<h2 id="文件描述符的copydup-dup2">文件描述符的copy(dup, dup2)</h2>
<p>dup, dup2 -- duplicate an existing file descriptor</p>
<p>open()函数返回fd遵循最小分配原则，默认打开了0、1、2，最小分配为3，如果0、1、2有关闭的，下次open就会占用系统的这些值, 例如close(1)后open一个文件，那么这个文件就成了输出缓冲区</p>
<pre><code class="language-c">int dup(int oldfd); // 将oldfd再分配一个fd，最小分配原则
int dup2(int oldfd, int newfd); // 复制fd，可指定新fd的值，如果新的已打开，先关闭。</code></pre>
<p><img src="../../../images/blog/apue/apue_file_io_4.png" alt="apue_file_io_4.png"></p>
<pre><code class="language-c">dup(fd); // ==&gt; fcntl(fd, F_DUPFD, 0);

dup(fd, fd2); // ==&gt; close(fd2); 
fcntl(fd, F_DUPFD, fd2);  // dup2是一个原子性的操作</code></pre>

            
            <ins class='adsbygoogle' style='display:block;margin-top:1em;margin-bottom:0' data-ad-format='fluid' data-ad-layout-key='-gw-3+1f-3d+2z' data-ad-client='ca-pub-9527676606416641' data-ad-slot='8870245163'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            <!-- 评论系统占位 -->
            <div id="commentDiv"></div>
          </article>

          <aside>
            <div class="aside-wrap">
              <div class="top ">
                <ul><li><span class="ul-span" data-id="apue-文件io" style="padding-left:1em">apue 文件IO<span></li><ul><li><span class="ul-span" data-id="文件描述符-file-descriptor" style="padding-left:2em">文件描述符 (file descriptor)<span></li></ul><ul><li><span class="ul-span" data-id="io函数概述" style="padding-left:2em">I/O函数概述<span></li><ul><li><span class="ul-span" data-id="open函数" style="padding-left:3em">open函数<span></li></ul><ul><li><span class="ul-span" data-id="create函数" style="padding-left:3em">create函数<span></li></ul><ul><li><span class="ul-span" data-id="read函数" style="padding-left:3em">read函数<span></li></ul><ul><li><span class="ul-span" data-id="write函数" style="padding-left:3em">write函数<span></li></ul><ul><li><span class="ul-span" data-id="lseek函数" style="padding-left:3em">lseek函数<span></li></ul><ul><li><span class="ul-span" data-id="close函数" style="padding-left:3em">close函数<span></li></ul><ul><li><span class="ul-span" data-id="fcntl函数" style="padding-left:3em">fcntl函数<span></li></ul></ul><ul><li><span class="ul-span" data-id="内核io数据结构" style="padding-left:2em">内核I/O数据结构<span></li></ul><ul><li><span class="ul-span" data-id="两个进程操作同一个文件" style="padding-left:2em">两个进程操作同一个文件<span></li></ul><ul><li><span class="ul-span" data-id="文件描述符的copydup-dup2" style="padding-left:2em">文件描述符的copy(dup, dup2)<span></li></ul></ul>
              </div>
              <ins class='adsbygoogle' style='display:block;width:300px;height:250px;' data-ad-client='ca-pub-9527676606416641' data-ad-slot='9476232907'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            </div>
          </aside>
        </section>
        <footer>
          <div class="footer_content">
            <div class="footer_right">Copyright © 2016-2020 zuo11.com. <a href='http://beian.miit.gov.cn/'>鄂ICP备16014741号-1</a></div>
            <div>Powered by <a href='https://github.com/zuoxiaobai/zuo-blog' target='_black'>zuo-blog</a></div>
          </div>
        </footer>
        <script src="/lib/prismjs/prism_default.js"></script>
        <script src="/lib/notes.js"></script> 
        <script src="/lib/global.js"></script>
        <script>
          
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?183281668cc3440449274d1f93c04de6";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    
        </script>
        <!-- Global site tag (gtag.js) - Google Analytics -->
<!-- <script async src="https://www.googletagmanager.com/gtag/js?id=UA-178732583-1"></script> -->
<script>
  // window.dataLayer = window.dataLayer || [];
  // function gtag(){dataLayer.push(arguments);}
  // gtag('js', new Date());
  // gtag('config', 'UA-178732583-1');

  window.onload = function() {
    setTimeout(function() {
      let script = document.createElement("script");
      script.setAttribute("data-ad-client", "ca-pub-9527676606416641");
      script.setAttribute("async", "");
      script.src = "//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js";
      document.body.appendChild(script);
    }, 200);
  }
</script>

      </body>
    </html>
  