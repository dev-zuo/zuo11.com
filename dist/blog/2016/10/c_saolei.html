
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">

        <meta name="application name" content="c_saolei.html">
        <meta name="author" content="guoqzuo">
        <meta name="description" content="扫雷游戏的逻辑其实很简单，只要学了C的循环语句、数组、递归就可以基本实现了。思路有了，就可以应用到UI上，这里例子是纯C代码，控制台下模拟，提供相关思路及示例。">
        <meta name="keywords" content="c语言扫雷实现,c 扫雷,扫雷源码,c语言扫雷源码,控制台扫雷源码,c语言扫雷,扫雷,扫雷一扫一大片">

        <title>c语言扫雷(控制台版) - 左小白的技术日常</title>
        <link rel="shortcut icon" href="/images/favicon.ico">
        <link href="/lib/prismjs/prism_default.css" rel="stylesheet" />
        <link href="/lib/notes.css" rel="stylesheet" />
        <link rel="stylesheet" href="/lib/global.css">
        <script data-ad-client="ca-pub-9527676606416641" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
      </head>
      <body>
        <header>
          <div>
            <img src="/images/logo.png" width="24" height="24" class="pointer" onclick="gotoIndex()" />
            <span class="pointer" onclick="gotoIndex()">左小白的技术日常</span>
            <span class="hidden"> | </span>
            <a href="/blog/category.html#c与apue" class="hidden">C与APUE</a>
          </div>
          <div>
            
          <a href="https://www.yuque.com/guoqzuo" target="_black" class="hidden">语雀</a>
        
          <a href="https://github.com/zuoxiaobai" target="_black" class="">Github</a>
        
          </div>
        </header>
        <section class="content">
          <article>
            
    <div class="article-top">
      <div>2016/10/15</div> 
      <div class="article-top-right">Author: guoqzuo</div>
    </div>
  
            <h1 id="c语言扫雷控制台版">c语言扫雷(控制台版)</h1>
<blockquote>
<p> 扫雷游戏的逻辑其实很简单，只要学了C的循环语句、数组、递归就可以基本实现了。思路有了，就可以应用到UI上，这里例子是纯C代码，控制台下模拟，提供相关思路及示例。</p>
</blockquote>
<p><img src="../../../images/blog/c/c_saolei_1.png" alt="c_saolei_1.png"></p>
<h2 id="游戏规则">游戏规则</h2>
<p>点击方格后，如果是雷，游戏结束。如果不是就显示其周围雷的个数，如果个数为0(一般UI显示为空白)，会遍历打开其周围的方格。如果是雷则不打开，否则显示其周围雷的个数，如果还为0，继续像前面一样遍历，直到遇到边界。以此类推，当除了雷之外所有的方格都点开后，游戏就胜利了。  </p>
<h2 id="实现思路">实现思路</h2>
<p>这里用c语言在控制台下模拟，不依赖任何第三方插件。右键插旗子是做不了的，鼠标点击改为输入坐标，旨在模拟扫雷实现的基本逻辑。首先要有两张地图，分别对应两个8*8的二维数组(字符)。一个用来显示界面，一个用来做内部地图，用memset()全部设置为&#39;+&#39;。内部地图里面设置10个雷，刚开始可以将雷的坐标写死，用&#39;l&#39;来标记。最好用随机数来决定雷的坐标，要注意防止随机数的重复。用while(1)来不断接收用户输入，并进行相关操作，注意坐标越界的处理。如果输入坐标为4，4。就到内部地图数组arr[3][3]查其值(数组为0开始，坐标为1开始，所以要减1)，如果为&#39;l&#39;就是踩到雷了。游戏结束。否则遍历其周围的8个方向雷的个数，得到雷的个数后设置到对应的UI数组arr_ui[3][3]。这里要注意字符&#39;0&#39;为数字48。上面的实现之后算是一个分水岭了，难点是如果雷的个数为0，要一扫一大片的效果。就要用到递归了，遍历的时候将坐标周围8个方向的坐标设置为了一个二维数组，当前坐标加上这些个方向坐标，正好代表了其周围的坐标。递归时如果越界了就continue。如果之前递归过该坐标(对应UI数组已经写过值或为雷)，也continue。如果雷数不为0，写值，为0递归。具体实现参见下面示例源码，下图为该示例的运行效果。</p>
<p><img src="../../../images/blog/c/c_saolei_2.png" alt="c_saolei_2.png"></p>
<h2 id="示例源码">示例源码</h2>
<pre><code class="language-c">/*
 *  C语言扫雷，控制台
 *  2016/10/15 12:19
 *  Create by Kevin Zuo
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#define NUM 8 // 地图长宽
#define LEI 10 // 雷的个数

int mark[8][2] = {{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1}}; // 8个方向坐标
char map[NUM][NUM] = {0}; // 内部地图
char ui[NUM][NUM] = {0};  // UI

void print(char map[][NUM], int n) // 打印UI或地图
{
    for(int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            printf(&quot;%c &quot;,map[i][j]);
        }
        printf(&quot;\n&quot;);
    }
}

int lei_count(int x, int y, int n) { // 根据坐标，计算周围有几个雷
    int count = 0;
    int x1 = 0, y1 = 0;
    for (int i = 0; i &lt; 8; i++) {
        x1 = x + mark[i][0];
        y1 = y + mark[i][1];
        if (x1 &lt; 1 || x1 &gt; n || y1 &lt; 1 || y1 &gt; n) continue; // 如果超出了边界
        if (map[x1-1][y1-1] == &#39;l&#39;)
            count++;
    }
    return count;
}

void zero_digui(int x, int y) // 递归显示
{
    ui[x-1][y-1] = 0 + 48;
    int x1 = 0, y1 = 0;
    for (int i = 0; i &lt; 8; i++) { // 遍历周围的8个方向
        x1 = x + mark[i][0];
        y1 = y + mark[i][1];
        if (x1 &lt; 1 || x1 &gt; NUM || y1 &lt; 1 || y1 &gt; NUM) continue; // 如果超出了边界
        int count = lei_count(x1,y1,NUM);
        if (count != 0) ui[x1-1][y1-1] = count + 48; // 不为0直接写值 
        else if (ui[x1-1][y1-1] == &#39;0&#39;) continue; // 为0, 但值已是0，以前遍历过
        else zero_digui(x1,y1); // 为0，没遍历过, 遍历
    }
}

int win_check() // 赢了返回1,else 返回0
{
    // 计算ui里面+的个数,为LEI，则胜利
    int count = 0;
    for (int i = 0; i &lt; NUM; i++) {
        for (int j = 0; j &lt; NUM; j++) {
            if (ui[i][j] == &#39;+&#39;)
                count++;
        }
    }
    if (count == LEI)
        return 1;
    else
        return 0;
}

int main(int argc, char* argv[])
{
    memset(map, &#39;+&#39;, NUM*NUM); // 填充+
    memset(ui, &#39;+&#39;, NUM*NUM);

    srand(time(NULL)); // 设置随机数种子
    for (int i = 0; i &lt; LEI; i++) { // 随机给出LEI个雷,用&#39;l&#39;标记
        int x = 0, y = 0;
        do {
            x = rand()%NUM;
            y = rand()%NUM;
        } while(map[x][y] == &#39;l&#39;); // 防止随机数重复
        map[x][y] = &#39;l&#39;;
    }
    print(map, NUM); // 测试用

    while (1) {
        int x = 0, y = 0;
        printf(&quot;扫雷\n&quot;);
        print(ui, NUM); // 打印UI
        do { // 提示输入，且保证输入坐标正常!
            printf(&quot;请输入鼠标(x,y):&quot;);
            scanf(&quot;%d,%d&quot;, &amp;x, &amp;y);
        } while (x &lt; 1 || x &gt; NUM || y &lt; 1 || y &gt; NUM);
        // 判断是否有雷
        if (map[x-1][y-1] == &#39;l&#39;) { // 如果是雷，游戏结束
            print(map, NUM);
            printf(&quot;踩到雷了，游戏结束!\n&quot;);
            break;
        } else { // 如果不是雷
            int count = lei_count(x, y, NUM);
            if (count != 0) // 周围有几个雷就显示几个雷
                ui[x-1][y-1] = count + 48; // int型 =&gt; 字符 +48
            else { // 没有雷就递归寻找，显示
                zero_digui(x, y);
            }
        }
        // 判断是否赢了
        if(win_check()) { // 恭喜，胜利
            print(ui,NUM);
            printf(&quot;恭喜,胜利!\n&quot;);
            break;
        }
    }
     return 0;
}</code></pre>
<h2 id="扩展">扩展</h2>
<p>在图形化界面里面可以将对应的方格对应到二维数组。思路是一样的，之前写过一个mac版的，但只做了基本的一扫一大片。后续还有一些要完善的，等完成了会更新具体实现，希望对大家有帮助。</p>
<p><img src="../../../images/blog/c/c_saolei_3.png" alt="c_saolei_3.png"></p>

          </article>
          <aside>
            <div>
              <ul><li><span class="ul-span" data-id="c语言扫雷控制台版" style="padding-left:1em">c语言扫雷(控制台版)<span></li><ul><li><span class="ul-span" data-id="游戏规则" style="padding-left:2em">游戏规则<span></li></ul><ul><li><span class="ul-span" data-id="实现思路" style="padding-left:2em">实现思路<span></li></ul><ul><li><span class="ul-span" data-id="示例源码" style="padding-left:2em">示例源码<span></li></ul><ul><li><span class="ul-span" data-id="扩展" style="padding-left:2em">扩展<span></li></ul></ul>
            <div>
          </aside>
        </section>
        <footer>
          <div class="footer_content">
            <div class="footer_right">Copyright © 2016-2020 zuo11.com. <a href='http://www.beian.miit.gov.cn/'>鄂ICP备16014741号-1</a></div>
            <div>Powered by <a href='https://github.com/zuoxiaobai/zuo-blog' target='_black'>zuo-blog</a></div>
          </div>
        </footer>
        <script src="/lib/prismjs/prism_default.js"></script>
        <script src="/lib/notes.js"></script> 
        <script src="/lib/global.js"></script>
        <script>
          
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?183281668cc3440449274d1f93c04de6";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    
        </script>
        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-178732583-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-178732583-1');
</script>

      </body>
    </html>
  