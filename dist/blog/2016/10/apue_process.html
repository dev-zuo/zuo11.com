
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">

        <meta name="application name" content="apue_process.html">
        <meta name="author" content="guoqzuo">
        <meta name="description" content="进程就是正在运行的程序。不管是进程还是线程，主要作用就是可以在同一时间内同时处理多个事情，提升用户体验。像shell终端，如果是单个进程，那每次执行完命令，都需要重新打开终端，非常不利于操作。拿扫雷来说，如果一边开个while(1)来处理输入输出，那如果你需要实时显示时间呢? 学了进程相关的操作后就可以fork一个子程序专门用来显示实时时钟。">
        <meta name="keywords" content="unix进程,fork,进程,process,apue fork">

        <title>apue 进程(Process) - 左小白的技术日常</title>
        <link rel="shortcut icon" href="/images/favicon.ico">
        <link href="/lib/prismjs/prism_default.css" rel="stylesheet" />
        <link href="/lib/notes.css" rel="stylesheet" />
        <link rel="stylesheet" href="/lib/global.css">
        <script data-ad-client="ca-pub-9527676606416641" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
      </head>
      <body>
        <header>
          <div>
            <img src="/images/logo.png" width="24" height="24" class="pointer" onclick="gotoIndex()" />
            <span class="pointer" onclick="gotoIndex()">左小白的技术日常</span>
            <span class="hidden"> | </span>
            <a href="/blog/category.html#c与apue" class="hidden">C与APUE</a>
          </div>
          <div>
            
          <a href="https://www.yuque.com/guoqzuo" target="_black" class="hidden">语雀</a>
        
          <a href="https://github.com/zuoxiaobai" target="_black" class="">Github</a>
        
          </div>
        </header>
        <section class="content">
          <article>
            <h1 id="apue-进程process">apue 进程(Process)</h1>
            
    <div class="article-top">
      <div class="flex">
        这篇文章发布于 2016/10/22，归类于 <a href="/blog/category.html#c与apue" class="hidden">C与APUE</a>
        <!-- ，阅读 11 次，今日 1 次 <div class="top-comment">4 条评论</div> -->
        <div id="readAndComment" class="flex"></div>
      </div> 
      <div class="flex keywords" style="flex-wrap: nowrap;">
        <div style="flex-shrink:0; align-self: flex-start;">标签：</div>
        <div class="flex" style="flex-wrap: wrap;"><span>unix进程</span>，<span>fork</span>，<span>进程</span>，<span>process</span>，<span>apue fork</span></div>
      </div>
    </div>
    <ins class='adsbygoogle' style='display:block;margin-top:1em;margin-bottom:0' data-ad-format='fluid' data-ad-layout-key='-gw-3+1f-3d+2z' data-ad-client='ca-pub-9527676606416641' data-ad-slot='8870245163'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
  
            
<blockquote>
<p>进程就是正在运行的程序。不管是进程还是线程，主要作用就是可以在同一时间内同时处理多个事情，提升用户体验。像shell终端，如果是单个进程，那每次执行完命令，都需要重新打开终端，非常不利于操作。拿扫雷来说，如果一边开个while(1)来处理输入输出，那如果你需要实时显示时间呢? 学了进程相关的操作后就可以fork一个子程序专门用来显示实时时钟。</p>
</blockquote>
<p><img src="../../../images/blog/apue/apue_process_1.png" alt="apue_process_1.png"></p>
<h2 id="进程---正在运行的程序">进程 - 正在运行的程序</h2>
<p>c语言中main函数就是主进程，一个shell程序的执行过程</p>
<ol>
<li>用户输入./a.out</li>
<li>shell建立一个新的进程来运行这个程序  // fork</li>
<li>shell将程序从磁盘载入 // exec 以代码覆盖的方式执行程序</li>
<li>程序在它的进程中运行知道结束 // wait</li>
</ol>
<pre><code class="language-c">int execl(const char *path, const char *arg0, ... /*, (char *)0 */);
int execlp(const char *file, const char *arg0, ... /*, (char *)0 */);
execl(&quot;/bin/ls&quot;, &quot;ls&quot;,&quot;-l&quot;,&quot;-a&quot;,NULL);  execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;-l&quot;,&quot;-a&quot;,NULL);
// 后面加p的作用直接从环境变量里找ls可执行程序，如果不加就要指定绝对路径
// l ==&gt; v 只是将参数2...到参数n字符串封装成了数组, 不用NULL((char*)0)结束

/* execl execv execlp  execvp 在程序运行过程中，运行另一个程序
 * 有无p表示是否需要指定路径 l/ｖ表示是否用数组封装
 */</code></pre>
<p>示例</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main()
{
  //execl(&quot;/bin/pwd&quot;,&quot;pwd&quot;,NULL); // 以代码覆盖的方式让一个程序替换另一个程序运行
  //execl(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL); 
  //char *arr[]={&quot;ls&quot;,&quot;-l&quot;,NULL}; // NULL 可以让数组知道在哪结束
  //execv(&quot;/bin/ls&quot;,arr);
  execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL); // 自动到环境变量里面去找
  perror(&quot;execl()&quot;); // 错误检查，如果上一行失败，不会执行到这里
  printf(&quot;b\n&quot;);

  return 0;
}</code></pre>
<h2 id="进程终止">进程终止</h2>
<p>5种正常终止方式</p>
<ul>
<li>从main函数返回</li>
<li>调用exit() // 执行清理处理(fclose() 所有打开流，fflush输出缓冲区) man 3 exit</li>
<li>调用_exit或_Exit // 立即进入内核 _exit由POSIX.1是系统调用，_Exit和exit为C库函数(ISO C)</li>
<li>最后一个线程return</li>
<li>最后一个线程调用 pthread_exit()</li>
</ul>
<p>3种异常终止方式:</p>
<ul>
<li>调用abort</li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求作出响应</li>
</ul>
<p>进程的终止状态exit, _exit, _Exit 可以指定具体值， return 0, exit(0);</p>
<p>查看程序的退出状态 echo $?</p>
<p><img src="../../../images/blog/apue/apue_process_2.png" alt="apue_process_2.png"></p>
<p><strong>内核使程序执行的唯一方式是调用一个exec()函数，进程自愿终止的唯一方法是显示或隐式调用_exit或_Exit,也可以非自愿的由一个终端信号使其终止</strong></p>
<h2 id="进程环境表">进程环境表</h2>
<p>shell cmd &quot;printenv&quot;, 每个程序都会有一张环境表，它是一个字符串指针数组和argv[]类似，全局变量environ可访问该环境表</p>
<pre><code class="language-c">extern char** environ;</code></pre>
<p><img src="../../../images/blog/apue/apue_process_3.png" alt="apue_process_3.png"></p>
<p>两种方法都可以打印环境表，到达printenv的效果, 代码如下:      </p>
<pre><code class="language-c">/*  
 *  环境表  
 *  Sat Oct 22 17:43:20 2016
 *  Create by Kevin Zuo
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

extern char** environ; // 调用全局变量方法

int main(int argc, char* argv[], char* envp[])
{
    int n = 0;

    while (1) { // 遍历打印环境表   
        if (*(environ+n) == NULL) break;
        printf(&quot;%s\n&quot;, *(environ+n));
        /*  调用 main函数第3参数 envp
            if (envp[n] == NULL)
                break;
            printf(&quot;%s\n&quot;, envp[n]);
        */
        n++;
    }

    exit(0);
}</code></pre>
<h2 id="fork-创建一个子进程">fork() 创建一个子进程</h2>
<p>通过fork系统调用可以以复制的方式创建一个新的进程，新进程拥有和原进程一样的代码，数据，运行位置。</p>
<pre><code class="language-c">pid_t fork(void);  // -- create a new process</code></pre>
<ul>
<li>fork()创建的新进程被称为子进程，函数执行一次，但返回两次,子进程返回0，父进程返回子进程id</li>
<li>子进程是父进程的副本，各自空间独立，也就是说子进程里面变量值的改变对父进程没有任何影响，fork之后</li>
<li>子进程会复制父进程的文件描述符，fork之后父子进程谁先执行时不确定的.<pre><code class="language-c">pid_t wait(int *stat_loc);  -- wait for process termination  // 父进程阻塞等待所有子进程结束
stat_loc是结果参数，可获子进程的退出状态，不去获取其退出状态可填NULL, wait(NULL);
pid_t waitpid(pid_t pid, int *stat_loc, int options); // 可等待某个子进程结束</code></pre>
pid如果是-1，表示所有子进程, stat_loc同wait, options 0无特殊要求 WNOHANG,有结束就等，没有就不等了</li>
</ul>
<p>子进程退出时，父进程会收到一个SIGCHLD信号    </p>
<pre><code class="language-c">/*  
 *  fork()
 *  Sat Oct 22 18:24:37 2016
 *  Create by Kevin Zuo
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char* argv[])
{
    fork();
    fork();
    printf(&quot;pid = %d, ppid = %d\n&quot;, getpid(), getppid());
    // 会打印4次,子进程结束后如果不return，顺序执行

    exit(0);
}

// 执行结果对比:    
// kevindeMacBook-Air:~ kevin$ ./a.out
// TERM_PROGRAM=Apple_Terminal
// SHELL=/bin/bash
// TERM=xterm-256color
// TMPDIR=/var/folders/mw/hbp6ytc9753gcm3zhqbmfkp40000gn/T/
// Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.iGH1KaBlJJ/Render
// TERM_PROGRAM_VERSION=361.1
// TERM_SESSION_ID=800C54D0-5E25-4B6D-9C3C-B7348F78B6BD
// USER=kevin
// SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.ZLi0oN8Xp8/Listeners
// __CF_USER_TEXT_ENCODING=0x1F5:0x19:0x34
// PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/mysql/bin
// PWD=/Users/kevin
// LANG=zh_CN.UTF-8
// XPC_FLAGS=0x0
// XPC_SERVICE_NAME=0
// SHLVL=1
// HOME=/Users/kevin
// LOGNAME=kevin
// _=./a.out
// kevindeMacBook-Air:~ kevin$ printenv
// TERM_PROGRAM=Apple_Terminal
// SHELL=/bin/bash
// TERM=xterm-256color
// TMPDIR=/var/folders/mw/hbp6ytc9753gcm3zhqbmfkp40000gn/T/
// Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.iGH1KaBlJJ/Render
// TERM_PROGRAM_VERSION=361.1
// TERM_SESSION_ID=800C54D0-5E25-4B6D-9C3C-B7348F78B6BD
// USER=kevin
// SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.ZLi0oN8Xp8/Listeners
// __CF_USER_TEXT_ENCODING=0x1F5:0x19:0x34
// PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/mysql/bin
// PWD=/Users/kevin
// LANG=zh_CN.UTF-8
// XPC_FLAGS=0x0
// XPC_SERVICE_NAME=0
// SHLVL=1
// HOME=/Users/kevin
// LOGNAME=kevin
// _=/usr/bin/printenv
// kevindeMacBook-Air:~ kevin$</code></pre>
<h2 id="fork-分支">fork 分支</h2>
<pre><code class="language-c">/*  
 *  fork() 分支  
 *  Sat Oct 22 18:24:37 2016
 *  Create by Kevin Zuo
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char* argv[])
{
    int pid = fork();
    // 这时有两个进程在顺序向下执行
    if (pid == 0) { // 如果是子进程
        return 0; //或 exit(0); 可以结束子进程,子进程就不会打印下面的值了
    }
    printf(&quot;pid = %d, ppid = %d\n&quot;, getpid(), getppid());

    exit(0);
}</code></pre>
<h2 id="wait-示例">wait() 示例</h2>
<pre><code class="language-c">/*  
 *  fork(), wait() 
 *  Sat Oct 22 18:24:37 2016
 *  Create by Kevin Zuo
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char* argv[])
{
    int pid = fork();

    if (pid == 0) { // 如果是子进程
        printf(&quot;child process!\n&quot;);
        return 0;
    }
    //sleep(1); // sleep后子进程会先打印
    //wait(NULL); // 等待子进程结束，只有这样子进程退出后其占用的资源才会被释放干净
    printf(&quot;123\n&quot;);

    exit(0);
}</code></pre>
<h2 id="fork的理解">fork的理解</h2>
<pre><code class="language-c">/*  
 *  fork() 的理解
 *  Sat Oct 22 18:24:37 2016
 *  Create by Kevin Zuo
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char* argv[])
{
    int  n = 1;
    for (int i = 0; i &lt; 3; i++) {
        fork();
    }
    n++;
    printf(&quot;%d\n&quot;, n); // n的值永远是2，进程各自独立，不会改变其值，打印次数为2的3次方

    exit(0);
}</code></pre>
<h2 id="sigchld信号">SIGCHLD信号</h2>
<pre><code class="language-c">/*  
 *  SIGCHLD 
 *  Sat Oct 22 18:24:37 2016
 *  Create by Kevin Zuo
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

void k(int n)
{
    printf(&quot;子进程结束!&quot;);
}

int main(int argc, char* argv[])
{
    signal(SIGCHLD, k);

    int pid = fork();
    if (pid == 0) {
        sleep(5); // 子进程空间与父进程空间独立, sleep 5s对父进程无影响
        return 0; // 子进程结束父进程会收到SIGCHLD信号
    }

    while (1) {
        putchar(&#39;.&#39;);
        fflush(stdout);
        sleep(1);
    }

    exit(0);
}

// 执行结果:
// kevindeMacBook-Air:~ kevin$ ./a.out
// .....子进程结束!....
// kevindeMacBook-Air:~ kevin$</code></pre>
<h2 id="子进程对文件描述符的影响">子进程对文件描述符的影响</h2>
<pre><code class="language-c">/*  
 *  fork对文件描述符的影响  
 *  Sat Oct 22 18:24:37 2016
 *  Create by Kevin Zuo
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main(int argc, char* argv[])
{
    int fd = open(&quot;data.txt&quot;, O_RDWR|O_CREAT, 0644);

    int pid = fork(); // 父子进程会共享文件表，偏移量

    //如果fd在此处open，数据会覆盖

    if (pid == 0) {
        write(fd,&quot;hellodd&quot;, 8);
        return 0;
    }

    wait(NULL);
    write(fd, &quot;world&quot;, 5);

    exit(0);
}</code></pre>
<p><img src="../../../images/blog/apue/apue_process_4.png" alt="apue_process_4.png"></p>

            
            <ins class='adsbygoogle' style='display:block;text-align:center;' data-ad-layout='in-article' data-ad-format='fluid' data-ad-client='ca-pub-9527676606416641' data-ad-slot='5125924359'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
            <!-- 评论系统占位 -->
            <div id="commentDiv"></div>
          </article>

          <aside>
            <div class="aside-wrap">
              <ins class='adsbygoogle' style='display:inline-block;width:300px;height:250px;' data-ad-client='ca-pub-9527676606416641' data-ad-slot='9476232907'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
              <div class="top ">
                <ul><li><span class="ul-span" data-id="apue-进程process" style="padding-left:1em">apue 进程(Process)<span></li><ul><li><span class="ul-span" data-id="进程---正在运行的程序" style="padding-left:2em">进程 - 正在运行的程序<span></li></ul><ul><li><span class="ul-span" data-id="进程终止" style="padding-left:2em">进程终止<span></li></ul><ul><li><span class="ul-span" data-id="进程环境表" style="padding-left:2em">进程环境表<span></li></ul><ul><li><span class="ul-span" data-id="fork-创建一个子进程" style="padding-left:2em">fork() 创建一个子进程<span></li></ul><ul><li><span class="ul-span" data-id="fork-分支" style="padding-left:2em">fork 分支<span></li></ul><ul><li><span class="ul-span" data-id="wait-示例" style="padding-left:2em">wait() 示例<span></li></ul><ul><li><span class="ul-span" data-id="fork的理解" style="padding-left:2em">fork的理解<span></li></ul><ul><li><span class="ul-span" data-id="sigchld信号" style="padding-left:2em">SIGCHLD信号<span></li></ul><ul><li><span class="ul-span" data-id="子进程对文件描述符的影响" style="padding-left:2em">子进程对文件描述符的影响<span></li></ul></ul>
              <div>
            </div>
          </aside>
        </section>
        <footer>
          <div class="footer_content">
            <div class="footer_right">Copyright © 2016-2020 zuo11.com. <a href='http://www.beian.miit.gov.cn/'>鄂ICP备16014741号-1</a></div>
            <div>Powered by <a href='https://github.com/zuoxiaobai/zuo-blog' target='_black'>zuo-blog</a></div>
          </div>
        </footer>
        <script src="/lib/prismjs/prism_default.js"></script>
        <script src="/lib/notes.js"></script> 
        <script src="/lib/global.js"></script>
        <script>
          
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?183281668cc3440449274d1f93c04de6";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    
        </script>
        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-178732583-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-178732583-1');
</script>

      </body>
    </html>
  