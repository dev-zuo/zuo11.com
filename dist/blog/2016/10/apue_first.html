
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">

        <meta name="application name" content="apue_first.html">
        <meta name="author" content="guoqzuo">
        <meta name="description" content="UNIX环境高级编程简介，概览">
        <meta name="keywords" content="APUE,apue 笔记, APUE笔记,UNIX基础知识,UNIX环境高级编程,apue">

        <title>unix环境高级编程(APUE) - 左小白的技术日常</title>
        <link rel="shortcut icon" href="/images/favicon.ico">
        <link href="/lib/prismjs/prism_default.css" rel="stylesheet" />
        <link href="/lib/notes.css" rel="stylesheet" />
        
      </head>
      <body>
        <header>
          <div>
            <img src="/images/logo.png" width="24" height="24" class="pointer" onclick="gotoIndex()" />
            <span class="pointer" onclick="gotoIndex()">左小白的技术日常</span>
            <span class="hidden"> | </span>
            <a href="/blog/category.html#unix环境高级编程" class="hidden">UNIX环境高级编程</a>
          </div>
          <div>
            
          <a href="https://www.yuque.com/guoqzuo" target="_black" class="hidden">语雀</a>
        
          <a href="https://github.com/zuoxiaobai" target="_black" class="">Github</a>
        
          </div>
        </header>
        <section class="content">
          <article>
            
    <div class="article-top">
      <div>2016/10/17</div> 
      <div class="article-top-right">Author: guoqzuo</div>
    </div>
  
            <h1 id="unix环境高级编程apue">unix环境高级编程(APUE)</h1>
<blockquote>
<p>APUE是一本非常经典的书，被认为是在UINX环境下进行程序设计有关人员必读，且需要经常查阅的首选参考书，对于深入了解UNIX及内核源码非常有利。这本书没有花哨的界面，各种高大上的程序都是用C语言编写且在终端下运行，在这个浮躁的社会，能潜心去钻研这本书真的非常不容易。但只要用心去研究，一定会有意想不到的收获。</p>
</blockquote>
<p><img src="../../../images/blog/apue/apue_first_1.png" alt="apue_first_1.png"></p>
<h2 id="unix操作系统os与内核kernel">UNIX操作系统(OS)与内核(Kernel)</h2>
<p>从严格意义上讲OS就是Kernel，可以理解为一种软件。它能够控制计算机软硬件资源，提供程序运行环境。从广义的角度来看OS不仅包含了Kernel，还加上一些其他软件，这些软件包括app，shell，公用库函等。</p>
<p><img src="../../../images/blog/apue/apue_first_2.png" alt="apue_first_2.png"></p>
<h2 id="系统调用、公用库函数、shell">系统调用、公用库函数、shell</h2>
<h3 id="系统调用system-call">系统调用(system call)</h3>
<p>内核提供的接口函数，对应man手册第2章。它是内核的唯一接口。只要和内核交互，一定通过系统调用来实现。一些C语言库函数就是对系统调用的封装，如fopen和fwrite就是封装了open和wirte两个系统调用，在用户空间增加了缓冲机制。C库函数不一定都是封装了系统调用，如一些不需要操作内核的函数:strcpy，atoi等。</p>
<p><img src="../../../images/blog/apue/apue_first_3.png" alt="apue_first_3.png"></p>
<h3 id="公用库函数">公用库函数</h3>
<p>C语言库函数，对应man手册第3章。  </p>
<p><img src="../../../images/blog/apue/apue_first_4.png" alt="apue_first_4.png"></p>
<h3 id="shell">shell</h3>
<p>一个抽象的概念，特殊应用程序，为其他应用程序提供接口。shell的用户输入通常来自终端(交互式shell)，也可以来自于文件(如shell脚本)。可以理解为命令解释器，接收用户命令(如ls等)，然后调用相应的程序。macOS下默认的shell是bash，终端下的可执行命令，也叫shell命令(man手册第1章)。    有些shell命令如pwd、ls、cp、mv、cd、cp、mv等都可以通过调用系统调用来实现，后面会具体的讲。</p>
<p><img src="../../../images/blog/apue/apue_first_5.png" alt="apue_first_5.png"></p>
<h2 id="apue内容对应内核功能">APUE内容对应内核功能</h2>
<ul>
<li>进程调度 -- 进程控制、线程控制、进程间通信(IPC)</li>
<li>内存分配</li>
<li>文件系统 -- 文件和目录、文件I/O、标准I/O、系统数据文件和信息、高级I/O</li>
</ul>
<h2 id="文件系统">文件系统</h2>
<p>文件系统非常重要，UNIX下所有的一切皆文件(everything is file)。</p>
<ul>
<li>根(root)目录用 &quot;/&quot;表示。</li>
<li>主文件夹为: &quot;<del>&quot; 打开Terminal，当前所在的目录就是主文件夹(</del>), 任何目录输入cd命令都会进入该目录。</li>
<li>相对路径: 不是以根目录开头的路径，绝对路径: 以根目录开头的路径。</li>
<li>目录(directory): 文件夹，也是文件的一种创建新目录时，会自动创建两个文件.和..文件，分别代表当前路径和上一级路径,可用ls -a查看。</li>
</ul>
<h2 id="输入和输出-io">输入和输出 I/O</h2>
<p>C语言中，输入输出函数都定义在stdio.h里，一般叫标准I/O，一个程序在运行时会打开3个缓冲区: 输入缓冲区，输出缓冲区，错误缓冲区。scanf的原理是从输入缓冲区读取相应格式的数据(%d),存储到变量里(&amp;n)。printf的原理是将数据(n)以相应的格式(%d)写入输出缓冲区。输入缓冲区的文件一般由键盘写入或文件重定向(./a.out &lt; 1.txt), 输入缓冲区的内容会打印或重定向到文件。这三个缓冲区实际上对应的是三个文件，当程序执行时，会默认打开着三个文件，标准I/O表现形式对应fopen的返回值FILE*类型 stdin、stdout、stderr; 文件I/O表现形式对应open的返回值int类型 0、1、2（有对应的宏，但感觉0，1，2更好记）。在C语言笔记里有用wirte(1,&quot;str&quot;,&quot;lengt&quot;)来代替printf的例子，printf就是向输出缓冲区文件写入内容这里的0、1、2也叫fd(文件描述符 file descriptor)。相关实例：将输入缓冲区内容写入输出缓冲区，gcc编译链接后 ./a.out &lt; 1.c 相当于cat 1.c, 复制文件可以用 ./a.out &lt; 1.c &gt; 1.txt, 相当于cp 1.c 1.txt</p>
<pre><code class="language-c">/*  
  *  将输入缓冲区的内容写入输出缓冲区  
  *  Mon Oct 17 17:26:29 2016
  *  Create by Kevin Zuo
  */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char* argv[])
{
    int n = 0;
    char buf[1024] = {0};

    /*
    while (fgets(buf, 1024, stdin) != NULL) { // 标准I/O
        fputs(buf, stdout);
    }
    */

    while((n = read(0, buf, 1024)) != 0) { // 文件I/O
        write(1, buf, n); // 忽略出错判断与网络掉包情况
    }

    exit(0);
}</code></pre>
<h2 id="程序和进程">程序和进程</h2>
<p>程序(program)是存储在磁盘上某个目录的可执行文件，使用exec函数将程序读入内存并执行。程序的运行实例称为进程(process)，UNIX确保每个进程都有一个唯一的数字标识符(进程ID)，控制进程主要有三个函数 fork, exec, waitpid。例子: shell终端程序模拟   </p>
<pre><code class="language-c">/*  
  *  shell终端程序模拟  
  *  Mon Oct 17 17:45:24 2016
  *  Create by Kevin Zuo
  */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char* argv[])
{
    char buf[128] = {0};
    // 服务器程序一般都是一个while(1)，UI程序也类似，会开多个进程或线程,一直等待用户操作    
    while (1) { // 省略了出错判断
        printf(&quot;] &quot;);
        memset(buf, 0, 128);
        fgets(buf, 128, stdin); // 获取输入缓冲区内容
        buf[strlen(buf)-1] = &#39;\0&#39;; // 去掉默认的回车
        int pid = fork();
        if (pid == 0) { // fork一个子进程，处理程序,如不开子进程execl运行完后程序后结束
            execlp(buf, buf, NULL); 
            return 0;
        }
        wait(NULL); // 等待子进程处理结束
    }

    exit(0);
}</code></pre>
<p>运行效果：</p>
<p><img src="../../../images/blog/apue/apue_first_6.png" alt="apue_first_6.png"></p>
<p>如果需要了解更多详情，请移步: <a href="http://www.apuebook.com/">APUE book</a></p>

          </article>
          <aside>
            <div>
              <ul><li><span class="ul-span" data-id="unix环境高级编程apue" style="padding-left:1em">unix环境高级编程(APUE)<span></li><ul><li><span class="ul-span" data-id="unix操作系统os与内核kernel" style="padding-left:2em">UNIX操作系统(OS)与内核(Kernel)<span></li></ul><ul><li><span class="ul-span" data-id="系统调用、公用库函数、shell" style="padding-left:2em">系统调用、公用库函数、shell<span></li><ul><li><span class="ul-span" data-id="系统调用system-call" style="padding-left:3em">系统调用(system call)<span></li></ul><ul><li><span class="ul-span" data-id="公用库函数" style="padding-left:3em">公用库函数<span></li></ul><ul><li><span class="ul-span" data-id="shell" style="padding-left:3em">shell<span></li></ul></ul><ul><li><span class="ul-span" data-id="apue内容对应内核功能" style="padding-left:2em">APUE内容对应内核功能<span></li></ul><ul><li><span class="ul-span" data-id="文件系统" style="padding-left:2em">文件系统<span></li></ul><ul><li><span class="ul-span" data-id="输入和输出-io" style="padding-left:2em">输入和输出 I/O<span></li></ul><ul><li><span class="ul-span" data-id="程序和进程" style="padding-left:2em">程序和进程<span></li></ul></ul>
            <div>
          </aside>
        </section>
        <footer>
          <div class="footer_content">
            <div class="footer_right">Copyright © 2016-2020 zuo11.com. 鄂ICP备16014741号-1</div>
            <div>Powered by <a href='https://github.com/zuoxiaobai/zuo-blog' target='_black'>zuo-blog</a></div>
          </div>
        </footer>
        <script src="/lib/prismjs/prism_default.js"></script>
        <script src="/lib/notes.js"></script> 
        <script src="/lib/global.js"></script>
        <script>
          
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?183281668cc3440449274d1f93c04de6";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    
        </script>
      </body>
    </html>
  