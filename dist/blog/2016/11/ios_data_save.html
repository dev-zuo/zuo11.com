
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">

        <meta name="application name" content="ios_data_save.html">
        <meta name="author" content="guoqzuo">
        <meta name="description" content="iOS里有一个专有名词叫数据持久化，可以理解为数据存储。iOS数据持久化有5种方式：1. XML属性列表 (plist文件) 2. Preference (偏好设置) 3. NSKeyedArchiver归档 (NSCoding) 4. SQLite3 5. Core Data 这里先讲前三种。">
        <meta name="keywords" content="iOS数据存储,iOS数据持久化,iOS应用沙盒,ios 数据持久化,ios 数据存储,ios 应用沙盒">

        <title>iOS数据持久化(存储数据) - 左小白的技术日常</title>
        <link rel="shortcut icon" href="/images/favicon.ico">
        <link href="/lib/prismjs/prism_default.css" rel="stylesheet" />
        <link href="/lib/notes.css" rel="stylesheet" />
        
      </head>
      <body>
        <header>
          <div>
            <img src="/images/logo.png" width="24" height="24" class="pointer" onclick="gotoIndex()" />
            <span class="pointer" onclick="gotoIndex()">左小白的技术日常</span>
            <span class="hidden"> | </span>
            <a href="/blog/category.html#ios" class="hidden">iOS</a>
          </div>
          <div>
            
          <a href="https://www.yuque.com/guoqzuo" target="_black" class="hidden">语雀</a>
        
          <a href="https://space.bilibili.com/486840111" target="_black" class="hidden">B站</a>
        
          <a href="https://github.com/zuoxiaobai" target="_black" class="">Github</a>
        
          </div>
        </header>
        <section class="content">
          <article>
            
    <div class="article-top">
      <div>2016/11/10</div> 
      <div class="article-top-right">Author: guoqzuo</div>
    </div>
  
            <h1 id="ios数据持久化存储数据">iOS数据持久化(存储数据)</h1>
<p>iOS里有一个专有名词叫数据持久化，可以理解为数据存储。iOS数据持久化有5种方式：</p>
<ol>
<li>XML属性列表 (plist文件) </li>
<li>Preference (偏好设置) </li>
<li>NSKeyedArchiver归档 (NSCoding) </li>
<li>SQLite3 </li>
<li>Core Data</li>
</ol>
<p>这里先讲前三种。</p>
<p><img src="../../../images/blog/ios/ios_data_save_1.png" alt="ios_data_save_1.png"></p>
<h2 id="应用沙盒">应用沙盒</h2>
<p><img src="../../../images/blog/ios/ios_data_save_2.png" alt="ios_data_save_2.png"></p>
<p>每个iOS应用都有自己的应用沙盒(就是文件系统目录), 与其他文件系统隔离，应用必须待在自己的沙盒里。其他应用不能访问该沙盒。应用沙盒的文件系统目录，如上图所示(假设app名称为Layer)</p>
<h3 id="沙盒路径">沙盒路径</h3>
<pre><code class="language-objectivec">NSString* homePath = NSHomeDirectory();</code></pre>
<p>也可以通过函数获取 NSDocumentDirectory / NSCachesDirectory / NSPreferencePanesDirectory</p>
<pre><code class="language-objectivec">// 参数1: 搜索文件夹   
// 参数2: 在哪个范围搜索 NSUserDomainMask // user&#39;s home directory
// 参数3: YES，全路径  NO, ~ 代替沙盒路径
NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];</code></pre>
<h3 id="应用程序包">应用程序包</h3>
<p>上图中的Layer, 包含了所有的资源文件和可执行文件</p>
<pre><code class="language-objectivec">NSString* path  = [NSbundle mainBundle] bundlePath];</code></pre>
<h3 id="documents">Documents</h3>
<p>保存app运行时生成的需要持久化的数据, iTunes同步时会备份该目录 (文件存这,app可能会被拒)</p>
<h3 id="tmp">tmp</h3>
<p>保存app运行时所需的临时数据，app没有运行时，系统可能清楚该目录下的文件，iTunes同步不会备份        </p>
<pre><code class="language-objectivec">NSString *tmp = NSTemporaryDirectory();</code></pre>
<h3 id="librarycaches">Library/Caches</h3>
<p>保存app运行时需要持久化的数据, iTunes同步不会备份, 一般存储体积大不需备份的非重要数据 (用的多)</p>
<h3 id="librarypreference">Library/Preference</h3>
<p>保存应用的偏好设置, iOS的Setting应用会在该目录查找app的设置信息，iTunes同步时会备份</p>
<h2 id="plist存储">plist存储</h2>
<p>注意事项: plist文件不能存储用户自定义对象</p>
<pre><code class="language-objectivec">// plist存储
- (IBAction)save:(id)sender {
    // Plist存储本质，就是生成一个plist文件
    // 一般plist文件由数组，字典组成
    NSArray* arr = @[@&quot;123&quot;, @1];

    // 找到应用沙盒的目录，存到Libaray/Caches文件
    NSString* cachesPath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];
    NSLog(@&quot;%@&quot;, cachesPath);

    //将数组写入plist文件
    //[arr writeToFile:[NSString stringWithFormat:@&quot;%@/arr.plist&quot;,cachesPath] atomically:YES];
    [arr writeToFile:[cachesPath stringByAppendingPathComponent:@&quot;arr.plist&quot;] atomically:YES];
}

// plist读取
- (IBAction)read:(id)sender {
    NSString* cachesPath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];
    // 读取，以什么形式存储就以什么形式读取
    NSArray* arr = [NSArray arrayWithContentsOfFile:[cachesPath stringByAppendingPathComponent:@&quot;arr.plist&quot;]];
    NSLog(@&quot;%@&quot;, arr);
}</code></pre>
<p>路径:</p>
<p>/Users/kevin/Library/Developer/CoreSimulator/Devices/5E144187-C238-412C-B2C2-E198C9626F98/data/Containers/Data/Application/71B35379-47B9-4D57-A3C3-96E3ACC644C4/Library/Caches</p>
<p>写入的文件</p>
<p><img src="../../../images/blog/ios/ios_data_save_3.png" alt="ios_data_save_3.png"></p>
<p>读取结果</p>
<p><img src="../../../images/blog/ios/ios_data_save_4.png" alt="ios_data_save_4.png"></p>
<h2 id="偏好设置存储preference">偏好设置存储(Preference)</h2>
<p>偏好设置好处: </p>
<ol>
<li>快速进行键值对的存储 </li>
<li>不关系文件名, 自动生成dict结构的plist文件, 键值对的存取方便</li>
</ol>
<pre><code class="language-objectivec">- (IBAction)save:(id)sender {
    // 偏好设置存储 NSUserDefaults
    // 获取NSUserDefaults单列对象
    NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];

    //NSLog(@&quot;%@&quot;, NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES));
    [defaults setObject:@&quot;123&quot; forKey:@&quot;num&quot;];
    [defaults setBool:YES forKey:@&quot;isOn&quot;];
}

- (IBAction)read:(id)sender {
    // 获取NSUserDefaults单列对象
    NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];

    NSString* num = [defaults objectForKey:@&quot;num&quot;];
    BOOL isOn = [defaults objectForKey:@&quot;isOn&quot;];
    NSLog(@&quot;num: %@, isON :%d&quot;, num, isOn);
}</code></pre>
<p><img src="../../../images/blog/ios/ios_data_save_5.png" alt="ios_data_save_5.png"></p>
<p>2016-11-10 02:45:34.539 UI-18[8878:616370] num: 123, isON :1</p>
<h2 id="归档nskeyedarchiver">归档(NSKeyedArchiver)</h2>
<p>可存储自定义对象，当自定义对象需要遵循NScoding协议, 实现对应归档，解档方法</p>
<pre><code class="language-objectivec">- (IBAction)save:(id)sender {
    // 存储自定义对象，可使用归档，但需要遵循NSCoding协议，实现对应方法
    Person* p = [[Person alloc] init];
    p.age = 18;
    p.name = @&quot;zgq&quot;;

    // 获取caches文件夹
    NSString* cachesPath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];
    NSString* path = [cachesPath stringByAppendingPathComponent:@&quot;person.data&quot;];
    NSLog(@&quot;%@&quot;, cachesPath);

    // object: 需要归档的对象，任何对象都可以进行归档  file: 文件的全路径
    [NSKeyedArchiver archiveRootObject:p toFile:path];
}

- (IBAction)read:(id)sender {
    // 存进去是什么 就怎么取出
    Person* p = [NSKeyedUnarchiver unarchiveObjectWithFile:[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@&quot;person.data&quot;]];
    NSLog(@&quot;age: %ld , name: %@&quot;, p.age, p.name);
}</code></pre>
<p><img src="../../../images/blog/ios/ios_data_save_6.png" alt="ios_data_save_6.png"></p>
<p>2016-11-10 13:42:30.328 UI-19[9601:719889] age: 18 , name: zgq    </p>
<p>Person.m</p>
<pre><code class="language-objectivec">@implementation Person

// 什么作用: 告诉系统，模型中的那些属性需要归档
// 把一个自定义对象归档的时候调用
- (void)encodeWithCoder:(NSCoder *)aCoder
{
    //aCode用来归档
    [aCoder encodeInteger:_age forKey:@&quot;age&quot;];
    [aCoder encodeObject:_name forKey:@&quot;name&quot;];
}

// 作用: 告诉系统中那些属性需要解档
// 解档文件时调用
// storyboard也是一个文件，系统storyboard上控件的解析绘制也会调用initWithCoder方法
- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder
{
    // 一定要给成员属性赋值
    if (self = [super init]) {
        _name = [aDecoder decodeObjectForKey:@&quot;name&quot;];
        _age = [aDecoder decodeIntegerForKey:@&quot;age&quot;];
    }

    return self;
}

@end</code></pre>
<h2 id="sqlite3">SQLite3</h2>
<p>待完善</p>
<h2 id="core-data">Core Data</h2>
<p>待完善，关于ios数据持久化可以参见: <a href="https://www.jianshu.com/p/7616cbd72845">iOS中几种数据持久化方案</a></p>

          </article>
          <aside>
            <div>
              <ul><li><span class="ul-span" data-id="ios数据持久化存储数据" style="padding-left:1em">iOS数据持久化(存储数据)<span></li><ul><li><span class="ul-span" data-id="应用沙盒" style="padding-left:2em">应用沙盒<span></li><ul><li><span class="ul-span" data-id="沙盒路径" style="padding-left:3em">沙盒路径<span></li></ul><ul><li><span class="ul-span" data-id="应用程序包" style="padding-left:3em">应用程序包<span></li></ul><ul><li><span class="ul-span" data-id="documents" style="padding-left:3em">Documents<span></li></ul><ul><li><span class="ul-span" data-id="tmp" style="padding-left:3em">tmp<span></li></ul><ul><li><span class="ul-span" data-id="librarycaches" style="padding-left:3em">Library/Caches<span></li></ul><ul><li><span class="ul-span" data-id="librarypreference" style="padding-left:3em">Library/Preference<span></li></ul></ul><ul><li><span class="ul-span" data-id="plist存储" style="padding-left:2em">plist存储<span></li></ul><ul><li><span class="ul-span" data-id="偏好设置存储preference" style="padding-left:2em">偏好设置存储(Preference)<span></li></ul><ul><li><span class="ul-span" data-id="归档nskeyedarchiver" style="padding-left:2em">归档(NSKeyedArchiver)<span></li></ul><ul><li><span class="ul-span" data-id="sqlite3" style="padding-left:2em">SQLite3<span></li></ul><ul><li><span class="ul-span" data-id="core-data" style="padding-left:2em">Core Data<span></li></ul></ul>
            <div>
          </aside>
        </section>
        <footer>
          <div class="footer_content">
            <div class="footer_right">Copyright © 2016-2020 zuo11.com. <a href='http://www.beian.miit.gov.cn/'>鄂ICP备16014741号-1</a></div>
            <div>Powered by <a href='https://github.com/zuoxiaobai/zuo-blog' target='_black'>zuo-blog</a></div>
          </div>
        </footer>
        <script src="/lib/prismjs/prism_default.js"></script>
        <script src="/lib/notes.js"></script> 
        <script src="/lib/global.js"></script>
        <script>
          
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?183281668cc3440449274d1f93c04de6";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    
        </script>
      </body>
    </html>
  