{
  "category": {
    "C与APUE": [
      {
        "title": "vi 生成c语言模板",
        "href": "2016/10/c_vim.html",
        "time": "2016/10/13",
        "description": "vi 生成c语言模板，vim在终端下编辑文件，每次vi一个新文件时都要敲一些重复的内容，于是就用C写了个程序，用来自动生成自定义模板。",
        "keywords": "vi 生成c语言模板,vim c模板程序,c语言模板"
      },
      {
        "title": "c语言扫雷(控制台版)",
        "href": "2016/10/c_saolei.html",
        "time": "2016/10/15",
        "description": "扫雷游戏的逻辑其实很简单，只要学了C的循环语句、数组、递归就可以基本实现了。思路有了，就可以应用到UI上，这里例子是纯C代码，控制台下模拟，提供相关思路及示例。",
        "keywords": "c语言扫雷实现,c 扫雷,扫雷源码,c语言扫雷源码,控制台扫雷源码,c语言扫雷,扫雷,扫雷一扫一大片"
      },
      {
        "title": "c语言实现控制台下走动的时间",
        "href": "2016/10/c_console_time.html",
        "time": "2016/10/16",
        "description": "UI下时间插件很容易展现一个走动的时间，但C语言下控制台程序想要实现一个走动的时间，就需要用while(1)每隔1秒来打印了。其间我们可以开个fork用子程序来跑这个死循环。顺便延升到输出缓冲区与printf函数的问题。",
        "keywords": "c 控制台走动的时间,c语言时间程序,c 走动时间, c 控制台时间"
      },
      {
        "title": "c语言文件操作 - 简单的文件加密解密",
        "href": "2016/10/c_file_encrypt.html",
        "time": "2016/10/16",
        "description": "文件加密对小白来说是一个很高大上的技术，但也不是那么遥不可及。只要学了C语言的文件操作，就可以用简单的文件操作方法，对文件进行简单的加密。",
        "keywords": "c语言文件加密,文件加密,文件取反加密,c 文件加密"
      },
      {
        "title": "c语言排序算法",
        "href": "2016/10/c_sort.html",
        "time": "2016/10/16",
        "description": "排序的方法有不少，不过到现在还没怎么具体应用过，可能还比较low吧。这里介绍4中常见的排序算法：冒泡排序、选择排序、插入排序、快速排序，用C语言实现。",
        "keywords": "c语言排序算法,c 冒泡排序,c 选择排序,c 插入排序,c 快排,c 排序"
      },
      {
        "title": "c语言单向链表的实现",
        "href": "2016/10/c_linked_list.html",
        "time": "2016/10/16",
        "description": "c语言指针和结构体一学完就是链表了。也是一个分水岭，很多小白都卡在了这里，当初我自学时就是在这个位置时放弃了。我发现很多地方讲链表都讲得比较复杂，其实链表很简单，就是将多个数据(结构体类型)连在一起。只要有该链表头结点的地址，就可以操作这一连串数据。",
        "keywords": "c语言单向链表,单向链表,单向链表理解,c 链表,c 单向链表"
      },
      {
        "title": "unix环境高级编程(APUE)",
        "href": "2016/10/apue_first.html",
        "time": "2016/10/17",
        "description": "APUE是一本非常经典的书，被认为是在UINX环境下进行程序设计有关人员必读，且需要经常查阅的首选参考书，对于深入了解UNIX及内核源码非常有利。这本书没有花哨的界面，各种高大上的程序都是用C语言编写且在终端下运行，在这个浮躁的社会，能潜心去钻研这本书真的非常不容易。但只要用心去研究，一定会有意想不到的收获。",
        "keywords": "APUE,apue 笔记, APUE笔记,UNIX基础知识,UNIX环境高级编程,apue"
      },
      {
        "title": "apue 文件IO",
        "href": "2016/10/apue_file_io.html",
        "time": "2016/10/18",
        "description": " UNIX系统中，文件I/O常用的5个函数: open,read,write,lseek,close。与标准I/O相比文件I/O通常称为不带缓冲的I/O(unbuffered)。一般所有I/O都要经过内核的块缓冲。read，write的数据也要被内核缓冲，这里不带缓冲的I/O指的是在用户进程用不会自动缓冲，每次都是系统调用。",
        "keywords": "文件IO,标准IO,C语言文件处理,APUE文件IO,apue 文件io"
      },
      {
        "title": "apue ls命令实现",
        "href": "2016/10/apue_ls.html",
        "time": "2016/10/18",
        "description": "C语言操作目录需要使用opendir()和readdir()。此外文件接口函数还有很多，如stat，umask，chmod，chown，link，rename等。这些函数和shell命令有些是一样的，我们可以通过调用这些系统调用来实现一些命令。这里以ls -l的写法为例介绍一些常用的系统调用文件I/O。",
        "keywords": "stat,文件和目录操作,ls实现"
      },
      {
        "title": "apue pwd命令实现",
        "href": "2016/10/apue_pwd.html",
        "time": "2016/10/20",
        "description": "了解了文件目录相关的系统调用后，就可以尝试模拟实现各种shell命令了。这里给出了ls -l的完成代码，加上pwd及mkdir -p的实现。里面用到了递归，也涉及到一些细节问题，如根目录的上一级目录还是根目录，chdir需要用户有目录的执行权限。",
        "keywords": "apue笔记,pwd实现,ls -l实现,mkdir -p实现"
      },
      {
        "title": "apue 信号signal",
        "href": "2016/10/apue_signal.html",
        "time": "2016/10/21",
        "description": "这里所说的信号也叫软中断信号，当进程接收到一个来自内核的信号，如ctrl+c时，进程就会中断。系统定义了一些宏来表示这些中断。一般以SIG开头，对于这些信号，系统会有默认的处理方式，也可以通过signal函数，自定义处理方式(系统默认处理/ignore/执行某个函数)。",
        "keywords": "信号signal,signal函数,alarm函数,sleep函数功能实现,unix signal"
      },
      {
        "title": "apue 进程(Process)",
        "href": "2016/10/apue_process.html",
        "time": "2016/10/22",
        "description": "进程就是正在运行的程序。不管是进程还是线程，主要作用就是可以在同一时间内同时处理多个事情，提升用户体验。像shell终端，如果是单个进程，那每次执行完命令，都需要重新打开终端，非常不利于操作。拿扫雷来说，如果一边开个while(1)来处理输入输出，那如果你需要实时显示时间呢? 学了进程相关的操作后就可以fork一个子程序专门用来显示实时时钟。",
        "keywords": "unix进程,fork,进程,process,apue fork"
      },
      {
        "title": "apue 进程间通信IPC",
        "href": "2016/10/apue_ipc.html",
        "time": "2016/10/23",
        "description": "由于进程所处的空间都是独立的，如果多个子进程需要交互数据，那就需要了解进程间通信(InterProcess Communication, IPC)了。这里先介绍前三种通信方式：1. 管道(无名) 只能用于父子进程通信，半双工，单向；2. 命名管道，同一台主机的任意两个进程；3. 共享内存。",
        "keywords": "IPC,ipc,进程间通信,apue,C语言实现聊天小程序,管道,共享内存,pipe,fifo"
      }
    ],
    "网站建设与SEO": [
      {
        "title": "从Web零基础到完成这个博客系统",
        "href": "2016/10/viewpoint_zero.html",
        "time": "2016/10/14",
        "description": "最开始接触Web是在15年的11月份，到现在快1年了。现在一般需求的小网站应该可以独立完成，其间遇到了很多问题，也学了很多东西。但我这个人很健忘，东西学的快也忘的快，于是就想用博客来记录所学。以方便查找，也为后来的人提供一些经验。",
        "keywords": "web零基础,个人博客"
      },
      {
        "title": "web站点优化 关于最近的改版",
        "href": "2016/12/web_optimize_1.html",
        "time": "2016/12/18",
        "description": "最近花了点时间将网站的前端重新改了下，顺便对移动端也做了专门处理。之前首页只是从笔记中挑选了最新的10篇放在首页，现在将各个分类的最近10篇笔记都展现在了首页，且加上了后台系统的轮播图片，站点有了一定的提升，下面总结了一些改进细节。",
        "keywords": "zuo11.com站点优化记录,PC站转移动站,移动端适配"
      },
      {
        "title": "网站打开速度优化",
        "href": "2016/12/web_more_speed.html",
        "time": "2016/12/22",
        "description": "最近用百度统计的网站测速工具测了下网站的打开时间，结果要7秒多，最后根据上面的提示进行了相关修改：将png图片压缩、开启GZip压缩、合并js文件等。将速度降到了不到3秒，同时在百度站长上处理了一些死链，提交了一些链接。",
        "keywords": "zuo11.com站点优化记录,Tomcat开启GZIP压缩,网站打开速度优化,tomcat 开启gzip"
      },
      {
        "title": "移动端适配",
        "href": "2016/12/web_to_m.html",
        "time": "2016/12/24",
        "description": "最近一有时间就刷刷百度站长/百度统计，展现量和收录没怎么变化，上不去。虽然从表面上看站点已经OK了，但网站的流量想要做上去，离不开搜索引擎。流量就是一切，想要做好网站就必须做好SEO，现在主要的问题是移动端的处理，百度从搜索引擎的角度将对移动端的处理方式分为三种，现在我的实现很尴尬，界定模糊。",
        "keywords": "zuo11.com站点优化记录,PC站转移动站,移动端适配"
      },
      {
        "title": "mip改造",
        "href": "2016/12/web_mip.html",
        "time": "2016/12/28",
        "description": "最近对网站进行了改版，移动端为了对搜索引擎更友好，用MIP改造了移动端，还有很多问题待完善。PC端也小改了下，本来找了个很好的背景图片，但由于文件大了，影响加载速度。还是放弃了，就加了个magnet图片，写了个js来控制背景图片的切换。",
        "keywords": "zuo11.com站点优化记录,mip改造,百度mip,pc端改移动端,mip改造实例"
      },
      {
        "title": "seo内容建设",
        "href": "2017/1/web_content.html",
        "time": "2017/01/17",
        "description": "我身边的很多朋友都曾抱怨过百度搜索的内容太杂，没有google搜索的内容质量高。之前感觉没什么，但有了这个站点后，写的内容也会提交给百度。当在百度搜索时，呈现的内容可能就是自己的笔记。如果我都没有用心去记录好内容，那还有什么理由去抱怨搜索引擎。",
        "keywords": "zuo11.com优化记录,内容建设,网站内容质量提升经验"
      },
      {
        "title": "404及500跳转处理",
        "href": "2017/1/web_404.html",
        "time": "2017/01/24",
        "description": "这几天百度的收录慢慢开始上升，但收录的有些页面是改版之前的旧内容，要么删了要么URL变了，造成访问出现404或者500的情况。404的问题可以提交死链，但500的问题就头疼了，当时在写后台的时候没有处理笔记id找不到的情况，如果随便输入id就会出现空指针异常，返回500。网上查了下，发现一般seo都需要专门对这些进行处理，于是就小改了一下。",
        "keywords": "404跳转,网站404跳转处,web 404跳转处理,web 500跳转处理,web.xml配置404和500的跳转"
      },
      {
        "title": "站点优化 新增访客记录、新UI及mip等",
        "href": "2017/2/web_optimize_2.html",
        "time": "2017/02/01",
        "description": "认真去做内容建设后，百度收录和索引量有了明显的提升。把之前笔记修改完后，发现mip限制的_blank属性用户体验非常差，加上之前没有做访客记录功能。就打算再改改移动端，顺便新增访客记录功能。花了4天时间勉强改完了，把页面效果提升了一个level，mip页面也新增了4个。",
        "keywords": "站点优化,mip改造,Servlet获取访问信息,web新增访客记录功解决方法能,prism代码高亮使用,UEditor过滤code便签的解决方法"
      },
      {
        "title": "使用Github的Pages功能创建静态个人网站",
        "href": "2018/2/web_github_pages.html",
        "time": "2018/02/25",
        "description": "使用Github的Pages功能创建静态个人网站，通过Github Pages这个功能，我们可以创建一个开源的静态个人网站，通过xxx.github.io 可以访问. 示例页面 https://zuoxiaobai.github.io",
        "keywords": "github pages个人博客,使用github创建个人博客"
      },
      {
        "title": "使用Hexo搭建个人博客",
        "href": "2018/2/web_hexo.html",
        "time": "2018/02/26",
        "description": "用Github Pages弄了一个简单的页面后，琢磨着用Hexo来搭一个博客。把大致的过程梳理了一下。首先百度了Hexo，找到了[Hexo的中文文档](https://hexo.io/zh-cn/docs/)，由于之前没接触过，就按着流程一步步来了。",
        "keywords": "使用hexo搭建个人博客,hexo 个人博客"
      },
      {
        "title": "站点优化 页面打开较慢处理",
        "href": "2019/8/web_optimize_3.html",
        "time": "2019/08/31",
        "description": "最近发现打开速度太慢，由于后台是java写的，好久没碰了，基本忘干净了。就一直拖着没处理，现在有时间了，还是硬着头皮优化了下，打开速度提升了很多。",
        "keywords": "站点优化,页面打开较慢优化"
      },
      {
        "title": "网页seo之将链接提交到搜索引擎进行评定收录",
        "href": "2020/1/seo_commit.html",
        "time": "2020/01/30",
        "description": "最近对zuo11.com进行了改版，完成了博客的静态化并完成了上线，nginx + 静态文件代替了原来的 tomcat + jsp + mysql的模式。针对百度收录与索引，google收录，做了一些处理。",
        "keywords": "提交站点链接到百度,提交链接到google"
      },
      {
        "title": "Google AdSense被拒理由网站已下线或无法访问怎么解决",
        "href": "2020/11/adsense_cannot_found.html",
        "time": "2020/11/16",
        "description": "在自己网站的 head 部分加入 AdSense 的校验代码后，会有一段审核的时间。在这个过程中，网站可能会有来自福建龙岩的 203.208.60.* IP段蜘蛛来爬取你的网页。蜘蛛会爬取JS渲染后的效果，可以触发百度统计等js代码。不用屏蔽，这属于 Google 蜘蛛正常爬取，Google Analytics 在计算访客时会忽略这一部分访客信息。蜘蛛爬完的第二天，就收到了邮件，说审核不通过，看了下原因：'网站已下线或无法访问怎么解决' ，如下图所示。但我的网站是确定可以正常访问的。",
        "keywords": "AdSense网站已下线或无法访问"
      },
      {
        "title": "Google Analytics、Google AdSense、Google Search Console分别是干什么的?",
        "href": "2020/11/google_web_tools.html",
        "time": "2020/11/16",
        "description": "在站点管理这一块，Google的工具有好几个，我现在知道的有三个，他们分别对应不同的功能，下面来看看他们的介绍、区别：Google Search Console，搜索控制台| 站长工具、sitemap提交，展现量/点击量简单查看，死链提交等；Google Analytics 偏数据分析，统计实时用户/累计用户/会话时长/跳出率等，受众群体、流量来源、转化率、页面价值等；Google AdSense 广告联盟 | 用于在自己站点投放 Google 广告，赚取收益",
        "keywords": "Google Analytics,Google AdSense,Google Search Console"
      },
      {
        "title": "Google广告一个页面怎么显示多个广告，多个广告只显示的一个是什么原因？",
        "href": "2020/11/google_ad_multiple.html",
        "time": "2020/11/30",
        "description": "在 Google Adsense 中，理论上配置好广告形式后，获取代码，把对应的代码放到页面中就可以显示广告了。但发现，如果放多个广告，只有一个可以显示出来，下面来看看是为什么？一般在验证开通 Google Adsense 时，就会引入第一行 script 代码。那么只需要把下面的 ins 元素 和 script 里的代码拷贝进页面里就行。当有多个广告时，我只拷贝了 多个 ins 到指定位置。",
        "keywords": "Google 广告同页面多个广告不显示,Google 配置了多个广告只显示一个"
      },
      {
        "title": "description在seo中的重要性",
        "href": "2020/2/seo_description.html",
        "time": "2020/02/16",
        "description": "网站页面描述(description)可能会直接显示在百度搜索的结果里，所以尽量不要写太少，不然看起来内容就比较少，description 最好能对当前页面的内容有一个大概的描述，下面我们来看看为什么会有这个结论。",
        "keywords": "description seo,网站页面描述(description),description在seo中的重要性,seo中Google和百度的一些区别"
      },
      {
        "title": "nginx访问不带www的域名，自动切到www",
        "href": "2020/2/www_redirect.html",
        "time": "2020/02/08",
        "description": "在seo时，搜索引擎可能会将xx.com和www.xx.com一起收录。这里需要进行处理，当使用一级域名直接访问时(xx.com)，自动切到www.xx.com，下面来看看怎么配置nginx",
        "keywords": "不带www跳转到www二域名,xx.com重定向到www.xx.com"
      },
      {
        "title": "使用curl向百度站长主动推送站点url",
        "href": "2020/7/push_url_baidu.html",
        "time": "2020/07/26",
        "description": "之前提交链接都是手动将url粘贴到输入框提交。这次试了下curl方式提交还是很方便的，来看看步骤",
        "keywords": "向百度站长主动推送站点url,推送url到百度"
      }
    ],
    "后端数据库等": [
      {
        "title": "mysql连接操作命令",
        "href": "2016/10/db_mysql_basecmd.html",
        "time": "2016/10/23",
        "description": "最开始接触数据库是在学校，有一门课就是讲数据库的，但只是拿着ppt讲了将书上的东西，没有实际操作。回想起来觉得很失败，一点动手操作的意识都没。现在学东西，我更喜欢从实际的问题出发，多查资料，多实践。这里总结了mac下mysql的安装与一些基本的应用。",
        "keywords": "mysql连接操作命令,mysql基础命令,mac下mysql安装,mysql mac,jsp连接mysql,jsp操作mysql"
      },
      {
        "title": "javaweb判断是否为移动端访问",
        "href": "2016/12/web_ismobile.html",
        "time": "2016/12/25",
        "description": "一般java后台，会先用servlet获取数据，再跳转到前端页面。在servlet里获取数据时，我们可以根据request.getheader(User-Agent&quot)的内容，判断是否为移动端访问，再转发到相应的页面。可以在保持url不变的情况下，生成两种页面。",
        "keywords": "javaweb判断是否为移动端访问,java判断是否为移动端访问,判断是否为移动端访问"
      },
      {
        "title": "java web获取访客信息(ip,归属地等)",
        "href": "2017/2/web_access_log.html",
        "time": "2017/02/01",
        "description": "之前写过一篇servlet判断是否为移动端访问的文章，是为了代码适配移动端或PC。这次需要记录访客信息。写了个类方法来获取访问者的ip、归属地、UA、访问URL以及是否为PC端访问。",
        "keywords": "servlet 获取ip,servlet获取访问信息,java获取访客信息,servlet获取访客ip,web获取用户访问信息,百度谷歌蜘蛛UA,java web获取访客信息"
      },
      {
        "title": "原生ajax上传图片，php后台处理总结",
        "href": "2018/10/web_upload_php.html",
        "time": "2018/10/03",
        "description": "开始做图片上传，发现之前的处理方式基本忘光了。看了下原来的源码才有了解，还是要总结经验，不然忘的太快。之前是用jQuery来处理的，也是ajax方式。现在改为用原生的ajax来处理，不依赖jQuery，整体还算是比较简单的。",
        "keywords": "原生ajax上传图片，php后台处理图片上传"
      },
      {
        "title": "php发送邮件",
        "href": "2018/10/web_php_mail.html",
        "time": "2018/10/05",
        "description": "邮件发送是一个很重要的功能，具体应用包括注册时邮箱验证、评论回复提醒、推送广告、线上异常报告等。一般网上php教程里面邮件发送很简单，一个mail()函数就搞定。但这个方法如果你去试，90%是不成功的。然后就会去搜php怎么发送邮件，搜到的答案基本没有直接使用mail()的，都是使用PHPMailer这个开源库，我一般的思路是在能不使用第三方库的时候尽量不去使用。但后面发现还是要使用这个库。",
        "keywords": "php发送邮件,php发送邮件乱码,php 发邮件,php使用qq邮箱发邮件"
      },
      {
        "title": "mysql中char与varchar的区别",
        "href": "2020/2/char_varchar.html",
        "time": "2020/02/12",
        "description": "在创建表，指定字段数据类型时，如果是字符串数据类型可以是varchar(50)，也可以是char(50)。这两种有什么区别呢？",
        "keywords": "char和varchar的区别,char varchar区别"
      },
      {
        "title": "为什么书上SQL语句一般都是大写",
        "href": "2020/2/sql_uppercase.html",
        "time": "2020/02/12",
        "description": "为什么小写更直观，而不使用小写呢？今天在看语法时，有了一个答案，你会发现可变动的内容一般是小写（比如：列名，表名，一些条件），而SQL语法相关的单词都是大写，这样更好理解。全小写描述语法时，对于初学者来看分不清哪些是SQL语句中必须的，哪些是可变动的。以后还是要习惯大写，更规范。",
        "keywords": "为什么书上SQL语句一般都是大写"
      },
      {
        "title": "ERROR 1396 (HY000): Operation DROP USER failed for 'zhangsan'@'localhost'",
        "href": "2020/2/sql_localhost.html",
        "time": "2020/02/18",
        "description": "在看mysql账号相关内容时，发现在root用户下，更新、删除用户均报错。后面发现居然是localhost的字母拼错了，但新建user时居然没报错。下面来复盘整个记录:",
        "keywords": "Operation DROP USER failed for,ERROR 1396 (HY000): Operation DROP USER failed for"
      },
      {
        "title": "Spring Boot 怎么解决跨域问题: 使用注解, 完整测试 demo 已传 github",
        "href": "2021/9/spring_boot_allow_cross.html",
        "time": "2021/09/09",
        "description": "根据 Spring 官网 Building a RESTful Web Service (opens new window) 写了一个测试接口，在使用时，需要让该接口支持跨域，理论上只要设置好对应的响应头、处理好 Options 请求预检就可以，但发现貌似没有处理 OPTIONS 请求的注解。需要一些特殊设置处理。后面发现有一个非常简单的方法来允许跨域，就是使用 @CrossOrigin 注解，使用方法如下",
        "keywords": "spring boot 解决跨域, spring boot 允许跨域, spring boot 通过注解允许跨域"
      }
    ],
    "iOS": [
      {
        "title": "iOS Info.plist与pch文件",
        "href": "2016/10/ios_plist.html",
        "time": "2016/10/24",
        "description": "plist的全称为property list，是apple的一种属性列表文件，一般用来存储数组或字典类型数据。是iOS中数据持久化的一种方式。info.plist是app的配置文件，里面包含了app名称、版本、启动入口等基本信息。",
        "keywords": "info.plist文件,ios pch文件, pch文件,plist文件,iOS plist文件"
      },
      {
        "title": "iOS程序启动过程，从main函数开始UIApplication与AppDelegate",
        "href": "2016/10/ios_startup.html",
        "time": "2016/10/25",
        "description": "想弄清楚一段程序，就需要了解程序的执行过程。一般程序都是从main函数开始执行，iOS app也不例外。iOS程序main函数里执行了UIApplicationMain()函数，这个函数会创建UIApplication对象及代理AppDelegate，并开启事件循环，显示UI.",
        "keywords": "iOS程序启动过程,UIApplication,AppDelegate,iOS main函数执行过程"
      },
      {
        "title": "iOS程序启动过程，视图加载UIWindow与ViewController",
        "href": "2016/11/ios_startup_viewload.html",
        "time": "2016/11/01",
        "description": "初步了解了iOS程序的启动过程、UIApplication和AppDelegate后，就要开始步入正题了，界面的显示问题。开启主运行循环后，会看Info.plist文件是否指定了main storyboard，有则加载。加载storyboard会创建UIWindow对象，再将默认的ViewController设置为该window的根控制器，然后将ViewController的view可视化",
        "keywords": "UIWindow,ViewController,代码手动加载storyboard,代码加载xib,iOS启动过程"
      },
      {
        "title": "iOS 自定义ViewController中的view",
        "href": "2016/11/ios_view_controller.html",
        "time": "2016/11/01",
        "description": "手动加载storyboard时，我们用storyboard创建了ViewController，它会自动创建一个空的view，这个view就是UIView类型。我们拖拽的按钮、label等就是拖拽在这个视图上面。如果需要自定义该view可以在该ViewController的loadView方法里设置。",
        "keywords": "ViewController里的view,iOS 控制器view,ViewController里View的创建"
      },
      {
        "title": "iOS选择器UIPickerView和UIDatePicker",
        "href": "2016/11/ios_picker.html",
        "time": "2016/11/01",
        "description": "Apple提供了两个选择器对象：UIPickerView和UIDatePicker，就像网页里的select。UIDatePicker是时间方面的选择器，用法和UIPickerView差不多，这里先介绍UIPickerView，它可以自定义选择的行和列，每行显示的内容可以是自定义的视图。",
        "keywords": "iOS选择器,iOS UIPickerView,iOS UIDatePicker,UIPickerView,UIDatePicker"
      },
      {
        "title": "iOS 自定义UITextField类(国旗、生日、城市键盘)",
        "href": "2016/11/ios_textfield.html",
        "time": "2016/11/08",
        "description": "前面介绍了PickerView的简单用法，这里用PickerView和DatePicker来自定义UITextField类，让输入框的inputView不再是键盘，而是选择器。接下来会介绍三种基于选择器的封装键盘类: 国旗键盘、日期键盘、城市键盘。",
        "keywords": "封装UITextField类,iOS封装国旗键盘,iOS UIPickerView,自定义UITextField,修改iOS键盘的输入,自定义UITextField的输入视图"
      },
      {
        "title": "iOS 页面的切换跳转UINavigationController",
        "href": "2016/11/ios_navigation.html",
        "time": "2016/11/08",
        "description": "app一般有很多个页面，一个页面会对应一个UIViewController。那怎么控制页面的切换呢？拖线就不讲了！这里介绍一种可以控制页面切换的控制器：导航控制器UINavigationController，就像一个view下面有很多个子view一样，导航控制器会通过添加(push)或删除(pop)其子控制器view，来实现页面的切换，类似于栈。",
        "keywords": "iOS导航控制器,UINavigationController,iOS页面的跳转,控制器View的生命周期,导航控制器"
      },
      {
        "title": "iOS微博个人详情页面",
        "href": "2016/11/ios_weibo.html",
        "time": "2016/11/09",
        "description": "用storyboard拖线来做个微博个人详情页面的UI。导航栏刚开始透明，滚动tableView的时候，上面的两个视图会向上，导航条也会从完全透明到不透明。这里会图解UITableView显示滚动区域的相关细节。",
        "keywords": "UITableView滚动,导航条随着滚动从透明到不透明,iOS微博个人详情页面,图解UITableView显示滚动区域"
      },
      {
        "title": "iOS数据持久化(存储数据)",
        "href": "2016/11/ios_data_save.html",
        "time": "2016/11/10",
        "description": "iOS里有一个专有名词叫数据持久化，可以理解为数据存储。iOS数据持久化有5种方式：1. XML属性列表 (plist文件) 2. Preference (偏好设置) 3. NSKeyedArchiver归档 (NSCoding) 4. SQLite3 5. Core Data 这里先讲前三种。",
        "keywords": "iOS数据存储,iOS数据持久化,iOS应用沙盒,ios 数据持久化,ios 数据存储,ios 应用沙盒"
      },
      {
        "title": "iOS transform设置控件平移、旋转、缩放",
        "href": "2016/11/ios_transform.html",
        "time": "2016/11/10",
        "description": "一般情况下，我们可以通过修改UI控件的x，y轴以及长宽来控制控件的形变，iOS提供了transform属性用来专门来处理控件的形变(平移，旋转，缩放等)。所有的UIView控件都有transform这个属性。",
        "keywords": "transform,iOS 形变,控件的移动/缩放/旋转"
      },
      {
        "title": "iOS UITabBarController",
        "href": "2016/11/ios_tabbar.html",
        "time": "2016/11/10",
        "description": "现在手机里常用的app绝大部分都用到了UITabBarController，也就是最下面的一排按钮，通过点击按钮可以切换页面。它可以轻松管理多个控制器，类似于UINavigationController，一个是在屏幕顶部，一个是在屏幕底部。这里通过一个小例子，来了解UITabBarController。",
        "keywords": "ios tabbar,iOS主流app框架,UITabBarController,UITabBarController与UINavigationController,UITabBarController与导航控制器结合使用"
      },
      {
        "title": "iOS Modal，另一种切换控制器的方法",
        "href": "2016/11/ios_modal.html",
        "time": "2016/11/14",
        "description": "之前页面的切换用的一般是push，这里介绍另一种控制器切换的方法: Modal。任何控制器都能通过Modal的形式展示出来。Modal的默认效果:新控制器从屏幕最底部往上钻，直到盖住之前的控制器为止(push的效果为从右至左)",
        "keywords": "iOS Modal,Modal跳转,UIAlertController与Modal,presentViewController跳转,ios modal"
      },
      {
        "title": "iOS UIResponder响应者对象，iOS中的事件",
        "href": "2016/11/ios_responder.html",
        "time": "2016/11/14",
        "description": "在使用app的过程中，会产生各种各样的事件，iOS中的事件可以分为3大类型:触摸事件、加速计事件、远程控制事件。不是任何对象都能处理事件，只有继承了UIResponder的对象，才能接收并处理事件。这些对象被称为响应者对象",
        "keywords": "UIResponder响应者对象,UITouch对象,触摸事件,iOS中的事件,hitTest应用"
      },
      {
        "title": "iOS 手势UIGestureRecognizer",
        "href": "2016/11/ios_gesture.html",
        "time": "2016/11/14",
        "description": "监听一个view的触摸事件可以先自定义view，再实现它的touches方法来处理事件。通过touches方法监听view触摸事件必须得自定义view，外界对象无法监听view的触摸对象，且不易区分用户的具体手势行为。这里将介绍手势识别类UIGestureRecognizer，它可以更好的识别触摸事件。",
        "keywords": "iOS UIGestureRecognizer手势识别,iOS手势,UIGesture,ios 手势,ios 手势事件"
      },
      {
        "title": "iOS页面之间传值 - Segue、通知、代理",
        "href": "2017/1/web_pass_data.html",
        "time": "2017/01/26",
        "description": "之前做通讯录的时候用的是navigation以代码的方式push跳转，tableView的传值只是用了控制器.h文件的一个变量。这里用拖线的方式跳转，通过添加和修改联系人练习segue、通知及代理传值。",
        "keywords": "页面之间传值 iOS,iOS页面之间传值,iOS用通知传值,Segue传值,iOS代理传值"
      },
      {
        "title": "iOS通讯录小列子",
        "href": "2017/1/web_address_list.html",
        "time": "2017/01/22",
        "description": "小马哥视频里讲的通讯录小例子登录界面用了动画，用的是storyboard拖线跳转，顺便讲了segue，页面传值及发送通知。这里简单的实现通讯录的基本功能，动画就不做了，主要练习页面的跳转以及tableView相关使用，只是了解基本的使用，可以根据实际情况进行优化。",
        "keywords": "UITableView的使用,通讯录小例子,UITableView左滑删除功能"
      },
      {
        "title": "Xcode8安装KSImageNamed插件后崩溃的解决方法",
        "href": "2017/2/ios_image.html",
        "time": "2017/02/04",
        "description": "苹果在Xcode8中取消了对第三方插件的支持，安装了KSImageNamed插件后，Xcode8会不停的崩溃。这里总结了网上找到了一种重新签名Xcode(re-codesign Xcode)的方法，可以解决这个问题。对于是否影响上架还有待考证。",
        "keywords": "Xcode安装KSImageNamed方法,Xcode8 安装KSImageNamed崩溃的解决方法"
      },
      {
        "title": "CocoaPods安装及使用",
        "href": "2017/2/ios_cocoapods.html",
        "time": "2017/02/06",
        "description": "在导入某个框架时，你可能还需要导入这个框架依赖的其他框架，这样就比较麻烦。如果用CocoaPods导入一个框架，它会自动导入这个框架所依赖的所有框架。在导入AFNetworking时用到了它，这里总结了安装方法及一些需要注意的细节。",
        "keywords": "CocoaPods 2020,cocoapods 2020, CocoaPods安装2020,CocoaPods,2020 CocoPods安装,最新CocoaPods安装方法"
      }
    ],
    "微信开发": [
      {
        "title": "微信小程序Failed to load resource: net::ERR_NAME_NOT_RESOLVED",
        "href": "2017/1/web_mp_vpn.html",
        "time": "2017/01/09",
        "description": "mac版的微信小程序最开始的demo调试时无法运行，报错Failed to load resource:... 网上查了很多资料，是开了网络代理造成的，关掉就可以了，为了方便后来的人更快找到解决方法，就专门写了这篇记录。",
        "keywords": "Failed to load resource: net::ERR_NAME_NOT_RESOLVED,微信小程序Failed to load resource: net::ERR_NAME_NOT_RESOLVED"
      },
      {
        "title": "小程序web-view组件内嵌网页调用微信JS-SDK",
        "href": "2018/2/mp_jssdk.html",
        "time": "2018/02/24",
        "description": "小程序web-view内置H5可以像公众号H5一样使用JS-SDK，但会有一定的限制，另外对于没有公众号H5调用JS-SDK经验的同学，可能会以为wx.config使用的参数是小程序的信息，下面以调用扫一扫为例子，介绍具体细节",
        "keywords": "web-view jssdk,小程序内嵌H5调用jssdk,微信JS-SDK使用"
      },
      {
        "title": "开发个人微信小程序前必看，个人主体可以做什么内容",
        "href": "2020/6/mp_personal_cando.html",
        "time": "2020/06/21",
        "description": "微信小程序很早就已经开放个人主体了，也就是个人也可以上传发布小程序。但现在个人主体小程序可以做的内容越来越少了，相信很多微信小程序的开发者都遇到过这种情况：好不容易做好了小程序，结果准备提交审核上线时，由于类目问题，审核被拒，无法上线的情况。",
        "keywords": "开发个人微信小程序前必看,小程序个人主体可以做什么内容,个人小程序审核被拒"
      },
      {
        "title": "小程序代码找回，代码丢失后找回过程记录（反编译、云开发函数恢复）",
        "href": "2021/4/miniprogram_code_reverse.html",
        "time": "2021/04/11",
        "description": "小程序代码找回，小程序云开发代码找回，小程序云函数恢复，最近想把之前写的一个已上线的小程序开源，发现当时居然没有用 git 管理，换电脑、折腾 mac 双系统后，代码丢失了。尝试用数据恢复软件恢复都没有找回代码，尽管小程序的文件特征很好找，比如 .wxml、project.config.json 等。后面在网上找了反编译线上小程序的方法。这样可以拿到 uglify 混淆压缩后的代码，至少比没有强。另外，云函数的代码也是可以恢复的，因为之前开发时上传过，它是可以下载的。",
        "keywords": "小程序代码找回,小程序云开发代码找回,小程序云函数恢复"
      }
    ],
    "http与https": [
      {
        "title": "http转https",
        "href": "2017/1/web_https.html",
        "time": "2017/01/10",
        "description": "在玩微信小程序的时候发现网络请求必须是https开头的，但我的数据都在我的web服务器上，只是简单的http，于是就在网上找ssl证书，发现居然有免费1年的SSL，还是阿里云的，果断申请使用。顺便将web的数据打包为json做了一个接口。",
        "keywords": "免费SSL,阿里云DV SSL使用实例,http转https,80端口转443端口,tomcat配置https"
      },
      {
        "title": "前端ajax请求时，设置Cookie请求头无效",
        "href": "2019/10/http_request_header.html",
        "time": "2019/10/10",
        "description": "前端设置请求头无效，header 设置cookie 无效，ajax 强制设置cookie无效，在前端mock接口时，对于需要设置请求头校验的情况，可能会想着在前端发送请求时设置对应的请求头，但发现前端设置了Cookie请求头，会出错。这是什么原因呢？",
        "keywords": "ajax中请求头的cookie,是否可以手动更改,前端设置请求头无效,Refused to set unsafe header Cookie,前端设置cookie请求头无效,axios添加请求头不生效,"
      },
      {
        "title": "axios请求拦截与响应拦截",
        "href": "2019/10/http_axios_interceptors.html",
        "time": "2019/10/12",
        "description": "axios提供了请求拦截与响应拦截的函数axios.interceptors，请求拦截器有什么用呢？具体怎么使用？下面来看看",
        "keywords": "axios请求拦截,axios响应拦截,axios.interceptors,axios拦截器"
      },
      {
        "title": "下载文件进度显示以及koa下载接口mock",
        "href": "2019/10/http_download_progress.html",
        "time": "2019/10/18",
        "description": "blob拒绝访问文件，下载进度，通用下载函数，IE下blob拒绝访问文件兼容处理了，在前端做导出功能的时候，需要请求一个接口去导出数据，一般是execl，然后接口会返回execl的文件数据。对于比较大的文件，我们怎么获取文件的下载进度呢？前端怎么用koa来mock导出的接口呢？下面来看看",
        "keywords": "blob拒绝访问文件,下载文件进度,axios下载文件进度,下载接口mock,koa导出文件接口,前端下载进度,进度信息total为0，只有loaded的情况"
      },
      {
        "title": "零编码或少编码根据配置生成通用封装的axios函数",
        "href": "2020/1/axios_package.html",
        "time": "2020/01/19",
        "description": "现在项目中，每个模块都会单独弄一个对应service.js，把所有接口请求放到里面，其实就是将axios请求封装为一个个函数。每个函数的函数名、url、请求方法会有所差别。重复代码比较多。最近在看mongodb教程时，了解到零编码编程的思想，于是想把这里优化下，最好以后写新模块时，只要写简单的配置文件就可以自动生成函数，不用再单独手写函数",
        "keywords": "axios二次封装,axios服务封装"
      },
      {
        "title": "前端通过document.cookie设置cookie，相关改动会传到后台吗？",
        "href": "2020/10/document_cookie_edit.html",
        "time": "2020/10/01",
        "description": "首先我们来捋一捋，什么是cookie？与cookie相关的知识点有两个：1. 前端获取/设置cookie，使用 document.cookie 2. HTTP请求与响应相关cookie，我们先下个结论：他们之间是相互关联的，接口响应头设置cookie，会对document.cookie的值产生影响；前端设置docuemnt.cookie也会对请求头cookie值产生影响，但如果后端写到前端的cookie如果使用了HttpOnly属性，前端是无法通过document.cookie做修改的",
        "keywords": "document.cookie设置cookie对接口影响"
      },
      {
        "title": "http请求有哪几种传参方式",
        "href": "2020/10/http_param_type.html",
        "time": "2020/10/01",
        "description": "在swagger文档里，有一个传参类型的描述 Parameter Type，一般有四种: - header 通过请求头传参，也就是参数加到首部 headers 里 - path  参数放到url路径里，比如 /user/123 这里 123是用户id - query 查询参数，也就是url后面 ? 符号之后的传参，一般用于get请求传参，比如 /user/123?a=xx&b=xx - body 参数放到请求体，一般用于post请求，相对get请求来说，安全性好，可以传的数据更多",
        "keywords": "http请求传参方式,http传参,swagger参数类型"
      },
      {
        "title": "HTTP2，怎么确定网站是否开启了HTTP2，HTTP3？",
        "href": "2020/11/http2_http3.html",
        "time": "2020/11/23",
        "description": "HTTP/2 是新一代的 HTTP 协议，于 2015 正式发布。相对 HTTP/1 来说，大幅提升了网页性能，绝大多数浏览器都支持了 HTTP/2。http 怎么开启 http2 呢？HTTP/2 现阶段必须使用 https，80端口就不要想了。HTTP/1.1 不足的地方 - 连接无法复用，每次请求都经历三次握手和慢启动 - HTTP/1.0 传输数据时，每次都需要重新建立连接，增加延迟。- HTTP/1.1 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。",
        "keywords": "HTTP2,HTTP3,怎么开启HTTP/2"
      },
      {
        "title": "Let’s Encrypt 免费HTTPS证书",
        "href": "2020/11/free_https.html",
        "time": "2020/11/23",
        "description": "Let’s Encrypt 是一个非盈利TLS（Transport Layer Security) 证书颁发机构（CA），免费提供 https 证书。 由于 Let’s Encrypt 证书的有效期为 3 个月，所以一般使用程序来自动续期更换证书。官方推荐使用 Certbot 来管理，它可以一站式申请、续期证书。在 Certbot 官网选择部署服务器使用的软件及系统，会自动列出需要操作的步骤，如下图",
        "keywords": "免费https,https"
      },
      {
        "title": "外部链接 a 标签为什么要加 noreferer 与 noopener ？",
        "href": "2020/12/a_noreferrer.html",
        "time": "2020/12/15",
        "description": "一般页面的外部链接 a 标签都会加上 ref='noreferrer noopener'，这样可以避免一些安全问题，下面通过几个问题来具体看看 1. a 标签加上 noreferrer 和 noopener 后会有什么效果？2. Referer 是什么？有什么应用场景? 3. window.opener 可以做什么？",
        "keywords": "noreferrer和noopener,noreferrer,noopener"
      },
      {
        "title": "防盗链时需要注意搜索引擎 Referer，百度和 Google 搜索内容跳转链接之间的区别",
        "href": "2020/12/search_referer.html",
        "time": "2020/12/15",
        "description": "一般搜索引擎为了方便网页做来源分析，不会使用 noreferer，因此从搜索引擎进入页面时，会携带对应的 Referer。当首页 index.html 也放在 CDN 的情况时，做防盗链 Referer 白名单时，要记得放开搜索引擎的相关 Referer。下面分两个部分介绍搜索引擎跳转链接的处理 1. 百度搜索结果链接的跳转方式 2. Google搜索结构链接的跳转方式",
        "keywords": "防盗链需要注意搜索引擎,百度和Google搜索跳转链接区别"
      },
      {
        "title": "前端怎么获取文件上传进度以及使用node mock上传文件接口demo",
        "href": "2020/2/upload_progress_monitor.html",
        "time": "2020/02/26",
        "description": "现在接口请求一般用的是axios，对于上传文件的进度监听，我们需要了解在axios的config参数里，可以传入onUploadProgress参数来接收upload进度事件，里面会有上传进度信息。我们前端怎么mock上传文件的接口呢？在koa处理时使用 `post-bodyparser` 可以很好的解析 `multipart/form-data` 数据，下面来具体看看",
        "keywords": "前端获取文件上传进度,文件上传进度demo,怎么获取文件上传进度,axios文件上传进度监听,前端怎么mock上传文件接口"
      },
      {
        "title": "利用koa来彻底理解web前端跨域问题",
        "href": "2020/6/koa_web_cros.html",
        "time": "2020/06/21",
        "description": "JS高程3中在Ajax那一章里有详细的讲解跨域的问题，由于是纯理论，之前看时只是了解个大概。之后学会了koa后，用koa来写测试接口模拟跨域的场景，对跨域问题有了更深层次的理解，下面来对跨域的相关知识点进行整理、回顾，并写demo做一些测试",
        "keywords": "web前端跨域问题,web跨域,前端跨域,请求预检,cros,跨域资源共享"
      },
      {
        "title": "Invalid character in header content ['Content-Disposition']",
        "href": "2020/6/content-dispositon.html",
        "time": "2020/06/21",
        "description": "在koa中，如果Content-Disposition里设置文件名有中文会提示错误，需要用类似 encodeURIComponent 转码的函数转码后才行，这里顺便介绍下encodeURIComponent和encodeURI的区别",
        "keywords": "Invalid character in header content ['Content-Disposition'],URI和URL的区别,encodeURIComponent和encodeURI的区别,encodeURI和encodeURIComponent区别"
      },
      {
        "title": "nginx以及koa实现301跳转：xx.com重定向到www.xx.com",
        "href": "2020/7/nginx_koa_301.html",
        "time": "2020/07/12",
        "description": "今天帮一个同学测试网络，使用curl来请求百度，发现baidu.com到 www.baidu.com 的重定向使用的是 html 的meta元素。我们可以做一个测试，当接收到一个请求后，修改状态码为301，然后设置Location响应头为 http://www.zuo11.com 看是否可以重定向页面，来写个koa例子",
        "keywords": "nginx重定向使用301,koa实现301,xx.com重定向到www.xx.com"
      },
      {
        "title": "通过koa写demo彻底理解前端http缓存",
        "href": "2020/9/web_cache.html",
        "time": "2020/09/07",
        "description": "http缓存,web缓存,前端缓存,强缓存,Expires,Cache-Control,弱缓存,协商缓存,sever revalidataion,Last-Modified/If-Modified-Since,ETag/if-None-Macth,在前端性能优化中，有一个方法是使用缓存。前端缓存可以减少网络请求次数，减少流量消耗，提升用户体验，降低服务器负载。前端缓存分为两种：http缓存、浏览器缓存。相关文档可以搜索对应请求头的MDN文档、另外可以参考《http权威指南》第7章 缓存",
        "keywords": "http缓存,web缓存,前端缓存,强缓存,Expires,Cache-Control,弱缓存,协商缓存,sever revalidataion,Last-Modified/If-Modified-Since,ETag/if-None-Macth"
      },
      {
        "title": "axios取消请求具体使用场景及实现原理",
        "href": "2020/9/axios_cancel.html",
        "time": "2020/09/12",
        "description": "axios取消请求用法,axios取消请求是怎么实现的,axios取消请求原理，取消请求在前端有时候会用到，以下是两个工作中可能会用到的场景 1. tab切换时刷新某个列表数据，如果他们共用一个变量存储数据列表，当请求有延时，可能会导致两个tab数据错乱 2. 导出文件或下载文件时，中途取消 下面来看看axios是怎么取消请求的，以及对应的原理",
        "keywords": "axios取消请求用法,axios取消请求是怎么实现的,axios取消请求原理"
      },
      {
        "title": "为什么有效的URI不能包含空格等其他字符，URI编码方法详解",
        "href": "2020/9/uri.html",
        "time": "2020/09/12",
        "description": "在JS高程3里介绍URI编码方法时，有这样一个描述：**有效的URI中不能包含某些字符，比如空格。使用URI编码方法可以把所有无效的字符替换为特殊的utf-8编码，从而让浏览器能够接受和理解** 为什么有效的URI不能包含空格等其他字符？ 在《HTTP权威指南》第2章URL与资源 - 各种令人头疼的字符(p38)里有介绍原因：",
        "keywords": "URI编码方法详解"
      },
      {
        "title": "HTTP 301 和 302 状态码的区别以及它们在浏览器和搜索引擎中的处理",
        "href": "2021/1/http-301-302.html",
        "time": "2021/01/12",
        "description": "301 和 302 状态码都是表示页面重定向，它们有两个用处：一是告诉浏览器，访问当前页面时需要跳转到新的页面。二是告诉搜索引擎如何正确的处理页面收录、索引。同样是发送 HTTP 请求，接收响应内容，浏览器对重定向页面的处理流程和普通页面有什么区别呢？一般访问某个页面时，基本流程如下：1. `客户端（浏览器）发起请求` 在浏览器中访问某个页面时，会向该页面资源所在的 URL 发送一个 HTTP 请求。2. `服务端处理请求并响应` 服务器接收到请求后，会将资源的数据响应给前端，一般响应状态码 status 为 200，响应内容为 html 文本。3. `客户端（浏览器）处理` 客户端接收到响应后，看状态码是否是 200 或 304(资源未修改)，如果是就将浏览器返回的 html 内容解析、绘制在浏览器窗口中。",
        "keywords": "301与302区别"
      }
    ],
    "运维部署与版本控制": [
      {
        "title": "Tomcat将多个域名解析到服务器的不同目录",
        "href": "2017/2/web_tomcat.html",
        "time": "2017/02/08",
        "description": "昨天好基友买了个域名limiaolei.com，并解析到了我的服务器。然后访问他的域名就进入了我的网站，于是就想怎么让同一ip上的两个域名访问不同的内容。由于不知道具体的方法，我用的搜索词都不怎么准确，找了好久才找到解决方法。就是配置Tomcat，当访问limiaolei.com时，指定为其它目录。",
        "keywords": "将不同的域名解析到不同的目录,Tomcat设置将多个域名解析到同一个服务器的不同目录,tomcat配置二级域名的访问目录,tomcat如何设置二级域名的访问目录"
      },
      {
        "title": "github向他人的项目提交代码及添加域名解析",
        "href": "2018/3/web_github_push.html",
        "time": "2018/03/04",
        "description": "在Github新建的仓库，如果是项目拥有者，进入项目，就会看到setting的入口，这个位置配置当前项目的一些信息，删除该仓库。如果想要其他的github用户可以把代码直接提交到该仓库，可以在这里把对应的用户名添加到合作者，collaborators下。添加后，对方需要同意，可以把链接发给对方。这样，其他账号就可以直接提交到项目了。使用hexo g 可直接提交生效。",
        "keywords": "github向他人项目提交代码,github使用自定义域名"
      },
      {
        "title": "macOS安装nginx",
        "href": "2019/10/mac_nginx_install.html",
        "time": "2019/10/08",
        "description": "mac下直接使brew install用命令安装，注意：mac自带的xcode不要随意卸载，不然会出各种奇怪的问题: 包括svn安装问题、nginx安装问题等",
        "keywords": "mac nginx,mac 安装nginx,macos安装nginx,macos nginx,nginx安装"
      },
      {
        "title": "nginx默认配置对前端开发的一些影响",
        "href": "2019/10/nginx_effect_web.html",
        "time": "2019/10/28",
        "description": "一般前端代码开发好后，会部署到nginx，但nginx的某些默认配置，会使前端页面受到影响，比如默认请求超时限制，默认文件上传大小限制，默认字符编码问题等。下面来看具体的问题，以及怎么解决这些问题。",
        "keywords": "nginx默认配置对前端开发的一些影响,ngnix请求超时时间默认60s,nginx默认文件上传大小限制为1M,nginx中文图片路径404的问题,nginx会影响前端页面超时吗"
      },
      {
        "title": "mac没安装xcode怎么安装svn以及怎么用命令操作svn",
        "href": "2019/10/mac_svn.html",
        "time": "2019/10/30",
        "description": "一般在mac下，如果安装了xcode貌似有自动安装svn，如果卸载了xcode，那怎么安装svn呢？还有svn怎么使用命令来拉取更新，一般的git命令对应svn的命令是什么呢？下面我们来看看。",
        "keywords": "mac没安装xcode怎么安装svn,怎么用命令操作svn,svn拉取代码命令"
      },
      {
        "title": "版本号中的rc是什么意思",
        "href": "2019/11/version_rc.html",
        "time": "2019/11/05",
        "description": "在看html2canvas的历史版本信息时，发现有rc版本，不知道是什么意思，于是查了下，rc版本代表比较成熟的版本，是release之前版本，除此之外还有aplpha、beta等版本，下面来看看",
        "keywords": "版本号中的rc是什么意思"
      },
      {
        "title": "Docker与K8S集群",
        "href": "2019/11/docker_k8s.html",
        "time": "2019/11/11",
        "description": "现在前端项目很多部署在docker容器上，相比之前的实体服务器、虚拟机来讲，docker不需要自己安装软件，可以直接配置使用，比较方便。下面来简单了解下",
        "keywords": "Docker与K8S集群"
      },
      {
        "title": "CI、CD、CO是什么意思",
        "href": "2019/11/ci_cd_co.html",
        "time": "2019/11/11",
        "description": "CI CD CO 是什么意思呢？在开发中他们分别代表 CI持续集成 => CD持续交付/持续部署 => CO持续运营，下面来看看",
        "keywords": "CI CD CO,CI、CD、CO是什么意思,CI,CD,CO,CI持续集成,CD持续交付,CO持续运营"
      },
      {
        "title": "git创建新分支并提交到远程仓库origin",
        "href": "2019/11/git_push_branch.html",
        "time": "2019/11/26",
        "description": "git如何建立新的origin，这里主要介绍下自己平常在工作中创建分支，将分支推送到远程的方法以及将分支合并到版本分支的方法。当我们加入到一个项目组开发项目，一般最开始的一件事情就是从远程仓库clone代码，然后新创建一个分支进行开发。显然你需要把每天写的代码上传到服务器，那怎么将本地创建的分支推送到远程并与之关联呢，下面来看一下对应的流程",
        "keywords": "git如何建立新的origin,git创建新分支并提交到远程仓库origin"
      },
      {
        "title": "git clone大文件仓库超时问题",
        "href": "2019/12/git_clone_timeout.html",
        "time": "2019/12/04",
        "description": "当远程仓库比较大，或者弱网的情况，可能会出现git clone超时的问题，一直clone不下来，一般可以用两种方法来解决：一是git clone时使用 depth参数；二是使用ssh拉取方式",
        "keywords": "git clone大文件仓库超时问题,git clone超时,git无法拉取文件,git克隆文件超时"
      },
      {
        "title": "nginx怎么开启gzip以及怎么判断nginx是否成功开启了gzip？",
        "href": "2020/1/nginx_gzip.html",
        "time": "2020/01/29",
        "description": "nginx是比较好的一个运行静态http服务的容器。当我们把静态网站部署到nginx上后，我们怎么设置开启zip，让网页资源体积更小，传输更快呢？下面来看看",
        "keywords": "nginx怎么开启gzip,怎么判断nginx是否成功开启了gzip,怎么判断nginx开启gzip生效"
      },
      {
        "title": "git将远程仓库A分支合并到B分支",
        "href": "2020/10/git_merge_branch.html",
        "time": "2020/10/01",
        "description": "假设要将远程分支的 A 分支合并到 B 分支，一般我会先在A分支将B分支merge，再切到B分支，merge A分支。以将远程仓库的 dev1.3.4 分支合并到远程的 test1.3.4 分支为例，下面是我一般的合并过程",
        "keywords": "git远程分支合并,git合并分支"
      },
      {
        "title": "git修改上上次的commit信息",
        "href": "2020/10/git_edit_commit_info.html",
        "time": "2020/10/01",
        "description": "由于提交代码时有钩子函数，信息里面没有包含前置的 code 会无法提交。所以如果 commit 信息写的有问题需要修改后才能提交。对于修改上一次 commit 备注信息，我们可以使用 `git commit --amend -m 'xxx'` 来修改。但它无法修改上上次提交信息，这种情况我们可以使用 rebase 来做处理，下面来做一个测试，本地做两次提交，第一次提交信息为'测试第一次提交'， 第二次提交信息为 '第二次提交'，先不push，我们需要修改上上次的提交信息，也就是修改'测试第一次提交'的内容",
        "keywords": "git修改commit信息"
      },
      {
        "title": "git status中文乱码怎么解决",
        "href": "2020/10/git_status_chinese.html",
        "time": "2020/10/31",
        "description": "git status时，如果中文乱码，可以对git进行一个配置即可 `git config --global core.quotepath false` 具体效果如下图",
        "keywords": "git中文乱码,git status乱码,git乱码"
      },
      {
        "title": "xx.github.io偶尔访问不了是为什么？",
        "href": "2020/11/github_io_failure.html",
        "time": "2020/11/16",
        "description": "在 Github 上开启 Pages 服务后，可以通过 xx.github.io 访问对应的网页。但偶尔会出现打不开的问题，之前都是可以打开的，试了其他人的 github.io，发现也打不开，这就不是自己网络的问题了。网上查原因是电信运营商 DNS 污染（域名解析不到正确的 IP 地址）。我们在本地手动设置 host 指定对应域名的解析 IP 即可正常访问。下面来看具体怎么操作",
        "keywords": "xx.github.io打不开,github.io打不开,githu.io访问不了"
      },
      {
        "title": "ssh生成rsa key时Enter passphrase加和不加有什么区别",
        "href": "2020/11/ssh_passphrase.html",
        "time": "2020/11/16",
        "description": "在使用 ssh 拉取 git 仓库前，需要先生成公共/私有 rsa 密钥对。(Generating public/private rsa key pair.)，一般使用 `ssh-keygen -t rsa -C '邮箱@xx.com'` 命令，这个时候，会有下面的提示：Enter passphrase (empty for no passphrase): 输入通行码(密码、口令短语)，如果不输入，那么就是不使用密码。如果输入了密码，这个有什么用呢？",
        "keywords": "ssh passphrase,ssh passphrase有什么用"
      },
      {
        "title": "使用git ssh方式解决RPC failed; HTTP 413 curl 22 The requested URL returned error: 413",
        "href": "2020/11/git_http_413.html",
        "time": "2020/11/16",
        "description": "由于改了博客生成系统的生成方式，每个html都改了，导致文件相对较多，也不算大，才 4.57 M, 但 git push 一直push不了，提示如下 error: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413 fatal: the remote end hung up unexpectedly，网上查了下，可以改用 ssh 的方式 push 代码，结合之前的经验，大文件 git clone 不下来，可以换 ssh 方式 git clone。",
        "keywords": "RPC failed; HTTP 413 curl 22,The requested URL returned error: 413,fatal: the remote end hung up unexpectedly"
      },
      {
        "title": "xx.github.io仓库配置Github pages后对其他仓库Github pages的影响",
        "href": "2020/12/github-io.html",
        "time": "2020/12/07",
        "description": "在 github 中，假设我们创建了 'github用户名.github.io' 仓库，开启 Github Pages 后，访问该域名，就指向了这个仓库的文件。这时如果你的其他仓库也开启了 Github Pages，那么对于的目录解析可能会有问题。以我的 github 账号 zuoxiaobai 为例，如果 zuoxiaobai.github.io 这个仓库开启 pages，再把另一个仓库 zuo-blog 也开启 pages，那么访问 `https://zuoxiaobai.github.io/zuo-blog/` 并不能自动跳转到对应的 index.html，而是提示 404。需要访问 `https://zuoxiaobai.github.io/zuo-blog/index.html` 才行。这里我直接把 zuoxiaobai.github.io 的仓库关掉了 Github Pages。这样 `https://zuoxiaobai.github.io/zuo-blog/` 才能自动解析目录下的 index.html。",
        "keywords": "github.io仓库开启pages后对其他仓库pages的影响"
      },
      {
        "title": "GitHub Pages使用自定义域名开启HTTPS，配置CNAME解析",
        "href": "2020/12/github_pages_https.html",
        "time": "2020/12/07",
        "description": "一般在仓库的 Setting 中，开启 Github Pages 会生成一个 `xxx.github.io/xx/` 的地址，地址有点长，我们可以使用自定义域名，这里我将 vue-chart 这个仓库设置成了自定义域名 vuechart.zuo11.com。然后，我们需要把自定义的域名解析到 github.com 地址。可以使用 ping github.com 来获取它的服务器 IP。",
        "keywords": "github pages https"
      },
      {
        "title": "git 修改文件内容后误删了该文件，再使用 git 还原该文件，修改的文件内容丢失怎么办？",
        "href": "2020/12/git_edit_loss.html",
        "time": "2020/12/30",
        "description": "最近修改某个文件后，还没将改动提交到 git，中途不小心删了该文件。然后想着恢复文件，就使用 git 恢复该文件。这个时候发现未提交的修改内容都丢失了，文件内容是 git 上最近的内容。这种情况，理论上 git 是无法还原的。因为没有提交，git 不会记录对应的内容。我们不能总是想着使用 git 怎么恢复，需要换一下思路。**修改的文件删除后，默认会存在废纸篓(回收站)，去里面找即可。**",
        "keywords": "git修改内容丢失怎么恢复,git修改内容未提交误删后怎么恢复"
      },
      {
        "title": "windows下nginx部署https服务实战",
        "href": "2020/6/nginx_https.html",
        "time": "2020/06/21",
        "description": "这里复盘下将koa写的接口服务部署到`https://api.zuo11.com`上，相关nginx配置的全流程",
        "keywords": "nginx部署https服务,nginx https"
      },
      {
        "title": "他人提交了package-lock.json的更新导致拉取时和本地冲突的问题",
        "href": "2020/6/git_package_lock.html",
        "time": "2020/06/29",
        "description": "一般在npm install 时会修改package-lock.json文件，我一般不会提交这个更新，但今天发现有人提交。我拉取时，提示这个文件冲突，导致拉取不下来，我又不想提交更新，所以尝试用下面的命令，将工作区该文件的修改丢弃，再拉取",
        "keywords": "是否要提交package-lock.json"
      },
      {
        "title": "git commit提交信息有误怎么修改",
        "href": "2020/6/git_comit_amend.html",
        "time": "2020/06/29",
        "description": "如果不小心提交了，但没有push，可以使用--amend参数来修改上一次的commit信息，命令如下：git commit --amend -m 'xxx', 注意，一般是修改没有push前的提交信息",
        "keywords": "git commit提交信息修改,commit备注信息有误怎么修改"
      },
      {
        "title": "常用的.gitignore配置",
        "href": "2020/7/git_ignore.html",
        "time": "2020/07/12",
        "description": "一般用git做代码管理时，需要将某些系统文件或配置文件不加入版本控制，就需要在.gitignore文件里加入对应的文件名或路径，下面是一个常用的.gitignore配置",
        "keywords": "gitignore配置,常用的.gitignore配置"
      },
      {
        "title": "git无法检测到文件名大小写的更改，为什么？怎么解决？",
        "href": "2020/7/git_file_name.html",
        "time": "2020/07/26",
        "description": "git无法检测文件大小写改变,mac系统文件大小写不敏感，今天把开发分支合并到月底分支后，发现之前修改过文件名没有提交上去，手动改文件名后，git status 提示没有任何改动。于是百度了下，发现git默认配置为忽略大小写，因此无法正确检测大小写的更改。",
        "keywords": "mac文件大小写不敏感,macOS文件大小写不敏感,git无法检测文件大小写改变"
      },
      {
        "title": "nginx配置二级域名解析目录",
        "href": "2020/7/nginx_sencod_domain.html",
        "time": "2020/07/26",
        "description": "nginx二级域名解析,nginx二级域名解析到不同的目录,最近看百度统计，有100多个河南的新ip访问，有些异常，而且都是访问的api.zuo11.com，最近两周明细里看到的ip段很有规律。其实就是多写一个server，把二级域名指向其他目录。中间有个坑的地方就是windows使用nginx时，关闭nginx运行的terminal后，进程不一定关闭，需要打开任务管理器，找nginx相关进程删掉，这样才彻底。",
        "keywords": "nginx二级域名解析,nginx二级域名解析,nginx二级域名解析到不同的目录"
      },
      {
        "title": "使用ssh方式拉取代码的步骤",
        "href": "2020/8/git_ssh.html",
        "time": "2020/08/02",
        "description": "在使用git拉取远程分支代码时，有两种方式，一种是git clone，另一种是 ssh。在文件太大git clone超时时，我们可以试试ssh这种方法，下面来看看具体步骤",
        "keywords": "git ssh"
      },
      {
        "title": "git删除远程分支与本地分支",
        "href": "2020/8/git_branch_del.html",
        "time": "2020/08/02",
        "description": "git删除分支,git删除远程分支,git怎么删除远程分支,当我们常见远程分支，使用完成后，怎么删除远程的分支呢？我们以删除file_backup分支为例，来看看具体步骤 1. 先查看本地分支 2. 删除远程的file_backup分支 3. 删除本地分支",
        "keywords": "git删除分支,git删除远程分支,git怎么删除远程分支"
      },
      {
        "title": "macos大小写不敏感，修改文件名大小写后git会异常",
        "href": "2020/9/mac_git_case.html",
        "time": "2020/09/07",
        "description": "怎么解决git修改文件大小后报错,git修改文件大小写,mac上git修改文件大小写,macos是文件大小写不敏感的系统，而widonws/linux是大小写敏感的，假设把git上之前提交过的文件，修改大小写，再次提交后，git上会出现两个大小写不一样的文件？为什么呢。macos是大小写不敏感的文件系统，也就是在macos上你无法在同一个目录下同时创建test.vue和Test.vue，如果出现这种情况，本地感知不到文件的改动，但git服务器却有记录这两个文件。最好的解决方法是将整个文件名都变更。而不是仅改变大小写",
        "keywords": "怎么解决git修改文件大小后报错,git修改文件大小写,mac上git修改文件大小写"
      },
      {
        "title": "github clone下载太慢怎么解决",
        "href": "2020/9/github_clone_slow.html",
        "time": "2020/09/24",
        "description": "以clone vue源码为例，默认git clone下载非常慢，我们可以把github.com链接改为镜像github.com.cnpmjs.org，这样下载速度就很快了，修改后效果对比图如下",
        "keywords": "github clone慢,github clone超时,github clone不下来"
      },
      {
        "title": "多个 ssh 怎么配置，github、gitlab、gitee 多个平台配置并测试",
        "href": "2021/4/multiple_ssh.html",
        "time": "2021/04/03",
        "description": "在之前我们有介绍过使用 ssh 方式拉取代码的步骤，仅一个平台时（比如 github）还可以。如果多个 git 平台（比如 github、gitlab、gitee）都需要配置 ssh 时，那怎么配置呢？首先我们要在 ~/.ssh/ 目录下新建一个 config 文件，内容如下",
        "keywords": "ssh多git平台,多个ssh配置,multiple ssh"
      },
      {
        "title": "git clone 输错了密码，怎么重新输入或修改密码",
        "href": "2021/4/git_clone_pw_error.html",
        "time": "2021/04/03",
        "description": "在 windows 系统中，如果是第一次拉取代码，而且是使用的 http 方式，涉及到登录的时候，会要求输入 git 相关账号密码，如果账号密码不小心输入错误。后面每次 git clone 都会提示 auth 失败。这时我们可以在 **控制面板 - 用户账户 - 凭据管理器** 里修改对应的密码",
        "keywords": "git clone error,git clone auth fail"
      },
      {
        "title": "Make sure you configure your ‘user.name’ and ‘user.email’ in git",
        "href": "2021/4/git_user_email.html",
        "time": "2021/04/11",
        "description": "git 设置 user.name user.email，github 提交没有绿点，github提交没头像，在 vscode 中，使用可视化工具，而非命令的方式提交代码时，如果没有配置 git 的 user.name 和 user.email，可能会弹出 Make sure you configure your ‘user.name’ and ‘user.email’ in git 的错误，代码无法提交。这就需要先配置好，再提交了。另外，在 github 或 gitlab 等页面中，可能会遇到提交没有绿点或者看不到头像的情况，可能是因为配置的 user.email 发生了变化，和平台的 email 不一致导致的。修改成一致的就正常了。",
        "keywords": "git config,git 设置 user.name user.email,github 提交没有绿点,github提交没头像"
      },
      {
        "title": "nginx emerg bind to 0.0.0.0:80 failed <10013, 80 端口被占用",
        "href": "2021/9/mginx_80_port.html",
        "time": "2021/09/09",
        "description": "重启服务器后发现开启 nginx 时，报错 nginx emerg bind to 0.0.0.0:80 failed <10013:，这个错误一般是 80 端口被占用的问题，访问 http://127.0.0.1 看看 80 端口的情况，发现是 Java 服务，检查后发现 tomcat 开了，它占用了 80 端口，关掉 tomcat，再次运行就可以了。",
        "keywords": "nginx 80 端口被占用,emerg bind to 0.0.0.0:80 failed"
      },
      {
        "title": "node 自动化部署、持续集成的核心原理: node 可以执行 shell 脚本 + 可以监听请求",
        "href": "2021/9/node_ci_cd.html",
        "time": "2021/09/09",
        "description": "node 可以用来支撑实现自动化部署、持续集成，核心原理是：1. node 可以执行 shell 脚本，而部署流程一般都是写在 shell 脚本中的。2. node 可以作为服务器 server, 当接收到请求后，根据条件判断是否执行部署的 shell 脚本。我们这里结合 github webhooks 来实现持续集成，自动化部署",
        "keywords": "node 自动化部署,node持续集成,node ci,node cd,node webhooks,github webhooks"
      }
    ],
    "JavaScript": [
      {
        "title": "富文本编辑器使用execCommand插入图片不生效的问题",
        "href": "2018/10/web_richtext.html",
        "time": "2018/10/02",
        "description": "execcommand插入图片光标消失，最近打算实现一个评论系统，评论如果只能回复文字就太low了，于是就打算自己做一个简单的富文本编辑器。一般回复内容，我第一个想到的是textarea，做完回复文字的功能后，想着如果插入图片貌似不可行。",
        "keywords": "execcommand插入图片光标消失,富文本编辑器使用execCommand插入图片不生效的问题,execCommand插入图片不生效"
      },
      {
        "title": "前端cookie的使用",
        "href": "2018/10/web_cookie.html",
        "time": "2018/10/26",
        "description": "http是基于请求和响应的无状态协议，无法保存状态，如果有数据需要在浏览器关闭后，下次进入还保存，就可以用cookie来解决这个问题。前端cookie可以用document.cookie来读取，格式为key=value;key=value键值对的形式",
        "keywords": "前端cookie的使用,cookie"
      },
      {
        "title": "js页面滚动相关操作",
        "href": "2019/10/web_js_scroll.html",
        "time": "2019/10/09",
        "description": "通过一个URL进入一个页面，需要滚动到对应的锚点位置，可以用什么方法呢，下面我们来总结下页面滚动相关的一些方法，例如：Element.scrollIntoView、window.scroll、window.scrollTo、window.scrollBy、Element.scrollTop等",
        "keywords": "js页面滚动,页面滚动,scroll,scrollTo,scrollBy,scrollTop,scrollLeft,scrollIntoView,使用hash滚动,vue中vue-router滚动"
      },
      {
        "title": "URLSearchParams URL查询字符串处理",
        "href": "2019/10/web_url_searchparams.html",
        "time": "2019/10/10",
        "description": "一般在通过url传参时会使用查询字符串，一般使用字符串相加的方法，当参数比较多时，就显得不够优雅了，这时就可以使用专门用于处理 URL 查询字符串API: URLSearchParams",
        "keywords": "URLSearchParams URL查询字符串处理,url查询字符串处理,URLSearchParams,处理查询字符串优雅的方法"
      },
      {
        "title": "原生JS实现美元图片四周散开的动画效果",
        "href": "2019/10/css_mask_animation.html",
        "time": "2019/10/26",
        "description": "之前一朋友在微信群里问，是否能做一个动画，在每次进入页面的时候，实现美元钞票向四周扩散的效果，也就是一个遮罩动画。当时刚看完js高程3不久，就用原生js写了个动画，如果页面需要这个动画，只需要引入一个js就可以。",
        "keywords": "原生JS实现遮罩动画,js实现美元图片四周散开动画效果,js实现美元各方向散开的动画效果"
      },
      {
        "title": "JS到底是解释型语言还是编译型语言",
        "href": "2019/10/js_language.html",
        "time": "2019/10/28",
        "description": "JS到底是解释型语言还是编译型语言呢？一般的书里都写的是js是一种解释型语言，但令人令人困惑的地方是：—般解释型语言是逐行解释执行的，为什么JS会有変曩提升(hoisting)的能力？执行JS时会用到JIT, JIT(just in time compilers 及时编译）会做代码优化(同时也会创建代码的编译版本),解释型语言无法做到这些变量提升问题",
        "keywords": "JS到底是解释型语言还是编译型语言"
      },
      {
        "title": "html2canvas将网页转换为图片",
        "href": "2019/11/html2vanvas.html",
        "time": "2019/11/05",
        "description": "在web开发中，我们需要生成图片时，可以使用html2canvas，他可以将html转为png，pc端还好，移动端css的坑比较多，这里只是简单的介绍下怎么使用。先引入 html2canvas.js，根据其api调用，来看看具体示例",
        "keywords": "html2canvas将网页转换为图片,html2canvas使用示例"
      },
      {
        "title": "非箭头函数作为参数时this问题",
        "href": "2019/11/js_this.html",
        "time": "2019/11/09",
        "description": "复习下JS高程3里面将的函数做参数时this的问题，如果是非箭头函数，参数函数中使用了this，那么this取决于执行函数的this指向，而非参数函数执行环境的this，怎么将this绑定呢？有三种方法，1.使用bind绑定一个作用域 2.使用闭包 3.使用箭头函数",
        "keywords": "非箭头函数作为参数时this问题"
      },
      {
        "title": "点击外部关闭div - js阻止事件冒泡实例",
        "href": "2019/11/click_external_close.html",
        "time": "2019/11/09",
        "description": "点击外部关闭div，一般在做弹窗div时，需要做点击div外部关闭div的功能，怎么做到的呢？一句话总结：用一个父元素(铺满屏幕，绝对布局)包裹该div(绝对布局，水平垂直居中，固定宽高)，**父元素监听点击事件后移除div，子元素div监听点击后阻止事件冒泡**。这样就实现了，点击外部关闭div，点击内部区域不关不div。",
        "keywords": "点击div外部关闭div,js点击外部关闭div,点击外部关闭div,js阻止事件冒泡实例"
      },
      {
        "title": "原生JS封装prompt组件",
        "href": "2019/11/custom_prompt.html",
        "time": "2019/11/09",
        "description": "自定义prompt组件，原生JS封装prompt，就项目中要用到prompt功能，但需要优化下UI，整体导入elementUI不合适，就自己用原生JS写了个。样式、div结构，直接从elementUI message-box审查元素里面抽离，相关点击事件，校验，自己封装。",
        "keywords": "自定义prompt,原生js自定义prompt组件"
      },
      {
        "title": "为什么说toFixed是不准确的",
        "href": "2019/11/toFixed.html",
        "time": "2019/11/12",
        "description": "Number.prototype.toFixed() 对number取整或保留指定小数位，但它是不准确的，就类似 0.1 + 0.2 ≠ 0.3 一样，下面来看看怎么处理",
        "keywords": "toFixed不精确的问题,toFixed保留小数点不准确的问题"
      },
      {
        "title": "toLocaleString将数字转为逗号分隔的字符串",
        "href": "2019/11/num_str.html",
        "time": "2019/11/14",
        "description": "Number.prototype.toLocaleString()可以将数字转换为千分位逗号分隔的字符串，而且该方法还内置了数字转人民币、美元等字符串的方法，这样我们在处理金钱相关的数据时就可以很方便使用了，来看一个列子",
        "keywords": "toLocaleString将数字转为逗号分隔的字符串,toLocaleString,Number.prototype.toLocaleString"
      },
      {
        "title": "sessionStorage和localstorage的区别",
        "href": "2019/12/web_storage.html",
        "time": "2019/12/04",
        "description": "sessionStorage和localstorage都属于Web Storage，在JS高程3中有讲，这里来回顾下，一般sessionStorage关闭浏览器后会消失，localstorage不会。",
        "keywords": "sessionStorage和localstorage的区别"
      },
      {
        "title": "使用URLSearchParams将对象转为url查询字符串",
        "href": "2019/12/url_query.html",
        "time": "2019/12/05",
        "description": "在做get请求时，我们需要传一些参数，单纯的字符串拼接的方法不够优雅，下面来看怎么用URLSearchParams将对象直接转为查询字符串，另外查看axios源码，看看axios内部是怎么将params对象拼接到url上的",
        "keywords": "对象转url查询字符串,axios是怎么将params对象转查询字符串的"
      },
      {
        "title": "ES2020 '?.' 与 '??' 操作符",
        "href": "2019/12/es2020_operator.html",
        "time": "2019/12/09",
        "description": "Optional chaining operator(?.) 与 Nullish coalescing Operator(??) 目前正式进入 stg4，确定会成为ES2020标准，阮一峰老师已经在他的es6入门教程里更新了，下面来看看具体怎么使用",
        "keywords": "??与?.,js ??是什么意思,js ?.是什么意思"
      },
      {
        "title": "安卓input键盘弹起导致底部按钮也被抬起的问题",
        "href": "2019/12/android_h5.html",
        "time": "2019/12/18",
        "description": "在写app内嵌H5页面时，之前遇到过这个问题，当输入时，键盘弹起导致底部按钮也被抬起了，这里用监听视窗高度变换的方法来fix这个问题,监听window.onresize，如果与之前的视窗高度不一致：变小了，就隐藏底部button，完成输入后，监听到视窗高度变大再次显示底部按钮",
        "keywords": "安卓input键盘弹起导致底部按钮也被抬起的问题,app内嵌H5安卓键盘抬起相关问题"
      },
      {
        "title": "怎么遍历localStorage",
        "href": "2019/12/localstorage_iterator.html",
        "time": "2019/12/19",
        "description": "localStorage本身没有提供对应的遍历方法，我们可以使用 localStorage.key(index) 结合for循环来遍历",
        "keywords": "怎么遍历localStorage,怎么遍历sessionStorage"
      },
      {
        "title": "iOS环境下点击输入框页面被顶起不能自动回弹底部的问题",
        "href": "2019/12/ios_kb_rebound.html",
        "time": "2019/12/19",
        "description": "在开发app内嵌H5时，iOS系统里，输入框输入时，页面会被抬起，但输入完成后，页面不会自动回弹，这里需要特殊处理下，解决方法：在对应的input元素加 @blur 事件，input失去焦点时，手动滚动页面 window.scroll(0,0)",
        "keywords": "iOS环境下点击输入框页面被顶起不能自动回弹底部的问题"
      },
      {
        "title": "ES2020 bigint数据类型，为什么要新增这个数据类型?",
        "href": "2019/12/bigint.html",
        "time": "2019/12/26",
        "description": "ES5之前，基本数据类型有五个 boolean, string, number, null, undefined, ES6(ES2015)新增了一个symbol，ES2019 新增了 bigint，它用于表示大于 2的53次方 - 1的数据，即 > 9007199254740991",
        "keywords": "a + 1 === a + 2为true的场景,es2019 bigint数据类型"
      },
      {
        "title": "Symbol、BigInt不能new，而String、Number可以new，为什么？",
        "href": "2019/12/new_check.html",
        "time": "2019/12/27",
        "description": "在基本数据类型中，我们发现像String, Number是可以通过 new 来创建的，而 Symbol，BigInt 却不能使用new创建，这是为什么呢？ BigInt内部是怎么检测用户使用了new来调用的？下面来看看",
        "keywords": "Symbol、BigInt不能new，而Stirng、Number可以new，为什么,BigInt内部是怎么检测用户使用了new来调用的"
      },
      {
        "title": "怎么清除app内嵌H5的localStorage",
        "href": "2019/12/clear_app_h5.html",
        "time": "2019/12/27",
        "description": "当你在app内容H5中使用了localStorage又担心可能会超出5M的限制时，就要注意localStorage的清除了。那怎么才能清除app内嵌H5的localStorage呢？我做了一些测试",
        "keywords": "怎么清除app内嵌H5的localStorage"
      },
      {
        "title": "怎么判断当前鼠标是否在某个div内部",
        "href": "2020/1/contains.html",
        "time": "2020/01/07",
        "description": "当监听到事件，事件的 eveent.target 怎么判断是否在某个div内部呢？可以使用DOM专有扩展的contains方法",
        "keywords": "怎么判断当前鼠标是否在某个div内部,怎么判断当前event.target在某个div内部"
      },
      {
        "title": "JS遍历数组方法总结，forEach的缺点以及与for..of和for...in的区别",
        "href": "2020/1/js_array.html",
        "time": "2020/01/09",
        "description": "在ES5中新增了很多方便操作数组的方法，包括新5种数组的迭代方法：forEach, map, filter, some, every；缩小方法：reduce()；检测数组方法Array.isArray()等，这些方法让操作数组更加优雅，趋近于函数式编程. 在ES6中又增加了for..of以及values,entres,keys等，下面来详细看看",
        "keywords": "js遍历数组方法总结,es5 es6遍历数组方法,forEach的缺点以及与for..of和for...in的区别"
      },
      {
        "title": "包含await操作的函数被二次封装成函数，await该函数时执行顺序的问题",
        "href": "2020/1/js_await_seq.html",
        "time": "2020/01/09",
        "description": "包含await操作的函数被二次封装成函数，await该函数时执行顺序需要注意，当一个包含await的函数A，被另一个函数B包裹，当await函数B执行时，如果包裹函数B里并没有return函数A或await函数A，await函数B执行时并不会等到函数A全部执行完毕才继续执行，来看个例子",
        "keywords": "async await执行顺序的额问题，如果await的非promise不会等待"
      },
      {
        "title": "JS sleep测试loading时写的等待函数最简代码",
        "href": "2020/1/js_sleep.html",
        "time": "2020/01/19",
        "description": "一般想模拟延时，测试loading效果时，会写一个等待函数，怎么最简单方便呢？下面来研究下",
        "keywords": "js sleep测试loading时写的等待函数最简代码"
      },
      {
        "title": "JS sort对数组进行默认排序时如果有数字为什么会不准确？",
        "href": "2020/1/js_sort_num.html",
        "time": "2020/01/21",
        "description": "正常情况使用 sort 是好用的，但如果有数字时，会有问题，因为如果sort不传参，默认情况下会将所有元素转换为字符串后，再根据unicode值来进行排序，下面我们来看看对应的实例",
        "keywords": "js sort数组不准确,js sort负数不准确, js sort对数组排序时的坑"
      },
      {
        "title": "JS 为什么使用set对数组或对象去重时会无效？",
        "href": "2020/1/js_set.html",
        "time": "2020/01/21",
        "description": "我们知道Set是JS的一个种新的数据结构，和数组类似，和数组不同的是它可以去重，比如存入两个1或两个'123'，只有1条数据会存入成功，但有个特殊情况，如果添加到set的值是引用类型，比如数组、对象，他将无法自动去重。因为值相同的两个引用类型地址是不一样的。下面来看一个例子：",
        "keywords": "js set去重对数组，对象无效,为什么使用set对数组或对象去重时会无效"
      },
      {
        "title": "Object.assgin时是否会忽略null,undefined,空字符串",
        "href": "2020/10/object_assgin.html",
        "time": "2020/10/01",
        "description": "一般我们在需要设置某个对象的多个值时Object.assgin是一种很好的方法，但又怕当某个属性的值为空字符串、null或undefined时，会自动跳过的情况。这里来做一个简单的测试",
        "keywords": "Object.assgin是否会跳过null,undefined,''"
      },
      {
        "title": "log对数在前端的应用场景：把文件大小或金额自动添加合适的单位",
        "href": "2020/10/log_web.html",
        "time": "2020/10/08",
        "description": "在写下载/导出文件接口时，由于接口文件数据是流的形式而非buffer，导致total为0，无法获取进度。只能通过loaded知道当前下载了多少字节。前端显示时，怎么给出合适的单位，是KB、MB，还是G？",
        "keywords": "文件大小转换合适单位,单位元数据加合适的单位"
      },
      {
        "title": "FileReader.readAsDataURL与URL.createObjectURL的区别",
        "href": "2020/10/file_preview_download.html",
        "time": "2020/10/25",
        "description": "在前端开发中，这两个函数都是可以用于处理文件二进制数据的，一般用于上传文件时预览图片，或者在下载、导出文件时使用。下面来以上传图片、前端预览图片的功能为例，比较两个函数的的区别。下面的代码中，我们使用一个 radio 来切换使用两种方法。当检测到上传文件的 input 内容 change 后，根据当前 radio 的值，调用不同的方法来预览图片。运行效果如上图",
        "keywords": "文件预览,文件下载函数,createObjectURL,readAsDataURL"
      },
      {
        "title": "涉及到状态code相关判断逻辑，建议使用常量",
        "href": "2020/11/code_logic.html",
        "time": "2020/11/08",
        "description": "对于一些状态较多的场景，当我们需要进行一些逻辑时，如果我们用状态的code来写判断逻辑。当后端提供的这个状态文案、code变更或调整，改动可能会很麻烦，特别是功能较多时。对于状态相关的判断逻辑，尽量把状态定义为容易识别的常量。这样状态名或状态code变更后，就不需要做大量修改了。",
        "keywords": "code消除魔术字符串,code判断逻辑使用常量"
      },
      {
        "title": "JS生成二维码怎么实现",
        "href": "2020/11/js_qrcode.html",
        "time": "2020/11/08",
        "description": "QRCode.js 是一个生成二维码的 js 库，使用 HTML5 Canvas 将二维码绘制到 dom 上，不依赖任何库。支持 svg 绘制方式。QRCode.js is javascript library for making QRCode. QRCode.js supports Cross-browser with HTML5 Canvas and table tag in DOM. QRCode.js has no dependencies. QRCode.js 使用很简单，下面来写一个自动生成二维码的工具",
        "keywords": "js生成二维码,前端生成二维码,js生成二维码链接"
      },
      {
        "title": "JS append 和 appendChild 的区别",
        "href": "2020/11/append_append.html",
        "time": "2020/11/16",
        "description": "在 JS 高程 3 中，并没有讲到 append()，基本都是用的 appendChild()，所以有知识盲点，这里对比下 append() 和 apendChiild() 的区别，如下表所示：append 用于在元素内容里追加一个 Node 节点，appendChiled() 用于在元素内容里追加一个或多个 Node 节点或 String，注意，如果 append 或 appendChild 的元素是已经存在的，会移动该元素，如果需要保持原来的不移动，需要先 cloneNode, 下面来看一个例子",
        "keywords": "append appendChild区别,append()和appendchild(),append和appendChild"
      },
      {
        "title": "图片占位、懒加载、预览",
        "href": "2020/11/img_placeholder_lazyload.html",
        "time": "2020/11/23",
        "description": "使用占位图片有什么好处? 1. 用户体验更好，标识此处有图片，但正在加载中的这一个状态，避免弱网或图片较大时，完全不显示的问题 2. 不阻塞其他资源加载，更快的整体文档加载速度，不阻塞其他请求。占位图片一般会和图片懒加载一起使用，当滚动到该区域时再加载图片，减少不必要的并发网络请求。3. 可以避免回流/重排，让图片加载完成后不改变页面的整体布局，避免回流(重新布局)，只需要重绘，注意: 需要占位图片与实际图片宽高不变",
        "keywords": "怎么实现图片懒加载,图片占位好处,图片预览,image lazyload,图片懒加载"
      },
      {
        "title": "Script error产生原因与解决方法、调试技巧",
        "href": "2020/11/script_error.html",
        "time": "2020/11/23",
        "description": "一般为了安全起见，如果当前页面引入了跨域的 js 文件，当这个 js 文件出现错误，监听错误会无法获取对应的行号、真实的错误message。这种情况错误信息就是 Script error。本地来做一个试验，重现该问题，用 koa 写两个服务，分别监听 5001/5002端口，同时开启服务",
        "keywords": "script error,script error是什么错误"
      },
      {
        "title": "DOMContentLoaded 与 Load 时间具体指的是什么时间？",
        "href": "2020/11/page_load_time.html",
        "time": "2020/11/30",
        "description": "在 Chrome DevTools 官网 Network Reference 里是这样介绍的：View load events：DevTools displays the timing of the DOMContentLoaded and load events in multiple places on the Network panel. The DOMContentLoaded event is colored blue, and the load event is red. 这两个时间是从页面开始到 DOMContentLoaded 与 load 事件触发的时间",
        "keywords": "DOMContentLoaded,load"
      },
      {
        "title": "console.log 打印带样式的文字、图片",
        "href": "2020/12/console_style_img.html",
        "time": "2020/12/07",
        "description": "console.log 的第一个参数中，如果有 '%c'，表示设置样式，会将第二个参数的 css 样式字符串应用到第一个参数的内容中 console.log('%c文字', 'css样式') 这样可以打印绿色的文字 console.log('%cSuccess!', 'color: green')，不仅可以设置文字颜色，还可以通过设置 background-color 在控制台显示图片",
        "keywords": "console.log打印样式文字,console.log打印图片"
      },
      {
        "title": "JS 判断两个日期是否是同一周，带单元测试",
        "href": "2020/12/js_same_week.html",
        "time": "2020/12/07",
        "description": "给定两个日期，怎么判断他们是同一周呢？核心是 **所有时间都是从 1970年1月1日(周4) 开始，计算出当前时间距离该日期的天数，再用 (天数 + 4)/7 就是周数，如果相同则是同一周**，这里会有一个特殊情况，就是周日的时候，需要特殊处理。判断时只需要日期，不要输入时间，默认都是以 '08:00:00' 为准。",
        "keywords": "判断两个时间是否是同一周,判断两个日期是否是同一周"
      },
      {
        "title": "JS 使用 localeCompare 函数对中文进行首字母排序",
        "href": "2020/12/js_chinese_sort.html",
        "time": "2020/12/07",
        "description": "String.prototype.localeCompare(compareString[, locales[, options]]) 该方法用于对字符串进行排序。第二个参数 locales 可以指定语言，中文排序传 'ch' 即可。它的返回值为 -1, 1, 0 ，与 sort 自定义排序的返回值基本一致。来看一个例子",
        "keywords": "js中文按首字母排序,前端中文按首字母排序,前端中文排序"
      },
      {
        "title": "JS 数据类型有多少种，有哪些细节需要注意的？",
        "href": "2020/12/js_data_type.html",
        "time": "2020/12/15",
        "description": "ES3 有 5 种基本数据类型：null、undefined、boolean、number、string；1 种复杂数据类型 object。ES6+ 后面新增了两种基本数据类型：Symbol, Bigint。如果把函数 function 也算作一种数据类型，就是 9 种。需要注意的是：- typeof 数组值为 `object`，typeof 函数值为 `function`, typeof null 值为 `object`，本质上其实有 9 种数据类型。- new String('12') 是字符串对象，不是 string，new Number(1) 是数字对象，不是 number，new Boolean(false) 是对象，不是 boolean",
        "keywords": "js数据类型有多少种,js数据类型,js data type"
      },
      {
        "title": "getElementsByTagName 结果为什么不可以 forEach ？和 querySelectorAll 有什么区别",
        "href": "2020/12/dom_arr_forEach.html",
        "time": "2020/12/15",
        "description": "在 JS DOM 编程艺术的例子中，看到 `document.getElementsByTagName` 后使用了 `Array.from(xx)` 将其结果转为标准数组后再使用 `forEach`。下面写个例子来验证为什么？从上面的例子中，我们可以看到 `getElementsByTagName` 函数返回的数据类型是 `HTMLCollection`，类数组对象，并没有实现 forEach 方法，但它内部实现了迭代 for...of（Symbol.iterator）方法，因此可以使用 for、for...of 来遍历",
        "keywords": "getElementsByTagName,querySelectorAll"
      },
      {
        "title": "Promise.all、race 实现，函数作为参数时的简写",
        "href": "2020/12/promise_all_abbr.html",
        "time": "2020/12/15",
        "description": "一般函数当参数时，有一种情况可以直接简写，例子如下 func(data => { console.log(data) })，可以简写为 func(console.log) 下面来看看在 Promise.all 和 Promise.race 实现中的应用",
        "keywords": "Promise.all实现,Promise.race实现,函数参数简写"
      },
      {
        "title": "JS 事件循环, Promise.then 与 setTimeout 执行顺序问题",
        "href": "2020/12/js_eventloop.html",
        "time": "2020/12/15",
        "description": "来看一个 demo 的执行顺序，执行顺序是：2 3 5 4 1，我们知道 setTimeout 与 Promise.then 的回调都是异步的。setTimeout 的执行函数是先 push 到任务队列的，而 Promise.then 的回调是后面 push 的。为什么 Promise.then 的回调先执行呢？这里涉及到 JS 事件循环中 **宏任务** 与 **微任务**。- 宏任务：同步任务、I/O(比如文件读写等)、setTimeout、setInterval、requestAnimationFrame 等 - 微任务：Promise.then/catch/finally、generator、async/await、MutationObserver 等。某个宏任务执行 ok 后，会先看微任务事件队列里是否有任务，有就执行，然后才是宏任务队列。",
        "keywords": "宏任务与微任务,JS 事件循环"
      },
      {
        "title": "DOMContentLoaded 与白屏, performance timing",
        "href": "2020/12/white-screen.html",
        "time": "2020/12/30",
        "description": "白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素，首屏时间 = 地址栏输入网址后回车 - 浏览器第一屏渲染完成。一般页面白屏结束的时间节点在 head 结束，body 开始执行时。可以通过 `window.performance.timing` 这个对象来看具体时间。",
        "keywords": "白屏时间计算,DOMContentLoaded与白屏"
      },
      {
        "title": "通过 performance.timing 简单理解浏览器输入 url 到页面显示全过程",
        "href": "2020/12/performance-timing.html",
        "time": "2020/12/30",
        "description": "performance.timing 记录了在浏览器中输入 url 到页面显示整个过程中各个关键节点的时间。包括：网页重定向的耗时、检查本地缓存的耗时、DNS查询的耗时、TCP连接的耗时、dom 加载完成的时间、页面 load 的总耗时等。performance.timing 是 PerformanceTiming 对象的实例。下面我们通过了解 performance.timing 各个字段的意思来实现下面图片的功能。",
        "keywords": "浏览器输入 url 到页面显示全过程,performance.timing各字段详解"
      },
      {
        "title": "字符串原始类型不是对象，为什么可以使用点语法运行方法",
        "href": "2020/12/string-base.html",
        "time": "2020/12/30",
        "description": "理论上，原始值本身不是对象，逻辑上是不能有属性、方法的。那为什么字符串可以使用点语法执行 substring 等方法呢？下面的例子中，第 2 行可以正常执行。主要是 JS 内部在后台进行了一些处理。在执行到第 2 行时 1. 临时创建一个 String 类型的实例 `let t = new String('some text')` 2. 调用实例上的特定方法 `s2 = t.substring(2)` 3. 销毁实例 `t = null`",
        "keywords": "基本包装类型,原始类型不是对象为什么可以执行方法"
      },
      {
        "title": "element.childNodes 和 element.children 有什么区别",
        "href": "2020/12/childNodes-children.html",
        "time": "2020/12/30",
        "description": "元素的 childNodes 和 children 属性都是用于获取元素子节点，他们返回值都是类数组对象，且都是活动对象（当节点变更后，值也会动态变更）。但有以下区别：1. childNodes 获取的子节点包含所有节点类型，比如注释节点、文本节点、换行空白符文本节点，而 children 仅包含元素类型的子节点。2. childNodes 类型是 NodeList，HTMLCollection 类型是 HTMLCollection",
        "keywords": "childNodes与children,childNodes children区别"
      },
      {
        "title": "HTMLCollection 和 NodeList 有什么区别",
        "href": "2020/12/HTMLCollection-NodeList.html",
        "time": "2020/12/30",
        "description": "在获取 dom 节点结集合时，有的 API 返回的是 HTMLCollection 类型，有的是 NodeList 类型。他们有什么区别呢？下来看看具体的 API。HTMLCollection 和 NodeList 的相同点：1. 它们都是表示节点集合的类数组对象，都可以是活动对象（实时监听 dom 变化并修改值） 2. 它们都有 length 属性，都可以通过 item() 和数组下标的方式访问内部元素。都实现了 Symbol.iterator 迭代器方法（可以被 for...of 遍历）",
        "keywords": "HTMLCollection,NodeList,HTMLCollection与NodeList区别"
      },
      {
        "title": "深入JS遍历对象，从4个维度比较遍历对象的8种方法",
        "href": "2020/2/js_obj_iterator.html",
        "time": "2020/02/02",
        "description": "一般遍历对象时，大部分人可能想到的方法是for..in或Object.keys.forEach()，但你知道吗？截止ES2020，在JS中总共有8种方法来遍历对象，而且不同的遍历方法在一些细节方面会有区别，下面我们将从以下几个方面来深入理解JS遍历对象 1. 看似可以遍历对象但又不能遍历对象的for与for...of 2. 可能会对遍历对象产生影响的4种因素：属性是否可枚举、Symbol、是否有继承属性、遍历次序 3. 从ES5到ES2020发展过程中所有的可以遍历对象的方法 4. 通过实例demo来从4个维度比较8种遍历对象的方法 5. 属性遍历次序总结",
        "keywords": "js遍历对象,js遍历对象方法总结,js遍历对象的8种方法"
      },
      {
        "title": "JS操作复制copy的内容，向复制内容中追加内容",
        "href": "2020/3/js_copy_opt.html",
        "time": "2020/03/02",
        "description": "在csdn等网站上，我们cttrl+c，ctrl+v时，会发现粘贴后的内容加了当前的作者信息、链接、版权问题等说明。那这个功能是怎么实现的呢？在JS高程中，有讲这一块的内容，下面来看看",
        "keywords": "js操作粘贴板内容,js向copy的内容中追加信息,js向复制信息里追加内容"
      },
      {
        "title": "JS怎么监听当前页面滚动比例，完整UI实现demo",
        "href": "2020/3/js_scorll_percent.html",
        "time": "2020/03/02",
        "description": "在阮一峰的es6入门教程里，顶部有一个计算页面百分比的UI，于是就想尝试实现这个功能，恰好在js高程3里有对应的描述，来看看",
        "keywords": "页面滚动比例监听"
      },
      {
        "title": "网页中怎么实时监听网络变动并给出提示",
        "href": "2020/3/1.html",
        "time": "2020/03/02",
        "description": "在js高程3中有讲过一个内容，叫做离线检测，就是监听页面的online和offline事件，这样在断网或再次连接到网络时，就会有对应的提示，下面是zuo11.com使用的网络检测功能，可以参考下",
        "keywords": "js离线检测,js断网检测,js怎么实时监听网络变动"
      },
      {
        "title": "JS怎么监听浏览器tab页切换？浏览器tab页切换时更改标题",
        "href": "2020/3/tab_change_title.html",
        "time": "2020/03/02",
        "description": "当用户点击了浏览器其他tab页离开页面，或者从其他tab页进入当前页，都会触发visibilitychange事件，根据docuemnt.hidden可以判断是否离开或回来，我们可以修改标题达到可视化的一个效果",
        "keywords": "浏览器tab切换事件监听,visibilitychange,js 页面可见性API"
      },
      {
        "title": "JSON数据转Blob后，怎么还原？怎么将Blob数据转JSON",
        "href": "2020/7/blob_json.html",
        "time": "2020/07/06",
        "description": "在axios请求下载文件接口时，一般设置responseType: 'blob'，文件返回正常就没问题，但后台如果处理文件或鉴权有问题，接口返回了包含错误信息的json格式数据，那样json数据也会被转为Blob对象，而前端有必要将错误信息展示，那怎么将Blob数据转JSON呢？下面来看看",
        "keywords": "blob转json,json转blob后怎么还原"
      },
      {
        "title": "canvas多次fill会覆盖前面的fill的问题",
        "href": "2020/7/canvas_file_more.html",
        "time": "2020/07/06",
        "description": "在使用canvas进行绘图时，封装了一个绘制函数，每次都会填充颜色 ctx.fill()，如果多次执行，只会在最后一次时，整体fill一次？刚开始以为是后面的fill覆盖了前面的fill，后来网上查了下，第一次fill后，再次fill需要再次调用ctx.beginPath()，不然只会在最后一次fill。",
        "keywords": "canvas多次fill会覆盖前面的fill的问题,ctx.fill覆盖了前一次的fill"
      },
      {
        "title": "canvas不支持文本换行怎么处理",
        "href": "2020/7/canvas_text_wrap.html",
        "time": "2020/07/06",
        "description": "今天在stackoveflow里面搜索ctx.fill的问题时，查到了很多关于canvas ctx.fillText()绘制文本时不支持换行的问题，找到了一个比较好的答案。I'm afraid it is a limitation of Canvas' fillText. There is no multi-line support. Whats worse, there's no built-in way to measure line height, only width, making doing it yourself even harder! 一般解决思路是，根据 ctx.measureText('Hello').width 来看需要显示的文字是否需要换行，写一个for循环来处理",
        "keywords": "canvas不支持文本换行怎么处理,canvas文本换行,canvas文本怎么换行"
      },
      {
        "title": "canvas绘制模糊的问题",
        "href": "2020/7/canvas_dim.html",
        "time": "2020/07/06",
        "description": "今天发现同样的代码在两台电脑上绘制的一个清晰，一个模糊，后来查资料发现确实有这个问题: 因为canvas不是矢量图，高dpi屏幕每平方英寸有更多的像素，也就是两倍屏，浏览器会以两个像素点的宽度来渲染一个像素，所以在Retina屏上会导致图片、文字都会模糊，怎么解决呢？",
        "keywords": "canvas绘制模糊的问题,retina屏canvas绘制模糊的问题"
      },
      {
        "title": "实战canvas绘制不规则形状填充渐变色",
        "href": "2020/7/cavas_unnormal_shape.html",
        "time": "2020/07/06",
        "description": "在JS高程3中，有一章专门将使用canvas绘图，今天终于用上了，效果还不错，来看效果，原生js，70行不到，用canvas画不规则形状，且添加渐变色",
        "keywords": "实战canvas绘制不规则形状填充渐变色,canvas画不规则形状,canvas渐变"
      },
      {
        "title": "canvas怎么绘制环形进度条",
        "href": "2020/7/canvas_progress.html",
        "time": "2020/07/12",
        "description": "使用canvas绘制渐变的环形进度条，主要是使用arc函数，下面来看看。4个重点：1. 怎么画圆弧, ctx.arc函数里开始角度、结束角度以PI为基准，取值范围时：0 ~ 2PI，PI就是π值约等于3.14，圆心正上方位置为1.5PI，圆心右侧为 0 或 2*PI，圆心正下方为0.5PI，选定义额开始位置和结束位置就可以绘制任意一个弧形",
        "keywords": "canvas绘制环形进度条,js画环形渐变进度条,canvas画进度条"
      },
      {
        "title": "Date.prototype.toLocaleString()在0点或12点时转换异常的问题",
        "href": "2020/7/toLocaleString_exception.html",
        "time": "2020/07/26",
        "description": "toLocaleString时间异常的情况，toLocaleString在0点或12点时时间转换问题，在使用toLocaleString把Date转为字符串时，需要额外注意时间为 '00:00:00' 和 '12:00:00' 的情况，它们分别会被转为 上午12:00:00，下午12点，下面来看看",
        "keywords": "toLocaleString时间异常的情况,toLocaleString在0点或12点时时间转换问题"
      },
      {
        "title": "怎么将Date数据转为TZ格式的字符串",
        "href": "2020/7/date_tojson.html",
        "time": "2020/07/26",
        "description": "TZ时间字符串，toJSON后时间转换为TZ格式，后台要求的数据格式 '2020-04-10T04:01:00.000Z' 为TZ格式的字符串。Date对象toString为 'Fri Apr 10 2020 12:00:00 GMT+0800 (中国标准时间)' 这种格式，那怎么转TZ字符串格式呢？用 Date.prototype.toJSON() 方法即可 ",
        "keywords": "TZ时间字符串,toJSON后时间转换为TZ格式,怎么将Date数据转为TZ格式的字符串"
      },
      {
        "title": "Array.prototype.fill()填充引用类型值的问题",
        "href": "2020/7/araay_fill.html",
        "time": "2020/07/26",
        "description": "js 数组fill填充的对象都指向同一个地址，array fill填充引用类型问题，在mock表格list数据时，我一般为了简洁会先创建一个对象info，然后new Array(10).fill(info) 来生成10条数据的数。但这次发现一个问题，由于表格有一个字段是状态值0 - 5，我想随机设置下值，发现修改后的值都一样，来看看例子",
        "keywords": "js 数组fill填充的对象都指向同一个地址,array fill填充引用类型问题"
      },
      {
        "title": "JSON.stringify的非常规用法以及内部执行顺序",
        "href": "2020/7/stringify_use.html",
        "time": "2020/07/26",
        "description": "JSON.stringify，JSON.stringify用法总结,JSON.stringify内部执行顺序,JSON.stringify非常规用法，我们一般用于将JSON对象转为字符串，但他不仅仅只有一个参数，而是三个，除最常用的用法外，还可以用来做三种实用功能: 1.利用第三参数在console里更好的展示对象; 2.有选择性的过滤字段; 3.详细处理没有字段序列化的值",
        "keywords": "JSON.stringify,JSON.stringify用法总结,JSON.stringify内部执行顺序,JSON.stringify非常规用法"
      },
      {
        "title": "关于商品价格有小数点时精度异常的问题",
        "href": "2020/8/goods_price_float.html",
        "time": "2020/08/02",
        "description": "在价格显示时，如果有小数位，由于js浮点数的缺陷，累加的价格可能会有经度差，我们直接 toFixed(2) 即可。一般不会超过3位小数点，且精度异常一般都是小数点很多位以后，注意js小数点运算时一定要注意这个问题，确定要保留几位小数点",
        "keywords": "商品价格有小数点时精度异常的问题"
      },
      {
        "title": "Object.observe()与Proxy",
        "href": "2020/8/observe_proxy.html",
        "time": "2020/08/02",
        "description": "Object.observe()是js实现观察者设计模式的一个API，现在已废弃，由Proxy取代，但Proxy不支持IE。它用于异步地监视一个对象的修改。当对象属性被修改时，方法的回调函数会提供一个有序的修改流。在vue2.0的双向绑定的实现里，会遍历data对象，通过建立对应的getter/setter访问器属性来追踪属性变化。Vue 3.0里已使用Proxy来追踪属性变化",
        "keywords": "observe与proxy"
      },
      {
        "title": "什么情况下 a == 1 && a == 2，什么情况 a + 1 === a + 2",
        "href": "2020/8/js_a1_a2.html",
        "time": "2020/08/22",
        "description": "a == 1 && a == 2,a == 1 && a == 2 && a == 3,a + 1 === a + 2,在js面试时，有时候会考察 ==（比较运算符）隐式转换的问题，问  a == 1 && a == 2 怎么使他成立，这个有好几种方法。还有一种情况下 a + 1 全等于 a + 2，这就涉及到最大安全整数的问题了，下面来具体看看",
        "keywords": "a == 1 && a == 2,a == 1 && a == 2 && a == 3,a + 1 === a + 2"
      },
      {
        "title": "H5原生拖放(Drag and Drop)demo以及浏览器兼容性处理",
        "href": "2020/8/js_drag_drop.html",
        "time": "2020/08/22",
        "description": "js拖拽,原生js拖放,js拖放,js拖放浏览器兼容性,HTML5 拖放,dragstart,drop,一般在网页中，如果需要实现拖放，首先要有两个元素：1. 可拖动的元素，元素draggable='true' 属性就是可拖放，如果设置为false就是不可拖放 2. 可以放置的区域，注意chrome如果不将放置区域的onenter和onover事件阻止默认行为，无法触发drop函数。拖放的过程中的钩子 1. 拖动元素时，会触发元素的 dragstart 钩子函数，在函数里可以设置数据、以及拖动到放置区域的鼠标样式 2. 当拖动元素进入放置区域时，放置区域元素会触发一次dragenter钩子(拖动进入)，触发多次dragover(拖动元素在放置区域移动中)，放下时再触发放置元素的drop钩子，这里可以用来接收拖拽元素dragstart设置的data，处理拖动的行为",
        "keywords": "js拖拽,原生js拖放,js拖放,js拖放浏览器兼容性,HTML5 拖放,dragstart,drop"
      },
      {
        "title": "怎么解决sessionStorage新打开一个tab页就失效的问题",
        "href": "2020/8/sessionStorage_loss.html",
        "time": "2020/08/22",
        "description": "sessionStorage新打开一个tab页就失效,sessionStorage打开新tab丢失,首页我们要知道3点：1. sessionStorage在浏览器的两个tab页之前是无法共享的，一个tab页中sessionStorage修改后，不能触发其他tab页的storage事件 2. 当前tab页的localStorage修改是无法触发当前页的storage事件的，他会触发其他tab页的storage事件 3. localStorage的共享，只发生在同源的地址里。非同源无法共享localStorage 怎么将就页面的sessionStorage传递到新开的tab页呢？",
        "keywords": "sessionStorage新打开一个tab页就失效,sessionStorage打开新tab丢失"
      },
      {
        "title": "怎么用js手动触发window resize事件",
        "href": "2020/8/manual_dispatch_resize.html",
        "time": "2020/08/30",
        "description": "js手动触发resize事件,手动触发resize事件,自定义resize事件,这里手动触发window.resize事件的目的，主要用于fix改变窗口大小后其他tab页echarts图表显示异常的问题，在echarts图表组件里，有时候需要图表大小自适应浏览器窗口大小。这种情况echart宽高都会设定为100%，依赖父元素的宽高。然后再监听window的resize事件，当窗口大小改变后，重绘图表。那么问题来了",
        "keywords": "js手动触发resize事件,手动触发resize事件,自定义resize事件,改变窗口大小后其他tab页echarts图表显示异常的问题"
      },
      {
        "title": "Symbol和Array.prototype.includes不兼容IE，有babel就可以，他的原理是什么",
        "href": "2020/8/includes_babel.html",
        "time": "2020/08/30",
        "description": "vue项目里使用includes，IE11支持吗？在mdn上可以查相关API的兼容性,可以看到Symbol和Array.prototype.includes是不支持IE的，但我们在vue-cli的项目中，发现使用了这些api，在IE下也可以运行，这是为什么呢？主要是安装了babel，babel有进行转换，当IE不支持某个方法时，会使用替代的pollyfill，那它是怎么打包进项目的？",
        "keywords": "vue项目里使用includes，IE11支持吗？"
      },
      {
        "title": "判断一个字符串出现次数最多的字符，并输出其次数",
        "href": "2020/8/char_most_count.html",
        "time": "2020/08/30",
        "description": "reduce使用场景,js 判断一个字符串出现次数最多的字符,在js处理数组时，有一个reduce方法是比较实用的，特别是计算字符串出现次数的时候。下面来逐步介绍，怎么用js写一个函数，显示判断一个字符串出现次数最多的字符，并输出其次数",
        "keywords": "reduce使用场景,js 判断一个字符串出现次数最多的字符"
      },
      {
        "title": "引用数据类型数组去重，去掉id重复的元素",
        "href": "2020/9/array_del_repeat.html",
        "time": "2020/09/12",
        "description": "数组去重优雅写法,引用类型数组去重,有一个需求，客户信息列表，需要去除重复的客户。于是想着怎么优雅的写去重的逻辑，下面是最后使用的方法，使用 filter 遍历数组，将遍历的id存入 Set 数组，判断该数组里是否存在该id，如果已经存在就过滤，这样返回的就是去重后的数组了，具体实现如下",
        "keywords": "数组去重优雅写法,引用类型数组去重"
      },
      {
        "title": "输入法组合文字事件compositionstart等不能用on监听",
        "href": "2020/9/oncompositionstart_issue.html",
        "time": "2020/09/12",
        "description": "今天用原生的js来写demo时发现使用oncompositoinstart无法监听到输入法组合文件的过程，后面替换为addEventListener就可以了。因此对于输入法组合文字过程事件必须要使用DOM2级事件监听",
        "keywords": "compositionstart等输入法组合文字过程的事件不能使用on监听"
      },
      {
        "title": "客户端修改host后js获取location.href不真实的问题",
        "href": "2020/9/host_href_issue.html",
        "time": "2020/09/24",
        "description": "macOS 修改host文件 /etc/hosts 后，本地访问某个域名会按照host指定的ip去解析，就会造成前端location.href不准确的问题，下面来看看",
        "keywords": "location.href不准确的问题,修改host后location.href也会变"
      },
      {
        "title": "设置允许跨域的响应头后，为什么还是不能跨域",
        "href": "2021/1/cors-allow.html",
        "time": "2021/01/12",
        "description": "在 post 请求中，设置了允许跨域的响应头，且考虑了 preflight 预检请求，但为什么还是报不能跨域的错误呢？下面来看看下面的例子，POST 请求中设置了允许跨域、允许预检的响应头。我们需要深入了解预检请求的过程，预检请求会先发送一个 OPTIONS 的请求去测试服务端是否允许跨域。这个时候我们需要注意，我们也需要处理对应接口的 OPTIONS 请求，上面只处理了接口 URL 的 POST 请求，并没有处理 OPTIONS 请求，可以使用 router.use(url, func) 或者加一个 router.options 请求处理",
        "keywords": "跨域,cors,请求预检"
      },
      {
        "title": "socket 'Bad handshake method' 400",
        "href": "2021/1/socket-400.html",
        "time": "2021/01/12",
        "description": "在使用 socket.io 测试 scoket 功能时，发现之前都运行正常的 demo 突然就无法正常运行了。接口返回 400 Bad Request，响应信息为 { code: 2, message: 'Bad handshake method' } 后来发现是版本的问题，前端页面引入的 socket.io 版本是 `2.3.0`，通过 npm install 默认安装的 socket.io 版本是 `3.0.4`，将 koa 里面的 npm 包降到  2.3.0 就正常了",
        "keywords": "socket.io 400,Bad handshake method"
      },
      {
        "title": "Error: Timeout of 2000ms exceeded. Mocha 超时解决方法",
        "href": "2021/1/mocha-timeout.html",
        "time": "2021/01/12",
        "description": "在 mocha 中，默认每个测试时间限制为 2s，如果超过两秒就会抛出异常。对于大于 2s 的异步任务可以使用 mocha 上下文的 timeout() 方法手动指定超时时间。注意不要使用箭头函数，否则无法调用 this.timeout() 方法。 - `this.timeout(5000)` 将超时时间设置为 5s，这样就不会有 2s 的限制了 - `this.timeout(1000)` 对于性能要求较高的场景，可以限制超时时间为 1s",
        "keywords": "mocha tiemout,mocha 超时"
      },
      {
        "title": "使用 Service Worker 接收服务器推送消息并显示通知",
        "href": "2021/1/sw-notification.html",
        "time": "2021/01/12",
        "description": "推送通知一般需要支持服务器推送，在常规网页中是不可能的。service worker 可以实现该行为 - service worker 可以显示通知 - service worker 可以处理这些通知的交互 - service worker 能够订阅服务器发送的推送通知 - service worker 能够处理推送消息，即使应用没有在前台运行或者根本没打开",
        "keywords": "service worker接收服务器推送消息"
      },
      {
        "title": "import { } 解构与 export 和 export default",
        "href": "2021/4/import_export.html",
        "time": "2021/04/03",
        "description": "在封装功能函数时，我们经常需要在 import 时使用解构 {} 来仅导出部分模块功能。在有些情况会发现是无法解构的，下面来看看 - 一般 export default 的内容，需要使用 `import xxx from 'xx'` 直接接收，不能在 import 时解构 - 通过 export xx 的内容，需要使用 `import { xx, xx } from 'xx'` 或 `import * as xx from 'xx'` 接收",
        "keywords": "import {} 与 export default,import {}"
      },
      {
        "title": "用游戏中的场景理解节流与防抖，最简单的 js 实现",
        "href": "2021/4/easy_throttle_debounce.html",
        "time": "2021/04/11",
        "description": "节流和防抖，手写节流和防抖，节流(throttle) 对应技能冷却时间，如果冷却(cooldown/cd)是 5 秒，使用技能后，5秒内，无法再次执行。用于控制事件执行一次后，多长时间内不允许再次执行。一般用于防止按钮多次点击，重复触发事件。防抖(去抖动 debounce、de + bounce) 对应 **回城**，在推塔游戏中，回城等待时间是 8 秒。可以理解为回城时，会开启一个定时任务，8 秒后执行完成回城的函数。防抖/去抖动，就是在定时任务等待执行的时间内，如果再次触发发了函数，会取消上一次的定时任务，重新开始一个定时任务。这样可以**将一段时间内连续的多次触发转化为一次触发，单位时间内仅执行最后一次**。一般用于 window 的 scroll、resize 事件、搜索框输入搜索内容后实时查询接口等。",
        "keywords": "节流和防抖,手写节流和防抖,节流和防抖,throttle debounce"
      },
      {
        "title": "正则表达式使用 () 和 match 或 replace 提取 url 路径参数",
        "href": "2021/5/regExp_url.html",
        "time": "2021/05/04",
        "description": "正则提取 url 参数，来看一个问题，使用正则表达式从 url 中提取区域、城市id、模块、页数id。url 示例如下 1. `http://www.xx.com/region/gd/module` 2. `http://www.xx.com/region/gd-c222/module` 3. `http://www.xx.com/region/gd-c222/module/p2` 下面来看看怎么实现。首先，回顾下正则表达式（Regular Expression）基础。正则表表达式以 `/pattern/flags` 表示，是 RegExp 对象的实例",
        "keywords": "正则提取 url 参数"
      },
      {
        "title": "String.prototype.replace 多个匹配替换时注意要使用正则",
        "href": "2021/5/replace_regExp.html",
        "time": "2021/05/04",
        "description": "在做字符串替换时可以使用 repalce，但这里要注意，当需要替换多个时，第一个参数不能是字符串，要使用正则表达式。来看一个例子，将字符串 '1,000,000' 中的 ',' 替换为空字符串 ''。注意：上面的例子中，如果单纯的字符串替换，只会替换第一个，全局匹配时，第一个参数就要用正则了",
        "keywords": "replace多个匹配时需要使用正则"
      },
      {
        "title": "js 怎么减少 if else 嵌套, 使用函数封装、三元运算符等",
        "href": "2021/9/reduce_if_else.html",
        "time": "2021/09/09",
        "description": "在 if else 或函数嵌套层级较多，代码会逐渐变的难看，不好理解及维护。一般可以通过改变代码组织方式，来减少代码嵌套层级，这里主要介绍下面 5 种方法：1.将代码块按功能块封装成函数，减少函数内代码的嵌套层级 2. if 优化，逻辑假时 true，减少 if 中包含大量代码的情况 3...",
        "keywords": "js 怎么减少 if else 嵌套,js 怎么减少 if 嵌套,js 怎么减少函数嵌套,js 中 if else 替代写法"
      },
      {
        "title": "js 点击按钮复制内容的实现, 使用 ele.select 加 document.execCommand('copy')",
        "href": "2021/9/js_copy.html",
        "time": "2021/09/09",
        "description": "点击按钮复制链接、复制代码在前端是比较常见的需求，这里介绍一种比较简单的实现：1.先借用 input 等可以选中文本的元素，调用 element.select() 选中文本内容 2.再执行 document.execCommand('copy') 对选中内容进行复制 我们可以通过下面的例子来了解这个过程，点击按钮复制内容 - 在线演示",
        "keywords": "js 点击按钮复制内容实现,js 向粘贴板写入内容,js copy text"
      },
      {
        "title": "js if(true) 代码块中函数和变量同名时作用域提升问题，Chrome Devtools Snippets 断点调试",
        "href": "2021/9/js_hoisting.html",
        "time": "2021/09/09",
        "description": "在 JS 代码块中变量和函数同名，作用域怎么提升的问题是比较难以理解的，对于不同的浏览器还有不同的结果，下面来看几个例子，我们可以通过 Chrome 浏览器中的 DevTools - Sources - Snippets 中利用断点调试的功能来看浏览器是如何一步步执行的。",
        "keywords": "js hoisting,js 函数提升,js 变量提升,Chrome Devtools Snippets 断点调试"
      }
    ],
    "CSS": [
      {
        "title": "单行文本截断与多行文本截断",
        "href": "2019/10/css_text_overflow.html",
        "time": "2019/10/08",
        "description": "单行文本截断与多行文本截断，文本溢出处理，在HTML5权威指南这本书里是没有讲到这个知识点。一般使用 text-overflow: ellipsis，对于单行文本，一般使用text-overflow: ellipsis即可。注意：使用这个样式的前提是需要先给定容器宽度、overflow:hidden等属性，来看一个实例",
        "keywords": "单行文本截断,文本溢出处理,多行文本截断,text-overflow: ellipsis,line-clamp"
      },
      {
        "title": "全局修改element组件样式而不影响其他页面",
        "href": "2019/10/css_global.html",
        "time": "2019/10/12",
        "description": "改element样式不影响其他，element全局样式，修改element样式如何不影响同类其他组件？vue项目中，虽然UI基于element设计，但有些情况还是需要修改element组件的默认样式，怎么修改element的默认样式呢",
        "keywords": "element全局样式,全局修改element组件样式而不影响其他页面,修改element默认样式"
      },
      {
        "title": "#ffffff与#fff的区别",
        "href": "2019/10/css_hex_color.html",
        "time": "2019/10/12",
        "description": "css的颜色可以使用rgb和十六进制表示法。有时十六进制色彩是6位，而有时是3位，比如白色可以是#ffffff，也可以写成#fff。有什么区别呢？",
        "keywords": "#ffffff与#fff的区别,css颜色简写,十六进制颜色简写"
      },
      {
        "title": "滚动条滚到底部消失的问题",
        "href": "2019/10/css_scroll_disappear.html",
        "time": "2019/10/15",
        "description": "在写一个功能时，测试反馈一个关于滚动条的bug，当菜单子项非常多时，滚动条滚到底部时滚动条居然消失了。",
        "keywords": "滚动条滚到底部消失的问题"
      },
      {
        "title": "骨架屏研究",
        "href": "2019/10/css_skeleton.html",
        "time": "2019/10/18",
        "description": "目前骨架屏在app端用的比较多，主要是从国外转过来的。国内大厂JD、知乎、淘宝等都有用，相比原来用loading 菊花图来表示加载中，骨架屏用户体验更好一点，这里我们来自己实现一个简单的骨架屏样式效果",
        "keywords": "骨架屏"
      },
      {
        "title": "custom validator check failed for prop 'percentage'",
        "href": "2019/10/css_element_progress.html",
        "time": "2019/10/24",
        "description": "在使用element的 el-progress 组件时，出现 custom validator check failed for prop 'percentage' 的错误，后来发现是 percentage 属性设置的值超过了100，我们可以在js逻辑理加一个判断，set percentage 的值时，不能超过100，如果大于100，就直接设置为100",
        "keywords": "custom validator check failed for prop 'percentage'"
      },
      {
        "title": "position:absolute元素高度自适应，换成relative设置top试试",
        "href": "2019/11/absolute_auto_height.html",
        "time": "2019/11/08",
        "description": "一般元素设置position:absolute后，就已经脱离了文档流，用css是无法计算其高度的，只能用js获取dom来计算。另外不要把自己限制死了，对于自适应高度的，为什么一定要使用position:absolute呢？**换position:relative也可以设置top、left等css属性**，如果自己真的想不到好的方法，问问其他同事或社群里的人试试？下面来看看我之前由于知识盲点踩的一个坑",
        "keywords": "position:absolute元素高度自适应,怎么用js计算元素高度"
      },
      {
        "title": "background-repeat与background-position冲突",
        "href": "2019/11/repeat_position.html",
        "time": "2019/11/08",
        "description": "background-repeat和background-position最好不要一起使用，background-repeat可能会导致background-position设置失效，当设置是background-repeat在y轴重复背景时，background-position设置的顶部开始具体位置会无效",
        "keywords": "background-repeat与background-position冲突,background-repeat导致background-position失效"
      },
      {
        "title": "css样式优先级，防止外部样式污染组件",
        "href": "2019/11/css_style_priority.html",
        "time": "2019/11/09",
        "description": "一般在写全局的样式时，总担心污染其他位置的样式，但我们怎么防止别人的样式来污染我们的样式了。一句话总结：对于很重要，不要被污染的用!import，如果不想用!important，那最前面加id，或者多加一个或多个优先级高的选择器，来提高整体优先级",
        "keywords": "css样式优先级,css样式优先级计算,css选择器样式优先级,css防止外部样式污染组件"
      },
      {
        "title": "移动端屏幕尺寸大小",
        "href": "2019/11/screen_size.html",
        "time": "2019/11/11",
        "description": "在开发中，我们一般需要知道常用手机型号的屏幕尺寸，这样才能更好的适配移动端，下面来看看小程序开发工具中提供的各个手机型号尺寸，对于全面屏来讲，宽度和 ihpone 7/8 一致，但页面长度却长很多，一般 高度 / 宽度 >=2 的就是全面屏，页面布局需要特殊处理下",
        "keywords": "移动端屏幕尺寸大小,常用手机屏幕大小,怎么判断是全面屏"
      },
      {
        "title": "space-between与space-around的区别",
        "href": "2019/11/flex_justify.html",
        "time": "2019/11/15",
        "description": "flex布局justify-content属性值区别，space-between 最左、最右item贴合左侧或右侧边框，item与item之间间距相等。space-around 每个item 左右方向的margin相等。两个item中间的间距会比较大",
        "keywords": "space-between 间距,space-around怎么使用,space-between与space-around的区别,space-around什么意思,space-around,space-around 三个 不居中,space-around调距离,"
      },
      {
        "title": "flex布局align-self使用场景",
        "href": "2019/11/align_self.html",
        "time": "2019/11/21",
        "description": "一般flex布局，使用algin-items: center垂直居中后，item子项某一个高度比较高，其他子项的高度也会是高度最高的子项高度。设置border时会特别明显。如果需要让item高度适应内容，就可以使用 align-self: flex-start。",
        "keywords": "align-self,flex align-self使用场景"
      },
      {
        "title": "部分安卓机型scale后border显示不全的问题",
        "href": "2019/11/scale_line.html",
        "time": "2019/11/21",
        "description": "由于border需要画比1px还细的线，也就是0.5px，在移动端你设置px是没用的，一般会使用scale(0.5)缩放来实现,但在某些安卓机型上，发现这样实现的border边框会有显示不全的情况，重点来了，解决方法是将对应scale等样式用style写在内联样式里，刚开始不相信写成内联样式就可以解决这个问题，但实践后发现确实可以解决这个问题。",
        "keywords": "scale border消失,部分安卓机型scale后border显示不全的问题,border在手机上显示不全的问题s"
      },
      {
        "title": "画比1px还细的线或border",
        "href": "2019/11/border_thin.html",
        "time": "2019/11/21",
        "description": "画比1px还细的线或border",
        "keywords": "一般使用transform缩小0.5倍来实现，如果是border先将元素放大2倍，再缩小0.5倍，放大缩小后还是以放大的空间来占位，使用positon:absolute脱离标准文档流，就不会有两倍的占位了。"
      },
      {
        "title": "使用iconfont时icon是如何加载成功的，字体图片？",
        "href": "2019/12/iconfont.html",
        "time": "2019/12/06",
        "description": "iconfont icon是如何加载成功的 字体图片？在前端开发中，经常会使用图标，而iconfont是很好的一种管理图标的方式。这里总结下iconfont的几种使用方式，以及iconfont通过设置class来显示图标内部做了哪些操作",
        "keywords": "iconfont使用,iconfont为什么可以加载图标,iconfont详细介绍"
      },
      {
        "title": ":not和:nth混用的问题",
        "href": "2019/12/not_nth.html",
        "time": "2019/12/09",
        "description": ":not() 不支持在其参数中使用其他伪类。例如，h1:not(p:first-of-type) 不能匹配任何元素，所以不能混用，额外加个class吧",
        "keywords": ":not和:nth混用的问题"
      },
      {
        "title": "长英文单词不换行的问题",
        "href": "2019/12/css_wrap.html",
        "time": "2019/12/20",
        "description": "关于换行问题，属于文本类的css样式，在css中有三个和换行有关的属性他们分别是：white-space、word-break、word-wrap，由于他们有点类似且特性比较怪，不容易理解，这里来总结下",
        "keywords": "长英文单词不换行的问题,css换行,white-space、word-break、word-wrap,word-break和word-wrap的区别"
      },
      {
        "title": "postcss-pxtorem px自动转rem怎么保持使用px",
        "href": "2019/12/pxtorem_px.html",
        "time": "2019/12/23",
        "description": "如果vue-cli3中配置了postcass-pxtorem，css中写的px单位都会自动转为rem，如果需要固定px，而不是转为rem，有两种方法",
        "keywords": "postcss-pxtorem px自动转rem怎么保持使用px"
      },
      {
        "title": "html2canvas在移动端使用时的问题",
        "href": "2019/12/html2canvas_notice.html",
        "time": "2019/12/23",
        "description": "html2canvas 生成图片时，background-image模糊的问题,html2canvas 移动端生成图片文字重叠的问题，在需要生成海报、图片的需求里，一般 html2canvas 是一种比较好的解决方案，pc端的问题还是比较少的，移动端兼容性问题就比较坑了，要特别注意多测试一些机型，下面总结下我之前遇到的两个移动端的问题",
        "keywords": "html2canvas在移动端使用时的问题,html2canvas 生成图片时，background-image模糊的问题,html2canvas 移动端生成图片文字重叠的问题"
      },
      {
        "title": "transform 两个动作怎么写？scale缩小后，依旧占用空间的问题",
        "href": "2019/12/transform.html",
        "time": "2019/12/25",
        "description": "transform对某个元素使用两个及以上变换时，用空格分隔，scale缩小0.5倍后，dom占用依旧，可以用translate移动下，矫正位置。",
        "keywords": "transform 两个动作怎么写？scale缩小后，依旧占用空间的问题"
      },
      {
        "title": "-- css变量的使用，var() 与变量 --",
        "href": "2020/1/css_var.html",
        "time": "2020/01/10",
        "description": "在less或sass中，有直接的变量定义方法，而css原生其实也是可以定义变量的，使用--和var即可",
        "keywords": "css变量,-- css变量的使用，var() 与变量 --"
      },
      {
        "title": "normalize.css浏览器样式差异抹平",
        "href": "2020/10/normalize.html",
        "time": "2020/10/31",
        "description": "normalize.css, A modern alternative to CSS resets 一个用于CSS重置的现代替代方法。主要用于解决不同浏览器默认样式之间的差异。What does it do? - Preserves useful defaults, unlike many CSS resets. 保留有用的默认样式，重置许多不一样的CSS - Normalizes styles for a wide range of elements. 为许多各种各样的元素标准化样式",
        "keywords": "浏览器样式差异抹平,normalize.css"
      },
      {
        "title": "什么是回流(Reflow)和重绘(Repaint)？怎么避免？",
        "href": "2020/11/css_reflow_repaint.html",
        "time": "2020/11/23",
        "description": "什么是回流和重绘？ 浏览器使用流式布局模型 (Flow Based Layout)，浏览器把 HTML 解析成 DOM，把 CSS 解析为 CSDOM，DOM 和 CSDOM 合并就产生了 Render Tree(渲染树)，根据Render Tree，计算各个元素在页面中的大小和位置，绘制到页面上。",
        "keywords": "回流和重绘,reflow,repaint,css回流,css重绘"
      },
      {
        "title": "使用 hash 滚动页面时，被顶部 fixed 区域遮挡怎么解决",
        "href": "2020/12/hash_scroll_fixed.html",
        "time": "2020/12/30",
        "description": "一般页面 URL 的 hash 值变化后，如果当前页面中存在 id 为该 hash 值的元素，页面会滚动到该区域。下面的例子中，点击跳转到h1，页面会滚动到 h1 元素，元素对齐到顶部。**这里有一个问题，如果顶部导航栏是 fixed 固定的，那使用这种方法滚动时，h1 标题会被导航栏遮挡。**后来使用 VuePress 时，发现跳转的时候没有遮挡，于是审查元素，看了下样式。发现使用一个 css 就可以解决这个问题。 **给需要定位到该 id 的元素加一个超过导航栏高度的 padding-top，再加一个保持元素位置的 margin-top，这样使用 hash 滚动到该 id 元素时，就不会有遮挡，会与顶部保持 padding 的距离**",
        "keywords": "hash滚动被fixed区域遮挡,fixed遮挡a标签滚动怎么解决"
      },
      {
        "title": "怎么给三角形加border，添加到我的小程序UI实现以及需要注意的问题",
        "href": "2020/2/border_border.html",
        "time": "2020/02/29",
        "description": "在给小程序添加 '添加到我的小程序' 引导时，里面有个带边框的三角形，一般用css画三角形使用的是border，但三角形边的边框怎么画呢？一般用两个三角形叠加来实现",
        "keywords": "css 三角形加border,css 用border画的三角形怎么加border,小程序添加到我的小程序引导UI实现"
      },
      {
        "title": "网页深色模式样式适配(web dark mode support)",
        "href": "2020/3/drak_mode.html",
        "time": "2020/03/28",
        "description": "web dark mode，网页js怎么监听深色模式改变事件，window.matchMedia, (prefers-color-scheme: dark)，目前iOS，macos都有了深色模式，而最近微信最新版也做了深色模式(dark mode)适配，我试了下，手机切换时页面效果样式是实时刷新的。于是就想着web怎么能够监听深色模式，并设置样式。查了资料后，在Stack Overflow上找到了答案，下面来看看",
        "keywords": "window.matchMedia, web drak mode event,web dark mode,web深色模式,网页深色模式,网页怎么监听深色模式,(prefers-color-scheme: dark)"
      },
      {
        "title": "css hover后改变其他元素样式",
        "href": "2020/6/css_hover.html",
        "time": "2020/06/29",
        "description": "css中某个元素hover后，可以对其他元素设置样式，但注意：只限定于改变他的子元素, 以及其后面的元素，下面我们写demo来看看",
        "keywords": "css hover后改变其他元素样式,css 元素hover后设置其他元素样式"
      },
      {
        "title": "如果需要兼容IE还是用flex比较好，慎用grid",
        "href": "2020/7/ie_grid.html",
        "time": "2020/07/12",
        "description": "grid适用于网格化布局，对于各个模块按百分比来的情况比较好，如果多个模块有的固定宽高有的非固定宽高就不怎么好分了, IE下支持需要加前缀，详情参见之前的笔记: grid网格布局。于是我在某个页面中使用了grid，但发现IE不兼容，grid的某些属性不兼容IE，加了-ms-都没用，最后为了不必要的麻烦和风险，还是换成flex布局了，改成flex后的代码居然比grid还简单...",
        "keywords": "grid的兼容性,grid使用场景,grid,ie grid不兼容"
      },
      {
        "title": "mac pro retina屏两倍图，建议使用iconfont",
        "href": "2020/7/retina_iconfont.html",
        "time": "2020/07/12",
        "description": "之前在处理canvas绘制模糊的问题时了解到，retina是两倍像素屏，50 x 50像素的图会绘制在 100 x 100 像素区域，会导致绘制模糊。同理，如果需要在retina屏上显示50 x 50的图，需要提供两倍图 100 * 100，然后设置样式宽高为50，这样才会清晰。最好的方式还是使用iconfont、svg矢量图等可以任意设置宽高(size)而不会失真的图或字体。这样就不会模糊。",
        "keywords": "retina屏两倍图,建议使用iconfont"
      },
      {
        "title": "全国哀悼日，怎么用一行css代码将整个站点变灰",
        "href": "2020/7/css_filter_gray.html",
        "time": "2020/07/12",
        "description": "前天4月4号全国哀悼日，各大网公司网站的风格都变灰了，是怎么实现的呢？其实很简单，一行代码就搞定。filter: grayscale(100%); css filter是什么属性？用css filter mdn关键字查了下，这里filter翻译为 滤镜，他可以将模糊或色相等图形效果应用于元素，来看一些例子",
        "keywords": "css滤镜,css filter,怎么用一行css代码将整个站点变灰,怎么将站点置灰"
      },
      {
        "title": "web前端BFC，什么是BFC",
        "href": "2020/7/web_bfc.html",
        "time": "2020/07/12",
        "description": "虽然做前端好几年了，但只是听说个这个名词，一直不清楚具体是什么意思，今天来研究下。BFC是 Block Formatting Context 的缩写，字面意思是 块格式化上下文。 字面意思很难理解，我们先来看几个例子",
        "keywords": "web BFC,前端BFC,css BFC,什么是BFC"
      },
      {
        "title": "iconfont通过设置class来显示图标内部做了那些操作",
        "href": "2020/7/iconfont_class.html",
        "time": "2020/07/26",
        "description": "iconfont是怎么通过class来加载图标的，内部做了哪些操作，注意我们在用class使用iconfont图标时，为什么可以使用，主要是iconfont.css里面做了三步操作: 1. 定义iconfont的 font-familay 2. 为.iconfont设置默认样式，指定为font-family字体 3. 为每个图标的class设置before的content",
        "keywords": "iconfont是怎么通过class来加载图标的,内部做了哪些操作,iconfont class字体图标"
      },
      {
        "title": "css利用perspective画梯形",
        "href": "2020/7/css_perspective.html",
        "time": "2020/07/26",
        "description": "今天看小伙伴的代码，发现有一个梯形的实现居然是css写的，我以为需要UI提供icon。这里用到了 perspective 远景这个参数",
        "keywords": "css画梯形,css perspective"
      },
      {
        "title": "text-align: justify两端对齐不生效的问题",
        "href": "2020/7/text-align.html",
        "time": "2020/07/26",
        "description": "一般直接设置text-align: justify是不会生效的。但你改为text又会立即居中对齐。我们需要注意的是我们需要将子元素设置一个after的属性或者后面放置一个空的占位标签，设置 display: inline-block; width: 100%，当出现高度占位间隙时，设置占位元素的height没用，需要设置元素的height。css 确实有点毫无逻辑的感觉....",
        "keywords": "text-align:justify,text-align:justify不生效的问题"
      },
      {
        "title": "UI设计视觉差问题，总感觉没有居中对齐时怎么办",
        "href": "2020/8/ui_vision_difference.html",
        "time": "2020/08/02",
        "description": "当实现设计稿后，总感觉上下没对齐，怎么办呢？建议放大n倍，截图画框，看是否在一条水平线上。这里涉及到视觉差的问题，下面来看看相关知识，测量面积和视觉面积 - 视觉体量是人眼如何察觉物体的大小和感觉，不需要等同于物体的实际像素值 - 圆、菱形、三角形和其他非方形形状为了与方形形状保持一样的视觉大小，应适当放大",
        "keywords": "视觉差,视觉差怎么解决,UI视觉差,iconfont上为什么有的图标周围有留白，而有的图标没有留白的原因"
      },
      {
        "title": "0-9数字中，每个数字的宽度是多少",
        "href": "2020/8/number_width.html",
        "time": "2020/08/02",
        "description": "什么数字最宽，以字体PingFangSC-Regular，大小12px为例, 一般宽度 1 < 7 < 0,2,3,4,5,6,8,9  但不排除其他字体没有差异，同理我们可以使用这种方法看26个字母里每个字母的占用宽度为多少",
        "keywords": "数字宽度,什么数字最宽"
      },
      {
        "title": "less使用mixin抽取css公共代码，减少重复代码",
        "href": "2020/8/less_mixin.html",
        "time": "2020/08/22",
        "description": "less函数,less mixin实例,less mixin,less封装css,less怎么抽取公共样式,less抽取公共样式，由于没有系统的学习less，之前只用到less的嵌套写法，很少用变量，基本没用mixin模块化封装，这次尝试了下，发现还是不错的，下面来用封装一个基础的布局组件，主要涉及三个知识点 1. 把css单独提成文件使用 @import (reference) url('') 引入 2. 封装mixin函数，在需要引入的地方执行函数 3. 使用 @headerHeight: 100px 这种方法定义变量",
        "keywords": "less函数,less mixin实例,less mixin,less封装css,less怎么抽取公共样式,less抽取公共样式"
      },
      {
        "title": "响应式设计和自适应设计的区别",
        "href": "2020/9/rwd_awd.html",
        "time": "2020/09/24",
        "description": "响应式(Responsive)布局和自适(Adaptive)应布局，也叫响应式设计与自适应设计。他们都用于在不同屏幕尺寸的设备上显示合适的内容。当你在思考这个问题的时候，表示你已经开始死扣概念了，这个问题在网上争议较大，包括国外的CSS-Tricks上的文章也有产生争议的。阮一峰博客里面将Responsive Web Design直接翻译为自适应web设计。",
        "keywords": "响应式布局和自适应设计的区别,响应式设计,自适应设计"
      },
      {
        "title": "移动端rem自适应与pc端rem自适应",
        "href": "2020/9/rem.html",
        "time": "2020/09/24",
        "description": "在还原设计稿稿时，对于展示型的页面，设计稿间距都是固定的px，那我们实现时，如果全部都用pixel(px)写死就会存在某些分辨率下显示比较差的问题。用百分比也可以，但你需要自己手动计算，现在一般比较好的方法是在合适的地方使用rem，他可以自动转换。先来复习下css rem的概念。在css中有以下几种相对长度单位，em表示相对当前父元素字体大小的倍数, rem表示相对根元素(html)字体的倍数。",
        "keywords": "pc rem,h5 rem,em与rem的区别"
      },
      {
        "title": "css background设置图片背景",
        "href": "2020/9/background.html",
        "time": "2020/09/24",
        "description": "HTML5权威指南这本书对background的简写貌似有点不正确，使用起来会有问题，这次让图片在某个区域完全显示，是分开写的，如下：div { background: #fff url('/images/xxx.png') no-repeat; background-size: cover;}",
        "keywords": "background背景图片,background-size"
      },
      {
        "title": "css表格怎么画斜线，怎么精准计算斜线rotate角度",
        "href": "2020/9/table_slash.html",
        "time": "2020/09/24",
        "description": "在最近的需求中，有个表格表头里有斜线，我特意翻了 HTML5权威指南 的笔记，发现并没有介绍怎么画表头的斜线。找了下网上的实现，一般都是通过 css 来实现，使用 after 或者特定 span 画一条直线，然后通过 rotate 来旋转成斜线效果。这里涉及到怎么计算斜线角度，会用到一点点数学的知识",
        "keywords": "css表格画斜线,css计算斜线角度,直角三角形给定直角边计算斜边角度"
      },
      {
        "title": "footer 始终保持在最底部 css 实现与 js 实现优缺点对比",
        "href": "2021/5/footer_bottom.html",
        "time": "2021/05/04",
        "description": "让 footer 一直保持在最底部是比较常见的需求，css 和 js 都可以实现，一般推荐使用 css 实现，下面来看看具体实现，以及他们的优缺点。需要考虑两种情况：1. 内容没占满视窗时，footer 在最底部，需要 body 有最小高度，才能撑起来 2. 内容较多时，滚动到底部才能看到 footer，且不遮挡内容区域",
        "keywords": "footer一直保持到底部怎么实现,footer区域保持在底部,footer固定到底部"
      }
    ],
    "Vue": [
      {
        "title": "Vue中img的src是动态参数时不显示的问题",
        "href": "2019/10/vue_img_src_var.html",
        "time": "2019/10/09",
        "description": "在Vue2.x中img的src如果是动态参数，图片会无法显示，需要使用require来加载图片",
        "keywords": "vue img src图片加载不了,Vue中img的src是动态参数时不显示的问题,vue 图片src是变量时无法显示"
      },
      {
        "title": "Element使用JS全局触发消息",
        "href": "2019/10/vue_element_globalmsg.html",
        "time": "2019/10/10",
        "description": "在Vue中，单文件组件xx.vue里如果想触发ElementUI的提示消息（如错误信息、警告信息），怎么通过一行js就能触发呢？下面来看看调用方法",
        "keywords": "elementUI 全局触发消息,element使用js全局触发消息,element提示错误信息,element message,element 提示信息"
      },
      {
        "title": "vue v-cloak指定防止页面内容显示抖动的问题",
        "href": "2019/10/vue_v_clock.html",
        "time": "2019/10/11",
        "description": "v-clock主要用于防止由于网络原因vue.js未渲染时，页面显示类似 {{username}} 的问题，下面来看看实现",
        "keywords": "v-clock,vue v-clock,页面显示前vue未渲染内容一闪而过的问题,vue页面显示抖动"
      },
      {
        "title": "vue deep样式",
        "href": "2019/10/vue_css_deep.html",
        "time": "2019/10/16",
        "description": "vue /deep/什么意思呢？/deep/ 样式为深度选择器，Vue单文件组件中如果style标签有scope属性，当前页面定义的样式对子组件会不生效。如果想让某些样式在子组件里面生效，可以使用/deep/",
        "keywords": "vue /deep/什么意思,/deep/,/deep/深度选择器,vue /deep/"
      },
      {
        "title": "vue仅开发环境下能看到的路由",
        "href": "2019/11/vue_dev_router.html",
        "time": "2019/11/04",
        "description": "通过vue-cli创建的项目，npm run build 的代码是可以根据开发环境的不同而调整的，使用 process.env.NODE_ENV 可以做一些只有开发环境有的逻辑，比如下面的例子中，仅开发环境，才能看到相应的路由",
        "keywords": "vue仅开发环境下能看到的路由"
      },
      {
        "title": "根据vue-router路由传参配置keep-alive以及登录校验",
        "href": "2019/11/vue_router_params.html",
        "time": "2019/11/04",
        "description": "在vue开发中，路由配置的时候，给每个路由添加一个自定义的meta对象，在meta对象中可以设置一些状态，来进行一些操作。可以用来设置是否使用keep-alive，以及登录校验，先来看看配置",
        "keywords": "vue 中路由meta,根据路由配置做登录验证,根据vue-router路由传参配置keep-alive"
      },
      {
        "title": "传数据全局变量就可以了，为什么需要状态管理",
        "href": "2019/11/why_vuex.html",
        "time": "2019/11/14",
        "description": "开发过程中遇到的相关真实场景，为什么需要使用Vuex状态管理？全局对象也可以管理状态，为什么需要vuex? 在vue开发中，我之前很少使用状态管理vuex，总觉得没有太大的实际用途。后面项目实践后，才能真正体会状态管理的强大。为什么需要状态管理，这个需要在开发实践中慢慢体会。",
        "keywords": "vuex使用场景,vue相对全局变量有什么优势,为什么需要使用Vuex状态管理,全局对象也可以管理状态，为什么需要vuex"
      },
      {
        "title": "v-if里使用filters无效的问题",
        "href": "2019/11/v-if_filters.html",
        "time": "2019/11/22",
        "description": "v-if 不能用filters,在项目中，想在v-if里使用filters发现不生效，于是查了下vue的文档，发现v-if里是不支持使用filters的。一般filters只能在两种情况下使用：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由'管道'符号指示。",
        "keywords": "v-if里使用filters无效的问题,v-if里使用filters无效,v-if中使用filter无效,v-if中使用过滤器无效"
      },
      {
        "title": "vue路由懒加载时import里面不能是变量的问题",
        "href": "2019/12/vue_import_var.html",
        "time": "2019/12/11",
        "description": "路由懒加载地址不能有变量，当在vue里面需要将路由组件按需加载时，import里面开头不能是变量，webpack编译会无法加载对应的组件，解决方法是前面加一部分写死的字符串路径，后面的使用变量即可",
        "keywords": "路由懒加载地址不能有变量，路由懒加载import变量无效,路由懒加载import里面使用变量不生效"
      },
      {
        "title": "vue组件里click事件监听可能会产生的性能问题",
        "href": "2019/12/vue_click.html",
        "time": "2019/12/13",
        "description": "vue click会不会影响性能？之前在看JS高程3里面有一个知识点，就是当多个子元素需要绑定click事件时，大量添加处理程序，会影响性能，尽量少添加处理事件。但写vue习惯后，突然忘了这一点，其实vue监听事件我们也可以遵循这个原则：把事件放到其父元素上监听，然后通过 data-key属性来指定每个子元素对应的值。e.target.getAttribute('data-key')有值就表示子元素点击了",
        "keywords": "vue click会不会影响性能？vue组件里click事件监听可能导致的性能问题,vue监听click事件注意事项"
      },
      {
        "title": "vuex状态更新后一直没生效的问题",
        "href": "2019/12/vuex_issue.html",
        "time": "2019/12/12",
        "description": "今天写一个功能时，push数据更新state变量可以刷新到页面，但用slice改变state变量时，页面报错，提示 'TypeError: Cannot rad property 'wrapper' of undefined'，百度了下可能是@click方法没定义报的错，但我这里只是改了vuex状态，而且push新增数据都可以，就是slice删除数据会报错，最后发现是有一个@click方法确实没有定义，但这种情况很奇怪。为什么push又不报错，可能涉及到了diff的一些检测、算法。所以，页面有consloe.error的错误，一定要先解决，不要以为对功能没影响就不管，不然可能会遇到一些奇怪的问题。",
        "keywords": "vuex状态更新后一直没生效的问题,vuex TypeError: Cannot rad property 'wrapper' of undefined'"
      },
      {
        "title": "vue组件updated钩子使用场景",
        "href": "2019/12/vue_updated.html",
        "time": "2019/12/12",
        "description": "updated钩子，在vue中，只要data变更就会触发，子组件的列表数据会根据接口请求的数据来刷新，当列表数据更新后，会调用子组件updated钩子函数，我们可以在这里里处理列表数据刷新后的一些操作。比如清除所有focus状态，滚动页面等",
        "keywords": "updated钩子,vue组件updated钩子使用场景"
      },
      {
        "title": "移动端兼容性问题：vuex设置后立即调用this.$router.back()按钮无法点击的问题",
        "href": "2019/12/vuex_nexttick.html",
        "time": "2019/12/24",
        "description": "今天测试机iPhone 7 plus，系统大概是iOS 11.3，vuex mutation操作后，立即调用 this.$router.back() 会导致页面里的下一步无法点击。而我自己的机型iPhone8是没问题的，解决方法是：在 vue mutaion操作后，不立即调用 back，而是使用 nextTick包裹，在下次 DOM 更新循环结束之后再执行",
        "keywords": "vuex设置后立即调用this.$router.back()按钮无法点击的问题"
      },
      {
        "title": "vue性能优化 - webpack包体积优化",
        "href": "2019/12/vue_webpack_optimization.html",
        "time": "2019/12/25",
        "description": "安装 webpack-bundle-analyzer npm包， 在package.json的scripts加入对应的命令，运行npm run report 即可build，并在dist目录生成report.html，打开就可以各个模块包对应的大小，这样就可以开始优化了",
        "keywords": "webpack-bundle-analyzer,webpack包体积优化"
      },
      {
        "title": "v-model为什么不能监听中文输入法实时输入，内部是怎么实现的？",
        "href": "2019/12/v_model_text.html",
        "time": "2019/12/20",
        "description": "在看vue文档时，有备注说 v-model 不会在输入法组合文字的过程中得到更新，这是为什么呢？内部是怎么实现的，我们来看看",
        "keywords": "v-model为什么不能监听中文输入法实时输入,输入法组合文字过程监听"
      },
      {
        "title": "Element表格IE下由于滚动条原因导致错位问题",
        "href": "2020/1/element_dolayout.html",
        "time": "2020/01/07",
        "description": "Element 表头固定，表内容可滑动，在IE下滚动条会显示，有一定的宽度占位，导致表头与表内容由点错位，解决方法是：由于表单内容是从接口加载的，从接口加载完数据后，对el-talbe进行从新布局dolayout",
        "keywords": "Element表格IE下由于滚动条原因导致错位问题"
      },
      {
        "title": "IE下dialog弹窗的滚动条滚动到底部时，触发了浏览器滚动条",
        "href": "2020/1/ie_dialog_scroll.html",
        "time": "2020/01/07",
        "description": "Element dialog弹窗的滚动条滚动到底部时，触发了浏览器滚动条同样都是有遮罩层，chrome都是OK的，但IE下会有问题。经过定位后发现，对于dialog使用了append-to-body属性的，都没问题。发现dialog显示时body上添加了一个 el-popup-parent--hidden的class, 设置了overflow为hidden，关了滚动条。对于没有append-to-body属性的dialog如果想修复有两种办法",
        "keywords": "IE下dialog弹窗的滚动条滚动到底部时，触发了浏览器滚动条"
      },
      {
        "title": "IE下dialog弹窗全屏后列表横向滚动卡顿的问题",
        "href": "2020/1/ie_scorll_slow.html",
        "time": "2020/01/08",
        "description": "全屏后添加了一个名为 is-fullscreen 的class，发现把对应的overflow:auto去掉后，就不会卡顿。去掉其实就是将overflow设置为默认值visible，如果子组件高度超出范围，将is-fullscreen设置的height 100% 改为 auto。另一种方法是将table的z-index改为3000(相对dialog比较高的一个层级)，这样IE下就不会卡顿了。",
        "keywords": "Element表格IE下由于滚动条原因导致错位问题"
      },
      {
        "title": "element合并单元格，自定义表格border",
        "href": "2020/10/element_merge_cells.html",
        "time": "2020/10/01",
        "description": "有个较为特殊的表格，需要合并单元格，且改变表格border，下面来看看element el-table怎么实现这种表格。先来分析下怎么做，1. 第一列中第二行以后的行是需要合并的，el-table 提供了一个 span-method 属性，用于传入合并单元格方法，在里面可以根据 rowspan、colspan 合并行或列 2. 第 2、3、4 列需要改变表格 border，需要使用 `/deep/` 修改 element 默认的颜色，使用 nth-child、first-child 等找到对应的行或列，修改border",
        "keywords": "element合并单元格,element表格合并单元格"
      },
      {
        "title": "el-input类型为textarea时不能使用v-model.trim",
        "href": "2020/10/textarea_not_trim.html",
        "time": "2020/10/01",
        "description": "el-input如果type为textarea，不能使用.trim修饰符，否则输入内容时会无法换行，如果需要去掉收尾空格，可以在提交数据时，手动执行.trim()去空格",
        "keywords": "textarea不用使用v-model.trim"
      },
      {
        "title": "节流与防抖理解以及element源码中节流与防抖的应用",
        "href": "2020/10/throttle_debounce.html",
        "time": "2020/10/08",
        "description": "理论上 throttle 节流一般用于监听类似 resize 方法，想要减少执行频率的场景。对于点击按钮提交，防止短时间内多次点击可以用 debounce 防抖，但实际使用时可根据具体情况来看，本质上都是利用 setTimeout 来处理执行频率或执行间隔。下面是一个简单的 loadash 防抖示例，300ms 内放置重复点击",
        "keywords": "节流与防抖,element中节流防抖的应用"
      },
      {
        "title": "element表单中，人数输入框怎么限制只能输入正整数",
        "href": "2020/10/people_num.html",
        "time": "2020/10/08",
        "description": "在人数这一栏，输入时，前端需要确保输入的只能是正整数，且不能是负数，且自动校正，来看看怎么实现",
        "keywords": "element只能输入正整数"
      },
      {
        "title": "前端代码规范风格指南",
        "href": "2020/10/fe_style.html",
        "time": "2020/10/08",
        "description": "新建文件夹，命名以小写字母开头，驼峰命名，单文件组件命名规则，参考vue风格指南。如果组件内容较多，创建一个文件夹，命名以npm包命名规则一致，全小写、-分隔，建议不超过3个单词。其他资源目录，参考Element组件源码",
        "keywords": "前端代码规范,前端命名规范"
      },
      {
        "title": "el-tabs跳转之前先弹窗确认后再切到tab页",
        "href": "2020/10/el-tabs-confirm.html",
        "time": "2020/10/25",
        "description": "增加 before-leave 钩子函数，如果返回 false，就不会跳转过去。它的返回值除了支持true，false外，还支持 promise 的 resolve 和 reject。我们可以将调用js弹窗组件函数改为promise，如果非提交表单关闭弹窗就返回 reject。否则 resove 表单数据。调用该函数时使用try catch可以很好的处理筛选组件弹窗确定后再跳转到对应tab的逻辑。",
        "keywords": "el-tabs阻止切换钩子函数,el-tabs跳转前确认"
      },
      {
        "title": "怎么写出类似element官网那样可以实时看运行效果的文档",
        "href": "2020/10/ui_doc.html",
        "time": "2020/10/25",
        "description": "对于UI组件、echarts图表相关文档来说，能够实时看具体显示效果是必须的。它是将文档和demo合并在一起，这样更有说服力。那怎么写出类似的文档呢？这里来介绍三种方法：1.dosify 2.vuepress 3.element官网源码",
        "keywords": "UI组件官网,组件展示官网,dosify实例"
      },
      {
        "title": "怎么用vue写一个组件库，类似element",
        "href": "2020/10/vue_ui_lib.html",
        "time": "2020/10/25",
        "description": "下面通过一个简单的示例来看怎么写一个vue组件库，分为 6 步：1. 目录规划 2. 组件库入口文件 3. 本地测试组件 4. 打包构建 UMD 5. 上传 npm 包 6. dosify搭建官网",
        "keywords": "vue组件库,vue组件库编写流程"
      },
      {
        "title": "Vue CLI构建项目时选择不同的eslint规则会有什么区别？",
        "href": "2020/10/vue_cli_eslint.html",
        "time": "2020/10/25",
        "description": "当我们使用 vue create xxx 时，会让选择是否需要某个模块，如果有使用空格选择 Linter / Formatter，那么后面的流程会让你选择一种eslint规则。总共有 5 种情况，我们都逐一试试，看生成的package.json有什么不同",
        "keywords": "vue-cli eslint,Vue CLI eslint"
      },
      {
        "title": "怎么在老项目中加入eslint规则，并可以保存后自动fix",
        "href": "2020/10/old_project_eslint.html",
        "time": "2020/10/25",
        "description": "在 'Vue CLI 构建项目时选择不同的 eslint 规则会有什么区别？' 中，我们有了解到，不同的 eslint 配置项，会对应不同的 npm 包，eslintConfig 中对应的 extends 也不一样。我们只要找出某个配置特有的 npm 包，以及配置，就可以在旧项目中，引入对应的 eslint 配置，结合 vscode eslint 插件就可以做到保存后自动 fix",
        "keywords": "老项目加eslint,旧项目引入eslint,vue eslint"
      },
      {
        "title": "Vue实用echarts组件封装",
        "href": "2020/10/vue_echarts.html",
        "time": "2020/10/31",
        "description": "vue中使用echarts可以自己封装一个简单的组件。实现每次更新数据只需要修改options的值即可，并自带loading、暂无数据slot。先来看看使用demo",
        "keywords": "Vue echarts组件封装,echarts组件"
      },
      {
        "title": "vue组件的封装性与可操作性：ref拿不到子组件实例以及vuex增加代码复杂度问题",
        "href": "2020/10/vue_comps_complex.html",
        "time": "2020/10/31",
        "description": "一般在封装vue组件时，怎么把组件封装的更好，更容易维护理解是值得思考的问题。来看一个实际场景：一个组件里有高级查询和列表，他们东西都比较多，需要拆分成两个子组件",
        "keywords": "vue组件封装,props ref vuex封装组件时对比"
      },
      {
        "title": "Vue 父组件在什么时候开始加载子组件，父子组件的钩子函数顺序是什么？",
        "href": "2020/11/vue_son_hooks.html",
        "time": "2020/11/08",
        "description": "一般父组件会在自身组件 mounted 后，开始加载子组件，下面来通过一个例子来看完整的父子组件钩子函数。下面的例子中在 index.vue 以及 compA.vue 父子组件中都加了对应的钩子函数 console。父组件 beforeCreate => 父组件 created => 父组件 beforeMount => 父组件 mounted => 父组件 beforeUpdate => 子组件 beforeCreate => 子组件 created => 子组件 beforeMount => 子组件 mounted => 父组件 index updated",
        "keywords": "vue父组件在什么时候开始加载子组件,vue父子组件钩子函数顺序"
      },
      {
        "title": "Vue 子组件名称与父组件name相同时死循环的问题",
        "href": "2020/11/vue_stacksize_exceeded.html",
        "time": "2020/11/08",
        "description": "在vue项目中，假设父组件name与子组件名称一致，会造成死循环，出现 Error in nextTick: 'RangeError: Maximum call stack size exceeded' 的错误，template在编译时，不会去找 components 引入的组件，而是直接引入自己，形成一个循环引用、递归组件，要特别注意。",
        "keywords": "vue组件循环引用,vue递归组件,Maximum call stack size exceeded"
      },
      {
        "title": "Vue keep-alive在路由跳转时按需缓存当前页面数据，$route非双向绑定的问题",
        "href": "2020/11/keep-alive-include.html",
        "time": "2020/11/08",
        "description": "有这么一个需求，页面 B 跳转到页面 C 时需要保存页面交互数据，跳到其他页面不缓存数据。在 Vue 中这种功能一般会使用 keep-alive 的 include 或 exclude 有条件的缓存来实现。起初我想省事，直接使用 $route.meta 来动态修改 include 值，但后面发现不生效，原来 $router.meta 不是双向绑定的，需要使用其他变量才行，下面来看看具体逻辑。",
        "keywords": "vue keep-alive按需缓存页面,vue按需缓存,$route是否是双向绑定的"
      },
      {
        "title": "Vue 单元测试",
        "href": "2020/11/vue_unit_test.html",
        "time": "2020/11/16",
        "description": "在 Vue.js 官网，学习 => CookBook 下有一个 Vue 组件的单元测试 文档。为什么要测试？组件的单元测试的好处: 节省手动测试的时间，减少研发新特性时产生的 bug，自动化测试使得大团队中的开发者可以维护复杂的基础代码。Vue Test Utils 是 Vue 组件单元测试的官方库。他的作者写了一本书 《Testing Vue.js Applications》，对应的中文版本是《Vue.js应用测试》，如果想系统的学习 Vue 应用测试，建议看这本书。",
        "keywords": "vue单元测试,vue测试,vue应用测试"
      },
      {
        "title": "什么是e2e test，除了单元测试外还有什么测试？",
        "href": "2020/11/e2e_test.html",
        "time": "2020/11/16",
        "description": "e2e 是 end to end 的缩写，翻译为端到端测试。单元测试只是整个测试金字塔中的一部分。其他类型的测试还包括 e2e(端到端)测试，快照比对测试等。e2e(端到端)测试致力于确保组件的一系列交互是正确的。相比简单快速的单元测试，它是更高级别的测试，例如可能会测试用户是否注册、登录以及更新他们的用户名。这种测试运行起来会比单元测试和快照比对测试慢一些。运行起来会更慢很多。这些测试通常只在部署前运行，来确保系统的每个部分都能够正常的协同工作。",
        "keywords": "e2e test,e2e test示例,端到端测试"
      },
      {
        "title": "Vue @功能实现",
        "href": "2020/11/vue_mentions.html",
        "time": "2020/11/30",
        "description": "如果自己写一个 @ 功能会比较麻烦，在 github 上找了一个现成的开源库 Tribute - ES6 Native @mentions，它是 ES 原生的实现，社区有各种框架的实现。这里我们使用它的 Vue 实现 vue-tribute。下图是实现效果",
        "keywords": "@实现,@功能实现,@下拉选择实现,Vue @功能实现"
      },
      {
        "title": "vue.config.js: 'plugins' is not allowed",
        "href": "2020/11/vue_cfg_plugins.html",
        "time": "2020/11/30",
        "description": "在 vue.config.js 中，webpack 相关的配置需要写到 configureWebpack 里，不能直接写到外面，否则会报错：vue.config.js: 'plugins' is not allowed。",
        "keywords": "plugins is not allowed"
      },
      {
        "title": "Vue ElementUI Cannot read property 'prototype' of undefined",
        "href": "2020/11/vue_element_err.html",
        "time": "2020/11/30",
        "description": "由于 vue 项目 npm run build 打包时 ElementUI 体积较大，因此把他单独抽离出去。放到 public/index.html 里直接引入。但抽离出去后发现启动后控制台会报这样一个错误：Cannot read property 'prototype' of undefined。网上查了下，是因为在 public/index.html 中引入 ElementUI 的 js 时，前面没有加 Vue.js 的引入。这里我们在前面加入 Vue.js 的引入即可。",
        "keywords": "element cannot read property 'prototype' of undefined"
      },
      {
        "title": "Vue CLI 项目页面打开时间优化：从16秒到2秒内",
        "href": "2020/11/vue_cli_slow.html",
        "time": "2020/11/30",
        "description": "在日常开发中，经常要写一些 demo 来测试一些功能，于是专门新建了一个 github 仓库来管理，方便积累。这次想着把 vue demo 部署到服务器，方便 PC/手机 实时看效果。于是把 vue-cli 项目 npm run build 后，将 dist 部署到服务器 nginx 下，但发现打开很慢，下面来看看怎么优化。如下图，DOM 加载完 15 秒，完全加载 16 秒",
        "keywords": "vue-cli项目页面加载时间太长,npm run build 打包很大,vue vendor.js文件太大,vue项目包体积优化"
      },
      {
        "title": "docsify嵌入vue echarts组件无法显示图表的问题",
        "href": "2020/12/dosify_vue_echarts.html",
        "time": "2020/12/07",
        "description": "在使用 docsify 自带的 vue 功能加载 echarts 相关的 vue 组件时，图表都无法正常显示。后来打印 log 发现，最终渲染到页面的 echarts div并不是 vue 初始化之后，进行绘制的 div，而是一个拷贝后的副本，所以图片显示不出来。 需要使用 vuep 插件才行。实例参考 https://vuechart.zuo11.com，效果如下图:",
        "keywords": "docsify echarts vue组件无法正常显示"
      },
      {
        "title": "使用 VuePress 生成静态网站并部署到 Github Pages",
        "href": "2020/12/vuepress.html",
        "time": "2020/12/15",
        "description": "VuePress 是一个静态网站生成器，诞生初衷是为了支持 Vue 及其子项目的文档需求。目前 Vue 相关文档都是由 vuepress 搭建。相比其他静态站点生成工具，Docsify 是运行时驱动，通过 JS 加载内容，对 SEO 不够友好。VuePress 类似于 Hexo，主要区别是 VuePress 是由 Vue 驱动。",
        "keywords": "VuePress,VuePress 创建网站,vuepress 使用"
      },
      {
        "title": "VuePress 复选框、任务列表不生效怎么处理",
        "href": "2020/12/vuepress_tasklist.html",
        "time": "2020/12/15",
        "description": "在写 markdown 笔记时，复选框、任务列表（task list）功能在本地 Typora 是生效的，但在 VuePress 中无法正常显示。于是在 Github 对应的 issue 里面搜索 Task lists，找到了解决方法：需要安装一个 markdown 插件 `markdown-it-task-lists`",
        "keywords": "VuePress复选框显示不正常,VuePress任务列表,VuePress Task list"
      },
      {
        "title": "使用js调用vue单文件组件",
        "href": "2020/2/js_vue_comp.html",
        "time": "2020/02/20",
        "description": "在封装组件时，如果是dialog组件，一般封装好后，通过component引入，然后把标签放到html里，通过true或false来隐藏和显示，每次都要写一些重复代码。怎么能够像ElementUI的message函数一样直接调用呢，首先需要搞懂怎么用js来调用vue单文件组件，下面来看方法",
        "keywords": "使用js调用vue单文件组件"
      },
      {
        "title": "element表单校验函数没生效的问题",
        "href": "2020/2/el_form_validate.html",
        "time": "2020/02/24",
        "description": "根据element官网的dmeo，加入表单校验，发现校验的rules根本没执行。注意：el-form-item 标签也需要设置 prop 属性，并且名称需要和对应model的名称一致，我这次漏写了，所以一直没生效",
        "keywords": "element表单校验没生效"
      },
      {
        "title": "element cascader显示异常问题",
        "href": "2020/2/el_cascader.html",
        "time": "2020/02/24",
        "description": "当cascader里选项比较多时，组件高度会异常，主要是 .el-cascader-menu__wrap 这个样式高度为100%，将cascader里其任意一父元素手动指定高度即可，但el-cascader-menu__wrap设置的效果最好",
        "keywords": "element cascader显示异常问题,element cascader高度问题"
      },
      {
        "title": "element怎么动态改变校验rules且实时生效",
        "href": "2020/2/element_form_rules.html",
        "time": "2020/02/27",
        "description": "在需要动态设置rules，并需要其实时生效的场景，一般需要将rules完成改变才行，这是为什么呢，下面来看看",
        "keywords": "element怎么动态改变校验rules且实时生,element el-form rules动态改变"
      },
      {
        "title": "el-form-item里非elment输入组件时，校验回调函数不触发的问题",
        "href": "2020/2/not_element_input_validate.html",
        "time": "2020/02/27",
        "description": "今天写表单校验规则，有个 el-form-item 里使用了富文本编辑器，发现校验规则校验这个值会有异常: 1. 当 change 或 blur 时，根本没有触发校验(提示错误) 2. 提交表单时，当该字段校验失败会提示错误，但该字段符合要求时，validate的回调一直没触发，导致无法进行校验成功之后的下一步操作，将富文本编辑器换成 el-input 正常，换成普通的 input 也会异常，感觉一头雾水。",
        "keywords": "element表单校验时如果非element组件会触发布料校验,富文本编辑器在element form中校验回调函数不触发的问题"
      },
      {
        "title": "vue封装组件时预留install函数便于Vue.use全局引入",
        "href": "2020/6/vue_use_install.html",
        "time": "2020/06/29",
        "description": "在element组件中，我们使用el-input等element元素时，不需要在components里引入。为什么呢？在引入element时，我们有在mian.js里我们使用了Vue.use(elemnt组件)，这样进行了全局注入组件，相当于组件做成了一个vue插件，如果我们自己封装组件如何能够在Vue.use后直接可以全局调用呢？",
        "keywords": "vue封装组件时预留install函数,element组件为什么use后可以直接使用"
      },
      {
        "title": "vue自定义组件使用v-model指令实现dialog组件的二次封装",
        "href": "2020/6/v_model_dialog.html",
        "time": "2020/06/29",
        "description": "当某个组件是对element的dialog组件进行二次封装时，我们需要对dialog进行隐藏显示，当子组件里的dialog关闭时，需要修改父组件传入的值，尽管不是表单组件也可以使用v-model来解决，先来看看怎么调用",
        "keywords": "v-model属性实现dialog组件的二次封装,element dialog组件的二次封装"
      },
      {
        "title": "vue封装组件方式的思考",
        "href": "2020/6/vue_component_think.html",
        "time": "2020/06/29",
        "description": "在封装组件时，一般我们使用的方法是：把组件单独放到一个xx.vue，然后需要引入时在components使用懒加载引入再使用，我就在想，每次引入组件都需要三步：1. 把组件通过 components 引入 2. 在template中写对应的代码 3. 在data中写对应的数据，methods里写绑定的事件。会不会太麻烦了，我希望像element的组件那样，通过 this.$message.error(e.message) 这样直接调用一个组件",
        "keywords": "vue封装组件思考,vue封装组件总结"
      },
      {
        "title": "vue-cli项目使用@开头的路径是什么意思",
        "href": "2020/7/vue_src_alias.html",
        "time": "2020/07/12",
        "description": "我们在vue-cli创建的vue项目里，可以使用@开头的路径，表示从src目录开始，这样如果后面代码的目录层级有调整，或者复用代码时，都不会影响功能，代码更健壮",
        "keywords": "vue-cli项目使用@开头的路径是什么意思,@开头的路径,路径中有@"
      },
      {
        "title": "Failed to resolve directive: infinite-scroll",
        "href": "2020/7/infinite-scroll.html",
        "time": "2020/07/26",
        "description": "在element InfiniteScroll无限滚动功能里，使用了v-infinite-scroll指令，但直接使用会发现提示 Failed to resolve directive: infinite-scroll，后面查了下，发现要使用该指令需要安装一个vue-infinite-scroll npm包，并且在main.js里引入才行",
        "keywords": "Failed to resolve directive: infinite-scroll,element v-infinite-scroll指令"
      },
      {
        "title": "v-infinite-scroll放到slot里或者用v-if控制时首次无法触发loadMore的问题",
        "href": "2020/7/v-infinite-scroll.html",
        "time": "2020/07/26",
        "description": "v-infinite-scroll不触发loadMore，element v-infinite-scroll指令, 最新项目结构调整，发现一个问题，把 v-infinite-scroll 对应的元素放到 slot 里，首次无法触发loadMore, 不放到slot里面又是正常的，来看代码",
        "keywords": "v-infinite-scroll不触发loadMore,element v-infinite-scroll指令"
      },
      {
        "title": "vue全局引入组件Vue.use()与Vue.component()的用法与区别",
        "href": "2020/7/vue_global_comps.html",
        "time": "2020/07/26",
        "description": "vue全局组件，Vue.use与Vue.component区别，之前的笔记里有将Vue.use()全局引入组件的方法，其实用 Vue.compoennt()也可以全局引入组件。下面来看具体用法，以及他们的区别",
        "keywords": "vue全局组件,Vue.use()与Vue.component()的区别,Vue.use与Vue.component区别"
      },
      {
        "title": "vue页面中监听路由改变的2种方法",
        "href": "2020/7/vue_watch_router.html",
        "time": "2020/07/26",
        "description": "vue监听路由变化,vue监听路由,在vue中，怎么监听vue-router路由的变更呢？一般有两种方法 1. 单页面组件中，使用 beforeRouteEnter 2. 使用watch监听$route",
        "keywords": "ue监听路由变化,vue监听路由,监听vue-router变化"
      },
      {
        "title": "element时间选择器限制选中：不能选择今天之后的日期，时间间隔不能超过一个月",
        "href": "2020/7/el-date-picker-limit.html",
        "time": "2020/07/26",
        "description": "elmement el-date-picker限制选中,elmement el-date-picker disabled某些选中,element时间限制选中,一般使用 picker-options 这个属性来disable某些时间段，注意 如果设置了default-time 00:00:00 - 23:59:59 会影响对应的日期判断，必要时可以去掉，逻辑可以由后端处理",
        "keywords": "elmement el-date-picker限制选中,elmement el-date-picker disabled某些选中"
      },
      {
        "title": "vue-router编程方式跳转路由以及其传参问题",
        "href": "2020/7/vue-router-jump.html",
        "time": "2020/07/26",
        "description": "vue-router有以下几种编程方式跳转路由的方法。一般push和repalce用的比较多，下面来看看",
        "keywords": "vue-router,vue-router编程式跳转方法,vue-router跳转路由方法"
      },
      {
        "title": "vue v-model的理解",
        "href": "2020/7/vue-v-model.html",
        "time": "2020/07/26",
        "description": "在前面讨论过，使用v-model的场景，来看一个实例，假如我们需要封装一个弹窗组件需要引入el-dialog组件。首先，我们来看看我们写好这个组件后应该怎么调用，通过show这个参数来控制dialog显示或隐藏",
        "keywords": "v-model的理解,v-model与,.sync"
      },
      {
        "title": "vue多层级组件，父组件怎么将事件传递给孙组件?",
        "href": "2020/8/vue_listeners.html",
        "time": "2020/08/10",
        "description": "来看一个例子，假设A组件包含组件B，B组件又包含组件C，我们知道，在B组件里 this.$emit('open-tab') 会执行其父组件A里面对应的方法，但如果B的子组件C，也想触发A组件的事件，那要怎么做呢？",
        "keywords": "vue多层级组件，父组件怎么将事件传递给孙组件"
      },
      {
        "title": "vue动态组件怎么动态绑定一个或多个v-bind属性",
        "href": "2020/8/component_vbind.html",
        "time": "2020/08/10",
        "description": "最近有封装一个tabs标签页组件，引入组件，可以将页面进行tab化。原先的页面作为子组件放到tabs组件里，由于标签页跳转页面时有需要打开新的标签页。所以tabs组件里会包含多个页面组件，为了避免像el-tabs那样，每次引入tabs组件都需要自己写v-if的逻辑来切换tab显示。我把这一步封装到了自定义tabs组件内部，内部使用动态组件component、is来切换组件显示。",
        "keywords": "动态组件怎么动态绑定一个或多个v-bind属性"
      },
      {
        "title": "vue在自定义组件上使用v-model指令",
        "href": "2020/8/custom_comp_v_model.html",
        "time": "2020/08/15",
        "description": "vue自定义组件使用使用v-model,vue v-model,vue v-model原理,vue v-model内部实现,在自定义组件上，使用v-model指令，默认会向子组件传递一个字段名为 value 的 prop 属性，以及绑定一个名为 input 的事件。在子组件里，可以用props来接收value字段，可以用 this.$emit('input') 来对父组件里value的值进行修改。它主要的应用在子组件需要修改父组件属性值的情况，你不需要额外再调用子组件时，传递一个修改值的事件，节省了一个事件监听。来看看示例",
        "keywords": "vue自定义组件使用使用v-model,vue v-model,vue v-model原理,vue v-model内部实现"
      },
      {
        "title": "vue中v-model与.sync的区别",
        "href": "2020/8/v-model_vs_sync.html",
        "time": "2020/08/15",
        "description": "v-model与.sync的区别,v-model vs .sync, vue v-model与 .sync的区别,一般父组件给子组件传值是单向的，对于非引用类型，子组件怎么修改父组件传给子组件prop对应的值呢？除了通过 $parent、$root、Bus(发布，订阅)、状态管理(vuex)、额外定义一个方法外，还有两种方法：使用 v-model，或者为加.sync，来看下对比",
        "keywords": "v-model与.sync的区别,v-model vs .sync, vue v-model与 .sync的区别"
      },
      {
        "title": "vue中$attrs 和 $listeners 的使用场景",
        "href": "2020/8/vue_attrs_listeners.html",
        "time": "2020/08/15",
        "description": "$attrs与$listeners,vue $attrs,vue $listeners,vue $attrs使用场景,vue $listeners使用场景,在vue中，$attrs，$listeners 分别记录了当前组件上绑定的属性以及事件，一般可能用的比较少，下面来看看。`v-bind=$attrs` 他类似属性展开运算符，将父组件调用子组件时传入的属性展开(不包含props已接收的)、v-bind到当前的元素上。listeners除了跨层级向下传递事件外，还可以用于将原生事件绑定到组件",
        "keywords": "$attrs与$listeners,vue $attrs,vue $listeners,vue $attrs使用场景,vue $listeners使用场景"
      },
      {
        "title": "vue为什么要将插槽slot='aaa'的写法变更为v-slot:aaa",
        "href": "2020/8/slot_vs_v-slot.html",
        "time": "2020/08/15",
        "description": "vue slot v-slot区别,v-slot是slot的语法糖，在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除。具名插槽 主要用于当有多个插槽时，通过名字对不同的插槽进行区分，先来看看聚名插槽使用时的一个特殊场景，由于在父组件里调用用子组件，会写上对应的插槽，这时插槽的作用域为当前的父组件，插槽内部使用的变量名默认都是从父组件取的。下面的例子中 slotA插槽内部调用的 user，它默认是当前组件的变量（父组件）",
        "keywords": "vue slot v-slot区别,v-slot是slot的语法糖"
      },
      {
        "title": "vue组件之间传值(通信)方式总结",
        "href": "2020/8/vue_comp_transmit.html",
        "time": "2020/08/15",
        "description": "vue组件之间传值,vue传值方式,vue传值方式总结,vue通信方式总结,在vue中一般组件之间传值是必须要理解的，下面来总结下组件间传值的方法，分为以下几种情况 1. 父组件 => 子组件 2. 子组件 => 父组件 3. 兄弟组件 4. 父组件 => 子组件 5. 祖先和后代之间 6. 任意两个组件之间",
        "keywords": "vue组件之间传值,vue传值方式,vue传值方式总结,vue通信方式总结"
      },
      {
        "title": "vue里简单的总线(bus)发布订阅模式实现",
        "href": "2020/8/vue_on_emit.html",
        "time": "2020/08/15",
        "description": "vue publish/subscription,vue发布订阅模式实现,vue bus发布订阅实现, 在vue组件内部有实现发布订阅模式，类似于bus，在兄弟组件或任意两组件之间传值可以使用这种方法，那内部是怎么实现的呢？我们先写一个调用demo",
        "keywords": "vue publish/subscription,vue发布订阅模式实现,vue bus发布订阅实现"
      },
      {
        "title": "vue项目文件以及文件夹命名规范问题，前端代码规范风格指南",
        "href": "2020/8/vue_code_style.html",
        "time": "2020/08/15",
        "description": "vue代码规范,vue命名规范,vue组件命名,前端代码规范,前端代码风格指南,vue代码风格指南,vue文件命名,在以vue为主的开发中，vue项目文件以及文件夹命名规范文件，在开发团队里面是需要统一的。我们尽量按照一种规范来开发，形成一种风格，这样更有利于项目迭代维护，下面来逐一介绍：1.个人总结的vue功能组件、目录结构风格 2.业界较权威的风格指南 3.其他风格",
        "keywords": "vue代码规范,vue命名规范,vue组件命名,前端代码规范,前端代码风格指南,vue代码风格指南,vue文件命名"
      },
      {
        "title": "vue为什么建议永远不要把 v-if 和 v-for 同时用在同一个元素上",
        "href": "2020/8/v-if_v-for.html",
        "time": "2020/08/15",
        "description": "vue v-if为什么不能和v-for一起用,vue v-if v-for一起用,vue v-if和v-for一起时优先级,在vue风格指南中，将'避免 v-if 和 v-for 用在一起'列为必要优先级，建议永远不要把 v-if 和 v-for 同时用在同一个元素上。官网文档如下: 一般我们在两种常见的情况下会倾向于这样做： 1. 为了过滤一个列表中的项目 (比如 v-for='user in users' v-if='user.isActive')。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。2. 为了避免渲染本应该被隐藏的列表 (比如 v-for='user in users' v-if='shouldShowUsers')。这种情形下，请将 v-if 移动至容器元素上 (比如 ul、ol)。",
        "keywords": "vue v-if为什么不能和v-for一起用,vue v-if v-for一起用,vue v-if和v-for一起时优先级"
      },
      {
        "title": "vue tabs标签页组件的坑，能不使用就不要使用",
        "href": "2020/8/vue_tabs_pit.html",
        "time": "2020/08/22",
        "description": "vue tabs标签页,vue 标签页,vue便签页的坑，最近项目中需要在一个页面中打开多个tab标签页，刚才是觉得element有现成的组件，觉得没啥问题，后面发现迭代维护新功能时真的是大坑。个人建议**能不使用tab标签页的情况，就不要使用**，下面来看看需要注意的地方",
        "keywords": "vue tabs标签页,vue 标签页,vue便签页的坑"
      },
      {
        "title": "vue element表单组件简单实现",
        "href": "2020/8/mock_element_form.html",
        "time": "2020/08/22",
        "description": "element form实现,element 表单模拟实现,element form模拟实现，在写表单时，一般我们会用到el-form相关组件，那它内部是怎么实现的呢？下面我们来写个demo，尝试实现下。先来写一个调用示例，把el-前缀换成z-，然后我们需要实现z-form, z-form-item, z-input组件",
        "keywords": "element form实现,element 表单模拟实现,element form模拟实现"
      },
      {
        "title": "vue + element实现在用户列表页同时打开多个用户详情页tab功能",
        "href": "2020/8/sameCompSwtich.html",
        "time": "2020/08/30",
        "description": "在使用el-tabs时，如果涉及到同组件会打开多个tab的情况，同组件切换需要使用watch来监听数据改变，再进行数据的初始化。下面结合一个实例来看看，使用 vue + elementUI 实现在用户列表页同时打开多个用户详情页tab功能",
        "keywords": "vue element el-tabs标签页功能demo"
      },
      {
        "title": "ElementUI el-tabs组件切换tab时会触发组件的哪些钩子函数",
        "href": "2020/8/el_tabs_hooks.html",
        "time": "2020/08/30",
        "description": "element el-tabs钩子,el-tabs钩子函数,这里主要是要弄清楚el-tabs是怎么实现组件切换的，使用el-tab-pane slot和不用这个插槽触发的钩子函数会相同吗？如果不使用el-tab-pane的slot，只使用tab的导航，下面的内容自己控制，就看是使用component还是v-if来控制了，这种情况el-tabs组件不会干扰切换的逻辑。问题来了，如果内容放到了el-tab-pane的slot呢？他有一个lazy属性，用来设置某个tab标签页是否延迟渲染，这个会对钩子函数有什么影响呢？我们改写上面的例子，通过demo来看看",
        "keywords": "element el-tabs钩子,el-tabs钩子函数"
      },
      {
        "title": "component动态组件与使用v-if控制组件显示有什么区别？",
        "href": "2020/8/component_v-if.html",
        "time": "2020/08/30",
        "description": "component动态组件与v-if控制组件有什么区别,component动态组件可以理解为它就是v-if控制组件显示的语法糖。我们用一个例子来测试，之前我们写过compoennt用is切换时的钩子函数demo，我们把demo改写下，使用 v-if来替换component，对比页面渲染以及钩子函数的执行情况。改写如下：",
        "keywords": "component动态组件与v-if控制组件有什么区别"
      },
      {
        "title": "component用is进行组件切换时会触发哪些钩子函数，加了keep-alive后呢？",
        "href": "2020/8/component_is_hooks.html",
        "time": "2020/08/30",
        "description": "component is hooks,component is 钩子函数,假设动态组件component使用is控制组件显示，默认显示为A组件，可以切换到B组件。问：首次进入页面以及用is切换组件时，会触发A/B组件的哪些钩子函数，加了keep-alive后呢？先给出结论 1. 如果不加keep-alive，和正常的进入页面和离开页面触发的钩子函数一致。2. 如果加了keep-alive，组件首次加载才会触发 created,mounted等钩子函数，切换时就不会触发created,mounted,beforedestroyed等，所以额外加一个activated和deactivated钩子来提示页面已切换，离开当前页面，才会销毁A/B两个组件触发beforeDestroyed和destroyed两个钩子",
        "keywords": "component is hooks,component is 钩子函数"
      },
      {
        "title": "element v-loading在IE下可能会关不掉的问题",
        "href": "2020/9/v_loading_cannotclose.html",
        "time": "2020/09/07",
        "description": "v-loading在IE下无法关闭的问题,IE 无法关闭v-loading，对于请求非常快的情况，loading一加载很快就关闭。在IE下，可能出现 v-loading设置的值已经是 false，但loading还是一直显示，关闭不了的情况，解决方法是：在关闭loading前，加一个500ms的延时，就没问题了。",
        "keywords": "v-loading在IE下无法关闭的问题,IE 无法关闭v-loading"
      },
      {
        "title": "element v-loading在IE下可能会溢出到全屏的问题",
        "href": "2020/9/v_loading_fullscreen.html",
        "time": "2020/09/07",
        "description": "v-loading在IE下溢出到全屏,IE v-loading全屏，在IE下，有可能出现v-loading指令在loading时不是作用在添加 v-loading 指令的元素区域里，而是溢出到全屏了。这种情况我查了下dom，了解到v-loading是position: absolute布局，而v-loading position不是relatvie 导致溢出到全屏了。这种情况给使用v-loading指令的元素手动加一个 position: relative就可以了。",
        "keywords": "v-loading在IE下溢出到全屏,IE v-loading全屏"
      },
      {
        "title": "v-loading指令的实现，怎么通过一个指令自动加骨架屏",
        "href": "2020/9/z_loading.html",
        "time": "2020/09/07",
        "description": "v-loading的实现,怎么通过一个指令自动加载骨架屏,element v-loading在IE下可能会溢出到全屏的问题,element v-loading在IE下可能会关不掉的问题，这里需要用到vue自定义指令，我们先写个v-zloading来实现loading，在loading过程中加骨架屏，由于是全局自定义指令，所以在main.js里写",
        "keywords": "v-loading的实现,怎么通过一个指令自动加载骨架屏,element v-loading在IE下可能会溢出到全屏的问题,element v-loading在IE下可能会关不掉的问题"
      },
      {
        "title": "输入过程中，怎么实时高亮部分文字(@xxx高亮实现)",
        "href": "2020/9/highlight_when_input.html",
        "time": "2020/09/07",
        "description": "输入过程中高亮部分文字,输入过程中高亮关键字,前端@高亮实现,输入过程中，怎么实时高亮部分文字(@xxx高亮实现)，实现思路是，使用富文本编辑器，当监听到输入的文件包含关键字时，使用replace对当前的输入内容进行替换，给关键字加上span给个highlight的class，代码如下",
        "keywords": "输入过程中高亮部分文字,输入过程中高亮关键字,前端@高亮实现"
      },
      {
        "title": "vue中为什么要使用js调用单文件组件？怎么实现js调用组件？",
        "href": "2020/9/vue_why_js_comp.html",
        "time": "2020/09/12",
        "description": "vue js直接调用组件,js调用vue组件,js加载vue组件,js vue组件，如果自己写一个组件。一般情况下，vue项目中在某个组件里调用另一个组件，至少需要修改三个位置 1. 在 template 里写引入组件，加上传参等 2. 在 components 里声明组件（如果全局引入了，可以省去这一步） 3. data 里面写对应的传参数 代码对应如下，这种组件对于使用地方比较多时候，我们就需要想办法直接使用js来调用组件，而不是每次都要在 template 里面声明对应的组件，这样会有很多重复代码，可维护性较差。",
        "keywords": "vue js直接调用组件,js调用vue组件,js加载vue组件,js vue组件"
      },
      {
        "title": "为什么vconsole直接new一下就能引入，实现原理是什么？",
        "href": "2020/9/vconsole.html",
        "time": "2020/09/12",
        "description": "在移动端真机调试时，一般会用到vconsole，那你会发现在vue中vconsole的引入非常简单，只需要在main.js里面引入，并new一下。相比其他组件需要Vue.use引入来说，会很迷惑，这个是怎么引入到项目的？页面底部时怎么显示vconsole的按钮的？先来看结论，vconsole大致实现思路 1. 通过window监听页面加载，加载ok后向页面append vconsle相关的dom（右下角按钮） 2. 像log、network等相关的渲染显示，都是通过重写window下对应的系统方法来加入一些自定义操作",
        "keywords": "vconsole实现原理,vconsole实现,vconsole为什么只需要new就能引入,为什么vconsole在vue中不用Vue.use就能使用"
      },
      {
        "title": "vue递归组件，实现一个树形菜单",
        "href": "2020/9/vue_tree.html",
        "time": "2020/09/20",
        "description": "vue递归组件,vue树形组件,vue tree组件,vue怎么使用递归组件,vue支持递归组件，也就是组件自己调用自己，一般用于树形组件，来写个简单tree组件实例，先写好调用demo，假设我们实现了一个 z-tree 组件，我们只需要传入data就可以渲染树形组件",
        "keywords": "vue递归组件,vue树形组件,vue tree组件,vue怎么使用递归组件"
      },
      {
        "title": "角色权限vuex状态管理设计思路",
        "href": "2020/9/vuex_role.html",
        "time": "2020/09/24",
        "description": "在vue项目中做角色权限控制时，如果角色较多、权限较复杂，或者很多地方需要使用，就需要使用vuex状态管理了，我们可以在vuex里提供一个getter方法，用于获取对应的角色权限，假设getter名为roleMuster，在需要用到的vue组件里，通过mapGetters导入，就可以使用了",
        "keywords": "vue角色权限,vuex权限"
      },
      {
        "title": "vuepress html lang 默认为英文，总是弹出 google 翻译怎么解决",
        "href": "2021/4/vuepress_lang.html",
        "time": "2021/04/03",
        "description": "默认情况下，vuepress 生成的网页 html lang 属性为 'en-US'，当在 Chrome 浏览器打开时，总是会弹出翻译的窗口。如下图，解决这个问题的方法就是将默认的 lang 设置为中文 'zh-CN' 即可。vuepress 支持国际化功能，我们只需要修改下对应的配置即可。",
        "keywords": "总是弹出 google 翻译怎么解决,vuepress 默认 lang 设置"
      },
      {
        "title": "Vue 使用 vue-i18n 国际化",
        "href": "2021/4/vue_international.html",
        "time": "2021/04/03",
        "description": "在 vue 项目中，可以使用 vue-i18n 来做国际化。下面来看具体是怎么使用的 1. 安装 npm install vue-i18n --save 2. 在 main.js 引入，并做初始化配置，使用 locale 设置默认语言，使用 messages 对象属性，指定不同语言对应的内容。3. 在 vue template 中直接使用。如果想动态切换语言，使用 `this.$root.$i18n.locale = 'en'` 即可修改语言",
        "keywords": "vue 国际化,vue international, vue i18n"
      },
      {
        "title": "props Right-hand side of 'instanceof' is not an object",
        "href": "2021/4/vue_props_error.html",
        "time": "2021/04/11",
        "description": "在 Vue 中写 props 属性时，一般最简单的方式是使用数组的形式： props: ['属性名1', '属性名2']，但这样没有类型校验、默认值。在使用对象的写法时，发现出现 props Right-hand side of 'instanceof' is not an object，错误，写法如下",
        "keywords": "vue props error"
      },
      {
        "title": "Vue 组件封装，通过发布订阅模式和 Vue 实例方法实现 js 操作组件",
        "href": "2021/5/vue_js_comp.html",
        "time": "2021/05/04",
        "description": "以消息组件为例，如果多个组件共用一个全局的消息组件，那怎么优雅的显示消息呢？普通的组件 props 传值的方式会受限，因为组件层级是不确定的。你可能会想到状态管理，将是否显示消息、消息内容存到状态管理 state 中，如果需要显示就修改 vuex 值即可。但这样调用起来会不够方便、简洁。这里我们可以使用发布订阅模式，结合 Vue 实例属性来优雅的实现该功能。下面来看看使用示例",
        "keywords": "vue js 操作组件, vue 组件封装"
      },
      {
        "title": "vue 组件中 css 路径简写 @ 不可用，需要使用 ~@",
        "href": "2021/5/vue_css_src.html",
        "time": "2021/05/04",
        "description": "vue css src 路径，css @ 不生效，css src 简写@, webpack 解析 css 路径，在 vue-cli 创建的 vue 项目中，可以使用 @ 来表示 src 路径。但在 css 中，图片路径使用 @ 就会出错。那 css 中要怎么使用 src 相对路径呢？需要在前面加 ~，也就是 ~@，这样就不必使用相对路径了。",
        "keywords": "vue css src 路径,css @ 不生效,css src 简写@,webpack 解析 css 路径"
      },
      {
        "title": "Vue 国际化 vue-i18n 相关用法、实践总结",
        "href": "2021/5/vue-i18n_use.html",
        "time": "2021/05/04",
        "description": "vue 国际化, Vue 国际化最佳实践, vue-i18n最佳实践, vue-i18n模块化方案, 在 'Vue 使用 vue-i18n 国际化' 中，我们简单介绍了 vue-i18n 的基本使用。如果想将它实际应用到项目中，我们还需要考虑怎么做到更加简洁、优雅、可维护，下面是一些实践总结。1. i18n 单独放一个目录，避免在 main.js 中写入太多内容 2. 方便实时测试：语言切换组件 3. 避免单文件过大、混乱：模块化 4. 列表渲染（code 值）处理：js 取值、过滤器 filter 设计",
        "keywords": "vue 国际化,Vue 国际化最佳实践,vue-i18n最佳实践,vue-i18n模块化方案"
      },
      {
        "title": "Vue filters 中 this 为 undefined，建议使用传参或 method 处理",
        "href": "2021/5/vue_filters_this.html",
        "time": "2021/05/04",
        "description": "在 i18n 国际化，将 code 转换为国际化文本的场景中，需要使用 this.$i18n 这个变量，但发现 fitlers 中的 this 是 undefined，无法使用，查了下。这个是 Vue 设计问题，以下是作者 尤雨溪 在 issue [this undefined in filters · Issue #5998 · vuejs/vue](https://github.com/vuejs/vue/issues/5998) 下的回复：",
        "keywords": "vue filters this,vue filter this 为空,vue filter 不能使用 this"
      },
      {
        "title": "v-model 怎么优雅的绑定 Vuex 状态管理中的值，三种方法优缺点",
        "href": "2021/5/v-model_vuex.html",
        "time": "2021/05/04",
        "description": "在需要将 vuex 中的值，直接与表单 v-model 对应时，如果我们按照 vuex 强调的规范，只能通过 mutation 来改变 vuex state，那么会比较麻烦。假设我们脱离规范，关闭严格模式。那么 v-model 可以直接绑定 vuex state 值，会非常方便，但貌似又不合规范，不利于追踪。那到底要怎么做合适呢？个人建议是：怎么方便怎么来，只要项目可控即可。下面来看看几种方法对比 1. 官方推荐：使用 computed 的 get 和 set",
        "keywords": "v-model 绑定 vuex 中的值"
      },
      {
        "title": "v-if 和 v-show 生命周期钩子函数有什么不同",
        "href": "2021/5/v-if_v-show_hooks.html",
        "time": "2021/05/04",
        "description": "在 vue 中我们知道 v-if 和 v-show 都可以用来控制内容的显示与隐藏，他们的区别是 1. v-if 是惰性加载，只有为 true 时，才真正渲染，否则页面是不存在该元素的。为 false 时，直接从 dom 移除。2. v-show 是根据 css display 属性来显示和隐藏组件的。那么他们的生命周期钩子函数有什么区别呢？1. v-show 控制隐藏或显示的组件，一进入就立即加载，执行 beforeCreate、created、beforeMount、mounted，中间切换显示和隐藏不会触发钩子函数 2. v-if 只有为 true 时，才会正常执行加载的钩子函数，否则不会加载。当切换时，实时挂载(created/mounted)、卸载组件(destoryed)。",
        "keywords": "v-if 与 v-show 钩子函数区别,v-if 与 v-show 区别"
      },
      {
        "title": "vue data 中以下划线开头的变量为 undefined, eslint 提示 Keys starting with '_' are reserved",
        "href": "2021/9/vue_data_underline.html",
        "time": "2021/09/09",
        "description": "在 vue 中，如果 data 中定义了以下划线开头的变量名，是无法获取到值的，一直是 undefined，为什么会这样呢？如果你安装了 eslint，会自动提示 Keys starting with '_' are reserved in '_test' group(vue/no-reserved-keys). 在官方文档 API 中有搜索 data 可以查到: 以 _ 或 $ 开头的 property 不会被 Vue 实例代理，因为它们可能和 Vue 内置的 property、API 方法冲突",
        "keywords": "vue data 中 _ 开头的变量为 undefined,data 下划线开头的变量,vue _ 开头的变量,vue  Keys starting with '_' are reserved"
      },
      {
        "title": "什么是 mvc, 什么是 mvvm, 怎么理解 mvc 与 mvvm，mvc 和 mvvm 有什么区别？",
        "href": "2021/9/mvc_vs_mvvm.html",
        "time": "2021/09/09",
        "description": "每个新技术的出现都有其历史原因，MVVM 也是如此。Vue 就是基于 MVVM 模式。那什么是 MVVM 构架模式，和 MVC 模式有什么区别呢？在介绍 MVVM 之前，我们先需要了解什么是 MVC 模式。在 ajax 技术没有出现之前，html 页面中发送 http 请求会刷新整个页面。页面内容强依赖后端接口响应的内容，于是催生了 jsp、php、asp 等前后端都耦合在一起的技术。下面来看一个实例",
        "keywords": "什么是 mvc,什么是 mvvm,怎么理解 mvc, mvc 与 mvvm 的区别,mvc,mvvm"
      }
    ],
    "计算机基础与开发工具": [
      {
        "title": "2020 vscode配置eslint保存后自动fix",
        "href": "2019/10/devtools_autofix.html",
        "time": "2019/10/12",
        "description": "2020/06/17更新，vscode最新eslint插件保存自动fix配置，vscode 保存执行fix, eslint 保存自动fix, vscode默认的autofix只能fix js格式文件(.js)，无法fix vue格式文件(.js)，怎么设置ctrl+s保存后自动fix呢？",
        "keywords": "vscode 保存自动fix,vscode 保存执行fix,eslint 保存自动fix,vscode 配置eslint保存后自动fix.md,vscode ctrl+s后自动fix,eslint 自动fix,vscode 自动fix,react vscode 自动保存,vscode *.ts 自动fix,eslint 保存的时候自动执行 --fix"
      },
      {
        "title": "eslint禁止在return语句中使用赋值",
        "href": "2019/10/devtools_eslint.html",
        "time": "2019/10/17",
        "description": "在项目中，有一次为了少写一行，将设置值和return语句写成了一行，发现eslint报错，为什么会有这个错误呢？下面我们来看看。",
        "keywords": "eslintno-return-assign,eslint禁止在return中使用赋值,no-return-assign, eslint no-return-assign"
      },
      {
        "title": "用mac做前端开发遇到的问题总结",
        "href": "2019/11/mac_dev.html",
        "time": "2019/11/04",
        "description": "在用mac开发的过程中，会遇到过一些问题，比如怎么显示文件的扩展名；mac隐藏文件 .DS_Store 对node遍历文件产生的影响；mac怎么修改环境变量；mac安装yarn的方法；mac加密zip文件；mac使用触控板来进行复制和拖动窗口等，下面来逐一介绍下。",
        "keywords": "小白用mac做前端,mac 隐藏文件 .DS_Store 对node遍历文件产生的影响,mac export PATH 后关闭termial就失效了,mac修改环境变量,macos安装Yarn方法,mac安装yarn方法,mac zip文件加密,mac显示文件扩展名,mac使用触控板拖动复制、移动窗口,mac三指拖动"
      },
      {
        "title": "jpg、png、bmp、gif图片格式区别，什么是webp？",
        "href": "2019/11/image_type.html",
        "time": "2019/11/05",
        "description": "在网页开发中一般用的都是png，现在比较流行或者说以后的趋势应该是webp，现有的一些图片格式都些有什么区别的？一般图片主要从两个方面来看：是否能无损压缩，图片大小、是否放大后不失真，下面来具体看看",
        "keywords": "jpg、png、bmp、gif图片格式区别,什么是webp"
      },
      {
        "title": "怎么使用Chrome断点调试功能，断点调试使用场景",
        "href": "2019/11/breakpoint.html",
        "time": "2019/11/07",
        "description": "在前端开发中，我们调试时一般都会使用console.log在控制台打log看程序执行情况，断点调试的功能好像用的比较少，那什么情况下就需要使用断点调试功能了呢？下面来讨论下",
        "keywords": "怎么使用Chrome断点调试功能,断点调试使用场景"
      },
      {
        "title": "函数命名validate和verify的区别",
        "href": "2019/11/validate_verify.html",
        "time": "2019/11/09",
        "description": "verify validate区别，一般我们在命名校验的函数时，发现validate和verify都有校验的意思，具体用那个呢？其实区别只是在于证实的强度：confirm < verify < validate，我们来看看",
        "keywords": "函数命名validate和verify的区别,verify validate区别,verify和validate,"
      },
      {
        "title": "什么是serverless",
        "href": "2019/11/serverless.html",
        "time": "2019/11/11",
        "description": "什么是serverless，最近在前端开发领域是一个比较火的概念，字面意思是无服务器，小程序云开发就是一种，主要是弱化服务器概念，把原来需要后端开发的内容搬到前端，让前端可以不用管数据库建表、部署方面的事情，写好代码一提交就可以自动生成对应的接口服务。",
        "keywords": "什么是serverless,serverless,severless是什么,serverless优点,serverless发展过程"
      },
      {
        "title": "什么是DevOps",
        "href": "2019/11/devops.html",
        "time": "2019/11/11",
        "description": "DevOps 是 Development（开发）和 Operations（运维） 的组合词，DevOps可以做什么？为什么会出现DevOps？企业为什么需要DevOps？DevOps有什么依赖？目前学术界和从业人员还没有为 'DevOps' 建立唯一的定义",
        "keywords": "DevOps"
      },
      {
        "title": "vscode 插件推荐，前端开发 vscode 常用插件",
        "href": "2019/11/vscode_plugin.html",
        "time": "2019/11/12",
        "description": "vscode 好用的插件推荐，在前端开发中，一般使用 vscode 来做开发，下面是一些开发中用的较多的插件推荐：Vetur、Vue VSCode snippets、GitLens、Preview on Web Server、ESLint 等",
        "keywords": "vscode好用的插件,vscode实用插件"
      },
      {
        "title": "文件结构目录树自动生成",
        "href": "2019/12/file_struct.html",
        "time": "2019/12/05",
        "description": "在我们写README.md时，如果需要描述一个文件的目录结构，就需要使用可以自动生成文件目录树的工具了，这里总结下一些实践经验",
        "keywords": "文件结构生成,文件目录树生成"
      },
      {
        "title": "以B站app为例实战Charles抓包以及将本地的H5代理到app内嵌H5运行",
        "href": "2019/12/b_charles.html",
        "time": "2019/12/18",
        "description": "当我们在开发app内嵌的H5页面时，怎么调试是一个问题。看内嵌H5运行时，接口的返回情况，可以使用Charles进行抓包查看，另外charles也可以将我们本地的H5页面直接代理到app内嵌H5里运行。这里以B站app为例，来进行相应的测试",
        "keywords": "Charles抓包,将本地的H5代理到app内嵌H5运行,charles,抓包,app内嵌H5调试技巧"
      },
      {
        "title": "function和method区别",
        "href": "2019/12/function_method.html",
        "time": "2019/12/13",
        "description": "在写程序时，你会发现function和method都代表函数，但他们又什么区别呢？function为函数，一般指外部定义的函数; method为方法，一般指类(class)内部的方法，类方法一般分为staic method，private method, instance method",
        "keywords": "function和method区别"
      },
      {
        "title": "为什么我们使用.html代替.htm?",
        "href": "2019/12/htm.html",
        "time": "2019/12/27",
        "description": "why do we use .html instead of .htm？DOS操作系统上文件后缀限制为3个字符，所以才会使用.htm的后缀，排除系统限制，所有的HTML文件应该使用.html的后缀名",
        "keywords": "为什么我们使用.html代替.htm,why do we use .html instead of .htm,.htm是什么文件类型"
      },
      {
        "title": "vscode中npm run dev提示端口被占用的问题",
        "href": "2019/9/devtools_vscode_bash.html",
        "time": "2019/09/30",
        "description": "vscode 提示端口被占用，vscode中npm run dev时提示端口被占用的问题, mac查看端口占用情况。vscode编辑器中npm run dev退出后依旧占用端口，vscode的console，有时候可能没关闭就开了新的terminal。",
        "keywords": "vscode中npm run dev时提示端口被占用,mac查看端口占用情况"
      },
      {
        "title": "当if else逻辑较多时可以使用策略模式",
        "href": "2020/1/if_else_handle.html",
        "time": "2020/01/08",
        "description": "当项目中，if else较多时，我们可以考虑使用策略模式，来更优雅的处理，来看看demo",
        "keywords": "js策略模式的使用场景"
      },
      {
        "title": "markdown里怎么为文字添加颜色，怎么画复杂表格",
        "href": "2020/1/markdown_html.html",
        "time": "2020/01/11",
        "description": "之前看markdown语法时，并没有添加颜色和复杂表格的方法，但最近了解到markdown里面可以直接使用html，那就方便了。复杂表格直接使用table标签画，如果想给文字加颜色，使用如下方法",
        "keywords": "markdown里怎么为文字添加颜色,markdown里怎么画复杂表格,markdown使用html时注意事项"
      },
      {
        "title": "开源许可MIT等具体含义",
        "href": "2020/1/os_licence.html",
        "time": "2020/01/30",
        "description": "一般新建一个开源仓库时，需要确定开源协议。之前习惯是MIT，就是别人拿去干什么都可以。对于一些需要控制他人使用的就需要其他协议了。阮一峰博客里有一张图来解释很清晰明了",
        "keywords": "开源许可MIT等具体含义,开源许可licence含义"
      },
      {
        "title": "怎么开发vscode插件?",
        "href": "2020/10/vscode_plugin.html",
        "time": "2020/10/08",
        "description": "在vue-cli项目中，每次修改vue.config.js都需要手动停止在运行，怎么一键就搞定呢？能不能开发个vscode插件，带着这个问题，来看看vscode插件的开发。直接找vscode官方教程。按照文档先来跑一个hello word",
        "keywords": "vscode插件"
      },
      {
        "title": "什么是好的代码？",
        "href": "2020/10/good_code.html",
        "time": "2020/10/08",
        "description": "在web前端方面，什么是好的代码？好的代码应该包含以下两个特性：高性能，低时延（性能优化），熟悉数据结构与算法，减少时间复杂度或空间复杂度，悉浏览器渲染基本原理、熟悉HTTP请求与响应细节、熟悉前端框架源码、减少不必要的渲染开销，提高加载速度。可读性、可维护性、可扩展性",
        "keywords": "前端什么是好代码,什么是好的代码"
      },
      {
        "title": "mac设置vscode默认打开的浏览器",
        "href": "2020/10/mac_default_browser.html",
        "time": "2020/10/25",
        "description": "vscode中，安装 Live Server 插件后，在html文件里，右键 open with Live Server，可以将网页使用http服务在浏览器里面打开。我电脑里面默认打开的是 safari，但我一般习惯用Chrome，这个默认浏览器的设置需要在mac系统里设置，点击屏幕左上角苹果标志 => 系统偏好设置 => 通用 => 默认网页浏览器 选择 Google Chrome 即可",
        "keywords": "vscode默认浏览器,mac设置默认浏览器"
      },
      {
        "title": "mac安装nginx在官网下载与使用brew下载的区别",
        "href": "2020/10/nginx_install.html",
        "time": "2020/10/31",
        "description": "nginx官网直接下载的包，mac下可以直接进入该目录使用，但没有加到环境变量，不能在Terminal的任何目录下直接使用。如果使用 `brew install nginx` 安装，他会直接都安装好，并修改环境变量。可以使用which nginx来看具体的地址",
        "keywords": "mac nginx安装方法,mac nginx"
      },
      {
        "title": "svn: error: The subversion command line tools are no longer provided by Xcode",
        "href": "2020/10/svn_error.html",
        "time": "2020/10/31",
        "description": "在新的macos系统中，xcode不再集成svn，需要自己安装。可以使用 `brew install svn` 进行安装。一般 brew 安装前，需要替换源，会快一点，参考：[mac安装brew下载慢，安装异常，切换成ruby-china源](http://www.zuo11.com/blog/2020/10/brew_slow.html)",
        "keywords": "svn error,mac svn安装"
      },
      {
        "title": "mac安装brew下载慢，安装异常，切换成ruby-china源",
        "href": "2020/10/brew_slow.html",
        "time": "2020/10/31",
        "description": "mac下使用brew可以很方便的安装svn、nginx等常用的工具。什么是brew [bruː]，它的全称是 [Homebrew](https://brew.sh/)，The Missing Package Manager for macOS (or Linux)。它可以安装macOS或linux下没有的包(Package)。一般使用ruby来安装",
        "keywords": "brew下载慢,brew切换ruby源,brew安装异常"
      },
      {
        "title": "eslintignore不生效, vscode eslint插件不同版本有差异的问题",
        "href": "2020/11/eslintignore_vscode.html",
        "time": "2020/11/08",
        "description": ".eslintignore 文件的作用是，当不想对项目的某个目录进行 eslint 检查时，可以在这个文件中声明，类似 .gitignore 文件的效果。但有一个问题，vscode eslint插件不同版本的行为可能有差异，有可能把目录加入到了.eslintignore 后，保存时还是会 fix 这个目录下的 eslint 错误。这种情况建议升级到最新版本。",
        "keywords": ".eslintignore不生效,vscode eslint插件不同版本差异"
      },
      {
        "title": "mac下怎么截取屏幕gif图：Gifox",
        "href": "2020/11/mac_gif_tools.html",
        "time": "2020/11/08",
        "description": "之前在 windows 下用过一款比较好用的免费 gif 工具。后面在 mac 上，就没怎么做 gif 图了。最开始在 mac 上尝试做 gif 图是使用 QuickTime 录制屏幕后，再搜索在线视频转 gif 图的网站进行转换，比较麻烦。最近发现一个比较好的软件 [Gifox](https://gifox.io/)，我使用的是免费版的，有水印，最大长度限制为10s。升级付费的版本可以去水印(watermark)，且没有10s限制。它功能强大，录制gif很方便",
        "keywords": "mac gif,mac好用的gif工具,mac做gif图"
      },
      {
        "title": "Chrome DevTools Network Waterfall 瀑布图各阶段详解",
        "href": "2020/11/chrome_waterfall.html",
        "time": "2020/11/23",
        "description": "在Chrom调试工具Network tab下，每个请求都有一个Waterfal diagrams(瀑布图)，点击具体接口，Timming(时序)位置会有具体描述。它记录了网络请求各个阶段的耗时，可以用于分析页面加载性能。Timing breakdown phases explained（时序分解阶段明细）。Here's more information about each of the phases you may see in the Timing tab:（下面是在Timing标签页中能看到的各个阶段的更多信息）",
        "keywords": "chrome瀑布图,Timming时序图"
      },
      {
        "title": "vscode配置了自动fix突然失效了，或者一直生效不了，怎么看对应的log",
        "href": "2020/12/vscode_eslint_log.html",
        "time": "2020/12/07",
        "description": "你是否会遇到下面的问题：在 vscode 里面安装了 eslint 插件后，正确设置了保存后自动 fix 参数，但没有生效。或者之前是生效的。忽然就不生效了。只要你的配置是没有问题的，那就是插件以来的包加载异常了，一般都重启几次就Ok了。那怎么看 eslint 对应的log呢？可以分下面两步 1. 点击 vscode 右下角的错误信息、警告信息图标，看是信息里是否有 eslint 相关报 2. 点击 输出 - 选择 ESLint 就可以看 ESLint 相关 log 了。",
        "keywords": "vscode eslit log"
      },
      {
        "title": "前端低代码框架 amis，通过 JSON 配置生成页面",
        "href": "2020/12/low-code-amis.html",
        "time": "2020/12/30",
        "description": "什么是低代码开发平台？ (LCDP，Low-Code Development Platform)，是无需编码（0代码）或通过少量代码就可以快速生成应用程序的开发平台。对于比较简单的、通用的页面可以自动生成代码。amis 就是这样的一个框架。可以根据 JSON 配置，自动生成页面，而且还支持在线可视化编辑。对于简单、通用、不需要定制化开发的情况，可以直接使用。",
        "keywords": "低代码开发平台,amis,根据json生成页面"
      },
      {
        "title": "使用new Date()在前端获取当期时间是不准确的",
        "href": "2020/6/new_date_fe.html",
        "time": "2020/06/21",
        "description": "一般我们在前端开发中，经常会用到new Date()来获取当前时间，但我们要知道：new Date()是获取的当前操作系统的时间，它是不准确的？",
        "keywords": "前端获取当前时间是不准确的,new Date()获取当前时间不准确,new Date()获取当前时间是当前操作系统的时间"
      },
      {
        "title": "github tag标签图片以及npm badge图片生成",
        "href": "2020/6/github_badge_img.html",
        "time": "2020/06/21",
        "description": "在github写readme时，最开始一般会贴一些tab标签(徽章图片)，比如 build passing，license MIT 等，注意这些都是引入的图片，npm badge也是类似的情况下面来看看",
        "keywords": "github tag标签图片,readme badge,npm badge"
      },
      {
        "title": "markdown里怎么加引用注释或脚注",
        "href": "2020/7/md_ref.html",
        "time": "2020/07/06",
        "description": "一般我们只是在markdown添加链接，但怎么在markdown里加脚注呢？下面来看看",
        "keywords": "md添加脚注,markdown里怎么加引用注释或脚注,markdown脚注,md脚注"
      },
      {
        "title": "md5加密是可逆的吗",
        "href": "2020/7/md5_reverse.html",
        "time": "2020/07/06",
        "description": "理论上md5加密后，在不知道原始消息的前提下，是无法凭借16个字节的消息摘要（Message Digest），还原出原始的消息的.但为什么有些网站可以破解md5加密后的密码呢？主要是使用的碰撞检测。它会提前算出一些常用弱密码的md5值，一个个比较。才会让人产生md5可逆的错觉。一般除了md5加密外，我们可以再多进行一些处理(加盐)，来进行干扰，提高破解难度",
        "keywords": "md5是否可逆,md5逆向,md5解密"
      },
      {
        "title": "两个不同文件md5可能一样吗",
        "href": "2020/7/file_md5.html",
        "time": "2020/07/06",
        "description": "我们先来看看什么是md5？md5 是 messge digest [daɪˈdʒest] 5 的缩写，意思是信息摘要算法，两个不同文件md5是有可能相同的，因为md5最多只能表示2的128次方种情况，而不同的文件绝对大于这个数。虽然两个文件的md5可能一致，但给定一个文件的md5值，想伪造另一个文件的md5值与该值一样，相对还是比较困难的，因此可用于判断文件完整性",
        "keywords": "两个不同文件md5可能一样吗,md5一样的文件存在吗,md5一样的文件"
      },
      {
        "title": "根据文件名后缀判断文件类型不准确，那怎么判断两个文件一模一样呢",
        "href": "2020/7/file_same.html",
        "time": "2020/07/06",
        "description": "一般根据文件名后缀判断文件类型不准确，比如我有个1.png文件，我修改下后缀名 1.txt，那前端如果仅凭文件名的后缀来显然是不行的，我们需要根据文件类型的二进制数据标记来判断对应的文件类型，这样才会更加准确，安全性更高",
        "keywords": "怎么判断两个文件一样,文件一致性检验,根据文件名后缀判断文件类型是不准确的"
      },
      {
        "title": "腾讯云慧眼架构相关设计学习",
        "href": "2020/7/txy_frame_study.html",
        "time": "2020/07/26",
        "description": "昨晚看了一个关于腾讯云慧眼架构相关的分享，由于之前参与过该项目的一些开发，对业务比较了解。结合业务场景再来看构架设计，会有一种豁然开朗的感觉，下面对一些构架方面比较好的点做一个总结",
        "keywords": "腾讯云慧眼架构相关设计学习,构架"
      },
      {
        "title": "WebSocket的使用场景",
        "href": "2020/8/websocket_scene.html",
        "time": "2020/08/10",
        "description": "WebSocket是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议。之前在工作中基本没用到过，今天偶然看到一个网站，他里面列出了WebSocket的几种使用场景，如下：在线多人点菜、远程画版同步、在线选座、游戏 (只要涉及到多人对战、协同的就需要用到)、扫码登录/支付、IM 聊天",
        "keywords": "WebSocket的使用场景,websocket可以做什么"
      },
      {
        "title": "为什么要写单元测试",
        "href": "2020/8/why_unit_test.html",
        "time": "2020/08/10",
        "description": "20/04/30日发版，持续到到今天凌晨2点左右，测试发现有个bug：时间区间组件DatePicker前面一个时间没有显示，而这里应该显示最近一周的时间区间，现在只显示了后面一个时间。但测试环境测试、UAT测试都是过了的，怎么突然就有问题了呢？于是看同事的代码定位问题，发现根据当前时间计算最近一周的日期逻辑有问题，只是简单粗暴的把 day 减了 6 天，之前一直是4月中下旬，大于6，所以没有出问题，这次正好是5月1号， 1 - 6 就是 -5 了, 时间拼接为 2020-05-0-5，这就导致有bug了。还好今天是5月1号，不然测不出这个bug就会导致后面生成环境的bug了。",
        "keywords": "为什么要写单元测试,单元测试有什么好处"
      },
      {
        "title": "怎么看chrome浏览器更新记录及内容",
        "href": "2020/8/chrome_update_log.html",
        "time": "2020/08/10",
        "description": "最近发现办公电脑的chrome浏览器console里不支持 ?? 运算符，而我自己的电脑就可以，对比了下版本，我的是最新的81版本，而办公电脑还是71的版本，于是我就想看看chrome每次版本的更新记录，这个貌似要翻墙，我用了一个开源的chrome访问助手，找到了对应的位置",
        "keywords": "怎么看chrome浏览器更新记录及内容,怎么看chrome浏览器每个版本更新了什么"
      },
      {
        "title": "macOS下怎么将mp4和m4a文件合并",
        "href": "2020/9/m4a_m4a_merge.html",
        "time": "2020/09/07",
        "description": "mp4 m4a合并,mp4 m4a,音视频合并, 可以使用ffmpeg命令行工具，输入如下命令进行合并，注意这个合并时间非常长，要等很久，下载ffmpeg解压后会有一个ffmpeg-4.2.3-macos64-static文件夹，然后进入这个目录的bin目录下，执行 ./ffmpeg -i /Users/kevin/Desktop/17下.mp4 -i /Users/kevin/Desktop/17下.m4a out2.mp4，其实合并视频和音频可以使用mac下的imovie或者一些其他的视频剪辑软件，比这个要快很多",
        "keywords": "mp4 m4a合并,mp4 m4a,音视频合并"
      },
      {
        "title": "iMovie剪辑的视频没有全屏显示，上下被截断的解决方法",
        "href": "2020/9/iMovie_not_fullscreen.html",
        "time": "2020/09/12",
        "description": "iMovie视频没有全屏,iMovie视频上下被截断，使用iMovie剪辑视频时，直接点击视频预览时ok的，但把视频拖动到iMovie时间轴后, 就不是全屏的了。屏幕上方和下方被截断了，注意这种情况，需要在时间轴，选中视频，然后在预览器，点击 '全部还原'，就可以了。",
        "keywords": "iMovie视频没有全屏,iMovie视频上下被截断"
      },
      {
        "title": "obs录制视不是全屏、录制视频模糊的问题",
        "href": "2020/9/obj_issue.html",
        "time": "2020/09/12",
        "description": "obs录制视频不是全屏的问题,obs录制视频模糊的问题，1. obs录制视不是全屏的问题, 解决方法：打开OBS => 点击顶部 '编辑' 按钮 => 选择 '变换' => 点击比例适配屏幕，2. obs录制视频模糊的问题 解决方法，右键显示捕获，选择调整输出大小到源大小，正常情况下是可以点击的。这里因为我已经设置了，且正在推流、录制，就是灰色的了。",
        "keywords": "obs录制视频不是全屏的问题,obs录制视频模糊的问题"
      },
      {
        "title": "什么是 BDD 风格（BDD style）",
        "href": "2021/1/bdd-style.html",
        "time": "2021/01/12",
        "description": "在 Mocha 官网的中，介绍 should.js 时，说它是一种 BDD 风格的断言库。而且在 mocha 的源码中，有很多都是以 bdd 命名的。那什么是 BDD 呢？BDD 是 Behavior Driven Development 的简写，行为驱动开发，是在测试驱动开发（Test-Driven Development，TDD）基础上发展而来的一种软件开发方法。",
        "keywords": "BDD,TDD,BDD Style"
      },
      {
        "title": "mac 安装 brew 异常: fatal: unable to access 'https:--github.com-Homebrew-brew-'",
        "href": "2021/4/mac_brew_new.html",
        "time": "2021/04/03",
        "description": "为了快速安装 svn, git, nginx 等，我想着先在 macbook 上安装 brew，按照常规的方法修改了 ruby 源，但还是出现安装错误 `fatal: unable to access 'https://github.com/Homebrew/brew/' LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 Failed during: git fetch --force origin` ",
        "keywords": "mac安装brew fail,mac 安装 brew,mac homebrew 安装失败"
      },
      {
        "title": "git xcrun: error: invalid active developer path",
        "href": "2021/4/git_xcrun_error.html",
        "time": "2021/04/03",
        "description": "在 mac 下输入 git 命令，突然提示 xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun，可能是没有安装 xcode，有些功能没有的原因。一般可以通过运行 `xcode-select --install` 命令来解决，按照提示完成安装，就 OK 了",
        "keywords": "git xcrun error,invalid active developer path"
      },
      {
        "title": "vscode 下载太慢，vscode 官网下载太慢解决方法",
        "href": "2021/4/vscode_download_slow.html",
        "time": "2021/04/03",
        "description": "在 vscode 官网下载 vscode 时，发现非常慢，过会儿就下载失败了。如下图，为了解决这个问题，我们可以在下载中，找到对应的下载链接将 url 前面的域名修改为其他源，这样下载会很快。如下图，将 vscode 官网默认下载 url 前面的路径改为 `vscode.cdn.azure.cn` 即可。参考: [国内下载vscode速度慢问题解决 - 知乎](https://zhuanlan.zhihu.com/p/112215618)",
        "keywords": "vscode下载慢,vscode官网下载慢,vscode download slow"
      },
      {
        "title": "vscode terminal 中 the term 'node' is not recognied",
        "href": "2021/4/not_recognied_terminal.html",
        "time": "2021/04/03",
        "description": "windows 系统下，在 vscode 的 Terminal 中，运行 npm install 或 node 命令时都会提示 the term node/npm is not recognied... 但是如果打开系统的 terminal 运行命令就是正常的。仔细看会发现 vscode 中使用的是 Powershell，而一般默认的 bash。Powershell 中无法执行 node 命令，需要运行下面的命令更新环境变量中的 Path",
        "keywords": "the term 'node' is not recognied,the term 'npm' is not recognied"
      },
      {
        "title": "import 出现黄色警告提示，ESLint is disabled since its execution has not been approved",
        "href": "2021/4/eslint_auth.html",
        "time": "2021/04/03",
        "description": "在有 ESLint 的项目中，发现 import 都出现了黄色警告，提示 ESLint is disabled since its execution has not been approved or denied yet. Use the light bulb menu to open the approval dialog.eslint。这是因为初次打开项目，没有 eslint 授权产生的错误提示。点击 vscode 开发工具右下角的 ESLint 就会弹出授权窗口，点击允许即可。",
        "keywords": "ESLint 授权弹窗,eslint auth dialog"
      },
      {
        "title": "提示 hints、tips、prompt 以及 message 的区别",
        "href": "2021/4/tips_hints.html",
        "time": "2021/04/11",
        "description": "在程序开发中，关于提示组件的命名，有 tips、hints、prompt、message 等，一般怎么使用呢？下面来看看  tips，n. 小贴士、温馨提示、小窍门。主要用于文字提示，比如 tooltip 组件。 hints，n. 暗示、提示，v. 暗示、示意。开发中用的较少，相比于 tips，它有间接含蓄, 暗示，不直接提示的意思。",
        "keywords": "hints和tips区别,提示命名,提示 英文,提示 英语"
      },
      {
        "title": "Vscode Live Server 插件 Open With Live Server 没反应，无法打开浏览器",
        "href": "2021/5/live_server_file.html",
        "time": "2021/05/04",
        "description": "在调试单个 html 文件时，可以使用 Live Server 插件，快速开启 http 服务，并打开当前页面。但目前这个插件可能会出现没反应，打不开的情况，可以使用 **Preview on Web Server** 来代替。使用方法基本一致，右键可以选择浏览器打开，或者在 vscode 侧边栏预览",
        "keywords": "live server 没反应,live server 无法打开浏览器"
      },
      {
        "title": "mac 其他文件怎么清理，使用免费的腾讯柠檬清理代替 CleanMyMac",
        "href": "2021/9/mac_clean.html",
        "time": "2021/09/09",
        "description": "mac 存储空间里面的其他文件占用较多，它主要是一些碎片文件、缓存等，一般不通过工具软件很难清理。如下图：mac 清理工具中，CleanMyMac 算是比较知名的一个，但它是收费的，这里介绍一款国产免费的清理工具 - 腾讯柠檬清理，关于柠檬清理与其他同类产品的对比，官方写了一遍总结，可以看看",
        "keywords": "mac others clean,mac clean, mac 其他清理,mac 其他文件清理,mac 其他文件怎么清理,mac 垃圾清理软件"
      }
    ],
    "前端工程化": [
      {
        "title": "什么是yarn",
        "href": "2019/11/yarn.html",
        "time": "2019/11/15",
        "description": "Yarn 是一个快速、可靠、安全的依赖管理工具。是 NPM 的替代品。今天看看了ts实战指南这本书，里面是这样介绍Yarn的：Yarn [jɑːn] 是facebook，google等公司共同开发的一款新的js包管理工具，并没有试图完全取代npm，Yarn同样是从npm获取包。存在的目的是：解决团队使用npm面临的少数问题，如版本锁定，并行安装、文案输出等",
        "keywords": "什么是yarn,yarn基本用法,macos安装yarn"
      },
      {
        "title": "failed at the phantomjs-prebuilt@2.1.16  intsall script",
        "href": "2019/12/phantomjs-prebuilt.html",
        "time": "2019/12/04",
        "description": "从远程仓库拉取代码，npm install，发现提示failed at the phantomjs-prebuilt@2.1.16 intsall script，怎么解决呢？ 使用 npm install —ignore-scripts** 忽略package.json中设置的脚本，意思就是避免package.json中的脚本影响包的正常安装。The --ignore-scripts argument will cause npm to not execute any scripts defined in the package.json. See npm-scripts.",
        "keywords": "failed at the phantomjs-prebuilt@2.1.16  intsall script"
      },
      {
        "title": "can't find module node_sleep.node",
        "href": "2019/12/node_sleep_module.html",
        "time": "2019/12/04",
        "description": "can't find module './build/Release/node_sleep.node'，看了具体报错是sleep包引起的，到node_modules里面对应的目录查看，发现根本就没有build目录，解决方法：之前的版本是5.2.4，修改package.json将版本改为5.1.1，让后删除package-lock.json 再npm install就ok 了",
        "keywords": "can't find module './build/Release/node_sleep.node'"
      },
      {
        "title": "npm设置下载源",
        "href": "2019/12/npm_resource.html",
        "time": "2019/12/04",
        "description": "npm设置下载源，在设置npm下载源之前，我们先来看看怎么查看当前npm的下载源，npm config list 可以查看当前npm配置项，包括源(registry)信息，npm config set命令可以设置对应npm源",
        "keywords": "npm设置下载源,npm查看当前配置"
      },
      {
        "title": "npm查询包信息以及安装指定版本",
        "href": "2019/12/npm_package_info.html",
        "time": "2019/12/17",
        "description": "当我们需要安装某个npm包的指定版本时，我们可以使用 npm view 先查看某个包的一些版本信息，npm install时，可以通过在包名后面加@版本号来指定安装对应的版本",
        "keywords": "npm查询包信息,npm安装指定版本,npm install以及加参数后的一些区别"
      },
      {
        "title": "node path.resolve()",
        "href": "2020/1/node_path.html",
        "time": "2020/01/10",
        "description": "koa静态文件服务中间件的实现里，需要将当前路径 __dirname 与用户传入的路径合并为一个绝对路径，就可以使用path.resolve函数",
        "keywords": "node path.resolve,node路径处理"
      },
      {
        "title": "npm install简写为npm i安装包时项目文件名与包名冲突不报异常的问题",
        "href": "2020/1/npm_i.html",
        "time": "2020/01/14",
        "description": "最近在安装 npm install 时喜欢简写 npm i mysql2 -s 但发现执行后，并没有安装成功，在package.json里也没有任何记录。还没有报任何错误。",
        "keywords": "npm install简写为npm i注意事项,npm init -y注意事项"
      },
      {
        "title": "node遍历文件夹下的文件再require对应的文件出错，要注意.DS_Store隐藏文件",
        "href": "2020/1/node_for_DS_Store.html",
        "time": "2020/01/16",
        "description": "在使用koa mock接口时，一个模块有很多接口，就写了十几个js，每个js对应一个接口数据。如果每增加一个接口，再添加一个require就很麻烦，于是写了个index.js来遍历文件夹，进行动态引入。以后写好js，就不用再手动require了。之前都运行正常的，最近再运行时发现一直报错，require异常。后来打印遍历的fileName，发现居然有 .DS_Store 文件，require这个文件时错误。这个文件属于mac系统自动生成的文件，之前都没有的。在程序中过滤调这个文件即可。",
        "keywords": "node遍历文件夹下的文件时需要过滤.DS_Store隐藏文件"
      },
      {
        "title": "静态博客生成系统(一)：JS怎么将markdown文件转html",
        "href": "2020/1/zuoblog_1_md.html",
        "time": "2020/01/29",
        "description": "其实早在18年12月，我就已经写好了最简的demo，使用的是marked这个工具。本来准备将博客静态化的，但后来就没继续了，这里来说下方法",
        "keywords": "怎么用js将markdown转html,markdown转html文件"
      },
      {
        "title": "用node实现发送包含echarts图表的邮件",
        "href": "2020/10/node_email.html",
        "time": "2020/10/08",
        "description": "在之前我用node研究过怎么收发邮件，但没有研究过邮件里面是否能包含图表，这次来研究下。首先，我们来看看怎么发邮件，准备工作：配置发件人邮箱 我们发送邮件，首先需要有一个邮箱作为发件人，以QQ邮箱为例，我们发邮件使用 `916707888@qq.com` 作为发件人，我们需要使用程序自动发邮件，所以需要配置发邮件的服务，开启发邮件的POP3/SMTP服务，得到授权码在操作，下面来看看具体过程",
        "keywords": "node发邮件,node发送图表邮件,node发送echart图表邮件"
      },
      {
        "title": "npm run 运行多条命令 && 不生效的问题",
        "href": "2020/10/npm_run_multi.html",
        "time": "2020/10/25",
        "description": "在项目中除了默认的 webpack-dev-server 外，我们还想同时运行 mock 接口的 node 服务，，会使用 && 同时执行两条命令。在有些使用实际运行 npm run server 时，只运行了第一条命令，我的是mac，不知道是不是node版本的问题。网上找了下， && 存在兼容性问题。建议使用 concurrently 来代替，concurrently 跨平台兼容",
        "keywords": "npm run &&多条命令不生效"
      },
      {
        "title": "npm install -g或者npm link需要sudo的问题",
        "href": "2020/10/npm_sudo.html",
        "time": "2020/10/31",
        "description": "在mac下，安装node后，会出现两个命令 npm 和 node，再使用 npm install -g 时，默认需要管理员权限，可以再前面加 sudo 以管理源方式运行即可。如果在开发 npm 包的时候。如果开发对应的命令程序，测试时需要在当前目录执行 npm link，这里也需要加 sudo。",
        "keywords": "sudo npm install -g,sudo npm link,npm link执行报错,npm install -g执行报错"
      },
      {
        "title": "不全局安装npm包，怎么在项目目录下局部执行对应的命令",
        "href": "2020/11/npm_cmd_part.html",
        "time": "2020/11/08",
        "description": "一般在 Vue 开发中，vue 命令可以执行，是因为全局安装了 `@vue/cli` npm包。假设你无法使用 npm install -g 全局安装，那怎么在当前项目所在的目录运行对应的命令呢？这里我们使用 zuo-util 这么 npm 包来介绍 3 种在项目种运行 npm 包命令的方法：1. npm run xxx 2. npx 命令 3. ./node_modules/.bin/命令",
        "keywords": "局部执行npm包命令,不全局安装npm包，怎么在项目中运行命令,局部执行命令"
      },
      {
        "title": "AMD、UMD、CommonJS、ES Modules的理解",
        "href": "2020/11/amd_umd_commonjs.html",
        "time": "2020/11/23",
        "description": "在 ES6 之前，JS 本身没有模块功能，社区出现了 CommonJS 和 AMD 等模块方案。从 ES6 开始, JS 开始原生支持模块，一般称之为 ES Modules。- CommonJS: 主要用于服务端，是 node 中使用的 require、module.exports。从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。但需要采用 .mjs 后缀文件名。如果不希望将后缀名改成.mjs，可以在项目的package.json文件中，指定type字段为module。- AMD: Asynchronous Module Definition，异步模块定义，主要用于客户端(浏览器)，以 RequireJS 为代表 define、require -  UMD: Universal Module Definition，通用模块定义模式，主要用来解决 CommonJS 模式和 AMD 模式代码不能通用的问题，并同时还支持老式的全局变量规范。",
        "keywords": "AMD,UMD,CommonJS,ES Modules"
      },
      {
        "title": "pm2 process.yml You cannot define a mapping item when in a sequence",
        "href": "2020/11/pm2_map.html",
        "time": "2020/11/23",
        "description": "使用 pm2 运行 node 项目，`pm2 start process.yml` 后提示 You cannot define a mapping item when in a sequence，是 process.yml 配置文件的问题，修改下配置文件即可。将 `- script: app.js` 改为 `script: app.js` 重新运行就可以了",
        "keywords": "pm2 process.yml"
      },
      {
        "title": "Vue CLI build --target lib 时如何避免打包成多个umd.js文件",
        "href": "2020/11/vue_umd_multiple.html",
        "time": "2020/11/30",
        "description": "Vue CLI 项目中，一般我们使用的是 npm run build 来构建项目，并发布到线上。当我们写组件/工具库的时候，就需要使用 `--target lib` 参数了。打包成库（Library）与普通的构建应用不一样，它会在 dist 目录下生成对应的 umd.js 文件，也就是通用模块定义的 js 文件。一般用于组件/工具库的入口文件，我们可以在静态 html 以及 Vue CLI 等项目中直接引入并使用。如果不进行构建，只能在 Vue CLI 项目中使用，无法引入一个 js 直接使用。",
        "keywords": "怎么避免生成多个umd.js,如何避免打包成多个umd.js"
      },
      {
        "title": "lodash.js 打包后默认是整包，怎么按需打包，减少包体积",
        "href": "2020/11/loadsh_as_demand.html",
        "time": "2020/11/30",
        "description": "在 vue-cli 打包 lib 项目时，发现包体积较大有 600多KB，于是使用 `-- report` 参数看具体是哪个包较大，发现尽管只用到了 lodash 的一个函数，但打包体积却有几百k，如下图，应该是整包打的，没有按需打包。 以下是 打开 lib/项目名.umd-report.html 后，显示的各模块大小示意图。这里借助 babel 的 loadsh 插件来进行按需打包。如果没有babel的配置文件，新建 .babelrc 文件，加入如下内容：",
        "keywords": "loadsh按需打包,loadsh tree shaking,loadsh摇树"
      },
      {
        "title": "两种方法解决Error: Cannot find module 'webpack-cli-bin-config-yargs'",
        "href": "2020/12/webpack_dev_server_err.html",
        "time": "2020/12/07",
        "description": "两种方法解决Error: Cannot find module 'webpack-cli/bin/config-yargs', 在运行 webpack-dev-server 这个命令时，如果出现了 Error: Cannot find module 'webpack-cli/bin/config-yargs' 这个错误，是因为默认情况下 webpack-dev-server 执行依赖 webpack-cli 包目录下的 bin/config-yargs，但 webpack-cli 4.1.0 的版本，做了一些调整，删除了这个文件，导致了这个错误。",
        "keywords": "Error: Cannot find module 'webpack-cli/bin/config-yargs'"
      },
      {
        "title": "静态博客生成系统(二)：markdown大纲提取以及页面滚动到对应区域时高亮处理",
        "href": "2020/2/zuoblog_2_outline.html",
        "time": "2020/02/02",
        "description": "在考虑把个人博客站点静态化时，其中一个原因是markdown的大纲显示比较好，文章结构层次分明，可以更好的阅读。那怎么提取markdown文件的大纲数据，并呈现在网页上呢？下面来看看zuo-blog是怎么处理的。",
        "keywords": "提取markdown文件的大纲结构数据,markdown大纲提取,mardown目录提取,根据大纲数据生成html,页面滚动时，自动切换大纲focus,怎么监听页面滚动到了某个标题区域"
      },
      {
        "title": "静态博客生成系统(三)：node复制或删除文件夹以及npm包命令执行时所在路径获取",
        "href": "2020/2/zuoblog_3_file.html",
        "time": "2020/02/02",
        "description": "静态博客生成系统，需要把src目录下的源文件生成dist目录下的可部署的文件，对于资源文件需要从src下直接拷贝过去。这就涉及怎么用node复制或删除文件夹了，另外我们在使用zuoblog init执行构建生成时，需要知道命令执行时所在的路径，下面来看看",
        "keywords": "node复制或删除文件夹,npm包命令执行时所在路径获取"
      },
      {
        "title": "node中的4种模块类型",
        "href": "2020/2/node_module_type.html",
        "time": "2020/02/04",
        "description": "Node.js的模块化使用CommonJS规范：module.exports导出，require引入。在node中你会发现使用某个模块时，有时候需要require，有时候不需要；有时候需要npm install，有时候不需要，这是为什么呢？下面来看看",
        "keywords": "node中的4种模块类型,node中使用某个模块时为什么有的模块需要require，有的模块又不需要，有的需要npm install，有的又不需要"
      },
      {
        "title": "Node.js、js、v8三者之间的关系",
        "href": "2020/2/node_js_v8.html",
        "time": "2020/02/04",
        "description": "Node.js 提供了JS运行时（运行js的环境，类似的概念有JRE提供了运行java的环境）。Node.js通过内部集成Chrome V8引擎来解析执行js，Node.js除了解析执行js外，还包含其他功能，比如浏览器里js无法操作文件、无法开启http服务器、而Node.js里可以，主要是因为Node.js里面扩展加入了很多功能。比如使用libuv，提供了文件系统、网络、子进程、管道、信号处理、轮询、流等功能；使用llhttp提供了HTTP解析功能；使用OpenSSL提供tls、crypto加密相关功能等等",
        "keywords": "node.js和js的区别,node.js v8 js之间的关系"
      },
      {
        "title": "koa ctx.body写在异步里接口会返回404的问题",
        "href": "2020/2/koa_async_404.html",
        "time": "2020/02/26",
        "description": "在前端mock上传的接口时，发现总是404，刚开始以为是代理的问题，后来单独写了个demo，发现如果ctx.body放在异步的回调，后端接收到请求了，但还是会返回404，下面来具体研究下",
        "keywords": "koa接口404,ctx.body写在异步操作里404"
      },
      {
        "title": "怎么使用一条命令安装多个npm包",
        "href": "2020/2/npm_install_multiple.html",
        "time": "2020/02/26",
        "description": "在安装npm包时，我们一般使用 npm install xx --save，但对于一次需要安装多个包的情况，怎么用一条命令来安装呢？下面来看看",
        "keywords": "怎么使用一条命令安装多个npm包,一条命令安装多个npm包"
      },
      {
        "title": "webpack与parcel区别",
        "href": "2020/6/webpack_parcel_difference.html",
        "time": "2020/06/29",
        "description": "webpack与parcel都是打包工具, webpack功能强大，但比较重，配置项比较多, 有点繁琐。而parcel就是为了解决配置项太多这个问题的，它默认集成了通用的常规功能，零配置，如果自定义较多，还是推荐webpack",
        "keywords": "webpack与parcel区别,parcel与webpack区别,webpack parcel difference"
      },
      {
        "title": "Node.js的核心用处及应用场景",
        "href": "2020/6/nodejs_uses.html",
        "time": "2020/06/29",
        "description": "Node.js是一个基于chrome v8引擎的js运行时，那他一般有什么用处呢，下面来看看。node三个核心应用场景：1.打包构建、工程化 2.写后台接口 3.综合应用：获取数据+渲染页面(高并发、高性能)",
        "keywords": "Node.js的核心用处及应用场景,node使用场景,node应用场景,node应用"
      },
      {
        "title": "npm包前面加@是什么意思(vue-cli与@vue-cli的区别)",
        "href": "2020/7/npm_scope.html",
        "time": "2020/07/06",
        "description": "今天看vue-cli文档，发现了下面的这段话 vue-cli 改为了 @vue/cli，这两个npm有什么区别呢？npm包前面加@是什么意思呢？查了下官网，npm包前面加@，代表scopes相关的包，可以理解为作用域(范围)包，作用域使我们可以创建与其他用户或组织创建的包同名，而不会发生冲突。A scope allows you to create a package with the same name as a package created by another user or Org without conflict.",
        "keywords": "npm包前面加@是什么意思,vue-cli与@vue/cli的区别"
      },
      {
        "title": "koa-multer与@koa-multer逻辑差异",
        "href": "2020/7/koa-multer.html",
        "time": "2020/07/06",
        "description": "之前有了解过以@开头的作用域包，这次在使用koa-multer这个模块时，发现@koa/multer与koa-multer的逻辑居然不一样。源码有些差异，下面来具体看看。koa-multer这个包是从express的multer包上面加了一层封装，而koa-multer并没有把fileds字段挂载到ctx.request.body上，只维持原来express那样挂载到node的request对象上，也就是ctx.req.body，来看看koa-multer的源码部分",
        "keywords": "koa-multer与@koa/multer逻辑差异"
      },
      {
        "title": "为什么会有Node.js，其衍生框架Express、Koa、Egg.js的演进过程",
        "href": "2020/8/why_node.html",
        "time": "2020/08/02",
        "description": "为什么会有Node.js，在前端开发中，经常会用到node.js，那大家有没有想过 为什么会出现node.js这个技术？它解决了前端开发中的哪些问题？假设在前端面试中问你这个问题？你会怎么回答，下面是我自己的一个理解",
        "keywords": "为什么会有Node.js,node.js的不足"
      },
      {
        "title": "pinyin中文转拼音npm包在前端使用时的坑,IE下js错误调试方法",
        "href": "2020/8/pinyin_ie.html",
        "time": "2020/08/22",
        "description": "pinyin npm,前端中文转拼音,web中文转拼音,在很早之前node项目中就使用过这个npm包。这次由于Element table组件排序时，无法按照首字母排序，就引入了这个包。由于是单页面应用，import进来是没问题的，chrome里面正常。后面在IE11里出现了一个bug，就是页面路由不能正常加载，调了好久。最开始以为是路由层级的问题，调到怀疑人生，最后发现是 pinyin 这个包的问题，他在IE下无法正常加载，偶尔报错 '函数错误'，导致整个页面执行失败，路由无法加载。**所以在遇到难调试的问题时，先把error的报错全部解决再调**, 已经遇到好几次这种情况了",
        "keywords": "pinyin npm,前端中文转拼音,web中文转拼音"
      },
      {
        "title": "node package.json中版本前的 ~ 与 ^ 分别代表什么",
        "href": "2020/8/node_package_symbol.html",
        "time": "2020/08/22",
        "description": "node版本~与^,npm 包~与^是什么意思,npm包版本前的~是什么意思npm包版本前^是什么意思, 在element ui的package.json，其中async-validator是 ~ 开头，而其他都是 ^ 开头，有什么区别呢？版本格式 1.8.1 对应 major.minor.patch。- major：表示版本有了一个大更改。 - minor：表示增加了新的功能，并且可以向后兼容。- patch：表示修复了bug，并且可以向后兼容。",
        "keywords": "node版本~与^,npm 包~与^是什么意思,npm包版本前的~是什么意思npm包版本前^是什么意思"
      },
      {
        "title": "深入koa-router源码理解allowedMethods中间件作用",
        "href": "2020/8/allowedMethods_use.html",
        "time": "2020/08/30",
        "description": "koa-router router.allowedMethods()中间件作用,router.allowedMethods 405,在使用koa koa-router mock接口时，我们会看到 `app.use(router.routes()).use(router.allowedMethods())`，使用 router中间件后，又链式调用了router.allowedMethods()这个中间件，那为什么要加router.allowedMethods()中间件呢？他有什么作用？我们写个demo来测试下。先下结论：1. router.allowedMethods()中间件，主要用于 405 Method Not Allowed 这个状态码相关 2. 如果不加这个中间件，如果接口是get请求，而前端使用post请求，会返回 404 状态码，接口未定义。如果加了这个中间件，这种情况时，会返回405 Method Not Allowed ，提示 request method 不匹配，并在响应头返回接口支持的请求方法，更有利于调试",
        "keywords": "koa-router router.allowedMethods()中间件作用,router.allowedMethods 405"
      },
      {
        "title": "koa 使用 multer 处理文件上传，FormData 数据解析",
        "href": "2021/1/koa-formdata.html",
        "time": "2021/01/12",
        "description": "一般在 koa 中，post 请求的数据是需要中间件来处理的，koa-bodyparser 可以很好的处理 json、serializer 数据，但 `multipart/form-data` 的类型无法处理，一般需要引入另外的中间件来处理，一般建议使用 multer 中间件来处理。先来看看前端上传文件代码，这里使用的是 fetch，当然也可以使用 xhr",
        "keywords": "multipart/form-data,FormData,文件上传"
      },
      {
        "title": "node koa 怎么获取 POST 请求 Content-Type 为 'text-plain' 的数据",
        "href": "2021/1/text-plain-post.html",
        "time": "2021/01/12",
        "description": "在 Beacon API 中，使用 `navigator.sendBeacon(url, dataString)` 发送的是 POST 请求，Content-Type 是比较少见的 'text/plain;charset=UTF-8' 。它既不是 xhr，也不是 fetch，是一种独立的请求类型。在 koa 中，一般使用 koa-bodyparser 来处理 post 请求数据。但这次发现使用 ctx.request.body 无法接收到数据。之前接收 'application/x-www-form-urlencoded' 和 'application/json' 类型的数据都是正常的。",
        "keywords": "text/plain post,post text/plain数据解析"
      },
      {
        "title": "npm run start 为什么可以简写为 npm start，npm run start 与 npm start 区别",
        "href": "2021/4/npm_start.html",
        "time": "2021/04/03",
        "description": "在一些项目中发现项目启动命令是 npm start，但一般启动都是 npm run xxx，而 npm start 有点像 npm run start 的简写，于是就想着他们之间有什么关系，其它的命令是否也可以简写。下面来具体看看 npm start 与 npm run start.",
        "keywords": "npm start 与 npm run start 区别,npm start,npm run start"
      },
      {
        "title": "npx create-react-app my-app 是什么意思？npx 有什么作用？",
        "href": "2021/4/npx_use.html",
        "time": "2021/04/03",
        "description": "在 react 官网，介绍 create-react-app 构建工具时，直接使用 npx create-react-app my-app 就可以直接创建一个 react 项目的脚手架，那 npx 命令执行和普通的 create-react-app my-app 有什么区别呢？下面来看看",
        "keywords": "npx 用法,npx 有什么用,npx create-react-app"
      },
      {
        "title": "ESLint 与 Prettier 冲突的问题怎么处理？",
        "href": "2021/4/eslint_prettier_conflict.html",
        "time": "2021/04/03",
        "description": "在安装 @vue/cli 后，使用 vue create xx 创建项目，如果选择了 eslint + prettier，可能会出现冲突。比如 在 .eslintrc.js 的 rules 中设置了强制单引号，而默认情况下 prettier 是双引号。`如果有双引号，eslint 会提示 error。如果有单引号 prettier 会警告提示`，保存自动 fix 会在单双引号之间来回切换，总是会有异常提示。",
        "keywords": "eslint prettier conflict,ESLint 与 Prettier 冲突"
      }
    ],
    "图表可视化": [
      {
        "title": "echarts动态改变option里dataZoom的值没有实时生效的问题",
        "href": "2020/10/echarts_resize.html",
        "time": "2020/10/01",
        "description": "这里我们虽然修改了options的值，但不会实时生效，需要手动调用下echarts实例的resize()方法，另外在做echarts时，对于自适应缩放的图表，一定要注意在窗口缩放时，重新调用resize()",
        "keywords": "echart修改options后没有实时生效的问题"
      },
      {
        "title": "echarts饼图label两端对齐label距离引导线距离",
        "href": "2020/10/echarts_label.html",
        "time": "2020/10/08",
        "description": "在对 echarts 饼图label做自定义时，可以通过label选项的 distanceToLabelLine 设置 label 距离引导线距离、alignTo 设置两端对齐。注意echarts版本要是 v4.6 + ，下面来看示例",
        "keywords": "echarts label两端对齐,引导线距离"
      },
      {
        "title": "echarts画高自定义仪表盘，echart本质是图的堆叠",
        "href": "2020/9/echart_dashboard.html",
        "time": "2020/09/07",
        "description": "echart自定义仪表盘,echarts复杂图,echart堆叠图,最近有个UI需求，画一个自定义的仪表盘，看起来很不好实现，后面在看了echarts社区的一些例子，经过写demo测试后，找到了规律，核心是化繁为简，对于复杂的UI，可以拆分为多个小的模块，一个个实现",
        "keywords": "echart自定义仪表盘,echarts复杂图,echart堆叠图"
      }
    ],
    "移动端混合开发": [
      {
        "title": "uni-app开发需要了解的事情，uni-app开发体验怎么样",
        "href": "2020/7/uni_app_use.html",
        "time": "2020/07/12",
        "description": "uni-app 读法为 u ni ai po，uni-app开发需要了解的事情：1. uni-app开发需要下载HBuilderX开发工具 2. 需要注册ucloud账号，打包安卓、iOS时需要有证书。安卓的证书免费，iOS证书需要花钱 3. uni开发和通常vue-cli搭的脚手架开发方式还是有一定区别的，更像是vue + 小程序开发的结合",
        "keywords": "uni-app,uni-app体验怎么样"
      },
      {
        "title": "uni设置tabbar后没显示的问题",
        "href": "2020/7/uni_tabbar_issue.html",
        "time": "2020/07/12",
        "description": "在pages.json里设置了tabbar配置，但设置成功后，在chrome运行却没效果，需要注意两点：1. pages.json配置中tabBar参数设置的页面同时也需要在pages参数里设置 2. pages数组中的第一项，必须是tabBar配置里的页面",
        "keywords": "uni设置tabbar不生效,uni tabbar不生效"
      },
      {
        "title": "uni.request封装为类似axios的请求对象",
        "href": "2020/7/uni_request.html",
        "time": "2020/07/26",
        "description": "uni.request封装,uni axios分装,在uni-app中为了抹平各平台的差异，官方提供了uni.request方法，和微信小程序的请求方法类似，一般这类请求是比较通用的，如果直接使用会有大量的重复代码，于是做了简单的封装，来看看代码",
        "keywords": "uni.request封装,uni axios分装"
      },
      {
        "title": "uni-app跨域问题接口代理配置",
        "href": "2020/7/uni-app-cros.html",
        "time": "2020/07/26",
        "description": "uni配置跨域,uin接口跨域,uni配置接口代理,在uni-app中有一个manifest.json配置文件，里面的h5配置下有默认的devServer选项，和vue.config.js里的代理配置一致，都是使用的webpack的代理功能，默认配置为...",
        "keywords": "uni配置跨域,uin接口跨域,uni配置接口代理"
      },
      {
        "title": "uni复制功能只支持app、小程序，怎么兼容H5",
        "href": "2020/8/uni_copy_h5.html",
        "time": "2020/08/10",
        "description": "uni复制功能只支持app、小程序，怎么兼容H5呢？当H5时，我们可以引导用户自己选择后copy，如果是app调用uni的api，代码如下",
        "keywords": "uni复制兼容H5,uni复制 h5"
      },
      {
        "title": "uni动态修改导航栏按钮文案",
        "href": "2020/8/uni_eidt_nav.html",
        "time": "2020/08/10",
        "description": "一般uni导航栏按钮是在配置文件里面写的，那怎么动态的修改配置呢？先来看导航栏按钮配置文件，导航栏右侧有一个按钮 编辑",
        "keywords": "uni动态修改导航栏按钮、文案"
      }
    ],
    "TypeScript": [
      {
        "title": "TypeScript error in 'AntdModal' refers to a value, but is being used as a type here",
        "href": "2021/4/ts_error_yarn.html",
        "time": "2021/04/03",
        "description": "在 ts + react + ant-design 的项目中，git clone 项目后，npm install 了，但 npm run serve 时一直提示 TypeScript error in 'AntdModal' refers to a value, but is being used as a type here. 在这个项目的场景下，npm install 安装的包是不全的。需要使用 yarn 来安装，具体命令如下",
        "keywords": "TypeScript error in 'AntModal',refers to a value, but is being used as a type here"
      }
    ],
    "React": [
      {
        "title": "React Declarative 声明式是什么意思？声明式编程与命令式 imperative 编程",
        "href": "2021/4/react_declarative.html",
        "time": "2021/04/03",
        "description": "React 的 Declarative 特性是什么意思？在 React github 的 README.md 中，介绍 react 的特点时，第一个是 Declarative，翻译成中文是声明式，具体要怎么理解呢？下面来看看",
        "keywords": "declarative与imperative,声明式编程,React Declarative; react declarative"
      }
    ]
  },
  "fileData": [
    {
      "htmlStr": "<h1 id=\"vi-生成c语言模板\">vi 生成c语言模板</h1>\n<p>每次写C语言程序，都先会敲一个框架，然后再添加内容。为了省事，就用C语言文件操作函数写了个用于生成模板的c程序。</p>\n<p><img src=\"../../../images/blog/c/c_vim.png\" alt=\"c语言_vim.png\"></p>\n<pre><code class=\"language-c\">#include &lt;stdio.h&gt;\nint main()\n{\n    return 0;\n}</code></pre>\n<p>逻辑：创建1.c这个文件，vim 1.c如果文件存在会打开，不存在会创建一个空的文本，现在我想自定义一个程序v，终端下v 1.c时，如果文件存在用vim打开，如果不存在，会用vim打开一个新文件，文件内容为模板内容。代码如下：</p>\n<pre><code class=\"language-c\">/*\n *    用vim写c语言程序时，每次都会写一些重复代码\n *  以后每次想写程序，直接打开这个程序就可以自动生成基本C代码\n *    且带有相关注释，时间戳，作者等信息!\n *  2016/07/09 13:05\n *    Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;string.h&gt;\n#include &lt;time.h&gt;\n\nint main(int argc, char* argv[])\n{\n    if (argc != 2) { // 这里只做2个参数处理，可以添加对无参数处理，直接system(vi);\n        printf(&quot;参数错误!\\n&quot;);\n        return 1;\n    }\n\n    int fd = 0;\n    char buf_touch[100] = {0}, buf_vim[100] = {0};\n    char date1[100] = {0};\n\n    if ((fd = open(argv[1],O_RDWR | O_CREAT | O_EXCL, 0644)) == -1 &amp;&amp; errno == EEXIST)\n    {\n        //printf(&quot;文件已存在!请重新运行\\n&quot;);\n        sprintf(buf_vim, &quot;vim %s +3&quot;, argv[1]);\n        system(buf_vim);        \n        exit(1);\n    } \n\n    sprintf(buf_touch, &quot;touch %s&quot;, argv[1]); \n    system(buf_touch);  // 用touch命令创建文件\n\n    /*  获取系统时间, 存入timestamp  */    \n    time_t long_t = time(0);\n    sprintf(date1, &quot; *  %s&quot;, ctime(&amp;long_t));\n\n    // 向文件写入内容\n    write(fd, &quot;\\n&quot;, strlen(&quot;\\n&quot;));\n    write(fd, &quot;/*  \\n&quot;, strlen(&quot;/*  \\n&quot;));\n    write(fd, &quot; *  \\n&quot;, strlen(&quot; *  \\n&quot;));\n     write(fd, date1, strlen(date1));\n    write(fd, &quot; *  Create by Kevin Zuo\\n&quot;, strlen(&quot; *  Create by Kevin Zuo\\n&quot;));\n    write(fd, &quot; */  \\n&quot;, strlen(&quot; */  \\n&quot;));\n    write(fd, &quot;\\n&quot;, 1);\n    write(fd, &quot;#include &lt;stdio.h&gt;\\n&quot;, strlen(&quot;#include &lt;stdio.h&gt;\\n&quot;));\n    write(fd, &quot;#include &lt;stdlib.h&gt;\\n&quot;, strlen(&quot;#include &lt;stdlib.h&gt;\\n&quot;));\n    write(fd, &quot;\\n&quot;, 1);\n    write(fd, &quot;int main(int argc, char* argv[])\\n&quot;, strlen(&quot;int main(int argc, char* argv[])\\n&quot;));\n    write(fd, &quot;{\\n&quot;, 2);\n    write(fd, &quot;\\n&quot;, 1);\n    write(fd, &quot;\\n&quot;, 1);\n    write(fd, &quot;\\texit(0);\\n&quot;, 10);\n    write(fd, &quot;}\\n&quot;, 2);\n\n    close(fd); // close file\n\n    sprintf(buf_vim, &quot;vim %s +3&quot;, argv[1]); // 用vim打开程序，光标停留在第三行\n    system(buf_vim); \n\n    exit(0);\n}\n</code></pre>\n<p>gcc编译文件后命名为v，将v这个程序copy到环境变量，我是copy到了/usr/local/bin下，以后用vim写C程序在终端下直接&quot;v 新建C程序名&quot;，就会生成如下图的模板:</p>\n<p><img src=\"../../../images/blog/c/c_vim_show.png\" alt=\"c语言_vim_show.png\"></p>\n<p>这样就不用每次都手打了，而且自动生成时间戳加自己名字，这样就有点像IDE了。这里只是一个思路，你还可以加入自己想要的一些东西，比如根据文件后缀名生成对应的框架内容。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vi 生成c语言模板"
        }
      ],
      "config": {
        "source": "vi 生成c语言模板.md",
        "staticFileName": "c_vim.html",
        "author": "guoqzuo",
        "createDate": "2016/10/13",
        "description": "vi 生成c语言模板，vim在终端下编辑文件，每次vi一个新文件时都要敲一些重复的内容，于是就用C写了个程序，用来自动生成自定义模板。",
        "keywords": "vi 生成c语言模板,vim c模板程序,c语言模板",
        "category": "C与APUE",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"从web零基础到完成这个博客系统\">从web零基础到完成这个博客系统</h1>\n<blockquote>\n<p>最开始接触Web是在15年的11月份，到现在快1年了。现在一般需求的小网站应该可以独立完成，其间遇到了很多问题，也学了很多东西。但我这个人很健忘，东西学的快也忘的快，于是就想用博客来记录所学。以方便查找，也为后来的人提供一些经验。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/web/blog_tomexam.png\" alt=\"blog_tomexam.png\"></p>\n<h2 id=\"我是怎么入坑的\">我是怎么入坑的</h2>\n<p>15年11月，我们Team leader想做一个考试系统。就在网上找了一个免费的考试系统TomExam让我们随便改改。但当时我只会一点C、APUE，网页从来没接触过。同事Curtis之前会点前端，但忘的差不多了。当时部门会写点代码还有空闲时间的就只有我们两个，任务就这样交给我们了。当时在选择后台语言时我问了下搞java的一个同学，了解到php可能要简单一点，上手快。于是跟老板商量，可不可以用php写，但老板说他会一点jsp，就用jsp吧。最重要的原因可能是因为免费考试系统源码是用jsp写的，想着改改就直接用，就这样入坑jsp/servlet。刚拿到项目都不知道网站具体是怎么运行起来的，于是开始学习怎么让这程序运行起来: 装java环境、tomcat、mysql等。起初是在windows环境，由于办公电脑都是mac mini，最后又在mac下部署了环境，运行了起来。在菜鸟教程上发了大概1个星期看了html、css、js相关的语法，并做了笔记，对基本的前端页面有了一点了解。后来看源码发现调用后台的方法基本都是servlet，且都是编译过后的class文件，也就意味着后端代码不开源，然后就萌生了重写后端的想法。Eclipse环境真正搭建起来是在一个月后(之所以选择eclipse开发环境，是因为网上教程只找到eclipse的)，期间也看了点jsp的资料。在书上看了mysql的基本语法，并做了笔记。以前总是以为数据库很难，但真正了解mysql，只用了半天时间。环境搭建好之后，就开始写代码了，这也是一切问题的开始。</p>\n<h2 id=\"从一个个问题开始\">从一个个问题开始</h2>\n<p>最先开始写的是登录界面，怎么给出输入账号密码的输入框？怎么弄出登录的按钮？按下登录按钮之后怎么去判断密码是否正确，正确了又怎么跳转？密码错误怎么提示？带着一个有一个的问题开始一步步开始去摸索。然后慢慢的对js+css+mysql+jsp熟悉了, 其实只要知道html基本语法以及数据库的调用，基本就没什么大的问题了。遇到不懂得直接百度，多思考一般都可以解决。就这样根据前端源码，以及数据表，用jsp 100%重写了这个考试系统。我们改名为TDE网络考试系统，之后又弄了单态登录，权限控制，文件服务系统，新闻发布，评论系统等。刚开始其实前端都没怎么改，我也没精力去弄，之后部门师姐司徒学了css+html用bootstrap改写了所有前端界面。后来我也开始用bootstrap了，包括这个博客系统。TDE网络考试系统完成之后，我基本对前端后端都有了一定的了解。这个过程看似很轻松，其实当真正遇到问题，还没找到解决方法时，那段时间是很纠结的，但找到解决方法的时候会很有成就感，然后又开始觉得这很简单，也没什么。</p>\n<h2 id=\"另一个项目\">另一个项目</h2>\n<p>考试系统OK之后我也从大Foxconn转正了。由于CoreOS部门成立，Station方面的事情就开始多了。期间自学过OC、PHP，复习了C，APUE。但工作方面的事，总是会打乱学习的进度。前段时间老板决定开始为备品室斌哥家修改AMS系统，当时Martin还在(专业java网页后端，是我写完考试系统之后他才来的)，当时就是我和他负责这个系统，这个系统源码是php写的。都不会php，还是决定用jsp/servlet重写后端。后来才知道dao，servlet，将每一个数据表弄成java class，其实我个人对java还是很排斥的，但确实比我之前纯jsp好了很多，他负责规划数据库dao，写入库，借领，出库等，我负责查询模块，刚开始脱离jsp用servlet还是很不习惯的，但还是逼着自己用servlet+jstl，慢慢的也就习惯了。在我快写完查询模块时，CoreOS的事开始变多了，Burnin的Panic，UI lab的Audit等。那段时间基本没有写代码，全部交给了martin去做。Martin基本写完了那个系统就离职了，然后AMS系统又交到了我手上，我没怎么看就发给了斌哥他们测试，结果出了一些问题，让我们改，当时我忙Station的事情，根本管不了AMS的事情，就拖了一段时间。大家弄得不怎么愉快，忙完之后我终于有时间来解决ams的问题了，然后我发现一段时间没弄基本都忘了，这也是我为什么要离职的原因，我不喜欢这种状态，花时间学了东西，弄一下其他事情又忘了，断断续续的，提升很慢。于是我有了离职的想法，找老板谈了我的想法，讨价还价后，决定将AMS系统交接给备品室再走, 于是我基本重写了整个AMS系统。</p>\n<p>为什么要重写，之前不是OK了吗?第一个原因是IE8的兼容问题，我们调试都是safari，但他们系统都是xp或win7的，出于正版的原因，只能用IE8，placeholder都不支持。还有就是前端基本没变，跟以前一样low，于是我将整个前端改了一遍，让界面整体上有了一个提升，期间才了解IE8不支持jQuery2.x以上的版本，不支持css3，html5等，最后找到了IE8使用css3的一个插件，弄出了input/button/table的圆角效果，不然input框总是感觉很low。第二个原因是相比原来的没什么改进，于是我对整个现有库存信息进行了唯一性分析，思考通过什么属性来确定一个物品，怎么去借领，归还等。他们让我们修改的主要原因是数据方面有异常的问题，最后改了一些逻辑，调整了数据表的一些结构，对影响的一些数据进行了修改，删除等。然后对mysql的一些稍微高级的用法有了一定的加强。期间js+css等也得到了强化，自学了用json来传递前后端的数据。IE8是个大坑，在文件上传时，我们隐藏了input file框，用另一个button来间接点击input file框，但用ajaxfileupload时，IE8不支持这个间接的调用，网上说可以将两个框重叠，但不会。low就low吧，直接不隐藏用input file，这个问题当时纠结了好久。还有个JS问题, 遍历chexbox多选框时，得到了数组遍历时有问题,for (i in list) IE8不支持，改成 for (var i = 0; i &lt; list.length; i++) 才行，关键是JS脚本语言不报错，有问题只能用alert(变量)，不停的换地方调试，才能找到是哪里出的问题。改这个系统还算比较顺利，没有什么大的问题，主要得归功于Martin将我基本不会的都弄了相应的接口，直接按照他写的方式来弄就行了。比如文件的上传，execl的导入导出等。做完这个系统，感觉成长很快，又学到了很多东西。</p>\n<p><img src=\"../../../images/blog/web/blog_schedule.png\" alt=\"blog_schedule.png\"></p>\n<h2 id=\"开始写博客\">开始写博客</h2>\n<p>技术上有了一定的积累就开始考虑做个博客系统了。起初因为我们写的系统都是局域网内部的，对真正的web运营不怎么了解，于是查了很多资料，注册了zuo11.com这个域名，又弄了个虚拟主机。刚接触虚拟主机时很不习惯，感觉束手束脚的，后来就习惯了，之前主机公园的系统支持安装wordpress，但感觉体现不出技术，自己写个后台也没什么难度，于是列出了Schedule。原先准备用php完整的写出这个博客系统，但时间有限，没时间系统的学php，就换回jsp了。后来发现主机公园的虚拟主机没有tomcat环境，就换成了阿里云的ECS。之前后台用jsp实现了。感觉low了，就用servlet重构了。博客的数据量相比考试系统，ams显得非常小。后台没什么，前端怎么显示的好看，浏览器的兼容等，花了不少心思。而且博客的维护是一个长期的过程，以后还需要不断的完善，优化。</p>\n<h2 id=\"the-end\">The End</h2>\n<p>写完这3个系统之后，虽然进步了很多，但这不算什么。还只是业余水平，没有大项目经验。但我也不打算将web作为工作，只想作为一个爱好，以后有机会会看看freecodecamp上面的内容，慢慢提升.....</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "从web零基础到完成这个博客系统",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "我是怎么入坑的"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "从一个个问题开始"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "另一个项目"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "开始写博客"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "The End"
            }
          ]
        }
      ],
      "config": {
        "source": "从Web零基础到完成这个博客系统.md",
        "staticFileName": "viewpoint_zero.html",
        "author": "guoqzuo",
        "createDate": "2016/10/14",
        "description": "最开始接触Web是在15年的11月份，到现在快1年了。现在一般需求的小网站应该可以独立完成，其间遇到了很多问题，也学了很多东西。但我这个人很健忘，东西学的快也忘的快，于是就想用博客来记录所学。以方便查找，也为后来的人提供一些经验。",
        "keywords": "web零基础,个人博客",
        "category": "网站建设与SEO",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"c语言扫雷控制台版\">c语言扫雷(控制台版)</h1>\n<blockquote>\n<p> 扫雷游戏的逻辑其实很简单，只要学了C的循环语句、数组、递归就可以基本实现了。思路有了，就可以应用到UI上，这里例子是纯C代码，控制台下模拟，提供相关思路及示例。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/c/c_saolei_1.png\" alt=\"c_saolei_1.png\"></p>\n<h2 id=\"游戏规则\">游戏规则</h2>\n<p>点击方格后，如果是雷，游戏结束。如果不是就显示其周围雷的个数，如果个数为0(一般UI显示为空白)，会遍历打开其周围的方格。如果是雷则不打开，否则显示其周围雷的个数，如果还为0，继续像前面一样遍历，直到遇到边界。以此类推，当除了雷之外所有的方格都点开后，游戏就胜利了。  </p>\n<h2 id=\"实现思路\">实现思路</h2>\n<p>这里用c语言在控制台下模拟，不依赖任何第三方插件。右键插旗子是做不了的，鼠标点击改为输入坐标，旨在模拟扫雷实现的基本逻辑。首先要有两张地图，分别对应两个8*8的二维数组(字符)。一个用来显示界面，一个用来做内部地图，用memset()全部设置为&#39;+&#39;。内部地图里面设置10个雷，刚开始可以将雷的坐标写死，用&#39;l&#39;来标记。最好用随机数来决定雷的坐标，要注意防止随机数的重复。用while(1)来不断接收用户输入，并进行相关操作，注意坐标越界的处理。如果输入坐标为4，4。就到内部地图数组arr[3][3]查其值(数组为0开始，坐标为1开始，所以要减1)，如果为&#39;l&#39;就是踩到雷了。游戏结束。否则遍历其周围的8个方向雷的个数，得到雷的个数后设置到对应的UI数组arr_ui[3][3]。这里要注意字符&#39;0&#39;为数字48。上面的实现之后算是一个分水岭了，难点是如果雷的个数为0，要一扫一大片的效果。就要用到递归了，遍历的时候将坐标周围8个方向的坐标设置为了一个二维数组，当前坐标加上这些个方向坐标，正好代表了其周围的坐标。递归时如果越界了就continue。如果之前递归过该坐标(对应UI数组已经写过值或为雷)，也continue。如果雷数不为0，写值，为0递归。具体实现参见下面示例源码，下图为该示例的运行效果。</p>\n<p><img src=\"../../../images/blog/c/c_saolei_2.png\" alt=\"c_saolei_2.png\"></p>\n<h2 id=\"示例源码\">示例源码</h2>\n<pre><code class=\"language-c\">/*\n *  C语言扫雷，控制台\n *  2016/10/15 12:19\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;time.h&gt;\n#define NUM 8 // 地图长宽\n#define LEI 10 // 雷的个数\n\nint mark[8][2] = {{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1}}; // 8个方向坐标\nchar map[NUM][NUM] = {0}; // 内部地图\nchar ui[NUM][NUM] = {0};  // UI\n\nvoid print(char map[][NUM], int n) // 打印UI或地图\n{\n    for(int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            printf(&quot;%c &quot;,map[i][j]);\n        }\n        printf(&quot;\\n&quot;);\n    }\n}\n\nint lei_count(int x, int y, int n) { // 根据坐标，计算周围有几个雷\n    int count = 0;\n    int x1 = 0, y1 = 0;\n    for (int i = 0; i &lt; 8; i++) {\n        x1 = x + mark[i][0];\n        y1 = y + mark[i][1];\n        if (x1 &lt; 1 || x1 &gt; n || y1 &lt; 1 || y1 &gt; n) continue; // 如果超出了边界\n        if (map[x1-1][y1-1] == &#39;l&#39;)\n            count++;\n    }\n    return count;\n}\n\nvoid zero_digui(int x, int y) // 递归显示\n{\n    ui[x-1][y-1] = 0 + 48;\n    int x1 = 0, y1 = 0;\n    for (int i = 0; i &lt; 8; i++) { // 遍历周围的8个方向\n        x1 = x + mark[i][0];\n        y1 = y + mark[i][1];\n        if (x1 &lt; 1 || x1 &gt; NUM || y1 &lt; 1 || y1 &gt; NUM) continue; // 如果超出了边界\n        int count = lei_count(x1,y1,NUM);\n        if (count != 0) ui[x1-1][y1-1] = count + 48; // 不为0直接写值 \n        else if (ui[x1-1][y1-1] == &#39;0&#39;) continue; // 为0, 但值已是0，以前遍历过\n        else zero_digui(x1,y1); // 为0，没遍历过, 遍历\n    }\n}\n\nint win_check() // 赢了返回1,else 返回0\n{\n    // 计算ui里面+的个数,为LEI，则胜利\n    int count = 0;\n    for (int i = 0; i &lt; NUM; i++) {\n        for (int j = 0; j &lt; NUM; j++) {\n            if (ui[i][j] == &#39;+&#39;)\n                count++;\n        }\n    }\n    if (count == LEI)\n        return 1;\n    else\n        return 0;\n}\n\nint main(int argc, char* argv[])\n{\n    memset(map, &#39;+&#39;, NUM*NUM); // 填充+\n    memset(ui, &#39;+&#39;, NUM*NUM);\n\n    srand(time(NULL)); // 设置随机数种子\n    for (int i = 0; i &lt; LEI; i++) { // 随机给出LEI个雷,用&#39;l&#39;标记\n        int x = 0, y = 0;\n        do {\n            x = rand()%NUM;\n            y = rand()%NUM;\n        } while(map[x][y] == &#39;l&#39;); // 防止随机数重复\n        map[x][y] = &#39;l&#39;;\n    }\n    print(map, NUM); // 测试用\n\n    while (1) {\n        int x = 0, y = 0;\n        printf(&quot;扫雷\\n&quot;);\n        print(ui, NUM); // 打印UI\n        do { // 提示输入，且保证输入坐标正常!\n            printf(&quot;请输入鼠标(x,y):&quot;);\n            scanf(&quot;%d,%d&quot;, &amp;x, &amp;y);\n        } while (x &lt; 1 || x &gt; NUM || y &lt; 1 || y &gt; NUM);\n        // 判断是否有雷\n        if (map[x-1][y-1] == &#39;l&#39;) { // 如果是雷，游戏结束\n            print(map, NUM);\n            printf(&quot;踩到雷了，游戏结束!\\n&quot;);\n            break;\n        } else { // 如果不是雷\n            int count = lei_count(x, y, NUM);\n            if (count != 0) // 周围有几个雷就显示几个雷\n                ui[x-1][y-1] = count + 48; // int型 =&gt; 字符 +48\n            else { // 没有雷就递归寻找，显示\n                zero_digui(x, y);\n            }\n        }\n        // 判断是否赢了\n        if(win_check()) { // 恭喜，胜利\n            print(ui,NUM);\n            printf(&quot;恭喜,胜利!\\n&quot;);\n            break;\n        }\n    }\n     return 0;\n}</code></pre>\n<h2 id=\"扩展\">扩展</h2>\n<p>在图形化界面里面可以将对应的方格对应到二维数组。思路是一样的，之前写过一个mac版的，但只做了基本的一扫一大片。后续还有一些要完善的，等完成了会更新具体实现，希望对大家有帮助。</p>\n<p><img src=\"../../../images/blog/c/c_saolei_3.png\" alt=\"c_saolei_3.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "c语言扫雷(控制台版)",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "游戏规则"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "实现思路"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "示例源码"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "扩展"
            }
          ]
        }
      ],
      "config": {
        "source": "c语言扫雷(控制台版).md",
        "staticFileName": "c_saolei.html",
        "author": "guoqzuo",
        "createDate": "2016/10/15",
        "description": "扫雷游戏的逻辑其实很简单，只要学了C的循环语句、数组、递归就可以基本实现了。思路有了，就可以应用到UI上，这里例子是纯C代码，控制台下模拟，提供相关思路及示例。",
        "keywords": "c语言扫雷实现,c 扫雷,扫雷源码,c语言扫雷源码,控制台扫雷源码,c语言扫雷,扫雷,扫雷一扫一大片",
        "category": "C与APUE",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"c语言实现控制台下走动的时间\">c语言实现控制台下走动的时间</h1>\n<blockquote>\n<p>UI下时间插件很容易展现一个走动的时间，但C语言下控制台程序想要实现一个走动的时间，就需要用while(1)每隔1秒来打印了。其间我们可以开个fork用子程序来跑这个死循环。顺便延升到输出缓冲区与printf函数的问题。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/c/c_console_time.png\" alt=\"c_console_time.png\"></p>\n<h2 id=\"初步实现\">初步实现</h2>\n<p>这里没有其他的操作就直接在主进程里面实现了。思路是在while(1)里每隔1s不断的打印当前时间。首先要获取当前时间,用man 3 localtime来获取时间，格式0000-00-00 00:00:00，之后就是让打印的时间总是显示在该行。也就是不换行，可以用&#39; &#39;来将光标移动至行首实现。代码如下:</p>\n<pre><code class=\"language-c\">/*  \n *  C语言 显示走动的时间  \n *  Sun Oct 16 14:26:55 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;unistd.h&gt;\nint main(int argc, char* argv[])\n{\n    while (1) {\n        struct tm *p;\n        time_t t = time(NULL);\n        p = localtime(&amp;t);\n        printf(&quot;%d-%d-%d %d:%d:%d\\n&quot;,p-&gt;tm_year+1900, p-&gt;tm_mon+1, p-&gt;tm_mday,\n                p-&gt;tm_hour, p-&gt;tm_min, p-&gt;tm_sec);\n        sleep(1);\n        fflush(stdout);\n    }\n    exit(0);\n}</code></pre>\n<h2 id=\"问题延升\">问题延升</h2>\n<p>上面的程序为什么加了sleep(1)和fflush(stdout)呢? 首先如果不加sleep(1)，打印的光标会一直刷，一秒钟while(1)可以执行多次。所以需要加休眠1秒，但加了sleep(1)之后，由于标准IO(printf)都是行缓冲或满缓冲，当短时间内打印的内容无法全部输出时，就会出现缓冲，暂时不打印，遇到换行或者等缓冲区满了才会打印。如果想要实时打印就要用fflush(stdout)强制刷新输出缓冲区。printf函数是c语言库函数，其本质就是向输出缓冲区文件写入内容。可以用write来代替printf。向write这样的系统调用在用户空间无缓冲机制，写入都是实时的，所以不用fflush(stdout))。代码如下:</p>\n<pre><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char* argv[])\n{\n    while (1) {\n        struct tm *p;\n        time_t t = time(NULL);\n        p = localtime(&amp;t);\n        char buf[100] = {0};\n        sprintf(buf,&quot;%04d-%02d-%02d %02d:%02d:%02d\\n&quot;,p-&gt;tm_year+1900, p-&gt;tm_mon+1, p-&gt;tm_mday,\n                p-&gt;tm_hour, p-&gt;tm_min, p-&gt;tm_sec);\n        write(1, buf, strlen(buf));\n        sleep(1);\n    }\n    exit(0);\n}</code></pre>\n<h2 id=\"最后\">最后</h2>\n<p>以上的代码执行效果和上面一致，只是用了系统调用函数。如果只学了基本的C语言，看上面的内容可能会不懂，关于系统调用，可参考UNIX高级编程笔记，也就是APUE。C语言方面想要提高的，可以好好研下。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "c语言实现控制台下走动的时间",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "初步实现"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "问题延升"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "最后"
            }
          ]
        }
      ],
      "config": {
        "source": "c语言实现控制台下走动的时间.md",
        "staticFileName": "c_console_time.html",
        "author": "guoqzuo",
        "createDate": "2016/10/16",
        "description": "UI下时间插件很容易展现一个走动的时间，但C语言下控制台程序想要实现一个走动的时间，就需要用while(1)每隔1秒来打印了。其间我们可以开个fork用子程序来跑这个死循环。顺便延升到输出缓冲区与printf函数的问题。",
        "keywords": "c 控制台走动的时间,c语言时间程序,c 走动时间, c 控制台时间",
        "category": "C与APUE",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"c语言文件操作---简单的文件加密解密\">c语言文件操作 - 简单的文件加密解密</h1>\n<blockquote>\n<p>文件加密对小白来说是一个很高大上的技术，但也不是那么遥不可及。只要学了C语言的文件操作，就可以用简单的文件操作方法，对文件进行简单的加密。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/c/c_encrypt.jpg\" alt=\"c_encrypt.jpg\"></p>\n<h2 id=\"文件取反加密\">文件取反加密</h2>\n<p>思路是先打开文件，再读取文件的每一字节，取反之后再写入文件。运行一次后，文件的每一个字节都取反了，内容肯定是乱了。就相当于加密了，再运行一次就会还原，相当于解密。代码如下:</p>\n<pre><code class=\"language-c\">/*  \n *  C语言 运行一次加密，再运行一次解密\n *  Sun Oct 16 15:23:23 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char* argv[])\n{\n    // 用第二个参数来接收要加密的文件\n    if (argc &lt; 2) {\n        printf(&quot;参数错误，找不到文件!\\n&quot;);\n        return 1;\n    }\n    FILE* fp = fopen(argv[1],&quot;r+&quot;);\n    if (fp == NULL) { // 如果打开文件失败\n        perror(&quot;open()&quot;);\n        return 2;\n    }\n    while (1) { // 遍历改文件的每一个字节，取反\n        char buf;\n        int n = fread(&amp;buf, 1, 1, fp); // 读取一个字节的内容,存入buf\n        if (n == 0) break; // 读到文件结尾就退出\n        buf = ~buf; //对自己取反\n        fseek(fp, -1, SEEK_CUR);  // 读一位之后，文件指针会后移,修改时需将文件指针向前移动一位\n        fwrite(&amp;buf, 1, 1, fp); // 将取反的结果再写入文件\n    }\n\n    fclose(fp); // 关闭文件\n    exit(0);\n}</code></pre>\n<p>测试程序效果：</p>\n<p><img src=\"../../../images/blog/c/c_encrypt_2.png\" alt=\"c_encrypt_2.jpg\"></p>\n<p>这个程序有个缺点就是不能对文件夹也就是目录加密，有了这个思路以后，就可以以此内推打造自己的加密算法了。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "c语言文件操作 - 简单的文件加密解密",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "文件取反加密"
            }
          ]
        }
      ],
      "config": {
        "source": "c语言文件操作 - 简单的文件加密解密.md",
        "staticFileName": "c_file_encrypt.html",
        "author": "guoqzuo",
        "createDate": "2016/10/16",
        "description": "文件加密对小白来说是一个很高大上的技术，但也不是那么遥不可及。只要学了C语言的文件操作，就可以用简单的文件操作方法，对文件进行简单的加密。",
        "keywords": "c语言文件加密,文件加密,文件取反加密,c 文件加密",
        "category": "C与APUE",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"c语言排序算法\">c语言排序算法</h1>\n<blockquote>\n<p>排序的方法有不少，不过到现在还没怎么具体应用过，可能还比较low吧。这里介绍4中常见的排序算法：冒泡排序、选择排序、插入排序、快速排序，用C语言实现。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/c/c_sort.png\" alt=\"c_sort.png\"></p>\n<p>直接上代码:</p>\n<pre><code class=\"language-c\">/*  \n *  排序  \n *  Sun Oct 16 15:54:56 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid swap(int* a, int* b) // 交换值\n{\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nvoid sort_mp(int *a, int n) // 冒泡排序\n{\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = i+1; j &lt; n; j++) { // 拿第一个值逐个比较，大于就交换\n            if (a[i] &gt; a[j])\n                swap(&amp;a[i], &amp;a[j]);\n        }\n    }\n}\n\nvoid sort_xz(int *a, int n) // 选择排序\n{\n    int min = 0;\n    for (int i = 0; i &lt; n; i++) {\n        min = i;\n        for (int j = i+1; j &lt; n; j++) { // 拿第一个值逐个比较，将小的值存入min\n            if (a[min] &gt; a[j])\n                min = j;\n        }\n        if (min != i) // 找出最小值，再交换\n            swap(&amp;a[min], &amp;a[i]);\n    }\n}\n\nvoid sort_cr(int *a, int n) // 插入排序\n{\n    // 将数组分为两个队列，逐渐把第二个队列的第一个元素，按到校顺序插到第一个队列\n    // 6      2,4,5,3,1,4,9,7,8\n    // 2,6    4,5,3,1,4,9,7,8\n    // 2,4,6  5,3,1,4,9,7,8\n    for (int i = 1; i &lt; n; i++) {\n        int t = a[i];\n        int j = 0;\n        for (j = i -1; j&gt;=0 &amp;&amp; a[j]&gt;t;j--) { // 找到合适的位置,之前的数据对应前移\n            a[j+1] = a[j];\n        }\n        a[j+1] = t;\n    }\n}\n\nvoid sort_ks(int *a, int n) // 快速排序\n{\n    // 将无序数列最左边的数作为参照，比它大的放右边，小的放左边，这样就得到了两个无序\n    // 数列，再递归\n    if (n &lt; 2) return; // 长度&lt;2 的不用排序，防止递归段错误\n    int l = 0, r = n - 1, t = a[l];\n    while (l &lt; r) {\n        while (a[r] &gt;= t &amp;&amp; l &lt; r)\n            r--;\n        swap(&amp;a[l], &amp;a[r]);\n        while (a[l] &lt;= t &amp;&amp; l &lt; r)\n            l++;\n        swap(&amp;a[l], &amp;a[r]);\n    }\n    sort_ks(a, l);\n    sort_ks(a+l+1, n-l-1);\n}\n\nint main(int argc, char* argv[])\n{\n    int a[10] = {6,7,4,5,3,1,4,9,2,8};\n\n    //sort_mp(a, 10);\n    //sort_xz(a, 10);\n    //sort_cr(a, 10);\n    sort_ks(a, 10);\n    for (int i = 0; i &lt; 10; i++)\n        printf(&quot;%d &quot;, a[i]);\n    printf(&quot;\\n&quot;);\n\n    exit(0);\n}</code></pre>\n<p>更多详情参见: <a href=\"https://www.toptal.com/developers/sorting-algorithms/\">https://www.toptal.com/developers/sorting-algorithms/</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "c语言排序算法"
        }
      ],
      "config": {
        "source": "c语言排序算法.md",
        "staticFileName": "c_sort.html",
        "author": "guoqzuo",
        "createDate": "2016/10/16",
        "description": "排序的方法有不少，不过到现在还没怎么具体应用过，可能还比较low吧。这里介绍4中常见的排序算法：冒泡排序、选择排序、插入排序、快速排序，用C语言实现。",
        "keywords": "c语言排序算法,c 冒泡排序,c 选择排序,c 插入排序,c 快排,c 排序",
        "category": "C与APUE",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"c语言单向链表的实现\">c语言单向链表的实现</h1>\n<blockquote>\n<p>c语言指针和结构体一学完就是链表了。也是一个分水岭，很多小白都卡在了这里，当初我自学时就是在这个位置时放弃了。我发现很多地方讲链表都讲得比较复杂，其实链表很简单，就是将多个数据(结构体类型)连在一起。只要有该链表头结点的地址，就可以操作这一连串数据。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/c/c_linked_list_1.png\" alt=\"c_linked list_1.png\"></p>\n<p>最开始自学C时，指针的概念都不怎么懂，在熟悉链表的过程中，指针就慢慢的熟悉了。链表由结点组成。结点用结构体来表示，单向链表的结构体有两个变量，一个存数据，一个存下一个结点的地址。就是把一连串的地址有序的连接起来，用头结点地址表示链表。每个结点的空间用malloc来分配。双向链表就是多了个pre的指针,环形链表只是head的pre指向尾结点，尾部的next指向头结点，一般单向链表理解了，其他的就好理解了。单向链表可以模拟一般数据库的功能，增删查改都行，以前用文件和链表写过纯C的学生成绩管理系统。如果想提升可以去研究内核的链表结构。链表一般情况也不怎么用，在高级语言中都有现成的类，方法都写好了，直接用就行了。</p>\n<p><img src=\"../../../images/blog/c/c_linked_list_2.png\" alt=\"c_linked list_2.png\"></p>\n<p>具体代码如下:</p>\n<pre><code class=\"language-c\">/*  \n *  C单向链表的实现与运用   \n *  Sun Oct 16 17:32:42 2016\n *  Create by Kevin Zuo\n */ \n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node { // 组成单向链表的节点,类似于对象\n    int d; // 这里只是示范,也可以将d替换为另一个struct对象，如学生信息结构体\n    struct Node* next;  // 纯C的学生成绩管理系统可不依赖数据库，直接用链表+文件\n};\ntypedef struct Node Node;\n\nint size(Node* head) // 计算链表长度\n{\n    if (head == NULL) return 0;\n    int count = 0;\n    while (head != NULL) {\n        count++;\n        head = head-&gt;next;\n    }\n    return count;\n}\n\nvoid print(Node* head) { // 打印链表\n    if (head == NULL) printf(&quot;链表为空!\\n&quot;);\n    else {\n        while (head != NULL) {\n            printf(&quot;%d &quot;, head-&gt;d);\n            head = head-&gt;next;\n        }\n        printf(&quot;\\n&quot;);\n    }\n}\n\n// 结点的增加\nvoid add_h(Node** head, int t) // 头部添加结点, 可能需要修改头结点，传地址\n{\n    // 在堆空间申请一个片空间，用来存放结点\n    Node* p = (Node*)malloc(sizeof(Node)); // 代码长度关系，就不进行出差判断了\n    p-&gt;d = t;\n    p-&gt;next = NULL;\n\n    if (*head == NULL) *head = p; // 如果链表为空，将p赋值给\n    else {\n        p-&gt;next = *head;\n        *head = p;\n    }\n}\n\nvoid add_t(Node** head, int t) // 尾部添加结点\n{\n    Node* p = (Node*)malloc(sizeof(Node)); // new 一个结点\n    p-&gt;d = t;\n    p-&gt;next = NULL;\n\n    if (*head == NULL) *head = p; // 如果链表为空，将p赋值给\n    else {\n        // 为了防止改动头结点, 用另一个指针来遍历\n        Node* temp = *head;\n        while (temp-&gt;next != NULL) { // 找到尾部结点\n            temp = temp-&gt;next;\n        }\n        temp-&gt;next = p;\n    }\n}\n\nvoid add_pos(Node** head, int t, int pos) // 指定位置(pos)添加结点\n{\n    if (pos &lt; 1 || pos &gt; size(*head)) { // 位置超出范围\n        printf(&quot;位置错误!&quot;); return;\n    }\n    Node* p = (Node*)malloc(sizeof(Node)); // new 一个结点\n    p-&gt;d = t;\n    p-&gt;next = NULL;\n    Node* temp = *head;\n    for (int i = 0; i &lt; pos-1; i++) { // 第一个位置添加，指针后移0，第二个，后移1,第pos个后移pos-1次\n        temp = temp-&gt;next;\n    }\n    p-&gt;next = temp-&gt;next;\n    temp-&gt;next = p;\n}\n\n// 结点的删除\nvoid del_h(Node** head) // 删除头部结点\n{\n    if (*head == NULL) return;\n    Node* temp = *head;\n    *head = (*head)-&gt;next;\n    free(temp);\n}\n\nvoid del_t(Node** head) // 删除尾部结点\n{\n    if (*head == NULL) return;\n    Node* temp = *head;\n    if (temp-&gt;next == NULL) {  // 只有一个结点\n        *head = NULL;\n        free(temp);\n        return;\n    }\n    // 至少有两个结点\n    while ((temp-&gt;next)-&gt;next != NULL) { // 找到要删除的前一个结点\n        temp = temp-&gt;next;\n    }\n    free(temp-&gt;next);\n    temp-&gt;next = NULL;\n}\n\nvoid del_pos(Node** head, int pos) // 删除指定位置(pos)结点\n{\n    if (pos &lt; 1 || pos &gt; size(*head)) {\n        printf(&quot;位置错误!&quot;); return;\n    }\n    if (pos == 1) del_h(head);\n    else if (pos == size(*head)) del_t(head);\n    else { // 不是头尾, 且长度至少为3\n        Node* temp = *head;\n        for (int i = 0; i &lt; pos-2; i++) // 删除第二个，移动0,第3个,移动1，第pos个，移动pos-2\n            temp = temp-&gt;next;\n        Node* temp2 = temp-&gt;next;\n        temp-&gt;next = temp2-&gt;next;\n        free(temp2);\n    }\n}\n\n// 结点的逆序 单向链表特有\nvoid inv(Node** head)\n{\n    if (size(*head) &lt; 2) return;\n    Node* t1 = *head; // 结点1\n    Node* t2 = t1-&gt;next; // 结点2\n    Node* t3; // 当结点2改为指向结点1时，临时存结点2的next  \n    while (t2 != NULL) { // 这种模型很常见，如菲波那切数列, 1/2+2/3+3/5,都可以用这种思路\n        t3 = t2-&gt;next;\n        t2-&gt;next = t1;\n        Node* t = t2;\n        t2 = t3;\n        t1 = t;\n    }\n    (*head)-&gt;next = NULL;\n    *head = t1;\n}\n\n// 结点的排序\nNode* find_zx(Node** head) // 寻找最小值结点地址\n{\n    // 肯定不为空，至少有1个结点\n    Node* temp = *head;\n    if (temp-&gt;next == NULL) { // 只有一个结点 \n        *head = NULL;\n        return temp;\n    } else { // 至少两个结点\n        Node* min = temp;\n        Node* pre_min;\n        while (temp-&gt;next != NULL) {\n            if (min-&gt;d &gt; (temp-&gt;next)-&gt;d) {\n                min = temp-&gt;next;\n                pre_min = temp;\n            }\n            temp = temp-&gt;next;\n        }\n        pre_min-&gt;next = min-&gt;next;\n        return min;\n    }\n}\n\nvoid add_node(Node** head, Node* p) // 尾部添加完整结点\n{\n    p-&gt;next = NULL;\n    if (*head == NULL)\n        *head = p;\n    else {\n        Node* temp = *head;\n        while (temp-&gt;next != NULL) {\n            temp = temp-&gt;next;\n        }\n        temp-&gt;next = p;\n    }\n}\n\nvoid sort(Node** head) // 排序\n{\n    if (size(*head) &lt; 2) return;\n    //思路 新建一个链表头结点，每次找出最小值结点(返回地址,解除与原链表的关系)，依次添加到新链表\n    Node* list = NULL;\n    while(1) {\n        if (size(*head) == 0) break;\n        Node* t = find_zx(head);\n        // printf(&quot;[[%d &quot;,t-&gt;d);  测试用\n        add_node(&amp;list, t);\n    }\n    *head = list;\n}\n\nint main(int argc, char* argv[])\n{\n    Node* head = NULL; // 创建一个单向链表，头节点\n    add_h(&amp;head, 1);\n    add_h(&amp;head, 2);\n    add_h(&amp;head, 3);\n    add_t(&amp;head, 4);\n    add_t(&amp;head, 5);\n    add_t(&amp;head, 6);\n    add_pos(&amp;head, 10, 1);\n    add_pos(&amp;head, 100, 3);\n    add_pos(&amp;head, 1000, 8);\n    /*del_h(&amp;head);\n    del_h(&amp;head);\n    del_t(&amp;head);\n    del_t(&amp;head);\n    del_pos(&amp;head,1);\n    del_pos(&amp;head,4);\n    del_pos(&amp;head,2);\n    */\n    printf(&quot;size=%d\\n&quot;, size(head));\n    print(head);\n    inv(&amp;head);\n    print(head);\n    sort(&amp;head);\n    print(head);\n    exit(0);\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "c语言单向链表的实现"
        }
      ],
      "config": {
        "source": "c语言单向链表的实现.md",
        "staticFileName": "c_linked_list.html",
        "author": "guoqzuo",
        "createDate": "2016/10/16",
        "description": "c语言指针和结构体一学完就是链表了。也是一个分水岭，很多小白都卡在了这里，当初我自学时就是在这个位置时放弃了。我发现很多地方讲链表都讲得比较复杂，其实链表很简单，就是将多个数据(结构体类型)连在一起。只要有该链表头结点的地址，就可以操作这一连串数据。",
        "keywords": "c语言单向链表,单向链表,单向链表理解,c 链表,c 单向链表",
        "category": "C与APUE",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"unix环境高级编程apue\">unix环境高级编程(APUE)</h1>\n<blockquote>\n<p>APUE是一本非常经典的书，被认为是在UINX环境下进行程序设计有关人员必读，且需要经常查阅的首选参考书，对于深入了解UNIX及内核源码非常有利。这本书没有花哨的界面，各种高大上的程序都是用C语言编写且在终端下运行，在这个浮躁的社会，能潜心去钻研这本书真的非常不容易。但只要用心去研究，一定会有意想不到的收获。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/apue/apue_first_1.png\" alt=\"apue_first_1.png\"></p>\n<h2 id=\"unix操作系统os与内核kernel\">UNIX操作系统(OS)与内核(Kernel)</h2>\n<p>从严格意义上讲OS就是Kernel，可以理解为一种软件。它能够控制计算机软硬件资源，提供程序运行环境。从广义的角度来看OS不仅包含了Kernel，还加上一些其他软件，这些软件包括app，shell，公用库函等。</p>\n<p><img src=\"../../../images/blog/apue/apue_first_2.png\" alt=\"apue_first_2.png\"></p>\n<h2 id=\"系统调用、公用库函数、shell\">系统调用、公用库函数、shell</h2>\n<h3 id=\"系统调用system-call\">系统调用(system call)</h3>\n<p>内核提供的接口函数，对应man手册第2章。它是内核的唯一接口。只要和内核交互，一定通过系统调用来实现。一些C语言库函数就是对系统调用的封装，如fopen和fwrite就是封装了open和wirte两个系统调用，在用户空间增加了缓冲机制。C库函数不一定都是封装了系统调用，如一些不需要操作内核的函数:strcpy，atoi等。</p>\n<p><img src=\"../../../images/blog/apue/apue_first_3.png\" alt=\"apue_first_3.png\"></p>\n<h3 id=\"公用库函数\">公用库函数</h3>\n<p>C语言库函数，对应man手册第3章。  </p>\n<p><img src=\"../../../images/blog/apue/apue_first_4.png\" alt=\"apue_first_4.png\"></p>\n<h3 id=\"shell\">shell</h3>\n<p>一个抽象的概念，特殊应用程序，为其他应用程序提供接口。shell的用户输入通常来自终端(交互式shell)，也可以来自于文件(如shell脚本)。可以理解为命令解释器，接收用户命令(如ls等)，然后调用相应的程序。macOS下默认的shell是bash，终端下的可执行命令，也叫shell命令(man手册第1章)。    有些shell命令如pwd、ls、cp、mv、cd、cp、mv等都可以通过调用系统调用来实现，后面会具体的讲。</p>\n<p><img src=\"../../../images/blog/apue/apue_first_5.png\" alt=\"apue_first_5.png\"></p>\n<h2 id=\"apue内容对应内核功能\">APUE内容对应内核功能</h2>\n<ul>\n<li>进程调度 -- 进程控制、线程控制、进程间通信(IPC)</li>\n<li>内存分配</li>\n<li>文件系统 -- 文件和目录、文件I/O、标准I/O、系统数据文件和信息、高级I/O</li>\n</ul>\n<h2 id=\"文件系统\">文件系统</h2>\n<p>文件系统非常重要，UNIX下所有的一切皆文件(everything is file)。</p>\n<ul>\n<li>根(root)目录用 &quot;/&quot;表示。</li>\n<li>主文件夹为: &quot;<del>&quot; 打开Terminal，当前所在的目录就是主文件夹(</del>), 任何目录输入cd命令都会进入该目录。</li>\n<li>相对路径: 不是以根目录开头的路径，绝对路径: 以根目录开头的路径。</li>\n<li>目录(directory): 文件夹，也是文件的一种创建新目录时，会自动创建两个文件.和..文件，分别代表当前路径和上一级路径,可用ls -a查看。</li>\n</ul>\n<h2 id=\"输入和输出-io\">输入和输出 I/O</h2>\n<p>C语言中，输入输出函数都定义在stdio.h里，一般叫标准I/O，一个程序在运行时会打开3个缓冲区: 输入缓冲区，输出缓冲区，错误缓冲区。scanf的原理是从输入缓冲区读取相应格式的数据(%d),存储到变量里(&amp;n)。printf的原理是将数据(n)以相应的格式(%d)写入输出缓冲区。输入缓冲区的文件一般由键盘写入或文件重定向(./a.out &lt; 1.txt), 输入缓冲区的内容会打印或重定向到文件。这三个缓冲区实际上对应的是三个文件，当程序执行时，会默认打开着三个文件，标准I/O表现形式对应fopen的返回值FILE*类型 stdin、stdout、stderr; 文件I/O表现形式对应open的返回值int类型 0、1、2（有对应的宏，但感觉0，1，2更好记）。在C语言笔记里有用wirte(1,&quot;str&quot;,&quot;lengt&quot;)来代替printf的例子，printf就是向输出缓冲区文件写入内容这里的0、1、2也叫fd(文件描述符 file descriptor)。相关实例：将输入缓冲区内容写入输出缓冲区，gcc编译链接后 ./a.out &lt; 1.c 相当于cat 1.c, 复制文件可以用 ./a.out &lt; 1.c &gt; 1.txt, 相当于cp 1.c 1.txt</p>\n<pre><code class=\"language-c\">/*  \n  *  将输入缓冲区的内容写入输出缓冲区  \n  *  Mon Oct 17 17:26:29 2016\n  *  Create by Kevin Zuo\n  */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char* argv[])\n{\n    int n = 0;\n    char buf[1024] = {0};\n\n    /*\n    while (fgets(buf, 1024, stdin) != NULL) { // 标准I/O\n        fputs(buf, stdout);\n    }\n    */\n\n    while((n = read(0, buf, 1024)) != 0) { // 文件I/O\n        write(1, buf, n); // 忽略出错判断与网络掉包情况\n    }\n\n    exit(0);\n}</code></pre>\n<h2 id=\"程序和进程\">程序和进程</h2>\n<p>程序(program)是存储在磁盘上某个目录的可执行文件，使用exec函数将程序读入内存并执行。程序的运行实例称为进程(process)，UNIX确保每个进程都有一个唯一的数字标识符(进程ID)，控制进程主要有三个函数 fork, exec, waitpid。例子: shell终端程序模拟   </p>\n<pre><code class=\"language-c\">/*  \n  *  shell终端程序模拟  \n  *  Mon Oct 17 17:45:24 2016\n  *  Create by Kevin Zuo\n  */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char* argv[])\n{\n    char buf[128] = {0};\n    // 服务器程序一般都是一个while(1)，UI程序也类似，会开多个进程或线程,一直等待用户操作    \n    while (1) { // 省略了出错判断\n        printf(&quot;] &quot;);\n        memset(buf, 0, 128);\n        fgets(buf, 128, stdin); // 获取输入缓冲区内容\n        buf[strlen(buf)-1] = &#39;\\0&#39;; // 去掉默认的回车\n        int pid = fork();\n        if (pid == 0) { // fork一个子进程，处理程序,如不开子进程execl运行完后程序后结束\n            execlp(buf, buf, NULL); \n            return 0;\n        }\n        wait(NULL); // 等待子进程处理结束\n    }\n\n    exit(0);\n}</code></pre>\n<p>运行效果：</p>\n<p><img src=\"../../../images/blog/apue/apue_first_6.png\" alt=\"apue_first_6.png\"></p>\n<p>如果需要了解更多详情，请移步: <a href=\"http://www.apuebook.com/\">APUE book</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "unix环境高级编程(APUE)",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "UNIX操作系统(OS)与内核(Kernel)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "系统调用、公用库函数、shell",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "系统调用(system call)"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "公用库函数"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "shell"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "APUE内容对应内核功能"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "文件系统"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "输入和输出 I/O"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "程序和进程"
            }
          ]
        }
      ],
      "config": {
        "source": "unix环境高级编程(APUE).md",
        "staticFileName": "apue_first.html",
        "author": "guoqzuo",
        "createDate": "2016/10/17",
        "description": "APUE是一本非常经典的书，被认为是在UINX环境下进行程序设计有关人员必读，且需要经常查阅的首选参考书，对于深入了解UNIX及内核源码非常有利。这本书没有花哨的界面，各种高大上的程序都是用C语言编写且在终端下运行，在这个浮躁的社会，能潜心去钻研这本书真的非常不容易。但只要用心去研究，一定会有意想不到的收获。",
        "keywords": "APUE,apue 笔记, APUE笔记,UNIX基础知识,UNIX环境高级编程,apue",
        "category": "C与APUE",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"apue-文件io\">apue 文件IO</h1>\n<blockquote>\n<p>UNIX系统中，文件I/O常用的5个函数: open,read,write,lseek,close。与标准I/O相比文件I/O通常称为不带缓冲的I/O(unbuffered)。一般所有I/O都要经过内核的块缓冲。read，write的数据也要被内核缓冲，这里不带缓冲的I/O指的是在用户进程用不会自动缓冲，每次都是系统调用。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/apue/apue_file_io_1.png\" alt=\"apue_file_io_1.png\"></p>\n<h2 id=\"文件描述符-file-descriptor\">文件描述符 (file descriptor)</h2>\n<p>对内核而言，所有打开的文件都是通过fd来引用。</p>\n<p>文件描述符0，1，2分别与进程的标准输入，输出，错误缓冲区相关联，分别对应宏STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO。这些宏都在unistd.h里定义，一般每个进程最多能打开64个文件</p>\n<h2 id=\"io函数概述\">I/O函数概述</h2>\n<p>这里主要介绍open、create、read、write、lseek、close、fcntl等函数</p>\n<h3 id=\"open函数\">open函数</h3>\n<p>类似printf，可变长参数，可以是2参或3参。打开文件，返回该文件的fd，错误返回-1，且修改errno值</p>\n<pre><code class=\"language-c\">int open(const char *path, int oflag, ...); // open or create a file for reading or writing</code></pre>\n<p>函数参数：</p>\n<ul>\n<li>path: 文件路径</li>\n<li>oflag: 文件打开的方式，只读O_RDONLY、只写O_WRONLY、读写O_RDWR、追加写入O_APPED等<ul>\n<li>只读，只写，读写 三个中必选一个，其它的是可以追加的，一般标志位的定义都是以8进制来对应</li>\n<li>只读为0，只写为1，追加写入为8，可以&quot;|&quot;的方式进行组合。</li>\n<li>O_EXCL | O_CREAT，文件存在返回-1，否则正常执行，防止同名文件被修改</li>\n<li>O_TRUNC | O_CREAT, 文件存在就清空，不存在就创建</li>\n<li>open时如果文件不存在会返回错误，除非打开时加上标记位:O_CREAT, 文件不存在就创建</li>\n</ul>\n</li>\n<li>创建文件时权限，O_CREAT 打开文件时，如果文件不存在，就需要使用参数3了，用来指定穿件文件时的默认权限，0644。<ul>\n<li>以前只有两参后来加了一个参数，用来淘汰creat()函数，使打开文件和创建文件成为原子性操作</li>\n</ul>\n</li>\n</ul>\n<p>示例: open(&quot;1.c&quot;, O_RDONLY | O_CREAT, 0644) 打开文件，如果存在就打开，不存在创建，权限为0644，如果只用2参，写法如下    </p>\n<pre><code class=\"language-c\">if ((fd = open(&quot;1.c&quot;, O_RDONLY)) &lt; 0) {\n    if (error == ENOENT) { // 如果文件打开失败，且错误为文件不存在\n        creat(&quot;1.c&quot;, 0644);\n    } else {\n        perror(&quot;open()&quot;);\n        return 1;\n    }\n}</code></pre>\n<p><strong>系统调用函数一般是原子性(atomic operation)的，在执行的时候不会因为进程调度中断其执行而产生bug</strong></p>\n<h3 id=\"create函数\">create函数</h3>\n<pre><code class=\"language-c\">// DESCRIPTION   This interface is made obsolete by: open(2).\n// The creat() function is the same as: open(path, O_CREAT | O_TRUNC | O_WRONLY, mode);\nint creat(const char *path, mode_t mode);</code></pre>\n<h3 id=\"read函数\">read函数</h3>\n<pre><code class=\"language-c\">// 读取文件内容存入buf，返回读取的字节数，return 0 表示文件已读完\nssize_t read(int fildes, void *buf, size_t nbyte); // read input </code></pre>\n<h3 id=\"write函数\">write函数</h3>\n<pre><code class=\"language-c\">// 向文件写入内容\nssize_t write(int fildes, void *buf, size_t nbyte); // wirte output</code></pre>\n<h3 id=\"lseek函数\">lseek函数</h3>\n<pre><code class=\"language-c\">// 移动文件偏移位置，之前写一个取反加密时用过.  \n// whence有3种情况0,1,2分别对应SEEK_SET、SEEK_CUR、SEEK_END, 宏和数字怎么方便就怎么用\noff_t lseek(int fildes, off_t offset, int whence); // reposition read/write file offset</code></pre>\n<h3 id=\"close函数\">close函数</h3>\n<pre><code class=\"language-c\">// 关闭文件，官方解释为删除fd\nint close(int fildes);  // delete a descriptor</code></pre>\n<h3 id=\"fcntl函数\">fcntl函数</h3>\n<pre><code class=\"language-c\">int fcntl(int fildes, int cmd, ...); // file control\n// 可以修改已打开文件的fd标志，文件状态标志，复制fd，参数2决定它的功能\n// cmd = F_GETFD/F_SETFD 获取或设置fd标志\n// cmd = F_GETFL/F_SETFL 获取或设置文件状态标志，可追加O_APPED\n// cmd = F_DUPFD，复制fd</code></pre>\n<h2 id=\"内核io数据结构\">内核I/O数据结构</h2>\n<p>当打开一个文件，内核以什么形式来保持/操作相关数据？(以下UNIX系统适用，具体实现可能有差异）</p>\n<p>当一个进程执行时：</p>\n<ul>\n<li>有一张进程表，里面包含一张打开文件表。每个打开的fd占一行，有两个属性:fd标志、文件指针</li>\n<li>文件表里记录了文件状态标志(只读/写/追加等,用于指向该表所有fd)、当前偏移量、指向v结点表的指针</li>\n<li>v结点表简化来讲包含了i节点表，里面记录了文件的基本信息，当前文件的长度等，如下图:    </li>\n</ul>\n<p><img src=\"../../../images/blog/apue/apue_file_io_2.png\" alt=\"apue_file_io_2.png\"></p>\n<p>0、1、2为进程默认代开的文件</p>\n<p><strong>每次write后，文件表里的文件偏移量会加入所写入的字节数，如国偏移量超过文件长度，i结点表的当前文件长度会修改为当前偏移量，文件增大。lseek没有进行任何I/O操作，只是修改了文件表中的当前文件偏移量</strong></p>\n<h2 id=\"两个进程操作同一个文件\">两个进程操作同一个文件</h2>\n<p><img src=\"../../../images/blog/apue/apue_file_io_3.png\" alt=\"apue_file_io_3.png\"></p>\n<ul>\n<li><p>两个进程打开同一个文件，对应的文件表独立，但v结点是同一个</p>\n</li>\n<li><p>当两个进程同时open了一个文件，他们的文件偏移位置是独立的，进程1向文件写入数据，文件偏移，但此时进程2的文件偏移还是0，此时进程2写入数据，进程1写入的数据将被覆盖, O_APPEND可解决这个问题</p>\n</li>\n<li><p><strong>O_APPEND原理是当要写入数据到文件时，如果文件状态标志有O_APPEND，会先将文件的偏移量改为v结点里当前文件的长度，再write，就相当于每次write都要先lseek(fd, 0, SEEK_END); 但是这里是原子性的.</strong></p>\n</li>\n</ul>\n<h2 id=\"文件描述符的copydup-dup2\">文件描述符的copy(dup, dup2)</h2>\n<p>dup, dup2 -- duplicate an existing file descriptor</p>\n<p>open()函数返回fd遵循最小分配原则，默认打开了0、1、2，最小分配为3，如果0、1、2有关闭的，下次open就会占用系统的这些值, 例如close(1)后open一个文件，那么这个文件就成了输出缓冲区</p>\n<pre><code class=\"language-c\">int dup(int oldfd); // 将oldfd再分配一个fd，最小分配原则\nint dup2(int oldfd, int newfd); // 复制fd，可指定新fd的值，如果新的已打开，先关闭。</code></pre>\n<p><img src=\"../../../images/blog/apue/apue_file_io_4.png\" alt=\"apue_file_io_4.png\"></p>\n<pre><code class=\"language-c\">dup(fd); // ==&gt; fcntl(fd, F_DUPFD, 0);\n\ndup(fd, fd2); // ==&gt; close(fd2); \nfcntl(fd, F_DUPFD, fd2);  // dup2是一个原子性的操作</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "apue 文件IO",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "文件描述符 (file descriptor)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "I/O函数概述",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "open函数"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "create函数"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "read函数"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "write函数"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "lseek函数"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "close函数"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "fcntl函数"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "内核I/O数据结构"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "两个进程操作同一个文件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "文件描述符的copy(dup, dup2)"
            }
          ]
        }
      ],
      "config": {
        "source": "apue 文件IO.md",
        "staticFileName": "apue_file_io.html",
        "author": "guoqzuo",
        "createDate": "2016/10/18",
        "description": " UNIX系统中，文件I/O常用的5个函数: open,read,write,lseek,close。与标准I/O相比文件I/O通常称为不带缓冲的I/O(unbuffered)。一般所有I/O都要经过内核的块缓冲。read，write的数据也要被内核缓冲，这里不带缓冲的I/O指的是在用户进程用不会自动缓冲，每次都是系统调用。",
        "keywords": "文件IO,标准IO,C语言文件处理,APUE文件IO,apue 文件io",
        "category": "C与APUE",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"apue-ls命令实现\">apue ls命令实现</h1>\n<blockquote>\n<p>C语言操作目录需要使用opendir()和readdir()。此外文件接口函数还有很多，如stat，umask，chmod，chown，link，rename等。这些函数和shell命令有些是一样的，我们可以通过调用这些系统调用来实现一些命令。这里以ls -l的写法为例介绍一些常用的系统调用文件I/O。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/apue/apue_ls.png\" alt=\"apue_ls.png\"></p>\n<h2 id=\"stat\">stat()</h2>\n<p>get file status 获取文件的状态   <code>man 2 stat</code></p>\n<pre><code class=\"language-c\">int stat(const char *restrict path, struct stat *restrict buf); // 成功return 0，失败return -1</code></pre>\n<p><strong>指针作为函数参数只有两种情况，一种是传参(path)，一种是做为结果参数.</strong> 这里的path就是传的路径，stat函数会获取这个路径文件的状态信息，存入buf这个结构体变量里(struct stat*)</p>\n<pre><code class=\"language-c\">struct stat { /* when _DARWIN_FEATURE_64_BIT_INODE is NOT defined */\n  dev_t    st_dev;    /* device inode resides on */\n  ino_t    st_ino;    /* inode&#39;s number */\n  mode_t   st_mode;   /* inode protection mode */\n  nlink_t  st_nlink;  /* number of hard links to the file */\n  uid_t    st_uid;    /* user-id of owner */\n  gid_t    st_gid;    /* group-id of owner */\n  dev_t    st_rdev;   /* device type, for special file inode */\n  struct timespec st_atimespec;  /* time of last access */\n  struct timespec st_mtimespec;  /* time of last data modification */\n  struct timespec st_ctimespec;  /* time of last file status change */\n  off_t    st_size;   /* file size, in bytes */\n  quad_t   st_blocks; /* blocks allocated for file */\n  u_long   st_blksize;/* optimal file sys I/O ops blocksize */\n  u_long   st_flags;  /* user defined flags for file */\n  u_long   st_gen;    /* file generation number */\n};\nstruct timespec {  // st_atimespec.tv_sec ==&gt; st_atime; st_mtimespec.tv_sec ==&gt; st_mtime;...\n  time_t tv_sec; // seconds \n  long tv_nsec; // and nanoseconds \n};</code></pre>\n<p><strong>需要用到的属性st_mode, st_ino, st_nlink, st_uid, st_pid, st_mtime, st_size</strong></p>\n<h3 id=\"st_mode\">st_mode</h3>\n<p>st_mode 记录了文件类型，文件的权限信息</p>\n<pre><code class=\"language-sh\">kevindeMacBook-Air:~ kevin$ ls -l 1.c\n-rw-r--r--  1 kevin  staff  247 10 19 22:55 1.c</code></pre>\n<h4 id=\"文件类型\">文件类型</h4>\n<p>第一位:&quot;-&quot; 表示文件类型，UNIX下文件就只有以下7种类型</p>\n<pre><code class=\"language-c\">#define S_IFMT   0170000  /* type of file 用于&amp;st_mode值后与如下值对比 */\n#define S_IFIFO  0010000  /* named pipe (fifo) 管道文件&quot;p&quot; */\n#define S_IFCHR  0020000  /* character special 字符设备文件&quot;c&quot; */\n#define S_IFDIR  0040000  /* directory 目录(文件夹)&quot;d&quot; */\n#define S_IFBLK  0060000  /* block special 块设备&quot;b&quot; */\n#define S_IFREG  0100000  /* regular 普通文件&quot;-&quot; */\n#define S_IFLNK  0120000  /* symbolic link 符号链接(快捷方式)文件&quot;l&quot; */\n#define S_IFSOCK 0140000  /* socket 网络套接字文件 &quot;s&quot; */</code></pre>\n<h4 id=\"文件对应权限\">文件对应权限</h4>\n<p>第2-10位&quot;rw-r--r--&quot; 对应三组权限(当前用户权限、当前用户组权限、其它用户权限)</p>\n<pre><code class=\"language-c\">// 三组权限0644 ==&gt; 110100100 ==&gt; rw-r--r--\n// st_mode 类型是mode_t,16位,一般用6个8进制来表示，高两位表示文件类型，第一位最高为1, 16 = 1+5*3</code></pre>\n<h4 id=\"特殊属性\">特殊属性</h4>\n<p>第3位是文件的特殊属性(设置用户ID，设置组ID，暂时用不到), 后3位为文件的三种权限</p>\n<pre><code class=\"language-c\">struct stat buf;\nstat(&quot;1.c&quot;, &amp;buf); // 获取当前目录(~)下文件1.c的信息存入变量buf\nprintf(&quot;%lu\\n&quot;, sizeof(mode_t)); // 打印mode_t的长度\nprintf(&quot;%o\\n&quot;, buf.st_mode); // 打印st_mode值\n// 执行结果: \n// kevindeMacBook-Air:~ kevin$ ./a.out\n// 2\n// 100644\n// kevindeMacBook-Air:~ kevin$\n// 高两位10表示是普通文件&quot;-&quot;，最后3为表示权限644 &quot;rw-r--r--&quot;</code></pre>\n<h3 id=\"st_nlink-文件硬链接数\">st_nlink 文件硬链接数</h3>\n<pre><code class=\"language-sh\">kevindeMacBook-Air:~ kevin$ ls -l 1.c\n-rw-r--r--  1 kevin  staff  247 10 19 22:55 1.c</code></pre>\n<p>文件的硬链接与软链接：</p>\n<ul>\n<li><p>软链接: 创建一个符号链接(软连接，快捷方式) make symbolic link to a file</p>\n<pre><code class=\"language-c\">int symlink(const char *path1, const char *path2);\n// 当用stat获取软件接软件文件时，会获取它指向的文件\n// lstat()可以解决这个bug, new文件的i节点与源文件不同，大小也不同，不受限于文件系统，可用于目录  </code></pre>\n<p>缺点: 当链接文件换了路径，这个符号链接就找不到了</p>\n</li>\n<li><p>硬链接: 为一个已存在的文件创建一个硬链接 make a hard file link, 类似于为文件创建了一个新的名字，两个文件的i节点是一样的，cp出来的则不同，i节点是不一样的</p>\n<pre><code class=\"language-c\">int link(const char *path1, const char *path2); // 两个文件任意更改一个都会影响另一个\nlink(&quot;1.c&quot;,&quot;2.c&quot;); // 修改1.c， 2.c的文件同步更新，rm 1.c或unlink 1.c，2.c都不会变</code></pre>\n<p>这个函数不能都目录进行操作. 但系统里面是存在目录硬链接的。当文件的硬连接数为0，系统会删除该文件</p>\n</li>\n</ul>\n<h3 id=\"文件名\">文件名</h3>\n<p>为什么要单独讲文件名，如果我们是通过argv来获取文件名，文件名很好获取，但系统自带的ls，是不会传文件名的，这里就需要用到opendir()和readdir()以及st_ino(i结点号)了。有一个笨的方法来获取一个文件的文件名，就是读取当前目录里的每一个文件，与当前文件的st_ino对比，用stat获取文件的状态不包含文件名，但有i结点号</p>\n<pre><code class=\"language-c\">DIR * opendir(const char *filename); // 打开目录\nstruct dirent * readdir(DIR *dirp); // 遍历读取目录文件，包括. 和..\nint closedir(DIR *dirp); // man 5 dir\nstruct dirent { /* when _DARWIN_FEATURE_64_BIT_INODE is NOT defined */\n      ino_t      d_fileno;     /* file number of entry */\n      __uint64_t d_seekoff;    /* seek offset (optional, used by servers) */\n      __uint16_t d_reclen;     /* length of this record */\n      __uint16_t d_namlen;     /* length of string in d_name */\n      __uint8_t  d_type;       /* file type, see below */\n      char    d_name[1024];    /* name must be no longer than this */\n};</code></pre>\n<p>示例</p>\n<pre><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;dirent.h&gt;\n\nint main()\n{\n    struct stat buf;\n    char fn[100] = {0};\n    struct dirent* p;\n    DIR* dirp = opendir(&quot;.&quot;); // 打开当前目录\n\n    stat(&quot;1.txt&quot;, &amp;buf);\n    while (1) {\n        int n = errno;\n        p = readdir(dirp);\n        if (p == NULL &amp;&amp; n != errno) { // 读取目录失败\n            perror(&quot;readdir()&quot;);\n            return;\n        }\n        if (p == NULL) break; // 读取目录完毕\n        if (p-&gt;d_ino == buf.st_ino) {\n            strncpy(fn, p-&gt;d_name, strlen(p-&gt;d_name));\n            break;\n        }\n    }\n    printf(&quot;%s\\n&quot;, fn);\n    return 0;\n}\n\n// 执行结果:\n// kevindeMacBook-Air:~ kevin$ ./a.out\n// 1.txt\n// kevindeMacBook-Air:~ kevin$</code></pre>\n<h3 id=\"其他\">其他</h3>\n<ul>\n<li>st_uid用户id</li>\n<li>st_gid用户组id</li>\n<li>st_size文件大小</li>\n<li>st_time文件最后修改时间</li>\n</ul>\n<p>根据uid，gid获取用户名和用户组名</p>\n<pre><code class=\"language-c\">struct passwd * getpwuid(uid_t uid); // struct passwd* t; t-&gt;pw_name 就是用户名\nstruct group * getgrgid(gid_t gid); // struct group* t; t-&gt;gr_name 就是用户组名\n// 最后一次修改时间 st_mtime， 是ld类型，可用localtime转为对应的格式  </code></pre>\n<p>示例:</p>\n<pre><code class=\"language-c\"> int main(int argc, char* argv[])\n {\n    struct stat buf;\n    struct passwd* t1;\n    struct group* t2;\n    struct tm* t;\n\n    stat(&quot;1.c&quot;, &amp;buf); // 获取当前目录(~)下文件1.c的信息存入变量buf\n    t1 = getpwuid(buf.st_uid);\n    t2 = getgrgid(buf.st_gid);\n    t = localtime(&amp;buf.st_mtime);\n\n    printf(&quot;%d &quot;, buf.st_nlink); // 文件硬链接数\n    printf(&quot;%s %s &quot;, t1-&gt;pw_name, t2-&gt;gr_name); // 文件的拥有者及所在用户组\n    printf(&quot;%lld &quot;, buf.st_size); //文件大小\n    printf(&quot;%d %d %d:%d\\n&quot;, t-&gt;tm_mon+1, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min);\n\n    return 0;\n}  \n// 执行结果:\n// kevindeMacBook-Air:~ kevin$ ./a.out\n// 1 kevin staff 247 10 19 22:55</code></pre>\n<p>上面的例子其实已经包含了ls -a实现方法了，ls只需过滤文件名为.开头的文件</p>\n<p>ls -l 就是ls功能的增强版，只是遍历文件得到文件名后，在获取文件状态，再按照上面的方法获取相应值。</p>\n<p>ls -R的实现也是可以的，递归的方法好实现，但当数据过大时栈满了会溢出。造成段错误! </p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "apue ls命令实现",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "stat()",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "st_mode",
                  "children": [
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "文件类型"
                    },
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "文件对应权限"
                    },
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "特殊属性"
                    }
                  ]
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "st_nlink 文件硬链接数"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "文件名"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "其他"
                }
              ]
            }
          ]
        }
      ],
      "config": {
        "source": "apue ls命令实现.md",
        "staticFileName": "apue_ls.html",
        "author": "guoqzuo",
        "createDate": "2016/10/18",
        "description": "C语言操作目录需要使用opendir()和readdir()。此外文件接口函数还有很多，如stat，umask，chmod，chown，link，rename等。这些函数和shell命令有些是一样的，我们可以通过调用这些系统调用来实现一些命令。这里以ls -l的写法为例介绍一些常用的系统调用文件I/O。",
        "keywords": "stat,文件和目录操作,ls实现",
        "category": "C与APUE",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"apue-pwd命令实现\">apue pwd命令实现</h1>\n<blockquote>\n<p>了解了文件目录相关的系统调用后，就可以尝试模拟实现各种shell命令了。这里给出了ls -l的完成代码，加上pwd及mkdir -p的实现。里面用到了递归，也涉及到一些细节问题，如根目录的上一级目录还是根目录，chdir需要用户有目录的执行权限。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/apue/apue_pwd.png\" alt=\"apue_pwd.png\"></p>\n<h2 id=\"pwd命令的实现，显示当前路径\">pwd命令的实现，显示当前路径</h2>\n<p>思路: 先获取当前目录的名字，然后chdir到上一级目录，重复..直到根目录  </p>\n<pre><code class=\"language-c\">/*  \n *  pwd的实现  \n *  Thu Oct 20 17:48:52 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;dirent.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;string.h&gt;\n\nvoid pwd()\n{\n    struct stat buf;\n    struct stat buf2;\n    DIR* dirp = opendir(&quot;..&quot;);\n\n    lstat(&quot;.&quot;, &amp;buf);\n    lstat(&quot;..&quot;, &amp;buf2);\n    if ( buf.st_ino == buf2.st_ino) // 如果当前目录和上一级目录的i节点相同\n        return;\n\n    chdir(&quot;..&quot;); // 先递归再打印\n    pwd();\n\n    struct dirent* p;\n    while(1) {\n        int err = errno;\n        p = readdir(dirp);\n        if (p == NULL &amp;&amp; errno != err) { // 错误提示\n            perror(&quot;readdir()&quot;);\n            return;\n        }\n        if (p == NULL) break; // 读完退出\n        if (p-&gt;d_fileno == buf.st_ino) { // 找到文件名后结束\n            printf(&quot;/%s&quot;, p-&gt;d_name);\n            break;\n        }\n    }\n\n\nint main(int argc, char* argv[])\n{\n    // 如果是在根目录，省略处理...; 某些出错判断，省略...\n    pwd();\n    printf(&quot;\\n&quot;);\n\n    exit(0);\n}\n\n// 运行效果:\n// kevindeMacBook-Air:~ kevin$ ./a.out\n// /Users/kevin\n// kevindeMacBook-Air:~ kevin$ pwd\n// /Users/kevin\n// kevindeMacBook-Air:~ kevin$</code></pre>\n<h2 id=\"ls--l-的完整实现\">ls -l 的完整实现</h2>\n<p>思路: 遍历当前目录的文件，过滤掉以.开头的文件，以一定格式打印</p>\n<pre><code class=\"language-c\">/*  \n *  ls -l的实现  \n *  Thu Oct 20 19:09:48 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;dirent.h&gt;\n#include &lt;pwd.h&gt;\n#include &lt;grp.h&gt;\n#include &lt;errno.h&gt;\n\nvoid print_mode(mode_t mode)\n{\n    //printf(&quot;%o &quot;, mode);\n    switch (mode &amp; S_IFMT) { // 打印文件类型\n        case S_IFIFO: putchar(&#39;p&#39;); break;\n        case S_IFCHR: putchar(&#39;c&#39;); break;\n        case S_IFDIR: putchar(&#39;d&#39;); break;\n        case S_IFBLK: putchar(&#39;b&#39;); break;\n        case S_IFREG: putchar(&#39;-&#39;); break;\n        case S_IFLNK: putchar(&#39;l&#39;); break;\n        case S_IFSOCK: putchar(&#39;s&#39;); break;\n    }\n    if (mode &amp; S_IRUSR) putchar(&#39;r&#39;); else putchar(&#39;-&#39;);\n    if (mode &amp; S_IWUSR) putchar(&#39;w&#39;); else putchar(&#39;-&#39;);\n    if (mode &amp; S_IXUSR) putchar(&#39;x&#39;); else putchar(&#39;-&#39;);\n\n    if (mode &amp; S_IRGRP) putchar(&#39;r&#39;); else putchar(&#39;-&#39;);\n    if (mode &amp; S_IWGRP) putchar(&#39;w&#39;); else putchar(&#39;-&#39;);\n    if (mode &amp; S_IXGRP) putchar(&#39;x&#39;); else putchar(&#39;-&#39;);\n\n    if (mode &amp; S_IROTH) putchar(&#39;r&#39;); else putchar(&#39;-&#39;);\n    if (mode &amp; S_IWOTH) putchar(&#39;w&#39;); else putchar(&#39;-&#39;);\n    if (mode &amp; S_IXOTH) putchar(&#39;x&#39;); else putchar(&#39;-&#39;);\n\n    putchar(&#39; &#39;);\n}\n\nint main(int argc, char* argv[])\n{\n    DIR* dirp = opendir(&quot;.&quot;);\n    struct dirent* p;\n\n    while (1) {\n        int err = errno;\n        p = readdir(dirp);\n        if (err != errno &amp;&amp; p == NULL) {\n            perror(&quot;readdir()&quot;);\n            return 1;\n        }\n        if (p == NULL) break;\n        if (p-&gt;d_name[0] == &#39;.&#39;) continue; // 如果是隐藏文件，退出\n\n        struct stat buf;\n        struct passwd* t1;\n        struct group* t2;\n        struct tm* t;\n\n        lstat(p-&gt;d_name, &amp;buf); // 获取当前目录(~)下文件1.c的信息存入变量buf\n        t1 = getpwuid(buf.st_uid);\n        t2 = getgrgid(buf.st_gid);\n        t = localtime(&amp;buf.st_mtime);\n\n        print_mode(buf.st_mode); // 打印前面的信息\n        printf(&quot;%2d &quot;, buf.st_nlink); // 文件硬链接数\n        printf(&quot;%s %s &quot;, t1-&gt;pw_name, t2-&gt;gr_name); // 文件的拥有者及所在用户组\n        printf(&quot;%6lld &quot;, buf.st_size); //文件大小\n        printf(&quot;%2d %2d %02d:%02d &quot;, t-&gt;tm_mon+1, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min);\n        printf(&quot;%s\\n&quot;, p-&gt;d_name);\n    }\n\n    exit(0);\n}\n\n// 运行效果：\n// kevindeMacBook-Air:~ kevin$ ./a.out\n// drwxr-xr-x 30 kevin staff   1020 10 20 19:19 1\n// -rw-r--r--  1 kevin staff    143 10 17 17:31 1.txt\n// -rw-r--r--  1 kevin staff 144313 10 15 16:27 1015.sql\n// -rw-r--r--  1 kevin staff 143533 10 15 19:07 1015_2.sql\n// -rw-r--r--  1 kevin staff    143 10 17 17:37 5.txt\n// -rwxr-xr-x  1 kevin staff   9008 10 20 19:49 a.out\n// drwx------ 17 kevin staff    578 10 20 18:56 Desktop\n// drwx------  7 kevin staff    238 10 13 14:46 Documents\n// drwx------ 15 kevin staff    510 10 18 15:04 Downloads\n// drwx------ 53 kevin staff   1802  8  2 12:21 Library\n// -rw-r--r--  1 kevin staff   2046 10 20 19:49 ls.c\n// drwx------  3 kevin staff    102  6  1 12:08 Movies\n// drwx------  5 kevin staff    170  6 25 15:49 Music\n// drwx------  4 kevin staff    136 10 17 16:00 Pictures\n// drwxr-xr-x  5 kevin staff    170  6  1 12:08 Public\n// -rw-r--r--  1 kevin staff    918 10 20 19:28 pwd.c\n// kevindeMacBook-Air:~ kevin$ ls -l\n// total 632\n// drwxr-xr-x  30 kevin  staff    1020 10 20 19:19 1\n// -rw-r--r--   1 kevin  staff     143 10 17 17:31 1.txt\n// -rw-r--r--   1 kevin  staff  144313 10 15 16:27 1015.sql\n// -rw-r--r--   1 kevin  staff  143533 10 15 19:07 1015_2.sql\n// -rw-r--r--   1 kevin  staff     143 10 17 17:37 5.txt\n// drwx------+ 17 kevin  staff     578 10 20 18:56 Desktop\n// drwx------+  7 kevin  staff     238 10 13 14:46 Documents\n// drwx------+ 15 kevin  staff     510 10 18 15:04 Downloads\n// drwx------@ 53 kevin  staff    1802  8  2 12:21 Library\n// drwx------+  3 kevin  staff     102  6  1 12:08 Movies\n// drwx------+  5 kevin  staff     170  6 25 15:49 Music\n// drwx------+  4 kevin  staff     136 10 17 16:00 Pictures\n// drwxr-xr-x+  5 kevin  staff     170  6  1 12:08 Public\n// -rwxr-xr-x   1 kevin  staff    9008 10 20 19:49 a.out\n// -rw-r--r--   1 kevin  staff    2046 10 20 19:49 ls.c\n// -rw-r--r--   1 kevin  staff     918 10 20 19:28 pwd.c\n// kevindeMacBook-Air:~ kevin$</code></pre>\n<p>这里没有处理l符号链接，有时间可以扩展</p>\n<h2 id=\"mkdir--p-功能模拟\">mkdir -p 功能模拟</h2>\n<pre><code class=\"language-c\">int mkdir(const char *path, mode_t mode); -- make a directory file\nint chdir(const char *path); -- change current working directory\nIn order for a directory to become the current directory, a process must have execute (search) access to the directory.</code></pre>\n<p>这里可能是为什么文件权限为0644, 而目录的权限是0755的原因(都多了执行权限)</p>\n<pre><code class=\"language-c\">/*  \n *  mkdir -p 模拟  \n *  Thu Oct 20 20:23:01 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/stat.h&gt;\n\nint main(int argc, char* argv[])\n{\n    if (argc != 2) { // 通过命令行传参 ./a.out 4/2/3, 乱传参数错误处理部分会忽略\n        printf(&quot;argc error!&quot;);\n        exit(1);\n    }\n\n    if (!access(argv[1], F_OK)) { // 如果该文件已存在\n        printf(&quot;文件已存在!&quot;);\n        exit(2);\n    }\n    if (argv[1][0] == &#39;/&#39;) // 如果是根目录下\n        chdir(&quot;/&quot;);\n    char* p = strtok(argv[1], &quot;/&quot;);\n    if (mkdir(p, 0755)) { // 根目录下可能会出现权限限制 ./a.out /5\n        perror(&quot;mkdir()&quot;);\n        exit(3);\n    }\n    chdir(p);\n\n    while (1) { // 循环切分\n        char* q = strtok(NULL, &quot;/&quot;);\n\n        if (q == NULL)\n            break;\n        if (!access(q, F_OK)) continue;\n        mkdir(q, 0755);\n        chdir(q);\n    }\n\n    exit(0);\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "apue pwd命令实现",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "pwd命令的实现，显示当前路径"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "ls -l 的完整实现"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "mkdir -p 功能模拟"
            }
          ]
        }
      ],
      "config": {
        "source": "apue pwd命令实现.md",
        "staticFileName": "apue_pwd.html",
        "author": "guoqzuo",
        "createDate": "2016/10/20",
        "description": "了解了文件目录相关的系统调用后，就可以尝试模拟实现各种shell命令了。这里给出了ls -l的完成代码，加上pwd及mkdir -p的实现。里面用到了递归，也涉及到一些细节问题，如根目录的上一级目录还是根目录，chdir需要用户有目录的执行权限。",
        "keywords": "apue笔记,pwd实现,ls -l实现,mkdir -p实现",
        "category": "C与APUE",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"apue-信号signal\">apue 信号signal</h1>\n<blockquote>\n<p>这里所说的信号也叫软中断信号，当进程接收到一个来自内核的信号，如ctrl+c时，进程就会中断。系统定义了一些宏来表示这些中断。一般以SIG开头，对于这些信号，系统会有默认的处理方式，也可以通过signal函数，自定义处理方式(系统默认处理/ignore/执行某个函数)。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/apue/apue_signal.png\" alt=\"apue_signal.png\"></p>\n<p>man signal</p>\n<pre><code class=\"language-c\">No    Name         Default Action       Description\n1     SIGHUP       terminate process    terminal line hangup\n2     SIGINT       terminate process    interrupt program // ctrl+c\n3     SIGQUIT      create core image    quit program  // ctrl+\n4     SIGILL       create core image    illegal instruction\n5     SIGTRAP      create core image    trace trap\n6     SIGABRT      create core image    abort program (formerly SIGIOT) // abort()\n7     SIGEMT       create core image    emulate instruction executed\n8     SIGFPE       create core image    floating-point exception\n9     SIGKILL      terminate process    kill program  // kill()\n10    SIGBUS       create core image    bus error\n11    SIGSEGV      create core image    segmentation violation\n12    SIGSYS       create core image    non-existent system call invoked\n13    SIGPIPE      terminate process    write on a pipe with no reader\n14    SIGALRM      terminate process    real-time timer expired // alarm signal\n15    SIGTERM      terminate process    software termination signal\n16    SIGURG       discard signal       urgent condition present on socket\n17    SIGSTOP      stop process         stop (cannot be caught or ignored)\n18    SIGTSTP      stop process         stop signal generated from keyboard\n19    SIGCONT      discard signal       continue after stop\n20    SIGCHLD      discard signal       child status has changed // child process terminate\n21    SIGTTIN      stop process         background read attempted from control terminal\n22    SIGTTOU      stop process         background write attempted to control terminal\n23    SIGIO        discard signal       I/O is possible on a descriptor (see fcntl(2))\n24    SIGXCPU      terminate process    cpu time limit exceeded (see setrlimit(2))\n25    SIGXFSZ      terminate process    file size limit exceeded (see setrlimit(2))\n26    SIGVTALRM    terminate process    virtual time alarm (see setitimer(2))\n27    SIGPROF      terminate process    profiling timer alarm (see setitimer(2))\n28    SIGWINCH     discard signal       Window size change\n29    SIGINFO      discard signal       status request from keyboard\n30    SIGUSR1      terminate process    User defined signal 1\n31    SIGUSR2      terminate process    User defined signal 2</code></pre>\n<h2 id=\"信号的产生\">信号的产生</h2>\n<ul>\n<li>通过ctr+c(SIGINT)或ctrl+(SIGQUIT)等组合键，请求内核产生信号</li>\n<li>当进程执行出错或某些事件(段错误[SIGSEGV]，除0[SIGFPE])发生时。</li>\n<li>通过kill调用</li>\n</ul>\n<h2 id=\"信号处理的3种方式\">信号处理的3种方式</h2>\n<ul>\n<li>执行默认处理方式，一般是终止程序，signal(SIGINT, SIG_DFL); // default 默认</li>\n<li>忽略信号 signal(SIGINT, SIG_IGN); // ignore 忽略</li>\n<li>调用一个函数(signal) // 写一个函数，收到某个信号就去执行这个函数 void k(int num); signal(SIGINT, k);</li>\n</ul>\n<h2 id=\"signal函数\">signal函数</h2>\n<pre><code class=\"language-c\">sig_t signal(int sig, sig_t func); \ntypedef void (*sig_t) (int); // 指向函数的指针 void k(int sum)\n// 参数1: 信号标识(宏) // SIGALRM, SIGINT\n// 参数2: 处理方式 SIG_IGN(忽略)，SIG_DFL(默认)，函数k</code></pre>\n<p>一般情况下while(1)执行的程序遇到ctrl+c和ctrl+&quot;&quot;系统会默认终止程序，下面的程序改写对应的处理方式  </p>\n<pre><code class=\"language-c\">/*  \n *  signal的基本处理  \n *  Fri Oct 21 00:17:19 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid k(int num)\n{\n    printf(&quot;产生了%d号中断信号!&quot;, num);\n}\n\nint main(int argc, char* argv[])\n{\n    // ctrl+c的效果\n    //signal(SIGINT, SIG_IGN); // ...^C... 忽略信号,进程不会结束\n    //signal(SIGINT, SIG_DFL); // ....^C  默认 结束进程\n    signal(SIGINT, k); // ...^C产生了2号中断信号!.... 执行k函数,进程不结束\n\n    // ctrl+的效果类似.. SIGQUIT\n\n    while (1) { // 每隔1秒打印一个.\n        putchar(&#39;.&#39;);\n        fflush(stdout);\n        sleep(1);\n    }\n\n    exit(0);\n}</code></pre>\n<h2 id=\"alarm信号sigalrm的处理\">alarm信号(SIGALRM)的处理</h2>\n<p>闹钟信号</p>\n<pre><code class=\"language-c\">// unsigned alarm(unsigned seconds); -- set signal timer alarm\n// DESCRIPTION\n//   This interface is made obsolete by setitimer(2). // 类似 creat ==&gt; open()</code></pre>\n<p>小例子:</p>\n<pre><code class=\"language-c\">/*  \n *  alarm 信号  \n *  Fri Oct 21 00:44:26 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char* argv[])\n{\n    signal(SIGALRM, SIG_DFL); // ...Alarm clock: 14 默认处理方式中断   \n    // signal(SIGALRM, SIG_IGN); // 忽略什么都不做\n    alarm(3);\n\n    while (1) {\n        putchar(&#39;.&#39;);\n        fflush(stdout);\n        sleep(1);\n    }\n\n    exit(0);\n}</code></pre>\n<h2 id=\"通过alarmpause-模拟sleep的功能\">通过alarm+pause() 模拟sleep的功能</h2>\n<pre><code class=\"language-c\">// int pause(void); -- stop until signal 进程挂起，直到捕捉到一个信号</code></pre>\n<p>将上面的程序改写</p>\n<pre><code class=\"language-c\">/*  \n *  alarm 信号  改写sleep \n *  Fri Oct 21 00:44:26 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid my_sleep(int t)\n{\n    alarm(t);\n    pause();\n}\n\nvoid k(int num)\n{\n}\n\nint main(int argc, char* argv[])\n{\n    signal(SIGALRM, k); // 执行函数，什么都不做，保证不退出进程，并可激活pause()\n    while (1) {\n        putchar(&#39;.&#39;);\n        fflush(stdout);\n        my_sleep(1); // 与系统的sleep基本一致\n    }\n\n    exit(0);\n}</code></pre>\n<h2 id=\"alarm的升级版，setitimer\">alarm的升级版，setitimer()</h2>\n<p>可产生连续的SIGALRM信号， 而alarm()只能产生一次</p>\n<pre><code class=\"language-c\">int setitimer(int which, const struct itimerval * value, struct itimerval * ovalue);\n//  -- set value of interval timer\n//  参数1: which 计时的方式,分3种\n//        #define ITIMER_REAL      0   真实时间\n//        #define ITIMER_VIRTUAL   1   用户空间执行时间  \n//        #define ITIMER_PROF      2   系统调用，cpu调度时间 \n//  参数2: \n//        struct itimerval {\n//            struct  timeval it_interval;    /* timer interval */ 以后每次产生时间间隔\n//            struct  timeval it_value;       /* current value */ 第一次产生时间\n//        }; \n//        struct timeval {\n//            time_t       tv_sec;     /* seconds */\n//            suseconds_t   tv_usec; /* microseconds */\n//        };\n//  参数3: 设置是否保存老值, 一般填NULL\n//  struct itimerval t; setitimer(0, &amp;t, NULL);</code></pre>\n<p>改写上面的sleep  </p>\n<pre><code class=\"language-c\">/*  \n *  setitimer 产生连续的alarm信号  改写sleep \n *  Fri Oct 21 00:44:26 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/time.h&gt;\n\nvoid k(int num) { }\n\nint main(int argc, char* argv[])\n{\n    signal(SIGALRM, k); // 执行函数，什么都不做，保证不退出进程，并可激活pause()\n    struct itimerval t;\n\n    t.it_interval.tv_sec = 1;\n    t.it_interval.tv_usec = 0;\n    t.it_value.tv_sec = 1;\n    t.it_value.tv_usec = 0;\n    setitimer(0, &amp;t, NULL); // 每个1秒产生一个SIGALRM信号\n\n    while (1) {\n        putchar(&#39;.&#39;);\n        fflush(stdout);\n        pause();\n    }\n\n    exit(0);\n}</code></pre>\n<h2 id=\"信号掩码-相当于信号黑名单\">信号掩码 相当于信号黑名单</h2>\n<p>在信号处理的过程中，如果该信号再次被触发，会阻塞，例子:</p>\n<pre><code class=\"language-c\">/*  \n *  signal 信号阻塞  \n *  Fri Oct 21 01:39:54 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid k(int num) {\n    printf(&quot;start\\n&quot;);\n    sleep(5);\n    printf(&quot;end\\n&quot;);\n}\n\nint main(int argc, char* argv[])\n{\n    signal(SIGINT, k);\n\n    while (1) {\n        putchar(&#39;.&#39;);\n        fflush(stdout);\n        sleep(1);\n    }\n\n    exit(0);\n}\n\n// 执行结果如下： \n// 当第一次ctrl+c，执行函数k，SIGINT自动加到黑名单，即信号掩码，除第一次之后的多次调用只会执行一次   \n// kevindeMacBook-Air:~ kevin$ ./a.out\n// ...^Cstart     \n// ^C^C^Cend\n// start\n// end\n// ............</code></pre>\n<h2 id=\"信号掩码的处理-signal的升级版-sigaction\">信号掩码的处理, signal的升级版 sigaction()</h2>\n<pre><code class=\"language-c\">struct  sigaction {\n    union __sigaction_u __sigaction_u;  /* signal handler */\n    sigset_t sa_mask;               /* signal mask to apply */\n    int     sa_flags;               /* see signal options below */\n};\nunion __sigaction_u {\n    void    (*__sa_handler)(int);\n    void    (*__sa_sigaction)(int, siginfo_t *, void *);\n};\n#define sa_handler      __sigaction_u.__sa_handler\n#define sa_sigaction    __sigaction_u.__sa_sigaction\nint sigaction(int sig, const struct sigaction * act, struct sigaction * oact);\n// 允许嵌套，允许添加信号掩码集，安全性高</code></pre>\n<p>示例</p>\n<pre><code class=\"language-c\">/*  \n *  signal 升级版 sigaction\n *  Fri Oct 21 02:02:29 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;signal.h&gt;\n\nvoid k(int num)\n{\n    printf(&quot;stat\\n&quot;);\n    sleep(5);\n    printf(&quot;end\\n&quot;);\n}\n\nint main(int argc, char* argv[])\n{\n    struct sigaction acts;\n    acts.sa_handler = k;\n    sigemptyset(&amp;acts.sa_mask); // 将信号掩码集清空,默认为空，可不写\n    sigaddset(&amp;acts.sa_mask, SIGQUIT); // 加入SIGQUIT信号\n    acts.sa_flags = SA_NODEFER; // 允许嵌套\n    sigaction(SIGINT, &amp;acts, NULL);\n    while (1) {\n        putchar(&#39;.&#39;);\n        fflush(stdout);\n        sleep(1);\n    }\n\n    exit(0);\n}\n\n// 执行结果:\n// kevindeMacBook-Air:~ kevin$ ./a.out\n// ..^Cstat\n// ^Cstat\n// ^Cstat\n// ^end\n// end\n// end\n// Quit: 3\n// kevindeMacBook-Air:~ kevin$</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "apue 信号signal",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "信号的产生"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "信号处理的3种方式"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "signal函数"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "alarm信号(SIGALRM)的处理"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "通过alarm+pause() 模拟sleep的功能"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "alarm的升级版，setitimer()"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "信号掩码 相当于信号黑名单"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "信号掩码的处理, signal的升级版 sigaction()"
            }
          ]
        }
      ],
      "config": {
        "source": "apue 信号signal.md",
        "staticFileName": "apue_signal.html",
        "author": "guoqzuo",
        "createDate": "2016/10/21",
        "description": "这里所说的信号也叫软中断信号，当进程接收到一个来自内核的信号，如ctrl+c时，进程就会中断。系统定义了一些宏来表示这些中断。一般以SIG开头，对于这些信号，系统会有默认的处理方式，也可以通过signal函数，自定义处理方式(系统默认处理/ignore/执行某个函数)。",
        "keywords": "信号signal,signal函数,alarm函数,sleep函数功能实现,unix signal",
        "category": "C与APUE",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"apue-进程process\">apue 进程(Process)</h1>\n<blockquote>\n<p>进程就是正在运行的程序。不管是进程还是线程，主要作用就是可以在同一时间内同时处理多个事情，提升用户体验。像shell终端，如果是单个进程，那每次执行完命令，都需要重新打开终端，非常不利于操作。拿扫雷来说，如果一边开个while(1)来处理输入输出，那如果你需要实时显示时间呢? 学了进程相关的操作后就可以fork一个子程序专门用来显示实时时钟。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/apue/apue_process_1.png\" alt=\"apue_process_1.png\"></p>\n<h2 id=\"进程---正在运行的程序\">进程 - 正在运行的程序</h2>\n<p>c语言中main函数就是主进程，一个shell程序的执行过程</p>\n<ol>\n<li>用户输入./a.out</li>\n<li>shell建立一个新的进程来运行这个程序  // fork</li>\n<li>shell将程序从磁盘载入 // exec 以代码覆盖的方式执行程序</li>\n<li>程序在它的进程中运行知道结束 // wait</li>\n</ol>\n<pre><code class=\"language-c\">int execl(const char *path, const char *arg0, ... /*, (char *)0 */);\nint execlp(const char *file, const char *arg0, ... /*, (char *)0 */);\nexecl(&quot;/bin/ls&quot;, &quot;ls&quot;,&quot;-l&quot;,&quot;-a&quot;,NULL);  execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;-l&quot;,&quot;-a&quot;,NULL);\n// 后面加p的作用直接从环境变量里找ls可执行程序，如果不加就要指定绝对路径\n// l ==&gt; v 只是将参数2...到参数n字符串封装成了数组, 不用NULL((char*)0)结束\n\n/* execl execv execlp  execvp 在程序运行过程中，运行另一个程序\n * 有无p表示是否需要指定路径 l/ｖ表示是否用数组封装\n */</code></pre>\n<p>示例</p>\n<pre><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main()\n{\n  //execl(&quot;/bin/pwd&quot;,&quot;pwd&quot;,NULL); // 以代码覆盖的方式让一个程序替换另一个程序运行\n  //execl(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL); \n  //char *arr[]={&quot;ls&quot;,&quot;-l&quot;,NULL}; // NULL 可以让数组知道在哪结束\n  //execv(&quot;/bin/ls&quot;,arr);\n  execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL); // 自动到环境变量里面去找\n  perror(&quot;execl()&quot;); // 错误检查，如果上一行失败，不会执行到这里\n  printf(&quot;b\\n&quot;);\n\n  return 0;\n}</code></pre>\n<h2 id=\"进程终止\">进程终止</h2>\n<p>5种正常终止方式</p>\n<ul>\n<li>从main函数返回</li>\n<li>调用exit() // 执行清理处理(fclose() 所有打开流，fflush输出缓冲区) man 3 exit</li>\n<li>调用_exit或_Exit // 立即进入内核 _exit由POSIX.1是系统调用，_Exit和exit为C库函数(ISO C)</li>\n<li>最后一个线程return</li>\n<li>最后一个线程调用 pthread_exit()</li>\n</ul>\n<p>3种异常终止方式:</p>\n<ul>\n<li>调用abort</li>\n<li>接到一个信号</li>\n<li>最后一个线程对取消请求作出响应</li>\n</ul>\n<p>进程的终止状态exit, _exit, _Exit 可以指定具体值， return 0, exit(0);</p>\n<p>查看程序的退出状态 echo $?</p>\n<p><img src=\"../../../images/blog/apue/apue_process_2.png\" alt=\"apue_process_2.png\"></p>\n<p><strong>内核使程序执行的唯一方式是调用一个exec()函数，进程自愿终止的唯一方法是显示或隐式调用_exit或_Exit,也可以非自愿的由一个终端信号使其终止</strong></p>\n<h2 id=\"进程环境表\">进程环境表</h2>\n<p>shell cmd &quot;printenv&quot;, 每个程序都会有一张环境表，它是一个字符串指针数组和argv[]类似，全局变量environ可访问该环境表</p>\n<pre><code class=\"language-c\">extern char** environ;</code></pre>\n<p><img src=\"../../../images/blog/apue/apue_process_3.png\" alt=\"apue_process_3.png\"></p>\n<p>两种方法都可以打印环境表，到达printenv的效果, 代码如下:      </p>\n<pre><code class=\"language-c\">/*  \n *  环境表  \n *  Sat Oct 22 17:43:20 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nextern char** environ; // 调用全局变量方法\n\nint main(int argc, char* argv[], char* envp[])\n{\n    int n = 0;\n\n    while (1) { // 遍历打印环境表   \n        if (*(environ+n) == NULL) break;\n        printf(&quot;%s\\n&quot;, *(environ+n));\n        /*  调用 main函数第3参数 envp\n            if (envp[n] == NULL)\n                break;\n            printf(&quot;%s\\n&quot;, envp[n]);\n        */\n        n++;\n    }\n\n    exit(0);\n}</code></pre>\n<h2 id=\"fork-创建一个子进程\">fork() 创建一个子进程</h2>\n<p>通过fork系统调用可以以复制的方式创建一个新的进程，新进程拥有和原进程一样的代码，数据，运行位置。</p>\n<pre><code class=\"language-c\">pid_t fork(void);  // -- create a new process</code></pre>\n<ul>\n<li>fork()创建的新进程被称为子进程，函数执行一次，但返回两次,子进程返回0，父进程返回子进程id</li>\n<li>子进程是父进程的副本，各自空间独立，也就是说子进程里面变量值的改变对父进程没有任何影响，fork之后</li>\n<li>子进程会复制父进程的文件描述符，fork之后父子进程谁先执行时不确定的.<pre><code class=\"language-c\">pid_t wait(int *stat_loc);  -- wait for process termination  // 父进程阻塞等待所有子进程结束\nstat_loc是结果参数，可获子进程的退出状态，不去获取其退出状态可填NULL, wait(NULL);\npid_t waitpid(pid_t pid, int *stat_loc, int options); // 可等待某个子进程结束</code></pre>\npid如果是-1，表示所有子进程, stat_loc同wait, options 0无特殊要求 WNOHANG,有结束就等，没有就不等了</li>\n</ul>\n<p>子进程退出时，父进程会收到一个SIGCHLD信号    </p>\n<pre><code class=\"language-c\">/*  \n *  fork()\n *  Sat Oct 22 18:24:37 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char* argv[])\n{\n    fork();\n    fork();\n    printf(&quot;pid = %d, ppid = %d\\n&quot;, getpid(), getppid());\n    // 会打印4次,子进程结束后如果不return，顺序执行\n\n    exit(0);\n}\n\n// 执行结果对比:    \n// kevindeMacBook-Air:~ kevin$ ./a.out\n// TERM_PROGRAM=Apple_Terminal\n// SHELL=/bin/bash\n// TERM=xterm-256color\n// TMPDIR=/var/folders/mw/hbp6ytc9753gcm3zhqbmfkp40000gn/T/\n// Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.iGH1KaBlJJ/Render\n// TERM_PROGRAM_VERSION=361.1\n// TERM_SESSION_ID=800C54D0-5E25-4B6D-9C3C-B7348F78B6BD\n// USER=kevin\n// SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.ZLi0oN8Xp8/Listeners\n// __CF_USER_TEXT_ENCODING=0x1F5:0x19:0x34\n// PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/mysql/bin\n// PWD=/Users/kevin\n// LANG=zh_CN.UTF-8\n// XPC_FLAGS=0x0\n// XPC_SERVICE_NAME=0\n// SHLVL=1\n// HOME=/Users/kevin\n// LOGNAME=kevin\n// _=./a.out\n// kevindeMacBook-Air:~ kevin$ printenv\n// TERM_PROGRAM=Apple_Terminal\n// SHELL=/bin/bash\n// TERM=xterm-256color\n// TMPDIR=/var/folders/mw/hbp6ytc9753gcm3zhqbmfkp40000gn/T/\n// Apple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.iGH1KaBlJJ/Render\n// TERM_PROGRAM_VERSION=361.1\n// TERM_SESSION_ID=800C54D0-5E25-4B6D-9C3C-B7348F78B6BD\n// USER=kevin\n// SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.ZLi0oN8Xp8/Listeners\n// __CF_USER_TEXT_ENCODING=0x1F5:0x19:0x34\n// PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/mysql/bin\n// PWD=/Users/kevin\n// LANG=zh_CN.UTF-8\n// XPC_FLAGS=0x0\n// XPC_SERVICE_NAME=0\n// SHLVL=1\n// HOME=/Users/kevin\n// LOGNAME=kevin\n// _=/usr/bin/printenv\n// kevindeMacBook-Air:~ kevin$</code></pre>\n<h2 id=\"fork-分支\">fork 分支</h2>\n<pre><code class=\"language-c\">/*  \n *  fork() 分支  \n *  Sat Oct 22 18:24:37 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char* argv[])\n{\n    int pid = fork();\n    // 这时有两个进程在顺序向下执行\n    if (pid == 0) { // 如果是子进程\n        return 0; //或 exit(0); 可以结束子进程,子进程就不会打印下面的值了\n    }\n    printf(&quot;pid = %d, ppid = %d\\n&quot;, getpid(), getppid());\n\n    exit(0);\n}</code></pre>\n<h2 id=\"wait-示例\">wait() 示例</h2>\n<pre><code class=\"language-c\">/*  \n *  fork(), wait() \n *  Sat Oct 22 18:24:37 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char* argv[])\n{\n    int pid = fork();\n\n    if (pid == 0) { // 如果是子进程\n        printf(&quot;child process!\\n&quot;);\n        return 0;\n    }\n    //sleep(1); // sleep后子进程会先打印\n    //wait(NULL); // 等待子进程结束，只有这样子进程退出后其占用的资源才会被释放干净\n    printf(&quot;123\\n&quot;);\n\n    exit(0);\n}</code></pre>\n<h2 id=\"fork的理解\">fork的理解</h2>\n<pre><code class=\"language-c\">/*  \n *  fork() 的理解\n *  Sat Oct 22 18:24:37 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char* argv[])\n{\n    int  n = 1;\n    for (int i = 0; i &lt; 3; i++) {\n        fork();\n    }\n    n++;\n    printf(&quot;%d\\n&quot;, n); // n的值永远是2，进程各自独立，不会改变其值，打印次数为2的3次方\n\n    exit(0);\n}</code></pre>\n<h2 id=\"sigchld信号\">SIGCHLD信号</h2>\n<pre><code class=\"language-c\">/*  \n *  SIGCHLD \n *  Sat Oct 22 18:24:37 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid k(int n)\n{\n    printf(&quot;子进程结束!&quot;);\n}\n\nint main(int argc, char* argv[])\n{\n    signal(SIGCHLD, k);\n\n    int pid = fork();\n    if (pid == 0) {\n        sleep(5); // 子进程空间与父进程空间独立, sleep 5s对父进程无影响\n        return 0; // 子进程结束父进程会收到SIGCHLD信号\n    }\n\n    while (1) {\n        putchar(&#39;.&#39;);\n        fflush(stdout);\n        sleep(1);\n    }\n\n    exit(0);\n}\n\n// 执行结果:\n// kevindeMacBook-Air:~ kevin$ ./a.out\n// .....子进程结束!....\n// kevindeMacBook-Air:~ kevin$</code></pre>\n<h2 id=\"子进程对文件描述符的影响\">子进程对文件描述符的影响</h2>\n<pre><code class=\"language-c\">/*  \n *  fork对文件描述符的影响  \n *  Sat Oct 22 18:24:37 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n\nint main(int argc, char* argv[])\n{\n    int fd = open(&quot;data.txt&quot;, O_RDWR|O_CREAT, 0644);\n\n    int pid = fork(); // 父子进程会共享文件表，偏移量\n\n    //如果fd在此处open，数据会覆盖\n\n    if (pid == 0) {\n        write(fd,&quot;hellodd&quot;, 8);\n        return 0;\n    }\n\n    wait(NULL);\n    write(fd, &quot;world&quot;, 5);\n\n    exit(0);\n}</code></pre>\n<p><img src=\"../../../images/blog/apue/apue_process_4.png\" alt=\"apue_process_4.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "apue 进程(Process)",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "进程 - 正在运行的程序"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "进程终止"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "进程环境表"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "fork() 创建一个子进程"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "fork 分支"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "wait() 示例"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "fork的理解"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "SIGCHLD信号"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "子进程对文件描述符的影响"
            }
          ]
        }
      ],
      "config": {
        "source": "apue 进程(Process).md",
        "staticFileName": "apue_process.html",
        "author": "guoqzuo",
        "createDate": "2016/10/22",
        "description": "进程就是正在运行的程序。不管是进程还是线程，主要作用就是可以在同一时间内同时处理多个事情，提升用户体验。像shell终端，如果是单个进程，那每次执行完命令，都需要重新打开终端，非常不利于操作。拿扫雷来说，如果一边开个while(1)来处理输入输出，那如果你需要实时显示时间呢? 学了进程相关的操作后就可以fork一个子程序专门用来显示实时时钟。",
        "keywords": "unix进程,fork,进程,process,apue fork",
        "category": "C与APUE",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"apue-进程间通信ipc\">apue 进程间通信IPC</h1>\n<blockquote>\n<p>由于进程所处的空间都是独立的，如果多个子进程需要交互数据，那就需要了解进程间通信(InterProcess Communication, IPC)了。这里先介绍前三种通信方式：1. 管道(无名) 只能用于父子进程通信，半双工，单向；2. 命名管道，同一台主机的任意两个进程；3. 共享内存。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/apue/apue_ipc_1.png\" alt=\"apue_ipc_1.png\"></p>\n<h2 id=\"无名管道pipe\">无名管道pipe</h2>\n<p>int pipe(int fildes[2]); -- create descriptor pair for interprocess communication</p>\n<ol>\n<li>pipe打开了一个&quot;文件&quot;, 他有两个文件描述符，一个专门用来读，一个专门用来写。</li>\n<li>fildes参数是一个结果参数，两个文件描述符(fd)</li>\n</ol>\n<pre><code class=\"language-c\">int arr[2] = {0}; \npipe(arr); \n// arr[0]只能为读端，arr[1]只能为写端，fd最小分配原则!  \n// arr[0] = 3; arr[1] = 4;</code></pre>\n<p>管道中的数据会被读走，如果没有数据，read也不会返回0，而是阻塞等待有人向写端写数据，对端关闭，才能返回0，pipe之后，fork，子进程会复制父进程的文件描述符表,父子进程看到的是同一个管道，都有读写端,父读子写，子读父写，不能同时又读又写，一般父子进程需要一个关闭读端，一个关闭写端，当读端是循环的，它的写端如果不关闭，read会一直阻塞，写端要都关闭read才能正常退出，包括自己的写端</p>\n<pre><code class=\"language-c\">/*  \n *  pipe() IPC  \n *  Sat Oct 22 21:08:25 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char* argv[])\n{\n    int pid = 0;\n    int pipefd[2] = {0};\n    char buf[100] = {0};\n\n    pipe(pipefd);\n    pid = fork();\n    if (pid == 0) { // 子进程\n        close(pipefd[0]); // 关闭读\n        // sleep(5);  // 如果read 读不到数据会阻塞等待\n        write(pipefd[1], &quot;hello&quot;, 5);\n        write(pipefd[1], &quot;world&quot;, 5);\n        return 0; // 子进程结束会自己关闭对应的读写端\n    }\n\n    // 父进程\n    close(pipefd[1]); // 关闭写,如果自己的写端不关闭，作为读端会一直阻塞\n    while (1) {\n        memset(buf, 0, 100);\n        int n = read(pipefd[0], buf, 100);\n        if (n == 0) break;\n        printf(&quot;%s\\n&quot;, buf);\n    }\n\n    exit(0);\n}</code></pre>\n<p>输出重定向</p>\n<pre><code class=\"language-c\">/*  \n *  pipe() IPC  \n *  Sat Oct 22 21:08:25 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char* argv[])\n{\n    int pid = 0;\n    int pipefd[2] = {0};\n    char buf[100] = {0};\n\n    pipe(pipefd);\n    pid = fork();\n    if (pid == 0) { // 子进程\n        close(pipefd[0]); // 关闭读\n        dup2(pipefd[1], 1); // 将文件重定向都输出缓冲区\n        printf(&quot;hello world!&quot;);\n        return 0; // 子进程结束会自己关闭对应的读写端\n    }\n\n    // 父进程\n    close(pipefd[1]); // 关闭写,如果自己的写端不关闭，作为读端会一直阻塞\n    while (1) {\n        memset(buf, 0, 100);\n        int n = read(pipefd[0], buf, 100);\n        if (n == 0) break;\n        printf(&quot;%s\\n&quot;, buf);\n    }\n\n    exit(0);\n}\n\n// 执行结果:\n// kevindeMacBook-Air:~ kevin$ ./a.out\n// hello world!\n// kevindeMacBook-Air:~ kevin$</code></pre>\n<h2 id=\"命名管道-fifo\">命名管道 fifo</h2>\n<p>有名管道FIFO, 文件类型p，突破无名管道只能在父子进程通信的问题</p>\n<pre><code class=\"language-bash\">mkfifo data # 建立一个叫data的管道文件\n\n# kevindeMacBook-Air:~ kevin$ ls -l data\n# prw-r--r--  1 kevin  staff  0 10 22 21:30 data</code></pre>\n<p>int mkfifo(const char *path, mode_t mode); -- make a fifo file</p>\n<p>文件大小永远是0, 只有i节点号，写入改文件的数据不会存在硬盘里，而是写入缓存,任意的两个进程同通过打开这个文件，操作这个文件进行通信，open打开有名管道时，需遵循一个读，一个写的原则</p>\n<ul>\n<li>a.out 以只读的方式打开data，没有写会阻塞。如果以读写的方式打开，读还是会阻塞 </li>\n<li>b.out 以只写的方式打开data，没有读会阻塞。如果以读写的范式打开，写不会阻塞</li>\n</ul>\n<p>进程间通信为什么不用普通文件呢?</p>\n<ul>\n<li>很难去控制，文件打开后，如果一端写入了内容，另一端有缓存，读不出文件的变化，需要关了再打开,但怎么判断写入了多少内容，需要控制检索。</li>\n<li>验证: 先open一个文件1.txt(内容为123), 用一个scanf阻塞程序，待修改1.txt内容后，让程序继续运行</li>\n</ul>\n<pre><code class=\"language-c\">/*  \n *  open的缓存问题  \n *  Sat Oct 22 22:19:14 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char* argv[])\n{\n    int d = 0;\n    int fd = open(&quot;1.data&quot;, O_RDONLY);\n    char buf[100] = {0};\n\n    scanf(&quot;%d&quot;, &amp;d); // 阻塞，待文件修改后，再输入\n    read(fd, buf, 100); // 读出的内容不是最新的\n    printf(&quot;%s\\n&quot;, buf);\n\n    exit(0);\n}</code></pre>\n<p>fifo在普通文件的基础上，加了一些特性，让两个进程可以依靠读写来通信</p>\n<p>半双工的管道，只能一边读另一边写，如果模拟一个聊天程序，需要两个管道文件才行</p>\n<p>管道文件a: a.out写，b.out读  a.out给b.out发送消息、管道文件b: a.out读，b.out写  b.out给a.out发送消息</p>\n<p>a.c</p>\n<pre><code class=\"language-c\">/*  \n *  程序a   \n *  Sat Oct 22 23:10:14 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char* argv[])\n{\n    int n = 0;\n    char buf[100] = {0};\n\n    if(access(&quot;data_a&quot;, F_OK)) // 文件存在返回0，不存在返回-1\n        mkfifo(&quot;data_a&quot;, 0644);\n    if (access(&quot;data_b&quot;, F_OK))\n        mkfifo(&quot;data_b&quot;, 0644);\n\n    int fd_a = open(&quot;data_a&quot;, O_RDONLY);\n    int fd_b = open(&quot;data_b&quot;, O_WRONLY);\n\n    int pid = fork();\n    if (pid == 0) {\n        while(1) { // 子进程用来接收来自程序b的消息\n            read(fd_a, buf, 100);\n            printf(&quot;%s&quot;, buf);\n            fflush(stdout);\n        }\n        return 0;\n    }\n    while (1) { // 父进程用来写入信息到程序b\n        memset(buf, 0, 100);\n        fgets(buf, 100, stdin);\n        buf[strlen(buf)-1] = &#39;\\0&#39;;\n        char buf_t[100] = {0};\n        sprintf(buf_t, &quot;ProcessA: %s&quot;, buf);\n        write(fd_b, buf_t, strlen(buf_t));\n    }\n\n    exit(0);\n}</code></pre>\n<p>b.c</p>\n<pre><code class=\"language-c\">/*  \n *  程序b   \n *  Sat Oct 22 23:10:14 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char* argv[])\n{\n    int n = 0;\n    char buf[100] = {0};\n\n    if(access(&quot;data_a&quot;, F_OK)) // 文件存在返回0，不存在返回-1\n        mkfifo(&quot;data_a&quot;, 0644);\n    if (access(&quot;data_b&quot;, F_OK))\n        mkfifo(&quot;data_b&quot;, 0644);\n\n    int fd_a = open(&quot;data_a&quot;, O_WRONLY);\n    int fd_b = open(&quot;data_b&quot;, O_RDONLY);\n\n    int pid = fork();\n    if (pid == 0) {\n        while(1) { // 子进程用来接收来自程序a的消息\n            read(fd_b, buf, 100);\n            printf(&quot;%s&quot;, buf);\n            fflush(stdout);\n        }\n        return 0;\n    }\n    while (1) { // 父进程用来写入信息到程序a\n        memset(buf, 0, 100);\n        fgets(buf, 100, stdin);\n        buf[strlen(buf)-1] = &#39;\\0&#39;;\n        char buf_t[100] = {0};\n        sprintf(buf_t, &quot;ProcessB: %s\n&quot;, buf);\n        write(fd_a, buf_t, strlen(buf_t));\n    }\n\n    exit(0);\n}</code></pre>\n<p>运行结果: </p>\n<p><img src=\"../../../images/blog/apue/apue_ipc_2.png\" alt=\"apue_ipc_2.png\"></p>\n<h2 id=\"共享内存-ipcs\">共享内存 ipcs</h2>\n<p>查看已有的共享内存</p>\n<ul>\n<li>shmget创建或打开    </li>\n<li>shmat建立链接    </li>\n<li>shmdt解除链接    </li>\n<li>shmctl管理共享内存</li>\n</ul>\n<p><img src=\"../../../images/blog/apue/apue_ipc_3.png\" alt=\"apue_ipc_3.png\"></p>\n<h3 id=\"shmget-创建或打开一个共享内存\">shmget 创建或打开一个共享内存</h3>\n<pre><code class=\"language-c\">int shmget(key_t key, size_t size, int shmflg); -- get shared memory area identifier\n// 得到一个共享内存标识符或创建一个共享内存对象并返回共享内存标识\n参数1: 相当于一个暗号, 0x1234两个进程key一样，就是同一块共享内存(大小size也要一样)\n参数2: 创建或打开的共享内存的大小\n参数3: 标识位  IPC_CREAT没有就创建, 一定要 | 0644, 创建权限\nshmget(0x1234, 512, IPC_CREAT | 0644); 返回一个id</code></pre>\n<h3 id=\"shmat-获取共享内存的起始地址\">shmat 获取共享内存的起始地址</h3>\n<p>可向本地空间一样访问，连接共享内存标识符为shmid的共享内存，将共享内存区对象映射到调用进程的地址空间</p>\n<pre><code class=\"language-c\">void * shmat(int shmid, const void *shmaddr, int shmflg); \n// -- map shared memory\n// 参数1：shmget的返回值，共享内存的标识\n// 参数2：指定共享内存出现在进程内存地址的什么位置，NULL表示让内核自己决定位置\n// 参数3：0  无特殊要求   SHM_RDONLY,只读模式， 其他为读写\nchar* p = shmat(shmid, NULL, 0);</code></pre>\n<h3 id=\"shmdt-断开共享内存连接\">shmdt 断开共享内存连接</h3>\n<p>关闭共享内存与进程的连接</p>\n<pre><code class=\"language-c\">int shmdt(const void *shmaddr);  // -- unmap shared memory\n// 参数为shamt的返回值，连接的共享内存的起始地址, shmdt(p); </code></pre>\n<h3 id=\"shmctl-共享内存管理\">shmctl 共享内存管理</h3>\n<p>对共享内存的控制，可用来删除共享内存空间</p>\n<pre><code class=\"language-c\">int shmctl(int shmid, int cmd, struct shmid_ds *buf); -- shared memory control operations\n// 参数1：共享内存标识符\n// 参数2：操作标识，参数不同，操作不同\n//       IPC_STAT：将共享内存的状态复制到buf结构体里\n//       IPC_SET：改变共享内存的状态，将buf里的参数，复制到进程的shmid_ds结构类\n//       IPC_RMID：删除这片共享内存\n// 参数3：共享内存管理结构体， IPC_RMID删除时一般填NULL；</code></pre>\n<p>实例:</p>\n<p>1a.c</p>\n<pre><code class=\"language-c\">/*  \n *  1a.c 共享内存  \n *  Sun Oct 23 02:15:22 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/shm.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char* argv[])\n{\n    int shmid = shmget(0x1234, 512, IPC_CREAT | 0644);\n    char* p = shmat(shmid, NULL, 0);\n\n    memcpy(p,&quot;hello word!&quot;,strlen(&quot;hello word!&quot;));\n    shmdt(p);\n\n    exit(0);\n}</code></pre>\n<p>1b.c</p>\n<pre><code class=\"language-c\">/*  \n *  1b.c 共享内存  \n *  Sun Oct 23 02:15:22 2016\n *  Create by Kevin Zuo\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/shm.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char* argv[])\n{\n    int shmid = shmget(0x1234, 512, IPC_CREAT | 0644);\n    char* p = shmat(shmid, NULL, 0);\n\n    char buf[32] = {0};\n    memcpy(buf, p, 31);\n    printf(&quot;%s\\n&quot;, buf);\n    shmdt(p);\n    shmctl(shmid, IPC_RMID, NULL); // 删除这片共享内存\n\n    exit(0);\n}\n\n// 运行效果：\n// kevindeMacBook-Air:~ kevin$ ./a.out\n// kevindeMacBook-Air:~ kevin$ ipcs\n// IPC status from &lt;running system&gt; as of Sun Oct 23 02:35:29 CST 2016\n// T     ID     KEY        MODE       OWNER    GROUP\n// Message Queues:\n// T     ID     KEY        MODE       OWNER    GROUP\n// Shared Memory:\n// m 196608 0x53414e44 --rw-rw-rw-    kevin    staff\n// m 786433 0x00001234 --rw-r--r--    kevin    staff\n// T     ID     KEY        MODE       OWNER    GROUP\n// Semaphores:\n// kevindeMacBook-Air:~ kevin$\n// kevindeMacBook-Air:~ kevin$ ./b.out\n// hello word!\n// kevindeMacBook-Air:~ kevin$ ipcs\n// IPC status from &lt;running system&gt; as of Sun Oct 23 02:35:44 CST 2016\n// T     ID     KEY        MODE       OWNER    GROUP\n// Message Queues:\n// T     ID     KEY        MODE       OWNER    GROUP\n// Shared Memory:\n// m 196608 0x53414e44 --rw-rw-rw-    kevin    staff\n// T     ID     KEY        MODE       OWNER    GROUP\n// Semaphores:\n// kevindeMacBook-Air:~ kevin$ ./b.out</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "apue 进程间通信IPC",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "无名管道pipe"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "命名管道 fifo"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "共享内存 ipcs",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "shmget 创建或打开一个共享内存"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "shmat 获取共享内存的起始地址"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "shmdt 断开共享内存连接"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "shmctl 共享内存管理"
                }
              ]
            }
          ]
        }
      ],
      "config": {
        "source": "apue 进程间通信IPC.md",
        "staticFileName": "apue_ipc.html",
        "author": "guoqzuo",
        "createDate": "2016/10/23",
        "description": "由于进程所处的空间都是独立的，如果多个子进程需要交互数据，那就需要了解进程间通信(InterProcess Communication, IPC)了。这里先介绍前三种通信方式：1. 管道(无名) 只能用于父子进程通信，半双工，单向；2. 命名管道，同一台主机的任意两个进程；3. 共享内存。",
        "keywords": "IPC,ipc,进程间通信,apue,C语言实现聊天小程序,管道,共享内存,pipe,fifo",
        "category": "C与APUE",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"mysql连接操作命令\">mysql连接操作命令</h1>\n<blockquote>\n<p>最开始接触数据库是在学校，有一门课就是讲数据库的，但只是拿着ppt讲了将书上的东西，没有实际操作。回想起来觉得很失败，一点动手操作的意识都没。现在学东西，我更喜欢从实际的问题出发，多查资料，多实践。这里总结了mac下mysql的安装与一些基本的应用。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/db/db_mysql_basecmd_1.png\" alt=\"db_mysql_basecmd_1.png\"></p>\n<p>SQL包括:</p>\n<ul>\n<li>DDL(data definition language) 数据定义语言(创建、删除数据库、创建、删除表)</li>\n<li>DML(data manufacture language) 数据操作语言(数据的增删查改)</li>\n</ul>\n<p>mysql 注释 -- 或 /**/</p>\n<h2 id=\"mac下数据库的安装\">Mac下数据库的安装</h2>\n<p>到官网下载一个dmg安装包，顺序安装后，弹出的最后一个对话框会生成一个随机密码，保存起来。</p>\n<p>下载地址: MySQL :: Download MySQL Community Server</p>\n<p>安装完成后打开系统偏好设置，最下面会多出一个mysql图标</p>\n<p><img src=\"../../../images/blog/db/db_mysql_basecmd_2.png\" alt=\"db_mysql_basecmd_2.png\"></p>\n<p>点击进去，设置自动启动mysql</p>\n<p><img src=\"../../../images/blog/db/db_mysql_basecmd_3.png\" alt=\"db_mysql_basecmd_3.png\"></p>\n<p>将mysql的bin目录添加到环境变量 </p>\n<pre><code class=\"language-bash\">vi ~/.bash_profile # 打开环境变量配置文件\n#输入 export PATH=${PATH}:/usr/local/mysql/bin\nsource .bash_profile</code></pre>\n<p>修改数据库登录密码，先用给的随机密码登录成功后 set password=password(&#39;123456&#39;);</p>\n<p>修改编码为utf-8，防止中文乱码，mysql登录后输入status命令，显示的结果不能有latin编码</p>\n<pre><code class=\"language-bash\">sudo cp /usr/local/mysql/support-files/my-medium.cnf /etc/my.cnf\nsudo vi /etc/my.cnf\n# [client]部分加入: default-character-set=utf8, \n# [mysqld]部分加入character-set-server=utf8</code></pre>\n<h2 id=\"mysql服务的启动与关闭\">MySQL服务的启动与关闭</h2>\n<pre><code class=\"language-bash\">net start mysql # 启动\nnet stop mysql # 关闭</code></pre>\n<h2 id=\"mysql登录\">mysql登录</h2>\n<pre><code class=\"language-bash\">mysql -h -uroot -p \n# -h 可远程登录其他主机上的数据库，如 mysql -h10.141.164.59 -uroot -p \n# -u 指定用户名  -p 密码\n\n# 登录到指定的数据库myblog\nmysql -uroot -p myblog</code></pre>\n<h2 id=\"设置允许远程访问数据库--h\">设置允许远程访问数据库 -h</h2>\n<pre><code class=\"language-bash\">mysql&gt; use mysql;\n\nmysql&gt; grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; with grant option;\n\nmysql&gt; update user set password=password(&#39;密码&#39;) where user=&#39;root&#39;;\n\nmysql&gt; flush privileges;\n\nmysql&gt; exit</code></pre>\n<h2 id=\"ddl-sql语句\">DDL SQL语句</h2>\n<p>数据库:  </p>\n<pre><code class=\"language-bash\">mysql&gt; show databases; # 列出所有的数据库\n\nmysql&gt; use myblog  # 切换数据库为myblog\n\nmysql&gt; select database(); # 显示当前使用的数据库名\n\nmysql&gt; create database 数据库名; # 创建一个数据库\n\nmysql&gt; drop database 数据库名; # 删除数据库\n\nmysql&gt; alter database 数据库名 character set utf8; # 修改数据库的编码</code></pre>\n<p>数据表: </p>\n<pre><code class=\"language-c\">mysql&gt; show tables; // 显示所有的数据表\n\nmysql&gt; desc tb_bj; // 查看表的结构 tb_bj;\n\nmysql&gt; create table tb_user (id int auto_increment primary key,user varchar(100) comment &quot;用户名&quot;,passwd varchar(100) comment &quot;密码&quot;) comment &quot;用户表&quot;; // 创建数据表，要指定id，primary key \n\n// comment用于注释, 常用类型int, varchar, date, timestamp,text,longtext</code></pre>\n<p>修改/删除表: </p>\n<pre><code class=\"language-c\">mysql&gt; alter table 表名 drop 要删除的列名; // 删除列\n\nmysql&gt; alter table 表名 add 列名; // 添加列\n\nmysql&gt; alter table 表名 change 列名 新列名; // 修改列\n\nmysql&gt; drop table 表名; // 删除表</code></pre>\n<h2 id=\"dml-sql语句\">DML SQL语句</h2>\n<p>查询数据:</p>\n<pre><code class=\"language-c\">mysql&gt; select * from tb_user; // 查询表\n\nmysql&gt; select user,passwd from tb_user; //查询表里面的具体数据，如果只需要1两个不需要整个表查\n\nmysql&gt; select * from tb_user order by id DESC; // order by 排序，DESC逆序\n\nmysql&gt; select count(*) from tb_note; // 查询数据的数量\n\nmysql&gt; select * from tb_user group by department; // 查询数据时按部门统计\n\nmysql&gt; select a.id,b.id form tb_a1 a, tb_b1 b where a.id=b.kid; // 跨表查询\n\n// 不等于&lt;&gt;， not in， like &#39;%123%&#39;, and, or, varchar要加单引号&#39;&#39;\n\n// .....\n\nmysql&gt; insert into tb_user (列1,列2) values (值1,值2); // 新增数据\n\nmysql&gt; delete from tb_user where ...; // 删除表中数据 \n\nmysql&gt; update tb_user set id=1 where ...; // 修改表的数据</code></pre>\n<p>字段的批量修改:</p>\n<pre><code class=\"language-bash\">mysql&gt; update tb_user set 要修改的列名=replace(要修改的列名,&#39;本来内容&#39;,&#39;要修改的内容&#39;) where id = ..;</code></pre>\n<h2 id=\"批量执行mysql语句\">批量执行mysql语句</h2>\n<p>可以将一条条的mysql语句放在.sql文件中: init.sql，可自动执行 </p>\n<h2 id=\"数据库的备份与导入\">数据库的备份与导入</h2>\n<p>备份数据库, 终端下任意位置 mysqldump -uroot -p 数据库名 &gt; 1.sql  //  即可备份数据库</p>\n<p>导入数据库，需要先选择数据库 use 数据库名， source 1.sql</p>\n<h2 id=\"jsp连接操作mysql数据库\">jsp连接操作mysql数据库</h2>\n<p>在Eclipse或其它IDE，连接数据库，先得配置数据库相关。配置好后导入jar包，就可以在jsp页面操作了。下面是一个用jsp写的登陆密码验证及跳转。 mysql jar包:  mysql-connector-java-5.1.7-bin.jar.zip</p>\n<p><img src=\"../../../images/blog/db/db_mysql_basecmd_4.png\" alt=\"db_mysql_basecmd_4.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "mysql连接操作命令",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "Mac下数据库的安装"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "MySQL服务的启动与关闭"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "mysql登录"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "设置允许远程访问数据库 -h"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "DDL SQL语句"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "DML SQL语句"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "批量执行mysql语句"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "数据库的备份与导入"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "jsp连接操作mysql数据库"
            }
          ]
        }
      ],
      "config": {
        "source": "mysql连接操作命令.md",
        "staticFileName": "db_mysql_basecmd.html",
        "author": "guoqzuo",
        "createDate": "2016/10/23",
        "description": "最开始接触数据库是在学校，有一门课就是讲数据库的，但只是拿着ppt讲了将书上的东西，没有实际操作。回想起来觉得很失败，一点动手操作的意识都没。现在学东西，我更喜欢从实际的问题出发，多查资料，多实践。这里总结了mac下mysql的安装与一些基本的应用。",
        "keywords": "mysql连接操作命令,mysql基础命令,mac下mysql安装,mysql mac,jsp连接mysql,jsp操作mysql",
        "category": "后端数据库等",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios-infoplist与pch文件\">iOS Info.plist与pch文件</h1>\n<blockquote>\n<p>plist的全称为property list，是apple的一种属性列表文件，一般用来存储数组或字典类型数据。是iOS中数据持久化的一种方式。info.plist是app的配置文件，里面包含了app名称、版本、启动入口等基本信息。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_plist_1.png\" alt=\"ios_plist_1.png\"></p>\n<h2 id=\"infoplist配置文件\">Info.plist配置文件</h2>\n<p>这个文件就是一个字典Dictionary，这里简单介绍下，更多详情移步: <a href=\"https://my.oschina.net/hmj/blog/104196\">iOS中Info.plist文件简介</a></p>\n<p><img src=\"../../../images/blog/ios/ios_plist_2.png\" alt=\"ios_plist_2.png\"></p>\n<ul>\n<li>Bundle name: app图标下显示名称，默认为项目名: $(PRODUCT_NAME)</li>\n<li>Bundle version string, short: 版本信息</li>\n<li>Launch screen interface file base name: 启动界面，如果不指定，界面不能全屏</li>\n<li>Main stroyboard file base name: 主界面    </li>\n<li>Supported interface orientations: 横屏/竖屏</li>\n</ul>\n<h2 id=\"解析plist文件\">解析plist文件</h2>\n<p>根据Info.plist文件获取当前的版本号信息等，获取Info.plist文件字典的方法有两种</p>\n<ol>\n<li>根据Info.plist文件的路径获取字典, 先得获取plist的路径<pre><code class=\"language-objectivec\">NSString* filePath = [[NSBundle mainBundle] pathForResource:@&quot;Info.plist&quot; ofType:nil];\nNSDictionary* dict = [NSDictionary dictionaryWithContentsOfFile:filePath];\nNSLog(@&quot;%@&quot;, dict);</code></pre>\n</li>\n<li>NSBundle类自带该字典的属性<pre><code class=\"language-objectivec\">NSDictionary* dict2 = [NSBundle mainBundle].infoDictionary;\nNSLog(@&quot;%@&quot;, dict2);\n// 根据key值获取属性\nNSString* version = dict[@&quot;CFBundleShortVersionString&quot;]; // 获取版本号</code></pre>\n</li>\n</ol>\n<h2 id=\"pch文件\">pch文件</h2>\n<p>pch原理: 项目下的所有文件都共用该文件；命名规范: 与工程名一致</p>\n<p>注意事项: </p>\n<ol>\n<li>pch文件需提前编译(prefix) </li>\n<li>需要做一些判断，有c文件，就不导入OC语法</li>\n</ol>\n<p>使用前操作: 设置该文件为提前编译 Precompile prefix Header =&gt; YES; prefix Header 改为pch文件路径，相对于工程</p>\n<p><img src=\"../../../images/blog/ios/ios_plist_3.png\" alt=\"ios_plist_3.png\"></p>\n<p>由于每个OC文件都定义了宏<strong>objectivec</strong>， 如果是C文件，改宏不会被定义，所有内容写在下面的语句之间</p>\n<pre><code class=\"language-objectivec\">#ifdef __objectivec__    \n\n#endif  // __objectivec</code></pre>\n<p>作用: </p>\n<ol>\n<li>存放一些公用宏    #denfie Wid 100</li>\n<li>存放一些公用的头文件 </li>\n<li>自定义输出日志(NSLog), 调试阶段需要打印来调试，而上架时就没必要了，节省资源</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_plist_4.png\" alt=\"ios_plist_4.png\"></p>\n<pre><code class=\"language-objectivec\"> #ifdef DEBUG // 调试 DEBUG系统自带宏, 上架可修改,edit scheme,run debug修改为release\n #define KEVINLog(...) NSLog(__VA_ARGS__);\n #else // 发布\n #define KEVINLog(...)\n #endif\n// 工程里面的打印都使用KEVINLog()就可以了，__VA_ARGS__宏为可变长参数的标识</code></pre>\n<h2 id=\"xcode5--xcode6\">xcode5 ==&gt; xcode6</h2>\n<ul>\n<li>xcode6没有Frameworks文件夹，会自动导入常见的开发框架(Foundation.framework, UIKit.framework等)</li>\n<li>xcode5自带pch文件，为减少编译时间xcode6去掉了自带的pch文件</li>\n<li>xcode6多了launchSreen.xib界面，启动界面</li>\n<li>Supporting Files目录下少了InfoPlist.strings文件</li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS Info.plist与pch文件",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "Info.plist配置文件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "解析plist文件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "pch文件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "xcode5 ==> xcode6"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS Info.plist与pch文件.md",
        "staticFileName": "ios_plist.html",
        "author": "guoqzuo",
        "createDate": "2016/10/24",
        "description": "plist的全称为property list，是apple的一种属性列表文件，一般用来存储数组或字典类型数据。是iOS中数据持久化的一种方式。info.plist是app的配置文件，里面包含了app名称、版本、启动入口等基本信息。",
        "keywords": "info.plist文件,ios pch文件, pch文件,plist文件,iOS plist文件",
        "category": "iOS",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios程序启动过程，从main函数开始uiapplication与appdelegate\">iOS程序启动过程，从main函数开始UIApplication与AppDelegate</h1>\n<blockquote>\n<p>想弄清楚一段程序，就需要了解程序的执行过程。一般程序都是从main函数开始执行，iOS app也不例外。iOS程序main函数里执行了UIApplicationMain()函数，这个函数会创建UIApplication对象及代理AppDelegate，并开启事件循环，显示UI.</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_startup_1.png\" alt=\"ios_startup_1.png\"></p>\n<h2 id=\"uiapplication\">UIApplication</h2>\n<p>UIApplication对象是app的象征，每一个app都有自己的UIApplication对象，而且是唯一的(单例)。</p>\n<p>单例: 整个app只能new一次该对象，再次new会出错, iOS程序启动时，创建的第一个对象就是UIApplication.</p>\n<pre><code class=\"language-objectivec\">UIApplication* app = [[UIApplication alloc] init]; // 系统已自动创建了该对象，再次new会抛出异常\n// Terminating app due to uncaught exception &#39;NSInternalInconsistencyException&#39;, reason:  \n// &#39;There can only be one UIApplication instance.&#39;</code></pre>\n<p>获取该单例对象</p>\n<pre><code class=\"language-objectivec\">UIApplication* app= [UIApplication sharedApplication]; //获取UIApplication对象</code></pre>\n<p>创建一个类模拟系统单例的实现</p>\n<ul>\n<li>不能外界调用alloc，一调用就抛出异常</li>\n<li>提供一个方法给外界获取单例   shareXxx</li>\n<li>内部创建一次单例</li>\n</ul>\n<p>创建一个Person对象</p>\n<p>Person.h</p>\n<pre><code class=\"language-objectivec\">#import &lt;Foundation/Foundation.h&gt;\n\n@interface Person : NSObject\n\n// 获取单例\n+ (instancetype)sharePerson;\n\n@end</code></pre>\n<p>Person.m  </p>\n<pre><code class=\"language-objectivec\">#import &quot;Person.h&quot;\n\n@implementation Person\n\n// 程序启动时候创建对象\n\n// 静态变量\nstatic Person *_instance = nil;\n\n// 作用: 加载类\n// 什么时候调用: 每次程序一启动，就会把所有的类加载进内存\n+ (void)load  // 启动时间早于main函数\n{\n    NSLog(@&quot;%s&quot;, __func__);\n    _instance = [[self alloc] init]; // 创建对象\n}\n\n+ (instancetype)sharePerson  // 获取单列对象\n{\n    return _instance;\n}\n\n+ (instancetype) alloc\n{\n    // super -&gt; NSObject 才知道怎么分配内存，调用系统默认的做法,当重写一个方法的时候，如不想覆盖原来的实现\n    // 就调用super\n    if (_instance) { // 如果有值，说明已分配了内存，非第一次调用\n        // 抛出异常\n        // Terminating app due to uncaught exception &#39;NSInternalInconsistencyException&#39;, \n        // reason: &#39;There can only be one UIApplication instance.&#39;\n        // name 异常名称 、  reson 原因  、  userInfo 异常信息\n        NSException* excp = [NSException exceptionWithName:@&quot;NSInternalInconsistencyException&quot; \n                            reason:@&quot;There can only be one Person  instance.&quot; userInfo:nil];\n        [excp raise];\n    }\n    return [super alloc];\n}\n\n@end</code></pre>\n<h2 id=\"uiapplication作用\">UIApplication作用</h2>\n<p>先获取该对象</p>\n<pre><code class=\"language-objectivec\">UIApplication* app = [UIApplication sharedApplication];</code></pre>\n<h3 id=\"设置app图标的提醒数字\">设置app图标的提醒数字</h3>\n<pre><code class=\"language-objectivec\">app.applicationIconBadgeNumber = 5; // iOS8之后需注册用户通知\n/* set to 0 to hide. default is 0. In iOS 8.0 and later, your application must register \n    for user notifications using -[UIApplication registerUserNotificationSettings:] before\n    being able to set the icon badge. */\nUIUserNotificationSettings* setting = [UIUserNotificationSettings\n        settingsForTypes:UIUserNotificationTypeBadge categories:nil]; //创建通知对象\n    [app registerUserNotificationSettings:setting]; // 注册用户通知</code></pre>\n<h3 id=\"设置状态栏联网提示\">设置状态栏联网提示</h3>\n<pre><code class=\"language-objectivec\">[app setNetworkActivityIndicatorVisible:YES];\n// 或者 \napp.networkActivityIndicatorVisible = YES;</code></pre>\n<h3 id=\"设置状态栏-隐藏\">设置状态栏, 隐藏</h3>\n<pre><code class=\"language-objectivec\">//状态栏默认是交给UIViewController控制器管理，但控制器可能多个，可交给UIApplication管理\n//设置Info.plist文件  add key: View controller-based status bar appearance ==&gt; No\napp.statusBarHidden = YES;\n\n// 如果没有设置，只能使用View controller的方法\n- (BOOL)prefersStatusBarHidden  // 隐藏状态栏\n{\n  return YES;\n}</code></pre>\n<p><img src=\"../../../images/blog/ios/ios_startup_2_2.png\" alt=\"ios_startup_2_2.png\"></p>\n<h3 id=\"打电话，发短信，发邮件，打开网页\">打电话，发短信，发邮件，打开网页</h3>\n<pre><code class=\"language-objectivec\">// URL 路径  URL: 协议头://资源路径, 根据协议头判断用什么软件打开  tel电话  mailto右键, sms 短信\nNSURL* url = [NSURL URLWithString:@&quot;http://zuo11.com&quot;];\nNSURL* url2 = [NSURL URLWithString:@&quot;tel://13566612138&quot;];  // 需要真机调试\nNSURL* url3 = [NSURL URLWithString:@&quot;sms://18826012138&quot;]; // 需要真机调试\nNSURL* url4 = [NSURL URLWithString:@&quot;mailto:916707888@qq.com&quot;]; // 需要真机调试\n[app openURL:url4];</code></pre>\n<h2 id=\"uiapplication与delegate\">UIApplication与delegate</h2>\n<p>在app受到干扰时，会产生一些系统事件，这时UIApplication会通知它的delegate，让delegate代理处理这些系统事件。delegate可处理的事件包括：</p>\n<ul>\n<li>应用程序的生命周期事件(如程序的启动和关闭)</li>\n<li>系统事件 (如来电)</li>\n<li>内存警告\n...</li>\n</ul>\n<pre><code class=\"language-objectivec\">// 当程序运行后，依次执行\ndidFinishLaunchingWithOptions // app启动完成时\napplicationDidBecomeActive // app完全获取焦点,当app完全获取到焦点，才能与用户交互\n// 按下Home键，执行   // 需保存一些资源\napplicationWillResignActive // 当app即将失去焦点时\napplicationDidEnterBackground // 当app完全进入后台的时候\n// 再次进入app时\napplicationWillEnterForeground // 当app即将进入前台的方法\napplicationDidBecomeActive // app完全获取焦点\n// app即将完全退出时执行\napplicationWillTerminate</code></pre>\n<h2 id=\"ios程序启动过程\">iOS程序启动过程</h2>\n<pre><code class=\"language-objectivec\">int main(int argc, char * argv[]) {\n    @autoreleasepool {\n        // 第3个参数 The name of the UIApplication class or subclass. If you specify nil, \n            UIApplication is assumed.   // nil == @&quot;UIApplication&quot;\n        //  NSStringFromClass([UIApplication class])\n        // 第4个参数 UIApplication的代理名称 @&quot;AppDelegate&quot;;\n\n        //NSStringFromClass: 把类名转化为字符串, 1.有提示功能 2.避免出错\n        // NSStringFromClass([AppDelegate class]);\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n// main之前会将所有的类加载到内存，会先执行类的 +(void)load;\n// UIApplicationMain底层实现\n// 1.根据principalClassName 传递的类名创建一个UIApplication对象\n// 2.创建UIApplication代理对象, 给UIApplication对象设置代理\n// 3.开启主运行事件循环，开始处理事件, 保持代码一直执行\n// 4.加载Info.plist，判断是否指定main,如指定了，就去加载</code></pre>\n<p>UIApplicationMain</p>\n<p>This function is called in the  entry point to create the application object and the application delegate and set up the event cycle.</p>\n<p>This function instantiates the application object from the principal class and instantiates the delegate (if any) from the given class and sets the delegate for the application. It also sets up the main event loop, including the application’s run loop, and begins processing events. If the application’s  file specifies a main nib file to be loaded, by including the  key and a valid nib file name for the value, this function loads that nib file.</p>\n<p><img src=\"../../../images/blog/ios/ios_startup_2.png\" alt=\"ios_startup_2.png\"></p>\n<h2 id=\"the-main-run-loop\">The Main Run loop</h2>\n<p><img src=\"../../../images/blog/ios/ios_startup_3.png\" alt=\"ios_startup_3.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS程序启动过程，从main函数开始UIApplication与AppDelegate",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "UIApplication"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "UIApplication作用",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "设置app图标的提醒数字"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "设置状态栏联网提示"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "设置状态栏, 隐藏"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "打电话，发短信，发邮件，打开网页"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "UIApplication与delegate"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "iOS程序启动过程"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "The Main Run loop"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS程序启动过程，从main函数开始UIApplication与AppDelegate.md",
        "staticFileName": "ios_startup.html",
        "author": "guoqzuo",
        "createDate": "2016/10/25",
        "description": "想弄清楚一段程序，就需要了解程序的执行过程。一般程序都是从main函数开始执行，iOS app也不例外。iOS程序main函数里执行了UIApplicationMain()函数，这个函数会创建UIApplication对象及代理AppDelegate，并开启事件循环，显示UI.",
        "keywords": "iOS程序启动过程,UIApplication,AppDelegate,iOS main函数执行过程",
        "category": "iOS",
        "year": "2016",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios程序启动过程，视图加载uiwindow与viewcontroller\">iOS程序启动过程，视图加载UIWindow与ViewController</h1>\n<blockquote>\n<p>初步了解了iOS程序的启动过程、UIApplication和AppDelegate后，就要开始步入正题了，界面的显示问题。开启主运行循环后，会看Info.plist文件是否指定了main storyboard，有则加载。加载storyboard会创建UIWindow对象，再将默认的ViewController设置为该window的根控制器，然后将ViewController的view可视化。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_startup_viewload_1.png\" alt=\"ios_startup_viewload_1.png\"></p>\n<h2 id=\"程序启动过程延伸\">程序启动过程延伸</h2>\n<p>main函数执行UIApplicationMain(): </p>\n<ol>\n<li>创建UIApplication对象 </li>\n<li>创建代理对象，设置为UIApplication的代理</li>\n<li>开启事件循环 </li>\n<li>加载Info.plist文件，如果指定了Main, 就去加载</li>\n</ol>\n<p>默认是指定了Main storyboard的. Main Storyboard的初始化过程</p>\n<ul>\n<li>It instantiates a window for you.  // 实例化一个window</li>\n<li>It loads the main storyboard and instantiates its initial view controller. </li>\n<li>It assigns the new view controller to the window&#39;s rootViewController property and then makes the window visible on the screen.</li>\n</ul>\n<h2 id=\"uiwindow\">UIWindow</h2>\n<p>它是一种特殊的UIView，一个app中至少会有一个UIWindow。</p>\n<p>iOS程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的view，最后将view添加到UIWindow上，于是控制器的view就显示到屏幕上了。</p>\n<p>没有UIWindow，就看不到任何UI界面</p>\n<p>A UIScreen object that identifies a physical screen connected to the device. A UIWindow object that provides drawing support fot the screen. A set of UIView objects to perform the drawing. These objects are attached to the window and draw their contents when the window asks them to.</p>\n<p><img src=\"../../../images/blog/ios/ios_startup_viewload_2.png\" alt=\"ios_startup_viewload_2.png\"></p>\n<h2 id=\"不指定main-storyboard-自己初始化window\">不指定Main storyboard, 自己初始化window</h2>\n<p>在代理AppDelegate.m里，程序启动完成后调用:</p>\n<pre><code class=\"language-objectivec\">// 1.实例化一个window(创建窗口对象) 注意点:1.不能是局部变量 2.必须设置窗口的尺寸\n_window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n// _window.backgroundColor = [UIColor redColor];\n\n// 2.创建窗口的根控制器, 并赋值\n// 对应界面的事情，交给对应的控制器管理\nUIViewController* rootVc = [[UIViewController alloc] init];\nrootVc.view.backgroundColor = [UIColor greenColor];\n\nUIButton* btn = [UIButton buttonWithType: UIButtonTypeContactAdd];\nbtn.center = CGPointMake(50, 50);\n[rootVc.view addSubview:btn];\n\n// 一旦设置窗口的根控制器，就会把根控制器的view添加到窗口\n_window.rootViewController = rootVc;\n\n// 3.显示窗口 显示窗口_window.hidden = NO;成为主窗口application.keyWindow = _window;\n[_window makeKeyAndVisible];</code></pre>\n<p><img src=\"../../../images/blog/ios/ios_startup_viewload_3.png\" alt=\"ios_startup_viewload_3.png\"></p>\n<h2 id=\"多个窗口与层级\">多个窗口与层级</h2>\n<pre><code class=\"language-objectivec\">// 1.创建窗口\n_window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n_window.backgroundColor = [UIColor greenColor];\n\n// 2.设置窗口的根控制器\nUIViewController* rootVc = [[UIViewController alloc] init];\n_window.rootViewController = rootVc;\n\n// 3.显示窗口\n[_window makeKeyAndVisible];\n\n// 创建第二个窗口\n_window1 = [[UIWindow alloc] initWithFrame:CGRectMake(50, 50, 200, 200)];\n_window1.backgroundColor = [UIColor redColor];\nUIViewController* rootVc1 = [[UIViewController alloc] init];\n_window1.rootViewController = rootVc1;\n_window1.hidden = NO;\n_window1.windowLevel = UIWindowLevelAlert+1;\n\n// 创建第3个窗口\n_window2 = [[UIWindow alloc] initWithFrame:CGRectMake(100, 100, 200, 200)];\n_window2.backgroundColor = [UIColor yellowColor];\nUIViewController* rootVc2 = [[UIViewController alloc] init];\n_window2.rootViewController = rootVc2;\n_window2.hidden = NO;\n_window2.windowLevel = UIWindowLevelAlert;\n\nNSLog(@&quot;%@&quot;, application.windows);</code></pre>\n<p><img src=\"../../../images/blog/ios/ios_startup_viewload_4.png\" alt=\"ios_startup_viewload_4.png\"></p>\n<h2 id=\"手动加载默认的storyboard，通过storyboard创建控制器\">手动加载默认的storyboard，通过storyboard创建控制器</h2>\n<pre><code class=\"language-objectivec\">// 1.创建window\n_window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n\n// 2.加载main.storyboard, 创建mian.storyboard描述的控制器\n// UIStoryboard专门用来加载storyboard\nUIStoryboard* storyboard = [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil];\n// 加载storyboard描述的控制器，默认会加载箭头指向的viewController\nUIViewController* vc = [storyboard instantiateInitialViewController];\n_window.rootViewController = vc;\n\n// 3.显示窗口\n[_window makeKeyAndVisible];</code></pre>\n<h2 id=\"通过xib创建控制器\">通过xib创建控制器</h2>\n<pre><code class=\"language-objectivec\">// xib加载控制器步骤，有view去描述控制器，让xib和控制器产生联系，告诉xib是用来描述一个控制器的\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n  // Override point for customization after application launch.\n\n  // 为什么通过xib或者storyboard\n  _window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n\n  UIViewController* vc = [[ViewController alloc] initWithNibName:@&quot;VC&quot; bundle:nil];\n\n  _window.rootViewController = vc;\n\n  [_window makeKeyAndVisible];\n\n  return YES;\n}</code></pre>\n<p>VC.xib 相关设置:</p>\n<p><img src=\"../../../images/blog/ios/ios_startup_viewload_5.png\" alt=\"ios_startup_viewload_5.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS程序启动过程，视图加载UIWindow与ViewController",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "程序启动过程延伸"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "UIWindow"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "不指定Main storyboard, 自己初始化window"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "多个窗口与层级"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "手动加载默认的storyboard，通过storyboard创建控制器"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "通过xib创建控制器"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS程序启动过程，视图加载UIWindow与ViewController.md",
        "staticFileName": "ios_startup_viewload.html",
        "author": "guoqzuo",
        "createDate": "2016/11/01",
        "description": "初步了解了iOS程序的启动过程、UIApplication和AppDelegate后，就要开始步入正题了，界面的显示问题。开启主运行循环后，会看Info.plist文件是否指定了main storyboard，有则加载。加载storyboard会创建UIWindow对象，再将默认的ViewController设置为该window的根控制器，然后将ViewController的view可视化",
        "keywords": "UIWindow,ViewController,代码手动加载storyboard,代码加载xib,iOS启动过程",
        "category": "iOS",
        "year": "2016",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios-自定义viewcontroller中的view\">iOS 自定义ViewController中的view</h1>\n<blockquote>\n<p>手动加载storyboard时，我们用storyboard创建了ViewController，它会自动创建一个空的view，这个view就是UIView类型。我们拖拽的按钮、label等就是拖拽在这个视图上面。如果需要自定义该view可以在该ViewController的loadView方法里设置。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_view_controller_1.png\" alt=\"ios_view_controller_1.png\"></p>\n<p>自定义ViewController中的view过程如下：</p>\n<ol>\n<li>去掉Info.plist里的指定Main</li>\n<li>手动指定窗口的根控制器为storyboard的控制器</li>\n</ol>\n<pre><code class=\"language-objectivec\">// 创建窗口对象\n_window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n// 指定storyboard的viewcontroller为该窗口的根控制器\nUIViewController* vc = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil] instantiateInitialViewController];\n_window.rootViewController = vc;\n// 使窗口可视化\n[_window makeKeyAndVisible];</code></pre>\n<ol start=\"3\">\n<li>新建类UIView的子类BGView，手动指定为控制器的view</li>\n</ol>\n<pre><code class=\"language-objectivec\">// loadView作用: 加载控制器的view，当控制器的view第一次使用(显示)时就会调用\n// 加载控制器的view，判断有没有指定storyboard或xib，如果有,会创建其默认的view:UIView，没有就创建一个空的view\n// 开发中什么时候使用: 想自定义view时\n- (void)loadView {\n    // 调用系统的默认方法\n    //[super loadView];\n    BGView* view = [[BGView alloc] initWithFrame:[UIScreen mainScreen].bounds];\n    self.view = view;\n    self.view.backgroundColor = [UIColor greenColor];\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    NSLog(@&quot;%@&quot;, self.view);\n}</code></pre>\n<ol start=\"4\">\n<li>通过xib创建控制器view</li>\n</ol>\n<p>创建ZUOViewController，设置为窗口的根控制器</p>\n<pre><code class=\"language-objectivec\">_window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n\n// 如指定了nibName就加载指定的xib,没指定就看有没有与根控制器同名(或后缀不带controller)的xib，有则加载\n\nZUOViewController* rootVc = [[ZUOViewController alloc] initWithNibName:nil bundle:nil];\n\n// 或者 ZUOViewController* rootVc = [[ZUOViewController alloc] init]; // 同名的好处\n\n_window.rootViewController = rootVc;  \n\n[_window makeKeyAndVisible];</code></pre>\n<p><img src=\"../../../images/blog/ios/ios_view_controller_2.png\" alt=\"ios_view_controller_2.png\"></p>\n<p>创建xib, 关联到ZUOViewController，设置对应的view</p>\n<p><img src=\"../../../images/blog/ios/ios_view_controller_3.png\" alt=\"ios_view_controller_3.png\"></p>\n<ol start=\"5\">\n<li>控制器默认为空的view</li>\n</ol>\n<pre><code class=\"language-objectivec\">_window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n_window.backgroundColor = [UIColor greenColor];\n\n//添加按钮\nUIButton* btn = [UIButton buttonWithType:UIButtonTypeContactAdd];\nbtn.center = CGPointMake(50, 50);\n[_window addSubview:btn];\n\n// 2.创建窗口的根控制器  空:黑色  空:几乎透明(不能穿透)\nViewController* vc = [[ViewController alloc] init];\n_window.rootViewController = vc;\nvc.view.backgroundColor = [UIColor clearColor];\n// vc.view.alpha = 0; //完全透明,button可以点击  alpha &lt;= 0.01 完全透明可穿透，&gt;则不可穿透\n// vc.view.backgroundColor = [UIColor redColor];\n\n[_window makeKeyAndVisible];</code></pre>\n<ol start=\"6\">\n<li>控制器view创建时间</li>\n</ol>\n<pre><code class=\"language-objectivec\">_window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n// 创建控制器，不一定会创建控制器的view\nViewController* vc = [[ViewController alloc] init];\nvc.view.backgroundColor = [UIColor redColor]; //这里使用了view，会再这里创建\n_window.rootViewController = vc;    \n[_window makeKeyAndVisible]; // 如果事先没使用view，在这里才会创建view, 创建view需执行loadview方法\n\n// --------------------------------------------------------------\n\n@implementation ViewController\n\n//- (UIView*)view { // 系统的view方法底层实现 vc.view 时调用\n//    if (_view == nil) {\n//        [self loadView];\n//        [self viewDidLoad];\n//    }\n//    return _view;\n//}\n\n- (void)loadView {\n    UIView* view = [[UIView alloc] initWithFrame:[UIScreen mainScreen].bounds];\n    view.backgroundColor = [UIColor redColor];\n    self.view = view;\n\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    self.view.backgroundColor = [UIColor blueColor];\n    NSLog(@&quot;%s&quot;, __func__);\n\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS 自定义ViewController中的view"
        }
      ],
      "config": {
        "source": "iOS 自定义ViewController中的view.md",
        "staticFileName": "ios_view_controller.html",
        "author": "guoqzuo",
        "createDate": "2016/11/01",
        "description": "手动加载storyboard时，我们用storyboard创建了ViewController，它会自动创建一个空的view，这个view就是UIView类型。我们拖拽的按钮、label等就是拖拽在这个视图上面。如果需要自定义该view可以在该ViewController的loadView方法里设置。",
        "keywords": "ViewController里的view,iOS 控制器view,ViewController里View的创建",
        "category": "iOS",
        "year": "2016",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios选择器uipickerview和uidatepicker\">iOS选择器UIPickerView和UIDatePicker</h1>\n<blockquote>\n<p>Apple提供了两个选择器对象：UIPickerView和UIDatePicker，就像网页里的select。UIDatePicker是时间方面的选择器，用法和UIPickerView差不多，这里先介绍UIPickerView，它可以自定义选择的行和列，每行显示的内容可以是自定义的视图。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_picker_1.png\" alt=\"ios_picker_1.png\"></p>\n<h2 id=\"storyboard拖拽picker-view\">storyboard拖拽picker view</h2>\n<p>这里就不用手动指定了，旨在了解基本的picker view，直接将pickerView控件拖拽到storyboard</p>\n<p><img src=\"../../../images/blog/ios/ios_picker_2.png\" alt=\"ios_picker_2.png\"></p>\n<p>数据我们用plist文件存储，foods.plist文件:</p>\n<pre><code class=\"language-xml\">&lt;plist version=&quot;1.0&quot;&gt;\n&lt;array&gt;\n    &lt;array&gt;\n        &lt;string&gt;榴莲&lt;/string&gt;\n        &lt;string&gt;西瓜&lt;/string&gt;\n        &lt;string&gt;樱桃&lt;/string&gt;\n        &lt;string&gt;橘子&lt;/string&gt;\n        &lt;string&gt;菠萝&lt;/string&gt;\n        &lt;string&gt;苹果&lt;/string&gt;\n        &lt;string&gt;香蕉&lt;/string&gt;\n    &lt;/array&gt;\n    &lt;array&gt;\n        &lt;string&gt;水煮肉片&lt;/string&gt;\n        &lt;string&gt;东坡肉&lt;/string&gt;\n        &lt;string&gt;红烧肉&lt;/string&gt;\n        &lt;string&gt;番茄鸡蛋&lt;/string&gt;\n    &lt;/array&gt;\n    &lt;array&gt;\n        &lt;string&gt;果蔬汁&lt;/string&gt;\n        &lt;string&gt;矿泉水&lt;/string&gt;\n        &lt;string&gt;果味饮料&lt;/string&gt;\n        &lt;string&gt;功能饮料&lt;/string&gt;\n        &lt;string&gt;茶饮料&lt;/string&gt;\n        &lt;string&gt;酸梅汤&lt;/string&gt;\n        &lt;string&gt;常温牛奶&lt;/string&gt;\n    &lt;/array&gt;\n&lt;/array&gt;\n&lt;/plist&gt;</code></pre>\n<h2 id=\"数据加载\">数据加载</h2>\n<p>如果不进行任何设置，运行后你会发现什么都看不到，我们还需要设置相关数据。将控件拖拽关联到ViewController里相应的属性。这里需要遵守UIPickViewDataSource和UIPickerViewDelegate协议，在viewDidLoad函数将pickerView的代理和数据源设置为该控制器view，然后用相应的方法设置数据。详情代码如下：</p>\n<pre><code class=\"language-objectivec\">#import &quot;ViewController.h&quot;\n\n@interface ViewController () &lt;UIPickerViewDataSource,UIPickerViewDelegate&gt;\n\n@property (strong, nonatomic) NSArray* arr; // 根据plist文件加载数据\n@property (weak, nonatomic) IBOutlet UILabel *label;  // 对应storyboard 的label\n@property (weak, nonatomic) IBOutlet UIPickerView *pickView; // 对应storyboard的pickview\n\n@end\n\n@implementation ViewController\n\n- (NSArray*)arr // 将foods.plist文件数据加载到数组\n{\n    if (_arr == nil) {\n        NSString* filePath = [[NSBundle mainBundle] pathForResource:@&quot;foods.plist&quot; ofType:nil];\n        _arr = [[NSArray alloc] initWithContentsOfFile:filePath];\n    }\n    return _arr;\n}\n\n// UIPickerViewDataSource协议必须实现的方法\n// returns the number of &#39;columns&#39; to display.\n- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView {\n    //return 3;\n    //return _arr.count; // 会加载不出数据，以后最好使用self，少用_开头的方式，.会默认调用get，set方法\n    return self.arr.count; // 数组列数\n}\n\n// returns the # of rows in each component..\n- (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component\n{\n    // return 5;\n    NSArray* arr1 = self.arr[component];\n    return arr1.count; // 对应每一列的行数\n}\n\n// 设置行高\n//- (CGFloat)pickerView:(UIPickerView *)pickerView rowHeightForComponent:(NSInteger)component __TVOS_PROHIBITED {\n//    return 100;\n//}\n// 返回对component列第row行的标题\n- (nullable NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component __TVOS_PROHIBITED {\n//    if (row == 1 &amp;&amp; component == 1) // 第一行第一列(从零开始)\n//        return @&quot;abc&quot;;\n//    else\n//        return @&quot;kkk&quot;;\n    NSArray* arr1 = self.arr[component];\n    return arr1[row];\n}\n// 给文本添加一些属性, 富文本, 可设置文本颜色，字体，阴影等\n//- (nullable NSAttributedString *)pickerView:(UIPickerView *)pickerView attributedTitleForRow:(NSInteger)row forComponent:(NSInteger)component NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED; // attributed title is favored if both methods are implemented\n//- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(nullable UIView *)view __TVOS_PROHIBITED;\n//\n//\n// 监听选中\n- (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component __TVOS_PROHIBITED {\n    //NSLog(@&quot;%ld %ld&quot;, component, row);\n    NSString* title = self.arr[component][row];\n    _label.text = title;\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    _pickView.dataSource = self;\n    _pickView.delegate = self;\n\n}</code></pre>\n<p>效果:</p>\n<p><img src=\"../../../images/blog/ios/ios_picker_3.png\" alt=\"ios_picker_3.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS选择器UIPickerView和UIDatePicker",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "storyboard拖拽picker view"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "数据加载"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS选择器UIPickerView和UIDatePicker.md",
        "staticFileName": "ios_picker.html",
        "author": "guoqzuo",
        "createDate": "2016/11/01",
        "description": "Apple提供了两个选择器对象：UIPickerView和UIDatePicker，就像网页里的select。UIDatePicker是时间方面的选择器，用法和UIPickerView差不多，这里先介绍UIPickerView，它可以自定义选择的行和列，每行显示的内容可以是自定义的视图。",
        "keywords": "iOS选择器,iOS UIPickerView,iOS UIDatePicker,UIPickerView,UIDatePicker",
        "category": "iOS",
        "year": "2016",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios-自定义uitextfield类国旗、生日、城市键盘\">iOS 自定义UITextField类(国旗、生日、城市键盘)</h1>\n<blockquote>\n<p>前面介绍了PickerView的简单用法，这里用PickerView和DatePicker来自定义UITextField类，让输入框的inputView不再是键盘，而是选择器。接下来会介绍三种基于选择器的封装键盘类: 国旗键盘、日期键盘、城市键盘。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_textfield_1.png\" alt=\"ios_textfield_1.png\"></p>\n<h2 id=\"封装国旗键盘\">封装国旗键盘</h2>\n<p>为什么要封装? 如果不封装为一个类，从storyboard将UITextField拖拽到对应的ViewController进行相关设置。代码会很混乱，且可移植性差。如果封装为一个UITextField类以后，只要设置UITextField的类为该封装类就可以调用国旗键盘，非常方便。这里我们创建一个UITextfield的子类FlagField，用来封装国旗键盘。默认的UITextField只要获取焦点就弹出一个键盘，可以用self.inputView方法指定弹出的view，只要是UIView都行。这里我们会将它的inputView设置为PickerView，国旗键盘只有一列，每一行都是label+ImageView，用xib来表示。效果如下:</p>\n<p><img src=\"../../../images/blog/ios/ios_textfield_2.png\" alt=\"ios_textfield_2.png\"></p>\n<h3 id=\"在什么时候修改inputview\">在什么时候修改inputView</h3>\n<p>也就是将默认弹出的键盘修改为UIpickView，当UITextField从storyboard或xib加载时，会调用- (void)awakeFromNib方法，重写该方法初始化</p>\n<p><img src=\"../../../images/blog/ios/ios_textfield_3.png\" alt=\"ios_textfield_3.png\"></p>\n<h3 id=\"实现uipickerviewdatasource-uipickerviewdelegate相关方法\">实现&lt;UIPickerViewDataSource, UIPickerViewDelegate&gt;相关方法</h3>\n<ol>\n<li>准备数据(从资源文件导入，里面存放了国家，与对应的国旗)，将资源文件加载到数组，建立相关模型，这里没有用kvc将字典直接转为对象，后面会使用。</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_textfield_4.png\" alt=\"ios_textfield_4.png\"></p>\n<ol start=\"2\">\n<li>设置每行的UIView, 自定义UIView类FlagView，创建时勾选创建xib。高度100，宽度375: 225+150，只是在4.7寸上模拟，没有加界面约束。</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_textfield_5.png\" alt=\"ios_textfield_5.png\"></p>\n<p><img src=\"../../../images/blog/ios/ios_textfield_6.png\" alt=\"ios_textfield_6.png\"></p>\n<ol start=\"3\">\n<li>设置pickerView的数据源和代理，数据加载</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_textfield_7.png\" alt=\"ios_textfield_7.png\"></p>\n<ol start=\"4\">\n<li>扩展：KVC, dict -&gt; model，上面的数据转模型的时候可以只用字典初始化数据。</li>\n</ol>\n<pre><code class=\"language-objectivec\">- (NSArray*)flags\n{\n    if (_flags == nil) {\n        _flags = [[NSMutableArray alloc] init];\n        // 1.拿到filePath\n        NSString* filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];\n        // 2.根据filePath创建JSON数据\n        NSArray* dictArr = [NSArray arrayWithContentsOfFile:filePath];\n        // 3.dict -&gt; model\n        for (NSDictionary* dict in dictArr) {\n            id obj = [Flag flagWithDict:dict];\n            [_flags addObject:obj];\n        }\n    }\n    return _flags;\n}</code></pre>\n<p>Flag.h</p>\n<pre><code class=\"language-objectivec\">#import &lt;Foundation/Foundation.h&gt;\n#import &lt;UIKit/UIKit.h&gt;\n\n@interface Flag : NSObject\n\n@property (nonatomic, strong) NSString* name;\n@property (nonatomic, strong) UIImage* icon;\n\n+ (instancetype)flagWithDict:(NSDictionary *)dict;\n\n@end</code></pre>\n<p>Flag.m</p>\n<pre><code class=\"language-objectivec\">#import &quot;Flag.h&quot;\n\n@implementation Flag\n\n+ (instancetype)flagWithDict:(NSDictionary *)dict\n{\n    Flag* flag = [[self alloc] init];\n\n    // kvc\n    //[flag setValuesForKeysWithDictionary:dict]; \n    [dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        // kvc\n        [flag setValue:obj forKey:key];\n    }];\n    return flag;\n}\n\n// [flag setValue:@&quot;agt.gif&quot; forKey:@&quot;icon&quot;];\n- (void)setIcon:(NSString *)icon\n{\n    _icon = [UIImage imageNamed:[NSString stringWithFormat:@&quot;guoqi/%@&quot;, icon]];\n}\n@end</code></pre>\n<h2 id=\"封装日期键盘\">封装日期键盘</h2>\n<p>与上面相比，日期键盘就简单多了，不用考虑什么协议，代理数据源。稍微不同的地方</p>\n<pre><code class=\"language-objectivec\">- (void)setUp\n{\n    _datePicker = [[UIDatePicker alloc] init];\n    _datePicker.datePickerMode = UIDatePickerModeDate; // 模式显示\n    _datePicker.locale = [NSLocale localeWithLocaleIdentifier:@&quot;zh&quot;]; // 设置为中文\n    // 添加控制器，监听选泽\n    [_datePicker addTarget:self action:@selector(dateChange) forControlEvents:UIControlEventValueChanged];\n    self.inputView = _datePicker;\n}\n\n// UIDatePicker选中时调用\n- (void)dateChange\n{\n    //NSLog(@&quot;%s&quot;, __func__);\n    NSLog(@&quot;%@&quot;, _datePicker.date);\n    // 创建一个日期格式字符串对象\n    NSDateFormatter* fmt = [[NSDateFormatter alloc] init];\n    fmt.dateFormat = @&quot;yyyy-MM-dd&quot;;\n    self.text = [fmt stringFromDate:_datePicker.date];\n}\n\n// 初始化文本\n- (void)initialWithText\n{\n   [self dateChange];\n}</code></pre>\n<h2 id=\"封装城市键盘\">封装城市键盘</h2>\n<p>这里有一个二级联动需要注意，其它差不多，要养成写注释的习惯，不然思维容易混乱。这里行列设置有点晕。</p>\n<p>CityFeild.m</p>\n<pre><code class=\"language-objectivec\">#import &quot;CityField.h&quot;\n#import &quot;City.h&quot;\n\n@interface CityField () &lt;UIPickerViewDataSource, UIPickerViewDelegate&gt;\n\n@property (nonatomic, strong)UIPickerView* pickView;\n@property (nonatomic, strong)NSMutableArray* citys;\n@property (nonatomic, assign)NSInteger currentRow;\n@property (nonatomic, assign)BOOL isInitial;\n\n@end\n\n@implementation CityField\n\n- (void)awakeFromNib\n{\n    [self setUp];\n}\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    if (self = [super initWithFrame:frame]) {\n        [self setUp];\n    }\n    return self;\n}\n\n- (NSMutableArray*)citys\n{\n    if (_citys == nil) {\n        _citys = [[NSMutableArray alloc] init];\n        NSString* filePath = [[NSBundle mainBundle] pathForResource:@&quot;provinces.plist&quot; ofType:nil];\n        NSArray* dictArr = [NSArray arrayWithContentsOfFile:filePath];\n        for (id dict in dictArr) {\n            id obj = [City cityWithDict:dict];\n            [_citys addObject:obj];\n        }\n    }\n    return _citys;\n}\n\n- (void)setUp\n{\n    self.pickView = [[UIPickerView alloc] init];\n    self.pickView.delegate = self;\n    self.pickView.dataSource = self;\n    //NSLog(@&quot;%@&quot;, self.citys);\n\n    self.inputView = _pickView;\n}\n\n#pragma mark - UIPickerViewDataSource\n\n- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView\n{\n    return 2;\n}\n\n- (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component\n{\n    if (component == 0) // 省份\n        return self.citys.count;\n    else {\n        City* tempCity = self.citys[_currentRow];\n        return tempCity.cities.count;\n    }\n}\n\n#pragma mark - UIPickerViewDelegate\n\n- (NSString*)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component\n{\n    if (component == 0) { // 省会名称\n        City* tempCity = self.citys[row];\n        return tempCity.name;\n    } else { // 省会下的城市\n        City* c = self.citys[_currentRow];\n        return c.cities[row];\n    }\n}\n\n- (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component\n{\n    if (component == 0) { // 滚动省份\n        _currentRow = row; // 记录省份\n        // 刷新第一列的城市\n        [pickerView reloadComponent:1]; // 刷新第一列,重新选择第1列第0行默认选中\n        [pickerView selectRow:0 inComponent:1 animated:YES];\n    }\n\n    City* c = self.citys[_currentRow];\n    // 获取第0列选中的省会\n    NSString* province = c.name;\n    // 获取第1列选中的城市\n    NSInteger row1 = [pickerView selectedRowInComponent:1];\n    NSString* city1 = c.cities[row1];\n\n    self.text = [NSString stringWithFormat:@&quot;%@-%@&quot;, province, city1];\n}\n\n// 初始化文本\n- (void)initialWithText\n{\n    if (_isInitial == NO) {\n        [self pickerView:self.pickView didSelectRow:0 inComponent:0];\n        _isInitial = YES;\n    }\n}\n\n@end</code></pre>\n<p>City.h</p>\n<pre><code class=\"language-objectivec\">#import &lt;Foundation/Foundation.h&gt;\n#import &lt;UIKit/UIKit.h&gt;\n\n@interface City : NSObject\n\n@property (nonatomic, strong)NSString* name;\n@property (nonatomic, strong)NSArray* cities;\n\n+ (instancetype)cityWithDict:(NSDictionary*)dict;\n\n@end</code></pre>\n<p>City.m</p>\n<pre><code class=\"language-objectivec\">#import &quot;City.h&quot;\n\n@implementation City\n\n+ (instancetype)cityWithDict:(NSDictionary *)dict\n{\n    City* city = [[self alloc] init];\n\n    //kvc\n    [city setValuesForKeysWithDictionary:dict];\n\n    return city;\n}\n\n@end</code></pre>\n<h2 id=\"综合设置初始值，监听过滤输入\">综合(设置初始值，监听过滤输入)</h2>\n<p>ViewController.m</p>\n<pre><code class=\"language-objectivec\">#import &quot;ViewController.h&quot;\n#import &quot;FlagFeild.h&quot;\n#import &quot;BirthdayFeild.h&quot;\n#import &quot;CityField.h&quot;\n\n@interface ViewController () &lt;UITextFieldDelegate&gt;\n\n@property (weak, nonatomic) IBOutlet FlagFeild *flagFeild;\n@property (weak, nonatomic) IBOutlet BirthdayFeild *birthdayFeild;\n@property (weak, nonatomic) IBOutlet CityField *cityFeild;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    _flagFeild.delegate = self;\n    _birthdayFeild.delegate = self;\n    _cityFeild.delegate = self;\n    // Do any additional setup after loading the view, typically from a nib.\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n// 是否允许用户输入文字，拦截用户输入, 每次输入都会询问代理，是否允许更改文本框内容\n- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string\n{\n    return NO;\n}\n\n@end</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS 自定义UITextField类(国旗、生日、城市键盘)",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "封装国旗键盘",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "在什么时候修改inputView"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "实现<UIPickerViewDataSource, UIPickerViewDelegate>相关方法"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "封装日期键盘"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "封装城市键盘"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "综合(设置初始值，监听过滤输入)"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS 自定义UITextField类(国旗、生日、城市键盘).md",
        "staticFileName": "ios_textfield.html",
        "author": "guoqzuo",
        "createDate": "2016/11/08",
        "description": "前面介绍了PickerView的简单用法，这里用PickerView和DatePicker来自定义UITextField类，让输入框的inputView不再是键盘，而是选择器。接下来会介绍三种基于选择器的封装键盘类: 国旗键盘、日期键盘、城市键盘。",
        "keywords": "封装UITextField类,iOS封装国旗键盘,iOS UIPickerView,自定义UITextField,修改iOS键盘的输入,自定义UITextField的输入视图",
        "category": "iOS",
        "year": "2016",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios-页面的切换跳转uinavigationcontroller\">iOS 页面的切换跳转UINavigationController</h1>\n<blockquote>\n<p>app一般有很多个页面，一个页面会对应一个UIViewController。那怎么控制页面的切换呢？拖线就不讲了！这里介绍一种可以控制页面切换的控制器：导航控制器UINavigationController，就像一个view下面有很多个子view一样，导航控制器会通过添加(push)或删除(pop)其子控制器view，来实现页面的切换，类似于栈。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_navigation_1.png\" alt=\"ios_navigation_1.png\"></p>\n<h2 id=\"uinavigationcontroller的使用\">UINavigationController的使用</h2>\n<p>先来看看导航控制器是怎么做到界面切换的，之前手动加载界面时将UIViewController设置为window的根控制器就可以显示该页面了。现在我们将UINavigationController作为window的根控制器。通过向NavgationController对象添加子控制器view的方式，显示页面。</p>\n<p><img src=\"../../../images/blog/ios/ios_navigation_2.png\" alt=\"ios_navigation_2.png\"></p>\n<p>实例操作: </p>\n<ul>\n<li>设置不从main加载storyboard。在代理里初始化UINavigationController</li>\n<li>设置UIWindow的rootViewController为UINavigationController</li>\n<li>通过push方法将控制器view添加到导航栈</li>\n</ul>\n<pre><code class=\"language-objectivec\">_window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n\n// 创建导航控制器的根控制器\nViewController* rootVc = [[ViewController alloc] init];\n//rootVc.view.backgroundColor = [UIColor greenColor];\n\n// 创建导航控制器\n// 导航控制器也需要有根控制器\nUINavigationController* navVc = [[UINavigationController alloc] initWithRootViewController:rootVc];\n// initWithRootViewController: 调用了push方法.\n// 导航控制器的根控制器就是导航控制器的第一个子控制器\n\n_window.rootViewController = navVc;\n\n[_window makeKeyAndVisible];</code></pre>\n<p>这里其实就是在viewController中间加了一层NavigationController。顶部会明显的多出一个导航栏，页面的跳转: 上面用ViewController直接定义的导航控制器的根控制器 alloc] init] 后，会默认去加载对应的stroyboard或xib，这里我们建立一个xib对应他，拖拽一个按钮用来跳转到第二个界面, 这里我们需要新建一个viewController来作为目的界面，新建类时勾选Also create XIB file，就可以了。</p>\n<p><img src=\"../../../images/blog/ios/ios_navigation_3.png\" alt=\"ios_navigation_3.png\"></p>\n<p>下面是跳转相关:</p>\n<p><img src=\"../../../images/blog/ios/ios_navigation_4.png\" alt=\"ios_navigation_4.png\"></p>\n<p><img src=\"../../../images/blog/ios/ios_navigation_5.png\" alt=\"ios_navigation_5.png\"></p>\n<p>ViewController.m</p>\n<pre><code class=\"language-objectivec\">@implementation ViewController\n\n- (IBAction)jump2Two:(id)sender {\n    NSLog(@&quot;%s&quot;, __func__);\n    // 导航控制器只显示栈顶控制器的view\n    TwoViewController* twoVc = [[TwoViewController alloc] init];\n\n    // 只有导航控制器才有跳转功能\n    // 只要是导航控制器的子控制器就能拿到导航控制器\n    [self.navigationController pushViewController:twoVc animated:YES];\n    // 会把push的控制器添加为导航控制器的子控制器\n    NSLog(@&quot;%@&quot;, self.navigationController.childViewControllers);\n}</code></pre>\n<p>点击跳转到第二个界面效果  </p>\n<p><img src=\"../../../images/blog/ios/ios_navigation_6.png\" alt=\"ios_navigation_6.png\"></p>\n<p>如果想跳转到一个界面只需要将其控制器push到导航控制器数组里，导航控制器只显示栈顶的控制器。点击back返回就是相当于pop出栈一次, 可以pop到指定的控制器，子控制器里获取导航控制器数组：</p>\n<pre><code class=\"language-objectivec\">self.navigationController.childViewControllers\n\n// 返回，出栈\n- (IBAction)back2Pre:(id)sender {\n    [self.navigationController popViewControllerAnimated:YES];\n}\n\n// 回到根控制器, 跳转到指定的控制器\n- (IBAction)back2Root:(id)sender {\n    //[self.navigationController popToRootViewControllerAnimated:YES];\n\n    [self.navigationController popToViewController:self.navigationController.childViewControllers[0] animated:YES];\n}</code></pre>\n<h2 id=\"addchildviewcontroller与push\">addChildViewController与push</h2>\n<p>上面有提到，导航控制器是通过数组来控制器页面切换的，但系统的方法是push和pop，类似于入栈出栈，我试了下直接向导航控制器添加子控制器的方式即  [navVc addChildViewController:rootVc]，在设置根控制器的时候没问题，但在ViewController里面准备跳转到twoVc就不能使用添加子控制器的方法了，只有用push才能跳转，表面是只是添加了子控制器，但push做的不仅仅做了addChildViewController操作，还加了一些隐藏的处理。多次push同一个控制器会出错。</p>\n<p><img src=\"../../../images/blog/ios/ios_navigation_7.png\" alt=\"ios_navigation_7.png\"></p>\n<h2 id=\"导航条内容的设置\">导航条内容的设置</h2>\n<p>导航条的内容是由栈顶控制器的navigationItem决定，也就是当前显示的界面，一般放在viewDidload中加载</p>\n<pre><code class=\"language-objectivec\">@implementation TwoViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view from its nib.\n\n    self.navigationItem.title = @&quot;中间内容&quot;;\n\n    // 添加导航条右边的按钮\n    UIBarButtonItem* item = [[UIBarButtonItem alloc] initWithTitle:@&quot;右边&quot; style:UIBarButtonItemStyleDone target:self action:@selector(click)];\n    self.navigationItem.rightBarButtonItem = item;\n\n    // 添加左边的按钮\n    UIImage* image = [UIImage imageNamed:@&quot;navigationbar_friendsearch&quot;];\n    image = [image imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];\n    // 一张图片时\n//  UIBarButtonItem* item2 = [[UIBarButtonItem alloc] initWithImage:image style:UIBarButtonItemStyleDone target:nil action:nil];\n\n    // 一个按钮两张图片\n    UIButton* btn = [UIButton buttonWithType:UIButtonTypeCustom];\n    [btn setBackgroundImage:image forState:UIControlStateNormal];\n    [btn setBackgroundImage:[UIImage imageNamed:@&quot;navigationbar_friendsearch_highlighted&quot;] forState:UIControlStateHighlighted];\n    // 如果是自定义按钮要定义尺寸, 导航条上的内容位置由系统决定, 按钮的尺寸自己可以定义\n    btn.frame = CGRectMake(100, 0, 35, 35);\n    UIBarButtonItem* item2 = [[UIBarButtonItem alloc] initWithCustomView:btn];\n\n    self.navigationItem.leftBarButtonItem = item2;\n    // 在apple的API中，只要以Item结尾，都是苹果的模型\n    // UINavigationItem: 决定导航条的内容(左，中，右)\n    // UIBarButtonItem: 决定导航条上按钮的内容\n}\n\n- (void)click\n{\n    NSLog(@&quot;%s&quot;, __func__);\n}</code></pre>\n<p>显示效果如下：   </p>\n<p><img src=\"../../../images/blog/ios/ios_navigation_8.png\" alt=\"ios_navigation_8.png\"></p>\n<h2 id=\"控制器view的生命周期方法\">控制器view的生命周期方法</h2>\n<p>页面第一次加载时:</p>\n<p>viewDidLoad -&gt; viewWillAppear -&gt; viewWillLayoutSubviews -&gt; viewDidLayoutSubviews -&gt; viewDidAppear</p>\n<p>跳转到其他页面时执行 viewWillDisappear -&gt; viewDidDisappear</p>\n<p>再次回到该界面时 viewWillAppear -&gt;  viewDidAppear </p>\n<p><img src=\"../../../images/blog/ios/ios_navigation_9.png\" alt=\"ios_navigation_9.png\"></p>\n<p>当出现内存警告时执行 didReceiveMemoryWarning方法，清空一些缓存，一般清空图片，一些没用的数据</p>\n<p>在非ARC环境下常用的方法:</p>\n<p>viewWillUnload、viewDidUnload 控制器view即将/完成销毁</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS 页面的切换跳转UINavigationController",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "UINavigationController的使用"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "addChildViewController与push"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "导航条内容的设置"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "控制器view的生命周期方法"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS 页面的切换跳转UINavigationController.md",
        "staticFileName": "ios_navigation.html",
        "author": "guoqzuo",
        "createDate": "2016/11/08",
        "description": "app一般有很多个页面，一个页面会对应一个UIViewController。那怎么控制页面的切换呢？拖线就不讲了！这里介绍一种可以控制页面切换的控制器：导航控制器UINavigationController，就像一个view下面有很多个子view一样，导航控制器会通过添加(push)或删除(pop)其子控制器view，来实现页面的切换，类似于栈。",
        "keywords": "iOS导航控制器,UINavigationController,iOS页面的跳转,控制器View的生命周期,导航控制器",
        "category": "iOS",
        "year": "2016",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios微博个人详情页面\">iOS微博个人详情页面</h1>\n<blockquote>\n<p>用storyboard拖线来做个微博个人详情页面的UI。导航栏刚开始透明，滚动tableView的时候，上面的两个视图会向上，导航条也会从完全透明到不透明。这里会图解UITableView显示滚动区域的相关细节。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_weibo_1.png\" alt=\"ios_weibo_1.png\"></p>\n<h2 id=\"storyboard拖拽ui\">storyboard拖拽UI</h2>\n<p>这里是在4.7寸上拖拽。</p>\n<ol>\n<li><p>拖拽一个Navigation Controller，删除自带的rootViewController，把其根控制器设置为系统给出的ViewController。在导航控制器的属性里勾选Is Initial View Controller，设置为启动页面。</p>\n</li>\n<li><p>拖拽一个tableView放在ViewController里，x:0, y:0，约束为top:0, bottom:0, left:0, right:0;</p>\n</li>\n<li><p>拖拽一个UIView命名为TopView，宽375，高200。x:0, y:0，界面约束top:0, left:0, height:200, right:0;</p>\n</li>\n<li><p>拖拽两个ImageView到TopView，先拖背景bg，其位置、长宽、约束和TopView一样，第二个是头像，长宽都是100，水平居中，y:36，界面约束，height:100, width:100, bottom:64, align center x to bg，在属性里设置对应的image，素材见资源打包。</p>\n</li>\n<li><p>再拖拽一个UIView命名为选项卡视图，宽375，高44，x:0, y:200，界面约束height:44, left:0,right:0,top:0px;</p>\n</li>\n<li><p>在拖拽两个button到选项卡视图上，命名为主页，微博，高度统一为44，宽50，左边x:50，右边x：275，界面约束为height:44, top:0, bottom:0，第四个约束条件左边left:50，右边right:50 </p>\n</li>\n<li><p>注意图层分级。图层不对可以拖拽，下图为storyboard参考层级。</p>\n</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_weibo_2.png\" alt=\"ios_weibo_2.png\"></p>\n<h2 id=\"效果设置\">效果设置</h2>\n<ol>\n<li>导航条背景透明，我们将View Controller的类设置为ViewController，在viewDidLoad里面修改相关设置</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_weibo_3.png\" alt=\"ios_weibo_3.png\"></p>\n<p><img src=\"../../../images/blog/ios/ios_weibo_4.png\" alt=\"ios_weibo_4.png\"></p>\n<ol start=\"2\">\n<li>设置TableView数据源和代理，首先在viewDidLoad方法里将tableView的数据源和代理都设置为self，遵守UITableViewDataSource和UITableViewDelegate协议。实现数据源方法:</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_weibo_5.png\" alt=\"ios_weibo_5.png\"></p>\n<ol start=\"3\">\n<li>显示问题，iOS7之后，apple会自动给导航控制器里的所有UIScrollView添加额外的滚动区域top:64，让导航栏不挡住ScrollView的数据显示。UITableView继承自UIScrollView，给UITableView添加额外的滚动区域top，那么tableview的显示区域会往下挤，带导航条的下挤了64。我们这里刚开始不用显示导航条，要显示topView+选项卡视图,一起高度是244,那需要添加额外滚动区域200+44，本来就有64，则还需额外添加244-64，这里的导航条一直都在只是刚开始背景设置为透明了。</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_weibo_6.png\" alt=\"ios_weibo_6.png\"></p>\n<pre><code class=\"language-objectivec\">// 设置tableView的滚动区域，TopView高200，主页微博高度44，导航条64，ok后效果如下图右\nself.tableView.contentInset = UIEdgeInsetsMake(200 + 44 -64, 0, 0, 0);</code></pre>\n<p><img src=\"../../../images/blog/ios/ios_weibo_7.png\" alt=\"ios_weibo_7.png\"></p>\n<ol start=\"4\">\n<li>滚动效果设置，向下滚动时，我们根据滚动的y值，来判断当前相对原来(-244)偏移了多少，根据修改topView的高度(界面约束)，来使页面有整体上移的效果。到视图高度减少到64时，就不再减了。这个过程中顶部视图的背景会逐渐从透明到不透明。这里用到了一个分类，根据透明度生成图片。</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_weibo_8.png\" alt=\"ios_weibo_8.png\"></p>\n<h2 id=\"源码\">源码</h2>\n<pre><code class=\"language-objectivec\">#import &quot;ViewController.h&quot;\n#import &quot;UIImage+Image.h&quot;\n\n#define TOPVIEW_H 200  // TopView视图高度\n#define TABBAR_H 44 // 选项卡视图高度\n#define NAV_H 64    // 导航条高度\n\n@interface ViewController () &lt;UITableViewDataSource, UITableViewDelegate&gt;\n\n@property (weak, nonatomic) IBOutlet NSLayoutConstraint *TopViewHeIght; //topView高度约束\n@property (weak, nonatomic) IBOutlet UITableView *tableView; // 对应tableView\n@property (weak, nonatomic) UILabel* label; // 导航条label，方便设置tableView滑动时的透明度\n@property (assign, nonatomic) CGFloat offSet; // 最开始的偏移量 -244\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 如果不设置导航条 图①\n    // 设置导航条背景透明，将一张空的图片设置为navigationBar的背景 图②\n    [self.navigationController.navigationBar setBackgroundImage:[[UIImage alloc] init] forBarMetrics:UIBarMetricsDefault];\n    // 清空导航条阴影线 图③\n    [self.navigationController.navigationBar setShadowImage:[[UIImage alloc] init]];\n\n    UILabel* label = [[UILabel alloc] init];\n    label.text = @&quot;kevin Zuo&quot;;\n    label.textColor = [UIColor clearColor]; // 设置为透明色\n    _label = label;\n    [label sizeToFit];\n    self.navigationItem.titleView = label; // 设置为标题\n\n\n    _tableView.dataSource = self;\n    _tableView.delegate = self;\n\n    // 设置最初偏移量 -244\n    self.offSet = -(TOPVIEW_H+TABBAR_H);\n   // self.automaticallyAdjustsScrollViewInsets = NO;\n    // 设置tableView的滚动区域\n    self.tableView.contentInset = UIEdgeInsetsMake(TOPVIEW_H + TABBAR_H - NAV_H, 0, 0, 0);\n}\n\n#pragma mark - UITableViewDataSource\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section\n{\n    return 20;\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    static NSString* identifier = @&quot;cell&quot;;\n    UITableViewCell* cell = [tableView dequeueReusableCellWithIdentifier:identifier];\n    if (!cell) {\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: identifier];\n    }\n    cell.textLabel.text = [NSString stringWithFormat:@&quot;%ld&quot;,indexPath.row];\n    return cell;\n}\n\n\n#pragma mark - UITableViewDelegate\n// 监听tableView的滚动 UITableViewDelegate遵守UIScrollViewDelegate协议\n- (void)scrollViewDidScroll:(UIScrollView *)scrollView\n{\n    // 最开始的偏移为 _offSet = -244, TopView+选项卡视图高度\n    // 当前偏移量\n    CGFloat curOffSet = scrollView.contentOffset.y; // 关键\n    // 差值，时差值 0 .. (200-64),\n    CGFloat delta = curOffSet - _offSet;\n    CGFloat h = TOPVIEW_H - delta; // 顶部视图为\n    if (h &lt; NAV_H) // 导航栏高度。\n        h = NAV_H;\n    // 修改头部视图高度\n    _TopViewHeIght.constant = h;\n    NSLog(@&quot;%f,%f,%f,%f&quot;, curOffSet,_offSet, delta,h);\n\n    // 修改导航条透明度\n    CGFloat alpha = delta/(TOPVIEW_H - TABBAR_H); // 差值/滚动高度\n    if (alpha &gt;= 1) alpha = 0.99;\n    // 根据透明度生成背景图片\n    UIImage* image = [UIImage imageWithColor:[UIColor colorWithWhite:1 alpha:alpha]];\n    [self.navigationController.navigationBar setBackgroundImage:image forBarMetrics:UIBarMetricsDefault];\n\n    _label.textColor = [UIColor colorWithWhite:0 alpha:alpha];\n    NSLog(@&quot;%f&quot;, alpha);\n}\n\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n@end</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS微博个人详情页面",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "storyboard拖拽UI"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "效果设置"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "源码"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS微博个人详情页面.md",
        "staticFileName": "ios_weibo.html",
        "author": "guoqzuo",
        "createDate": "2016/11/09",
        "description": "用storyboard拖线来做个微博个人详情页面的UI。导航栏刚开始透明，滚动tableView的时候，上面的两个视图会向上，导航条也会从完全透明到不透明。这里会图解UITableView显示滚动区域的相关细节。",
        "keywords": "UITableView滚动,导航条随着滚动从透明到不透明,iOS微博个人详情页面,图解UITableView显示滚动区域",
        "category": "iOS",
        "year": "2016",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios数据持久化存储数据\">iOS数据持久化(存储数据)</h1>\n<p>iOS里有一个专有名词叫数据持久化，可以理解为数据存储。iOS数据持久化有5种方式：</p>\n<ol>\n<li>XML属性列表 (plist文件) </li>\n<li>Preference (偏好设置) </li>\n<li>NSKeyedArchiver归档 (NSCoding) </li>\n<li>SQLite3 </li>\n<li>Core Data</li>\n</ol>\n<p>这里先讲前三种。</p>\n<p><img src=\"../../../images/blog/ios/ios_data_save_1.png\" alt=\"ios_data_save_1.png\"></p>\n<h2 id=\"应用沙盒\">应用沙盒</h2>\n<p><img src=\"../../../images/blog/ios/ios_data_save_2.png\" alt=\"ios_data_save_2.png\"></p>\n<p>每个iOS应用都有自己的应用沙盒(就是文件系统目录), 与其他文件系统隔离，应用必须待在自己的沙盒里。其他应用不能访问该沙盒。应用沙盒的文件系统目录，如上图所示(假设app名称为Layer)</p>\n<h3 id=\"沙盒路径\">沙盒路径</h3>\n<pre><code class=\"language-objectivec\">NSString* homePath = NSHomeDirectory();</code></pre>\n<p>也可以通过函数获取 NSDocumentDirectory / NSCachesDirectory / NSPreferencePanesDirectory</p>\n<pre><code class=\"language-objectivec\">// 参数1: 搜索文件夹   \n// 参数2: 在哪个范围搜索 NSUserDomainMask // user&#39;s home directory\n// 参数3: YES，全路径  NO, ~ 代替沙盒路径\nNSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];</code></pre>\n<h3 id=\"应用程序包\">应用程序包</h3>\n<p>上图中的Layer, 包含了所有的资源文件和可执行文件</p>\n<pre><code class=\"language-objectivec\">NSString* path  = [NSbundle mainBundle] bundlePath];</code></pre>\n<h3 id=\"documents\">Documents</h3>\n<p>保存app运行时生成的需要持久化的数据, iTunes同步时会备份该目录 (文件存这,app可能会被拒)</p>\n<h3 id=\"tmp\">tmp</h3>\n<p>保存app运行时所需的临时数据，app没有运行时，系统可能清楚该目录下的文件，iTunes同步不会备份        </p>\n<pre><code class=\"language-objectivec\">NSString *tmp = NSTemporaryDirectory();</code></pre>\n<h3 id=\"librarycaches\">Library/Caches</h3>\n<p>保存app运行时需要持久化的数据, iTunes同步不会备份, 一般存储体积大不需备份的非重要数据 (用的多)</p>\n<h3 id=\"librarypreference\">Library/Preference</h3>\n<p>保存应用的偏好设置, iOS的Setting应用会在该目录查找app的设置信息，iTunes同步时会备份</p>\n<h2 id=\"plist存储\">plist存储</h2>\n<p>注意事项: plist文件不能存储用户自定义对象</p>\n<pre><code class=\"language-objectivec\">// plist存储\n- (IBAction)save:(id)sender {\n    // Plist存储本质，就是生成一个plist文件\n    // 一般plist文件由数组，字典组成\n    NSArray* arr = @[@&quot;123&quot;, @1];\n\n    // 找到应用沙盒的目录，存到Libaray/Caches文件\n    NSString* cachesPath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];\n    NSLog(@&quot;%@&quot;, cachesPath);\n\n    //将数组写入plist文件\n    //[arr writeToFile:[NSString stringWithFormat:@&quot;%@/arr.plist&quot;,cachesPath] atomically:YES];\n    [arr writeToFile:[cachesPath stringByAppendingPathComponent:@&quot;arr.plist&quot;] atomically:YES];\n}\n\n// plist读取\n- (IBAction)read:(id)sender {\n    NSString* cachesPath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];\n    // 读取，以什么形式存储就以什么形式读取\n    NSArray* arr = [NSArray arrayWithContentsOfFile:[cachesPath stringByAppendingPathComponent:@&quot;arr.plist&quot;]];\n    NSLog(@&quot;%@&quot;, arr);\n}</code></pre>\n<p>路径:</p>\n<p>/Users/kevin/Library/Developer/CoreSimulator/Devices/5E144187-C238-412C-B2C2-E198C9626F98/data/Containers/Data/Application/71B35379-47B9-4D57-A3C3-96E3ACC644C4/Library/Caches</p>\n<p>写入的文件</p>\n<p><img src=\"../../../images/blog/ios/ios_data_save_3.png\" alt=\"ios_data_save_3.png\"></p>\n<p>读取结果</p>\n<p><img src=\"../../../images/blog/ios/ios_data_save_4.png\" alt=\"ios_data_save_4.png\"></p>\n<h2 id=\"偏好设置存储preference\">偏好设置存储(Preference)</h2>\n<p>偏好设置好处: </p>\n<ol>\n<li>快速进行键值对的存储 </li>\n<li>不关系文件名, 自动生成dict结构的plist文件, 键值对的存取方便</li>\n</ol>\n<pre><code class=\"language-objectivec\">- (IBAction)save:(id)sender {\n    // 偏好设置存储 NSUserDefaults\n    // 获取NSUserDefaults单列对象\n    NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];\n\n    //NSLog(@&quot;%@&quot;, NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES));\n    [defaults setObject:@&quot;123&quot; forKey:@&quot;num&quot;];\n    [defaults setBool:YES forKey:@&quot;isOn&quot;];\n}\n\n- (IBAction)read:(id)sender {\n    // 获取NSUserDefaults单列对象\n    NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];\n\n    NSString* num = [defaults objectForKey:@&quot;num&quot;];\n    BOOL isOn = [defaults objectForKey:@&quot;isOn&quot;];\n    NSLog(@&quot;num: %@, isON :%d&quot;, num, isOn);\n}</code></pre>\n<p><img src=\"../../../images/blog/ios/ios_data_save_5.png\" alt=\"ios_data_save_5.png\"></p>\n<p>2016-11-10 02:45:34.539 UI-18[8878:616370] num: 123, isON :1</p>\n<h2 id=\"归档nskeyedarchiver\">归档(NSKeyedArchiver)</h2>\n<p>可存储自定义对象，当自定义对象需要遵循NScoding协议, 实现对应归档，解档方法</p>\n<pre><code class=\"language-objectivec\">- (IBAction)save:(id)sender {\n    // 存储自定义对象，可使用归档，但需要遵循NSCoding协议，实现对应方法\n    Person* p = [[Person alloc] init];\n    p.age = 18;\n    p.name = @&quot;zgq&quot;;\n\n    // 获取caches文件夹\n    NSString* cachesPath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];\n    NSString* path = [cachesPath stringByAppendingPathComponent:@&quot;person.data&quot;];\n    NSLog(@&quot;%@&quot;, cachesPath);\n\n    // object: 需要归档的对象，任何对象都可以进行归档  file: 文件的全路径\n    [NSKeyedArchiver archiveRootObject:p toFile:path];\n}\n\n- (IBAction)read:(id)sender {\n    // 存进去是什么 就怎么取出\n    Person* p = [NSKeyedUnarchiver unarchiveObjectWithFile:[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@&quot;person.data&quot;]];\n    NSLog(@&quot;age: %ld , name: %@&quot;, p.age, p.name);\n}</code></pre>\n<p><img src=\"../../../images/blog/ios/ios_data_save_6.png\" alt=\"ios_data_save_6.png\"></p>\n<p>2016-11-10 13:42:30.328 UI-19[9601:719889] age: 18 , name: zgq    </p>\n<p>Person.m</p>\n<pre><code class=\"language-objectivec\">@implementation Person\n\n// 什么作用: 告诉系统，模型中的那些属性需要归档\n// 把一个自定义对象归档的时候调用\n- (void)encodeWithCoder:(NSCoder *)aCoder\n{\n    //aCode用来归档\n    [aCoder encodeInteger:_age forKey:@&quot;age&quot;];\n    [aCoder encodeObject:_name forKey:@&quot;name&quot;];\n}\n\n// 作用: 告诉系统中那些属性需要解档\n// 解档文件时调用\n// storyboard也是一个文件，系统storyboard上控件的解析绘制也会调用initWithCoder方法\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder\n{\n    // 一定要给成员属性赋值\n    if (self = [super init]) {\n        _name = [aDecoder decodeObjectForKey:@&quot;name&quot;];\n        _age = [aDecoder decodeIntegerForKey:@&quot;age&quot;];\n    }\n\n    return self;\n}\n\n@end</code></pre>\n<h2 id=\"sqlite3\">SQLite3</h2>\n<p>待完善</p>\n<h2 id=\"core-data\">Core Data</h2>\n<p>待完善，关于ios数据持久化可以参见: <a href=\"https://www.jianshu.com/p/7616cbd72845\">iOS中几种数据持久化方案</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS数据持久化(存储数据)",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "应用沙盒",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "沙盒路径"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "应用程序包"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "Documents"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "tmp"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "Library/Caches"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "Library/Preference"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "plist存储"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "偏好设置存储(Preference)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "归档(NSKeyedArchiver)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "SQLite3"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Core Data"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS数据持久化(存储数据).md",
        "staticFileName": "ios_data_save.html",
        "author": "guoqzuo",
        "createDate": "2016/11/10",
        "description": "iOS里有一个专有名词叫数据持久化，可以理解为数据存储。iOS数据持久化有5种方式：1. XML属性列表 (plist文件) 2. Preference (偏好设置) 3. NSKeyedArchiver归档 (NSCoding) 4. SQLite3 5. Core Data 这里先讲前三种。",
        "keywords": "iOS数据存储,iOS数据持久化,iOS应用沙盒,ios 数据持久化,ios 数据存储,ios 应用沙盒",
        "category": "iOS",
        "year": "2016",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios-transform设置控件平移、旋转、缩放\">iOS transform设置控件平移、旋转、缩放</h1>\n<blockquote>\n<p>一般情况下，我们可以通过修改UI控件的x，y轴以及长宽来控制控件的形变，iOS提供了transform属性用来专门来处理控件的形变(平移，旋转，缩放等)。所有的UIView控件都有transform这个属性。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_transform_1.png\" alt=\"ios_transform_1.png\"></p>\n<h2 id=\"代码实例\">代码实例:</h2>\n<p><img src=\"../../../images/blog/ios/ios_transform_2.png\" alt=\"ios_transform_2.png\"></p>\n<pre><code class=\"language-objectivec\">@property (weak, nonatomic) IBOutlet UIView *redView;\n\n@end\n\n@implementation ViewController\n\n- (IBAction)action:(id)sender {\n\n    // x+100 ,向右平移100\n    [UIView animateWithDuration:1 animations:^{ // 动画效果，持续时间1s\n\n        // 原始方法平移\n        //CGRect frame = _redView.frame;\n        //frame.origin.x += 100;\n        //_redView.frame = frame;\n\n        // MakeTranslation: 基于最开始的位置形变，会把之前的位置情空，一次有效\n        //_redView.transform = CGAffineTransformMakeTranslation(100, 0);\n\n        // 相对于上一次的形变, 这个就和上面的原始方法的效果一致\n        //_redView.transform = CGAffineTransformTranslate(_redView.transform, 100, 0);\n\n        // 旋转 M_PI: 180°、M_PI_2: 90°、M_PI_4:45°\n        //_redView.transform = CGAffineTransformMakeRotation(M_PI_2);\n        //_redView.transform = CGAffineTransformRotate(_redView.transform, M_PI_2);\n\n        // 按比例缩放\n        // sx: 宽度缩放比例，sy: 高度缩放比例\n        _redView.transform = CGAffineTransformScale(_redView.transform, 0.5, 0.5);\n        //_redView.transform = CGAffineTransformScale(_redView.transform, 2, 2);\n\n    }];\n\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS transform设置控件平移、旋转、缩放",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "代码实例:"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS transform设置控件平移、旋转、缩放.md",
        "staticFileName": "ios_transform.html",
        "author": "guoqzuo",
        "createDate": "2016/11/10",
        "description": "一般情况下，我们可以通过修改UI控件的x，y轴以及长宽来控制控件的形变，iOS提供了transform属性用来专门来处理控件的形变(平移，旋转，缩放等)。所有的UIView控件都有transform这个属性。",
        "keywords": "transform,iOS 形变,控件的移动/缩放/旋转",
        "category": "iOS",
        "year": "2016",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios-uitabbarcontroller\">iOS UITabBarController</h1>\n<blockquote>\n<p>现在手机里常用的app绝大部分都用到了UITabBarController，也就是最下面的一排按钮，通过点击按钮可以切换页面。它可以轻松管理多个控制器，类似于UINavigationController，一个是在屏幕顶部，一个是在屏幕底部。这里通过一个小例子，来了解UITabBarController。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_tabbar_1.png\" alt=\"ios_tabbar_1.png\"></p>\n<h2 id=\"uitabbarcontroller结构\">UITabBarController结构</h2>\n<p>UITabBarController的视图底部有一个类似于导航条(高64)的UITabBar(高49)，在不添加子控制器视图的情况下，底部就是一个白色的背景条。我们可以给UITabBarController添加对应的子视图控制器，他们会按顺序依次对应相应的UITabBarButton，通过子视图控制器的的UITabBarItem属性，可设置按钮的标题，图片等。              </p>\n<p><img src=\"../../../images/blog/ios/ios_tabbar_2.png\" alt=\"ios_tabbar_2.png\"></p>\n<p>UITabBarItem属性相关</p>\n<p><img src=\"../../../images/blog/ios/ios_tabbar_3.png\" alt=\"ios_tabbar_3.png\"></p>\n<h2 id=\"主流的app框架及应用\">主流的app框架及应用</h2>\n<p>关于UITabBarController，可参见: <a href=\"https://www.cnblogs.com/wendingding/p/3775488.html\">iOS开发UI篇-UITabBarController简单介绍</a>，基本了解UITabBarController之后，我们可以与之前的导航控制器相结合。一般主流app的结构如下。在导航控制器的前面再加一层TabBarController。</p>\n<p><img src=\"../../../images/blog/ios/ios_tabbar_4.png\" alt=\"ios_tabbar_4.png\"></p>\n<p>不依赖storyboard去掉main的入口，在代理里创建页面。这里的UIViewControlle我们可以根据需要创建对应的控制器如AddViewController，ContactsViewController等，相统一管理导航控制器也可以自定义UINavigationController。</p>\n<p><img src=\"../../../images/blog/ios/ios_tabbar_5.png\" alt=\"ios_tabbar_5.png\"></p>\n<p><img src=\"../../../images/blog/ios/ios_tabbar_6.png\" alt=\"ios_tabbar_6.png\"></p>\n<h2 id=\"代码\">代码</h2>\n<pre><code class=\"language-objectivec\">#import &quot;AppDelegate.h&quot;\n\n@interface AppDelegate ()\n\n@end\n\n@implementation AppDelegate\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n\n    _window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n\n    UITabBarController* tabBarC = [[UITabBarController alloc] init];\n\n    _window.rootViewController = tabBarC; // 将tabBar设置为window的根控制器\n\n    // 第一个导航控制器视图, 注意导航控制器的标题在vc里设置，UITabBarButton在navVc里设置\n    UIViewController* vc1 = [[UIViewController alloc] init];\n    vc1.view.backgroundColor = [UIColor redColor];\n    UINavigationController* navVc1 = [[UINavigationController alloc] initWithRootViewController:vc1];\n    vc1.navigationItem.title = @&quot;消息&quot;;\n    navVc1.tabBarItem.title = @&quot;消息&quot;;\n    navVc1.tabBarItem.image = [UIImage imageNamed:@&quot;message&quot;];\n\n    // 第二个导航控制器视图\n    UIViewController* vc2 = [[UIViewController alloc] init];\n    vc2.view.backgroundColor = [UIColor blueColor];\n    UINavigationController* navVc2 = [[UINavigationController alloc] initWithRootViewController:vc2];\n    vc2.navigationItem.title = @&quot;联系人&quot;;\n    navVc2.tabBarItem.title = @&quot;联系人&quot;;\n    navVc2.tabBarItem.image = [UIImage imageNamed:@&quot;contacts&quot;];\n\n    // 第三个导航控制器视图\n    UIViewController* vc3 = [[UIViewController alloc] init];\n    vc3.view.backgroundColor = [UIColor grayColor];\n    UINavigationController* navVc3 = [[UINavigationController alloc] initWithRootViewController:vc3];\n    vc3.navigationItem.title = @&quot;动态&quot;;\n    navVc3.tabBarItem.title = @&quot;动态&quot;;\n    navVc3.tabBarItem.image = [UIImage imageNamed:@&quot;news&quot;];\n    navVc3.tabBarItem.badgeValue = @&quot;10&quot;;\n\n    // 第四个导航控制器视图\n    UIViewController* vc4 = [[UIViewController alloc] init];\n    vc4.view.backgroundColor = [UIColor yellowColor];\n    UINavigationController* navVc4 = [[UINavigationController alloc] initWithRootViewController:vc4];\n    vc4.navigationItem.title = @&quot;设置&quot;;\n    navVc4.tabBarItem.title = @&quot;设置&quot;;\n    navVc4.tabBarItem.image = [UIImage imageNamed:@&quot;setting&quot;];\n\n\n    // 将导航控制器按顺序添加到TabBar\n    // [tabBarC setViewControllers:@[navVc1,navVc2,navVc3,navVc4]]; // 方法1\n    // 方法2\n    [tabBarC addChildViewController:navVc1];\n    [tabBarC addChildViewController:navVc2];\n    [tabBarC addChildViewController:navVc3];\n    [tabBarC addChildViewController:navVc4];\n\n    [_window makeKeyAndVisible];\n\n    return YES;\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS UITabBarController",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "UITabBarController结构"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "主流的app框架及应用"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "代码"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS UITabBarController.md",
        "staticFileName": "ios_tabbar.html",
        "author": "guoqzuo",
        "createDate": "2016/11/10",
        "description": "现在手机里常用的app绝大部分都用到了UITabBarController，也就是最下面的一排按钮，通过点击按钮可以切换页面。它可以轻松管理多个控制器，类似于UINavigationController，一个是在屏幕顶部，一个是在屏幕底部。这里通过一个小例子，来了解UITabBarController。",
        "keywords": "ios tabbar,iOS主流app框架,UITabBarController,UITabBarController与UINavigationController,UITabBarController与导航控制器结合使用",
        "category": "iOS",
        "year": "2016",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios-modal，另一种切换控制器的方法\">iOS Modal，另一种切换控制器的方法</h1>\n<blockquote>\n<p>之前页面的切换用的一般是push，这里介绍另一种控制器切换的方法: Modal。任何控制器都能通过Modal的形式展示出来。Modal的默认效果:新控制器从屏幕最底部往上钻，直到盖住之前的控制器为止(push的效果为从右至左)</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_modal_1.png\" alt=\"ios_modal_1.png\"></p>\n<h2 id=\"presentviewcontroller\">presentViewController</h2>\n<p>用storyboard拖拽一个按钮jmp，将view Controller的类设置为ViewController。在跳转函数里设置相关跳转，关于Modal详情可参见: iOS开发UI篇-Modal简单介绍</p>\n<p><img src=\"../../../images/blog/ios/ios_modal_2.png\" alt=\"ios_modal_2.png\"></p>\n<h2 id=\"uialertcontroller与modal\">UIAlertController与modal</h2>\n<p>联想到之前弹窗时用的presentViewController，可能UIAlertController的跳转方式就是modal，于是想看看弹窗结束系统是否调用的dissmiss函数。于是又拖拽了一个按钮来弹窗，并重写dissmiss方法。发现弹窗消失时确实调用了dissmiss函数。</p>\n<p><img src=\"../../../images/blog/ios/ios_modal_3.png\" alt=\"ios_modal_3.png\"></p>\n<h2 id=\"代码\">代码</h2>\n<pre><code class=\"language-objectivec\">#import &quot;ViewController.h&quot;\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n// 跳转到下一个界面\n-(IBAction)jmp:(id)sender {\n    // 创建一个视图控制器，按下按钮后跳转到该界面\n    UIViewController* vc = [[UIViewController alloc] init];\n    vc.view.backgroundColor = [UIColor greenColor];\n\n    //在界面上添加一个按钮，用来返回\n    UIButton* backBtn = [[UIButton alloc] init];\n    [backBtn setTitle:@&quot;返回&quot; forState:UIControlStateNormal];\n    [backBtn sizeToFit];\n    [backBtn setCenter:CGPointMake(100, 100)];\n    [vc.view addSubview:backBtn];\n\n    // 按下按钮后的事件\n    [backBtn addTarget:self action:@selector(back) forControlEvents:UIControlEventTouchDown];\n\n    // 跳转到下一个控制器\n    [self presentViewController:vc animated:YES completion:nil];\n}\n\n- (void)back // 跳转后的页面增加一个按钮, 点击按钮后执行\n{\n    // 把modal出来的控制器dismiss， 将最后一次modal出来的控制器退下,不依赖于(self)当前控制器\n    [self dismissViewControllerAnimated:YES completion:nil];\n    //NSLog(@&quot;%s&quot;, __func__);\n}\n\n// 测试弹窗消失时是否调用了dismissViewController..\n- (IBAction)alertView:(id)sender {\n    UIAlertController* alertC = [UIAlertController alertControllerWithTitle:@&quot;测试&quot; message:@&quot;弹窗视图是否用了modal方式&quot; preferredStyle:UIAlertControllerStyleActionSheet];\n    [alertC addAction:[UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:nil]];\n    [self presentViewController:alertC animated:YES completion:nil];\n\n}\n\n// 重写方法，看弹窗消失时是否调用该函数\n- (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion\n{\n    [super dismissViewControllerAnimated:flag completion:completion];\n    NSLog(@&quot;%s&quot;, __func__);\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n}\n\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n\n@end</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS Modal，另一种切换控制器的方法",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "presentViewController"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "UIAlertController与modal"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "代码"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS Modal，另一种切换控制器的方法.md",
        "staticFileName": "ios_modal.html",
        "author": "guoqzuo",
        "createDate": "2016/11/14",
        "description": "之前页面的切换用的一般是push，这里介绍另一种控制器切换的方法: Modal。任何控制器都能通过Modal的形式展示出来。Modal的默认效果:新控制器从屏幕最底部往上钻，直到盖住之前的控制器为止(push的效果为从右至左)",
        "keywords": "iOS Modal,Modal跳转,UIAlertController与Modal,presentViewController跳转,ios modal",
        "category": "iOS",
        "year": "2016",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios-uiresponder响应者对象，ios中的事件\">iOS UIResponder响应者对象，iOS中的事件</h1>\n<p>在使用app的过程中，会产生各种各样的事件，iOS中的事件可以分为3大类型:触摸事件、加速计事件、远程控制事件。不是任何对象都能处理事件，只有继承了UIResponder的对象，才能接收并处理事件。这些对象被称为响应者对象</p>\n<p><img src=\"../../../images/blog/ios/ios_responder_1.png\" alt=\"ios_responder_1.png\"></p>\n<h2 id=\"响应者对象\">响应者对象</h2>\n<p>UIApplication/UIViewController/UIView都继承自UIResponder，他们都能接收并处理事件。先来看看触摸事件，当用户一根手指触摸时，会创建一个与手指关联的UITouch对象，一根手指对应一个UITouch对象。它保持着手指相关信息，如触摸的位置、时间。当手指移动时，系统会更新同一个UITouch对象，使之能够一直保持该手指在的触摸位置。当手指离开屏幕时，系统会销毁相应的UITouch对象。</p>\n<p>这里我们在storyboard里拖拽一个UIView，背景设置为红色。修改类为自定义类RedView，在RedView.m文件里，监听该view的移动，用transform设置该view根据手指的移动而移动    </p>\n<p><img src=\"../../../images/blog/ios/ios_responder_2.png\" alt=\"ios_responder_2.png\"></p>\n<pre><code class=\"language-objectivec\">#import &quot;RedView.h&quot;\n\n@implementation RedView\n\n- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event\n{\n    NSLog(@&quot;开始触摸......&quot;);\n}\n\n- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event\n{\n    NSLog(@&quot;停止触摸......&quot;);\n}\n\n- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event\n{\n    NSLog(@&quot;移动中......&quot;);\n    // 实现该视图随着鼠标的移动而移动\n    UITouch* touch = [touches anyObject]; // 获取touches中的任意一对象\n    CGPoint curP = [touch locationInView:self]; // 当前位置\n    CGPoint preP = [touch previousLocationInView:self]; // 之前位置\n    CGFloat offsetX = curP.x - preP.x; // x偏移\n    CGFloat offsetY = curP.y - preP.y; // y偏移\n\n    self.transform = CGAffineTransformTranslate(self.transform, offsetX, offsetY);\n}\n\n- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event\n{\n    NSLog(@&quot;%s&quot;, __func__);\n}\n\n@end</code></pre>\n<h2 id=\"事件的产生和传递\">事件的产生和传递</h2>\n<p>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中，UIApplication会从事件队列中找出最前面的事件，将事件分发下去处理，通常先发送给主窗口(keyWindow)主窗口会一层层传递，找到最合适的视图来处理触摸事件</p>\n<p><img src=\"../../../images/blog/ios/ios_responder_3.png\" alt=\"ios_responder_3.png\"></p>\n<h2 id=\"uiview不接收触摸事件的3种情况\">UIView不接收触摸事件的3种情况</h2>\n<ol>\n<li>不接收用户交互，userInteractionEnabled = NO;</li>\n<li>隐藏 hidden = YES;</li>\n<li>透明 alpha = 0.0 ~ 0.01</li>\n</ol>\n<p>UIImageView的userInteractionEnabled默认就是NO，因此UIImageView及其子控件默认不接收触摸事件根据事件的传递规, 父控件如果不接收触摸事件，其子控件的触摸事件也会失效</p>\n<h2 id=\"hittest方法-寻找最合适的view\">hitTest方法: 寻找最合适的view</h2>\n<p>hitTest的底层实现：判断下自己能否接收事件，判断点在不在当前控件上，遍历自己的子控件，如果没有比自己合适的子控件，最合适的view就是自己。</p>\n<pre><code class=\"language-objectivec\">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent*)event</code></pre>\n<p>只要一个事件传递给一个控件，就会调用这个控件的hitTest，返回谁，谁就是最合适的view。在这个方法里return self，就是指定自己处理该事件。</p>\n<p>判断下点(point)是不是在当前控件上，重写如果返回NO，则该视图不接收处理事件。</p>\n<pre><code class=\"language-objectivec\">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent*)event {\n    return NO;\n}</code></pre>\n<p>练习1: 橘色的view在覆盖了button，当点击重合的button区域时，穿透橘色view，让button响应。这里第一层级为UIWidow --&gt; button按钮 --&gt; OriView(橙色视图)，当点击橙色视图和button重合的地方时，默认最佳的响应者为橙色视图，这里我们判断如果点击的位置刚好在和按钮重合的位置上时，就放弃响应，给button去响应。在OriView.m文件中建立btn IBOutlet属性，对应button。</p>\n<p><img src=\"../../../images/blog/ios/ios_responder_4.png\" alt=\"ios_responder_4.png\"></p>\n<pre><code class=\"language-objectivec\">#import &quot;OriView.h&quot;\n\n@interface OriView ()\n\n@property (nonatomic,weak) IBOutlet UIButton* btn;\n\n@end\n\n@implementation OriView\n\n- (UIView*)hitTest:(CGPoint)point withEvent:(UIEvent *)event\n{\n    // 判断点在不在按钮上\n    // 转换坐标系\n    // point的点事相对于橙色视图的，而我们要判断点是否在btn上，要将坐标转换为btn上的坐标\n    CGPoint btnP = [self convertPoint:point toView:self.btn];\n    NSLog(@&quot;转换后: %lf, %lf&quot;, btnP.x, btnP.y); // 打印后就明显的看出差距了\n    NSLog(@&quot;转换前: %lf,%lf&quot;, point.x, point.y);\n    // 获取按钮\n    if ([self.btn pointInside:btnP withEvent:event]) {\n        // 点在按钮上，事件传递 按钮 --&gt; 挡住按钮的橙色视图，返回nil，就给上一级处理\n        return nil;\n    } else {\n        return [super hitTest:point withEvent:event];\n    }\n}\n\n@end</code></pre>\n<p>练习2: 子控件超出父控件范围后的点击事件，点击弹出对话框: 为button添加一个子控件，点击控件图片改变，子控件超出父控件范围，点击该弹窗时，不能触发button的点击事件。</p>\n<p><img src=\"../../../images/blog/ios/ios_responder_5.png\" alt=\"ios_responder_5.png\"></p>\n<pre><code class=\"language-objectivec\">// 点击按钮后执行弹窗\n- (IBAction)alertChatView:(popButton*)sender {\n    UIImage* img1 = [UIImage imageNamed:@&quot;对话框&quot;];\n    UIImage* img2 = [UIImage imageNamed:@&quot;小孩&quot;];\n    UIButton* button = [UIButton buttonWithType:UIButtonTypeCustom];\n    [button setBackgroundImage:img1 forState:UIControlStateNormal];\n    [button setBackgroundImage:img2 forState:UIControlStateHighlighted];\n    [button sizeToFit];\n\n    sender.button = button; // popButton类.h文件中的属性，用来判断点是否在对话框视图上\n\n    // 让子视图超出父控件范围\n    NSLog(@&quot;%@&quot;, button); // frame(0,0,200,202)\n    CGSize oriSize = button.bounds.size;\n    button.center = CGPointMake(oriSize.width*0.5, -oriSize.height*0.5);\n    NSLog(@&quot;%@&quot;, button); // frame(0,-202,200,202);\n\n    [sender addSubview:button];\n}</code></pre>\n<p>我们给点我弹窗对话框这个按钮专门制定一个类popButton，用来处理hitTest，代码:</p>\n<pre><code class=\"language-objectivec\">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event\n{\n    // 坐标系转换\n    CGPoint curP = [self convertPoint:point toView:self.button];\n\n    // 判断点击是否在对话框视图上，在就让他响应\n    if ([self.button pointInside:curP withEvent:event]) {\n        return self.button;\n    } else {\n        return [super hitTest:point withEvent:event];\n    }\n\n}</code></pre>\n<h2 id=\"事件响应方法\">事件响应方法</h2>\n<p>将事件event根据响应者链条向上传递，将事件交给上一个响应者处理</p>\n<p><img src=\"../../../images/blog/ios/ios_responder_6.png\" alt=\"ios_responder_6.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS UIResponder响应者对象，iOS中的事件",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "响应者对象"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "事件的产生和传递"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "UIView不接收触摸事件的3种情况"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "hitTest方法: 寻找最合适的view"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "事件响应方法"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS UIResponder响应者对象，iOS中的事件.md",
        "staticFileName": "ios_responder.html",
        "author": "guoqzuo",
        "createDate": "2016/11/14",
        "description": "在使用app的过程中，会产生各种各样的事件，iOS中的事件可以分为3大类型:触摸事件、加速计事件、远程控制事件。不是任何对象都能处理事件，只有继承了UIResponder的对象，才能接收并处理事件。这些对象被称为响应者对象",
        "keywords": "UIResponder响应者对象,UITouch对象,触摸事件,iOS中的事件,hitTest应用",
        "category": "iOS",
        "year": "2016",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios-手势uigesturerecognizer\">iOS 手势UIGestureRecognizer</h1>\n<blockquote>\n<p>监听一个view的触摸事件可以先自定义view，再实现它的touches方法来处理事件。通过touches方法监听view触摸事件必须得自定义view，外界对象无法监听view的触摸对象，且不易区分用户的具体手势行为。这里将介绍手势识别类UIGestureRecognizer，它可以更好的识别触摸事件。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_gesture_1.png\" alt=\"ios_gesture_1.png\"></p>\n<h2 id=\"点按手势\">点按手势</h2>\n<p>在storyboard里拖拽一个imageView，用来测试点击事件</p>\n<p><img src=\"../../../images/blog/ios/ios_gesture_2.png\" alt=\"ios_gesture_2.png\"></p>\n<p>当点击图片时，打印点击了。用代理实现只有左半边能点击。</p>\n<p><img src=\"../../../images/blog/ios/ios_gesture_3.png\" alt=\"ios_gesture_3.png\"></p>\n<h2 id=\"长按手势\">长按手势</h2>\n<p>添加一个长按手势识别</p>\n<p><img src=\"../../../images/blog/ios/ios_gesture_4.png\" alt=\"ios_gesture_4.png\"></p>\n<h2 id=\"轻扫-有方向-默认往右滑\">轻扫 (有方向, 默认往右滑)</h2>\n<p><img src=\"../../../images/blog/ios/ios_gesture_5.png\" alt=\"ios_gesture_5.png\"></p>\n<h2 id=\"主要代码\">主要代码</h2>\n<p>ViewController.m</p>\n<pre><code class=\"language-objectivec\">#import &quot;ViewController.h&quot;\n\n@interface ViewController () &lt;UIGestureRecognizerDelegate&gt;\n\n@property (weak, nonatomic) IBOutlet UIImageView *imageView; // 图形视图\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    _imageView.userInteractionEnabled = YES; // imageView默认\n    UITapGestureRecognizer* t = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap)];\n    t.delegate = self; // 用代理&lt;UIGestureRecognizerDelegate&gt;方法，可禁止接收touch事件\n    [_imageView addGestureRecognizer:t]; // 点击后抬起的时候触发\n\n    // 长按手势\n    UILongPressGestureRecognizer* t2 = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPress:)];\n    [_imageView addGestureRecognizer:t2];\n\n    // 滑动手势，默认往右滑\n    UISwipeGestureRecognizer* t3 = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(rightSwipe)];\n    [_imageView addGestureRecognizer:t3];\n\n    // 滑动手势，设置滑动方向\n    UISwipeGestureRecognizer* t4 = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(leftSwipe)];\n    t4.direction = UISwipeGestureRecognizerDirectionLeft; // 设置方向为向左滑\n    // UISwipeGestureRecognizerDirectionUp  向上\n    // UISwipeGestureRecognizerDirectionDown 向下\n    [_imageView addGestureRecognizer:t4];\n}\n\n- (void)leftSwipe\n{\n    NSLog(@&quot;向左滑...&quot;);\n}\n\n- (void)rightSwipe\n{\n    NSLog(@&quot;往右滑...&quot;);\n}\n\n- (void)tap\n{\n    NSLog(@&quot;点击了!&quot;);\n}\n\n- (void)longPress:(UILongPressGestureRecognizer *)t2\n{\n    // 长按会调用多次\n    NSLog(@&quot;长按.....&quot;);\n    // 当长按开始的时候做事情, 又要获取t2对象\n    if (t2.state == UIGestureRecognizerStateBegan) {\n        NSLog(@&quot;长按开始...&quot;); // 只调用一次\n    }\n}\n\n// 是否允许接收touch\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch\n{\n    // return NO; // 不允许点击事件\n    // 实现左边可以点，右边不可以点\n    CGPoint curP = [touch locationInView:_imageView];\n    CGFloat maxX = _imageView.frame.size.width*0.5;\n    if (curP.x &lt; maxX) {\n        return YES;\n    } else {\n        return NO;\n    }\n}\n\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n\n@end</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS 手势UIGestureRecognizer",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "点按手势"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "长按手势"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "轻扫 (有方向, 默认往右滑)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "主要代码"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS 手势UIGestureRecognizer.md",
        "staticFileName": "ios_gesture.html",
        "author": "guoqzuo",
        "createDate": "2016/11/14",
        "description": "监听一个view的触摸事件可以先自定义view，再实现它的touches方法来处理事件。通过touches方法监听view触摸事件必须得自定义view，外界对象无法监听view的触摸对象，且不易区分用户的具体手势行为。这里将介绍手势识别类UIGestureRecognizer，它可以更好的识别触摸事件。",
        "keywords": "iOS UIGestureRecognizer手势识别,iOS手势,UIGesture,ios 手势,ios 手势事件",
        "category": "iOS",
        "year": "2016",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"web站点优化-关于最近的改版\">web站点优化 关于最近的改版</h1>\n<blockquote>\n<p>最近花了点时间将网站的前端重新改了下，顺便对移动端也做了专门处理。之前首页只是从笔记中挑选了最新的10篇放在首页，现在将各个分类的最近10篇笔记都展现在了首页，且加上了后台系统的轮播图片，站点有了一定的提升，下面总结了一些改进细节。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/web/web_optimize_1.jpg\" alt=\"web_optimize_1\"></p>\n<h2 id=\"百度快照乱码\">百度快照乱码</h2>\n<p>查看百度快照发现有乱码，原来是空格的原因，就将UINX 高级编程中的空格去掉了。</p>\n<p><img src=\"../../../images/blog/web/web_optimize_2.png\" alt=\"web_optimize_2\"></p>\n<h2 id=\"移动端的特殊处理\">移动端的特殊处理</h2>\n<p>用document.ready检测是否是移动端访问，如果是跳到m_index.jsp执行，本来打算用二级域名m.zuo11.com来处理，但在研究时发现二级域名绑定ip或目录都比较麻烦，我只是小改一下页面，其实可以不用跳转，直接改css也行，但用js处理css相关比较麻烦，而且我的元素定义时乱用class，导致都不好获取。感觉响应式布局，屏幕自适应也没什么，只是css相关的改变罢了。</p>\n<p><img src=\"../../../images/blog/web/web_optimize_3.png\" alt=\"web_optimize_3\"></p>\n<h2 id=\"畅言评论系统的不足\">畅言评论系统的不足</h2>\n<p>畅言的广告有时候显示的效果比较差，最大的硬伤是wap版的回复问题，用iphone SE调试时，只有横屏才能显示正常，竖屏有bug，最后索性将评论系统换成了多说，不过多说确实还是比较好一点，只是用起来稍微麻烦一点，它主要推广的是wordpress等直接安装，找自定义代码的入口比较费劲。</p>\n<p><img src=\"../../../images/blog/web/web_optimize_4.png\" alt=\"web_optimize_4\"></p>\n<h2 id=\"ueditor富文本插件的不足\">UEditor富文本插件的不足</h2>\n<p>在pc端，文章加载的还行。但移动端图片加载越界，有些复制粘贴的代码也有越界的,img的用css加了个约束就好了, 但代码还是要用插件自带的代码来写，但ueditor的代码插入不支持oc，有时间得找个更合适的插件。 </p>\n<pre><code class=\"language-css\">img { width:auto;height:auto;max-width:100%;max-height:100%; }</code></pre>\n<p><img src=\"../../../images/blog/web/web_optimize_5.png\" alt=\"web_optimize_5\"></p>\n<h2 id=\"seo相关\">seo相关</h2>\n<p>最近有段时间没有更新了文章了，蜘蛛抓的频次很低，百度收录波动比较大，看来还是要定期更新几篇文章.</p>\n<p><img src=\"../../../images/blog/web/web_optimize_6.png\" alt=\"web_optimize_6\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "web站点优化 关于最近的改版",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "百度快照乱码"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "移动端的特殊处理"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "畅言评论系统的不足"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "UEditor富文本插件的不足"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "seo相关"
            }
          ]
        }
      ],
      "config": {
        "source": "web站点优化 关于最近的改版.md",
        "staticFileName": "web_optimize_1.html",
        "author": "guoqzuo",
        "createDate": "2016/12/18",
        "description": "最近花了点时间将网站的前端重新改了下，顺便对移动端也做了专门处理。之前首页只是从笔记中挑选了最新的10篇放在首页，现在将各个分类的最近10篇笔记都展现在了首页，且加上了后台系统的轮播图片，站点有了一定的提升，下面总结了一些改进细节。",
        "keywords": "zuo11.com站点优化记录,PC站转移动站,移动端适配",
        "category": "网站建设与SEO",
        "year": "2016",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"网站打开速度优化\">网站打开速度优化</h1>\n<blockquote>\n<p>最近用百度统计的网站测速工具测了下网站的打开时间，结果要7秒多，最后根据上面的提示进行了相关修改：将png图片压缩、开启GZip压缩、合并js文件等。将速度降到了不到3秒，同时在百度站长上处理了一些死链，提交了一些链接。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/web/web_more_fast_1.png\" alt=\"web_more_fast_1.png\"></p>\n<h2 id=\"将零散的css、js文件合并为一个\">将零散的css、js文件合并为一个</h2>\n<p>减少加载文件的个数, 将js声明，处理放到代码末尾。</p>\n<h2 id=\"启用gzip压缩\">启用GZip压缩</h2>\n<p>tomcat下开启GZip需设置tomcat安装目录conf下的server.xml文件</p>\n<p><img src=\"../../../images/blog/web/web_more_fast_2.png\" alt=\"web_more_fast_2.png\"></p>\n<h2 id=\"用imagealpha将png图片无损压缩\">用ImageAlpha将png图片无损压缩</h2>\n<p><img src=\"../../../images/blog/web/web_more_fast_3.png\" alt=\"web_more_fast_3.png\">  </p>\n<p>首页的图片有5张，logo加上4张轮播的图片,用ImageAlpha无损压缩后大小变化:</p>\n<p>112kb =&gt; 32kb, 328kb =&gt;105kb, 331kb =&gt; 105kb, 207k=&gt; 57kb, 19kb =&gt; 8kb    </p>\n<p>在关于页面用手机拍的照片直接1.2M，最后直接截图，567kb，压缩后145kb,这样加载速度就明显提升了</p>\n<h2 id=\"关于百度链接提交的问题\">关于百度链接提交的问题</h2>\n<p>之前想把链接提交给百度只能提交主页zuo11.com这个链接，其他的页面链接都不能提交，最后发现习惯不写www是错误的关键</p>\n<p><img src=\"../../../images/blog/web/web_more_fast_4.png\" alt=\"web_more_fast_4.png\"></p>\n<p>不然一直提示提交的不是本站的站点，前面加上www完整的链接就能成功一下子将页面的所有链接都提交了</p>\n<p><img src=\"../../../images/blog/web/web_more_fast_5.png\" alt=\"web_more_fast_5.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "网站打开速度优化",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "将零散的css、js文件合并为一个"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "启用GZip压缩"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "用ImageAlpha将png图片无损压缩"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "关于百度链接提交的问题"
            }
          ]
        }
      ],
      "config": {
        "source": "网站打开速度优化.md",
        "staticFileName": "web_more_speed.html",
        "author": "guoqzuo",
        "createDate": "2016/12/22",
        "description": "最近用百度统计的网站测速工具测了下网站的打开时间，结果要7秒多，最后根据上面的提示进行了相关修改：将png图片压缩、开启GZip压缩、合并js文件等。将速度降到了不到3秒，同时在百度站长上处理了一些死链，提交了一些链接。",
        "keywords": "zuo11.com站点优化记录,Tomcat开启GZIP压缩,网站打开速度优化,tomcat 开启gzip",
        "category": "网站建设与SEO",
        "year": "2016",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"移动端适配\">移动端适配</h1>\n<blockquote>\n<p>最近一有时间就刷刷百度站长/百度统计，展现量和收录没怎么变化，上不去。虽然从表面上看站点已经OK了，但网站的流量想要做上去，离不开搜索引擎。流量就是一切，想要做好网站就必须做好SEO，现在主要的问题是移动端的处理，百度从搜索引擎的角度将对移动端的处理方式分为三种，现在我的实现很尴尬，界定模糊。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/web/web_to_m_1.png\" alt=\"web_to_m_1.png\"></p>\n<h2 id=\"跳转方式\">跳转方式</h2>\n<p>现在zuo11.com的跳转方式又像跳转适配又像代码适配，当访问站点时，浏览器通过链接向服务器发出请求。web.xml配置了默认打开index.woe的servlet页面，获取数据库内容后转发给前端页index.jsp，Tomcat解析完成后生成html传回给浏览器。</p>\n<pre><code class=\"language-java\">if (request.getParameter(&quot;action&quot;) != null) {\n    request.getRequestDispatcher(&quot;m_index.jsp&quot;).forward(request, response);\n} else {\n    request.getRequestDispatcher(&quot;index.jsp&quot;).forward(request, response);\n}</code></pre>\n<p>第一次访问时action肯定是null，就进了index.jsp。这个页面我用了js来判断是否为移动端，如果是就再次请求index.woe但传了一个action值，使页面跳转到另一个页面m_index.jsp。</p>\n<pre><code class=\"language-java\">document.ready = start;\nfunction start(){\n    if (navigator.userAgent.match(/(iPhone|iPod|Android|ios)/i)) {\n        window.location.href = &quot;index.woe?action=m&quot;;\n    }\n}</code></pre>\n<p>站点前端只用了三个页面来完成: index.jsp, notes.jsp, about.jsp，分别有相应的移动处理页面m_index.jsp, m_notes.jsp, m_about.jsp。由于是servlet的forward，表面上的链接其实是</p>\n<pre><code class=\"language-bash\">主页:\nhttp://zuo11.com/index.woe    对应index.jsp\nhttp://zuo11.com/index.woe?action=m 对应m_index.jsp \n笔记分类:ios/apue等\nhttp://zuo11.com/Notes.woe?action=iOS 对应notes.jsp \nhttp://zuo11.com/Notes.woe?mobile=true&amp;action=iOS  对应m_notes.jsp \n笔记详情:\nhttp://zuo11.com/Notes.woe?action=detail&amp;note_id=55 对应notes.jsp \nhttp://zuo11.com/Notes.woe?mobile=true&amp;action=detail&amp;note_id=55 对应m_notes.jsp \n关于:\nhttp://zuo11.com/Timeline.woe 对应about.jsp \nhttp://zuo11.com/Timeline.woe?action=m 对应m_about.jsp</code></pre>\n<p>从上面的分类来看有跳转，像是跳转适配，但我更倾向于第二种代码适配，所以得把网址url弄成一样，因为如果同一篇文章如果有两个链接，那么百度收录怎么怎么处理，明显同一篇文章，同一个链接更适合收录，所以我想用session来处理，根据session的值来判断是否转发值，这样三个页面我都需要检测浏览器的版本，判断session，防止非主页进入本站。</p>\n<h2 id=\"百度推荐\">百度推荐</h2>\n<p>关于移动配置，百度不建议的做法: </p>\n<ul>\n<li>单一域名下请使用同一种配置方式(跳转适配、代码适配、自适应)，例如，不要把移动站的页面作为pc站网址中的一个子目录来配置。</li>\n<li>如果使用跳转适配的方式，请不要使用JS对ua进行适配跳转。这种方式存在两个缺点：<ul>\n<li>对用户：会加大由重定向的客户端造成的延迟；这是因为客户端需要先下载网页，接着解析并执行JavaScript，然后才能触发重定向。301或302则不会有这个延迟。</li>\n<li>对搜索：爬虫也需要使用支持JS渲染的爬虫，才能发现此重定向。</li>\n</ul>\n</li>\n</ul>\n<p>现在这两点我全占了，目前能想到的最合适的处理方法就是在js的ready函数里，判断是否为移动端并设置session。或者可以试试ajax传值。其次是找到除js外判断是否为移动端并跳转的方法。之后还要用MIP改造移动端。</p>\n<p>参考资料:</p>\n<p><a href=\"https://ziyuan.baidu.com/college/courseinfo?id=156\">百度站长平台-移动搜索</a></p>\n<p>2016-12-25 06:24:26 更新</p>\n<p>距离写上面一大堆的内容不过10小时，现在发现在这之前自己是多么的low，明明是很简单的一个问题，但当你不知道怎么处理时，就很头疼，当知道了后就豁然开朗了，不知道这是多少次有这种感觉，每有一次就算是进步了。不管遇到什么问题，总会解决的。解决方法: java web判断是否为移动端访问</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "移动端适配",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "跳转方式"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "百度推荐"
            }
          ]
        }
      ],
      "config": {
        "source": "移动端适配.md",
        "staticFileName": "web_to_m.html",
        "author": "guoqzuo",
        "createDate": "2016/12/24",
        "description": "最近一有时间就刷刷百度站长/百度统计，展现量和收录没怎么变化，上不去。虽然从表面上看站点已经OK了，但网站的流量想要做上去，离不开搜索引擎。流量就是一切，想要做好网站就必须做好SEO，现在主要的问题是移动端的处理，百度从搜索引擎的角度将对移动端的处理方式分为三种，现在我的实现很尴尬，界定模糊。",
        "keywords": "zuo11.com站点优化记录,PC站转移动站,移动端适配",
        "category": "网站建设与SEO",
        "year": "2016",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"javaweb判断是否为移动端访问\">javaweb判断是否为移动端访问</h1>\n<blockquote>\n<p>一般java后台，会先用servlet获取数据，再跳转到前端页面。在servlet里获取数据时，我们可以根据request.getheader(User-Agent&amp;quot)的内容，判断是否为移动端访问，再转发到相应的页面。可以在保持url不变的情况下，生成两种页面。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/web/web_ismobile.png\" alt=\"web_ismobile.png\"></p>\n<h2 id=\"测试功能\">测试功能</h2>\n<p>先创建一个Test的servlet来测试，在doGet函数里面写如下测试代码:</p>\n<pre><code class=\"language-java\">String ua = request.getHeader(&quot;User-Agent&quot;);    \nif (this.checkAgentIsMobile(ua))\n    response.getWriter().print(&quot;YES&quot;);\nelse \n    response.getWriter().print(&quot;NO&quot;);</code></pre>\n<p>在该servlet内实现checkAgentIsMobile方法:</p>\n<pre><code class=\"language-java\">/**\n * 判断User-Agent 是不是来自于手机\n * @param ua\n * @return\n */\npublic  boolean checkAgentIsMobile(String ua) {\n    /*  System.out.print(ua); */\n    boolean flag = false;\n    if (!ua.contains(&quot;Windows NT&quot;) || (ua.contains(&quot;Windows NT&quot;) &amp;&amp; ua.contains\n    (&quot;compatible; MSIE 9.0;&quot;))) {\n        // 排除 苹果桌面系统\n        if (!ua.contains(&quot;Windows NT&quot;) &amp;&amp; !ua.contains(&quot;Macintosh&quot;)) {\n        for (String item : agent) {\n            if (ua.contains(item)) {\n            flag = true;\n            break;\n            }\n            }\n        }\n    }\n    return flag;\n}\nprivate final static String[] agent = { &quot;Android&quot;, &quot;iPhone&quot;, &quot;iPod&quot;,&quot;iPad&quot;, &quot;Wi\nndows Phone&quot;, &quot;MQQBrowser&quot; };</code></pre>\n<p>访问该servlet看是YES还是NO，可以用google浏览器根据不同的设备调试。</p>\n<h2 id=\"在本站中的应用\">在本站中的应用</h2>\n<p>这个原理其实很简单，就是获取ua后抓关键字，有对应的关键字就是移动端。我这个站有3个servlet需要判断，我就封装了一个IsMobileDevice类</p>\n<pre><code class=\"language-java\">public class IsMobileDevice {\n    public  boolean checkAgentIsMobile(String ua) {\n    boolean flag = false;\n    if (!ua.contains(&quot;Windows NT&quot;) || (ua.contains(&quot;Windows NT&quot;) &amp;&amp; ua.cont\n    ains(&quot;compatible; MSIE 9.0;&quot;))) {\n        // 排除 苹果桌面系统\n        if (!ua.contains(&quot;Windows NT&quot;) &amp;&amp; !ua.contains(&quot;Macintosh&quot;)) {\n        for (String item : agent) {\n            if (ua.contains(item)) {\n            flag = true;\n            break;\n            }\n            }\n        }\n    }\n    return flag;\n    }\n    private final static String[] agent = { &quot;Android&quot;, &quot;iPhone&quot;, &quot;iPod&quot;,&quot;iPad&quot;,\n     &quot;Windows Phone&quot;, &quot;MQQBrowser&quot; };\n}</code></pre>\n<p>实际中的应用:</p>\n<pre><code class=\"language-java\">String ua = request.getHeader(&quot;User-Agent&quot;);\nIsMobileDevice isMobile = new IsMobileDevice();\nString url = &quot;index.jsp&quot;;\nif (isMobile.checkAgentIsMobile(ua)) { // 判断是否为移动端\n    url = &quot;m_index.jsp&quot;;\n}\nrequest.getRequestDispatcher(url).forward(request, response);</code></pre>\n<p>参考：<a href=\"https://jingyan.baidu.com/article/870c6fc30708f7b03fe4be06.html\">Java语言如何判断请求是否来自移动端</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "javaweb判断是否为移动端访问",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "测试功能"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "在本站中的应用"
            }
          ]
        }
      ],
      "config": {
        "source": "javaweb判断是否为移动端访问.md",
        "staticFileName": "web_ismobile.html",
        "author": "guoqzuo",
        "createDate": "2016/12/25",
        "description": "一般java后台，会先用servlet获取数据，再跳转到前端页面。在servlet里获取数据时，我们可以根据request.getheader(User-Agent&quot)的内容，判断是否为移动端访问，再转发到相应的页面。可以在保持url不变的情况下，生成两种页面。",
        "keywords": "javaweb判断是否为移动端访问,java判断是否为移动端访问,判断是否为移动端访问",
        "category": "后端数据库等",
        "year": "2016",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"mip改造\">mip改造</h1>\n<blockquote>\n<p>最近对网站进行了改版，移动端为了对搜索引擎更友好，用MIP改造了移动端，还有很多问题待完善。PC端也小改了下，本来找了个很好的背景图片，但由于文件大了，影响加载速度。还是放弃了，就加了个magnet图片，写了个js来控制背景图片的切换。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/web/web_mip_1.png\" alt=\"web_mip_1.png\"></p>\n<h2 id=\"移动端改动\">移动端改动</h2>\n<p>移动端改动主要是关于MIP相关改造，MIP很容易上手，不用怎么学，只是将相关的tag改下基本就可以了。mip校验工具简直就是神器。图片的轮播插件很赞，只需要简单的几句代码就OK了。</p>\n<pre><code class=\"language-xml\">&lt;mip-carousel autoplay defer=&quot;3000&quot; layout=&quot;responsive&quot; width=&quot;600&quot; height=&quot;400&quot;&gt;\n    &lt;mip-img src=&quot;images/lb02.png&quot;&gt; &lt;/mip-img&gt;\n    &lt;mip-img src=&quot;images/lb03.png&quot;&gt; &lt;/mip-img&gt;\n    &lt;mip-img src=&quot;images/lb04.png&quot;&gt;&lt;/mip-img&gt;\n    &lt;mip-img src=&quot;images/lb07.png&quot;&gt;&lt;/mip-img&gt;\n&lt;/mip-carousel&gt;</code></pre>\n<p>虽然MIP改造对收录很有好处，但目前zuo11.com想要完全符合MIP规范基本不可能，主要有一下几个问题:</p>\n<ol>\n<li><p><code>script</code>只支持百度mip和json相关script，其它的一律不能用，移动端多说的评论插件直接就扑街了，要解决这个问题，只有自己写相关评论系统。或者关闭移动端的评论功能。</p>\n</li>\n<li><p><code>a</code>链接的target问题，target目前必须指定为_blank，iPhone下打开内部链接的那个效果差的很，不过据说以后的版本会改。</p>\n</li>\n<li><p>非head内<code>style</code>的乱用问题，其实代码上面可以将style都写在一起，但是UEditor编辑出来的笔记，随便加个颜色就会产生这种带style的不规范代码，还有img还要转为mip-img。那样就极大限制了UEditor编辑的丰富性。</p>\n</li>\n</ol>\n<p>MIP相关链接:</p>\n<p>MIP官网: <a href=\"https://www.mipengine.org\">https://www.mipengine.org</a></p>\n<p>MIP校验工具: <a href=\"https://www.mipengine.org/validator/validate\">https://www.mipengine.org/validator/validate</a></p>\n<h2 id=\"pc端改动\">PC端改动</h2>\n<ol>\n<li>将顶部的导航改成了一个整体，增加了favicon相关图片，修改了友链的样式。找了几张漂亮的背景图片，本来打算用来做背景图片的，但网站测速直接过5秒，压缩什么的也降不到3秒以下，最后就没用了。写了个比较low的js来手动控制图片的切换。这里有个缺点，重新刷新网页或进入新的页面，效果就没了。怎么设置全局的css是个问题，以后会想办法解决。</li>\n</ol>\n<p><img src=\"../../../images/blog/web/web_mip_2.png\" alt=\"web_mip_2.png\"></p>\n<pre><code class=\"language-css\">/* 背景图片切换*/\nvar mark = 0;\nfunction my_try() {\n  if (mark == 0) {\n    $(&quot;body&quot;).css(&quot;background&quot;,&quot;url(images/good4.jpg) fixed no-repeat 0 0&quot;);\n    mark++;\n  } else if (mark == 1){\n    $(&quot;body&quot;).css(&quot;background&quot;,&quot;url(images/good3.jpg) fixed no-repeat 0 0&quot;);\n    mark++;\n  } else if (mark == 2){\n    $(&quot;body&quot;).css(&quot;background&quot;,&quot;url(images/good2.jpg) fixed no-repeat 0 0&quot;);\n    mark++;\n  } else if (mark == 3){\n    $(&quot;body&quot;).css(&quot;background&quot;,&quot;url(images/good.jpg) fixed no-repeat 0 0&quot;);\n    mark = 0;\n  }\n  $(&quot;body&quot;).css(&quot;background-size&quot;,&quot;cover&quot;);\n}</code></pre>\n<ol start=\"2\">\n<li><p>之前jquery用的是本地的jquery.min.js，有80k左右。就算Tomcat开启了gzip，但这个文件基本没怎么变，之后在网上找了个相关的cdn资源，加载速度快且大小只有30k左右。刚才忘记改后台的jquery.min.js导入了，这篇文章本来早写完了，但保存的时候，什么内容都没存入，害的现在又重新手打一遍。</p>\n</li>\n<li><p>代码高亮的问题，最近才知道UEditor内部就集成了第三方插件SyntaxHighlighter，但是当超出width时，没有scroll的效果，特别是移动端那个效果惨不忍睹，还有页面向上翻时，代码块会挡住顶部的fix部分。还不如不载入相关高亮效果，自带的pre效果虽然没有高亮，基本没这些问题。其实也想换个富文本编辑器，但UEditor用了这么久，短时间内找个比这个好用的基本不可能，只能凑合用了。</p>\n</li>\n<li><p>关于文章质量的问题，最近无意间看到了张戈的博客，文章质量排版真心赞，相比自己以前写的渣渣文章，惭愧的很，我以前觉得博客是为自己服务的，但想要有流量想要做好，必须要用心去写好每一篇文章。以后我会用心的去写内容。尽自己最大的努力去经营好这个博客。</p>\n</li>\n</ol>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "mip改造",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "移动端改动"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "PC端改动"
            }
          ]
        }
      ],
      "config": {
        "source": "mip改造.md",
        "staticFileName": "web_mip.html",
        "author": "guoqzuo",
        "createDate": "2016/12/28",
        "description": "最近对网站进行了改版，移动端为了对搜索引擎更友好，用MIP改造了移动端，还有很多问题待完善。PC端也小改了下，本来找了个很好的背景图片，但由于文件大了，影响加载速度。还是放弃了，就加了个magnet图片，写了个js来控制背景图片的切换。",
        "keywords": "zuo11.com站点优化记录,mip改造,百度mip,pc端改移动端,mip改造实例",
        "category": "网站建设与SEO",
        "year": "2016",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"微信小程序failed-to-load-resource-neterr_name_not_resolved\">微信小程序Failed to load resource: net::ERR_NAME_NOT_RESOLVED</h1>\n<p>mac版的微信小程序最开始的demo调试时无法运行，报错Failed to load resource:... 网上查了很多资料，是开了网络代理造成的，关掉就可以了，为了方便后来的人更快找到解决方法，就专门写了这篇记录。</p>\n<p><img src=\"../../../images/blog/web/web_mp_vpn_1.png\" alt=\"web_mp_vpn_1.png\"></p>\n<p>关掉代理，重新运行后就可以正常运行了。</p>\n<p><img src=\"../../../images/blog/web/web_mp_vpn_2.png\" alt=\"web_mp_vpn_2.png\"></p>\n<p>或者可以在微信小程序里面设置:  动作-设置-不使用任何代理</p>\n<p><img src=\"../../../images/blog/web/web_mp_vpn_3.png\" alt=\"web_mp_vpn_3.png\"></p>\n<p>参考资料:\n<a href=\"http://www.henkuai.com/forum.php?mod=viewthread&amp;tid=15371\">http://www.henkuai.com/forum.php?mod=viewthread&amp;tid=15371</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "微信小程序Failed to load resource: net::ERR_NAME_NOT_RESOLVED"
        }
      ],
      "config": {
        "source": "微信小程序Failed to load resource: net::ERR_NAME_NOT_RESOLVED.md",
        "staticFileName": "web_mp_vpn.html",
        "author": "guoqzuo",
        "createDate": "2017/01/09",
        "description": "mac版的微信小程序最开始的demo调试时无法运行，报错Failed to load resource:... 网上查了很多资料，是开了网络代理造成的，关掉就可以了，为了方便后来的人更快找到解决方法，就专门写了这篇记录。",
        "keywords": "Failed to load resource: net::ERR_NAME_NOT_RESOLVED,微信小程序Failed to load resource: net::ERR_NAME_NOT_RESOLVED",
        "category": "微信开发",
        "year": "2017",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"http转https\">http转https</h1>\n<blockquote>\n<p>在玩微信小程序的时候发现网络请求必须是https开头的，但我的数据都在我的web服务器上，只是简单的http，于是就在网上找ssl证书，发现居然有免费1年的SSL，还是阿里云的，果断申请使用。顺便将web的数据打包为json做了一个接口。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/web/web_https_1.png\" alt=\"web_https_1.png\"></p>\n<h2 id=\"阿里云ssl\">阿里云SSL:</h2>\n<p>阿里云一年免费DV SSL申请    </p>\n<p><img src=\"../../../images/blog/web/web_https_2.png\" alt=\"web_https_2.png\"></p>\n<h2 id=\"tomcat配置https\">Tomcat配置https</h2>\n<p>tomcat默认是8080的端口，由于http访问时默认是80端口，就将tomcat配置为了80端口。需要知道的是https在访问的时候默认访问443端口，需要进行相关设置，阿里云有相关教程，但有些细节不一样,我的配置如下:</p>\n<p>tomcat目录下conf/server.xml   <code>service</code> tag下添加如下配置:</p>\n<p><img src=\"../../../images/blog/web/web_https_3.png\" alt=\"web_https_3.png\"></p>\n<p>这样设置后重启tomcat，不出什么意外，https就可以访问了。这里虽然可以访问https了，但默认访问的还是http，如果想要访问http自动跳转到https需要做如下处理：</p>\n<ol>\n<li>80端口redirctPort设置为443</li>\n</ol>\n<p><img src=\"../../../images/blog/web/web_https_4.png\" alt=\"web_https_4.png\"></p>\n<ol start=\"2\">\n<li>在conf/web.xml下加上如下代码, 这样访问<a href=\"http://zuo11.com\">http://zuo11.com</a> 会自动跳转到<a href=\"https://zuo11.com\">https://zuo11.com</a></li>\n</ol>\n<p><img src=\"../../../images/blog/web/web_https_5.png\" alt=\"web_https_5.png\"></p>\n<p>参考:</p>\n<p><a href=\"https://yundun.console.aliyun.com/?spm=5176.2020520163.1002.d10cas.UB7mOZ&amp;p=cas#/cas/download/213995662290985\">阿里云SSL下载，配置说明文档</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\">SSL/TLS协议运行机制的概述</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "http转https",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "阿里云SSL:"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Tomcat配置https"
            }
          ]
        }
      ],
      "config": {
        "source": "http转https.md",
        "staticFileName": "web_https.html",
        "author": "guoqzuo",
        "createDate": "2017/01/10",
        "description": "在玩微信小程序的时候发现网络请求必须是https开头的，但我的数据都在我的web服务器上，只是简单的http，于是就在网上找ssl证书，发现居然有免费1年的SSL，还是阿里云的，果断申请使用。顺便将web的数据打包为json做了一个接口。",
        "keywords": "免费SSL,阿里云DV SSL使用实例,http转https,80端口转443端口,tomcat配置https",
        "category": "http与https",
        "year": "2017",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"seo内容建设\">seo内容建设</h1>\n<blockquote>\n<p>我身边的很多朋友都曾抱怨过百度搜索的内容太杂，没有google搜索的内容质量高。之前感觉没什么，但有了这个站点后，写的内容也会提交给百度。当在百度搜索时，呈现的内容可能就是自己的笔记。如果我都没有用心去记录好内容，那还有什么理由去抱怨搜索引擎。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/web/web_content_1.png\" alt=\"web_content_1.png\"></p>\n<h2 id=\"初衷\">初衷</h2>\n<p>看了百度站长学院的内容建设，才意识到之前自认为不错的博文在搜索引擎面前就是垃圾。没有排版，没有插图，思路混乱等。之前创建这个站点的初衷是用来记录学到的东西，方便日后查看，所以没有考虑太多，只要自己看的懂就行。现在发现自己学到了知识没什么，可贵的是将学到的知识和经验与需要的人分享......我得把笔记记录的更加清晰，希望能帮助更多的后来者，避过我之前走过的坑。虽然自身的水平有限，写的笔记可能有错误，但我会用心去做到最好。好吧，上面的原因都是其次，最主要的原因是为了做知识积累以及提高百度对站点的评价，如果蜘蛛在抓取的时候都觉得站点垃圾，那对seo来说，百害而无一利。为了收录、权重、流量，必须将内容做好。</p>\n<p><img src=\"../../../images/blog/web/web_content_2.png\" alt=\"web_content_2.png\"></p>\n<h2 id=\"修改记录\">修改记录</h2>\n<ol>\n<li>图片大小与压缩，之前主页轮播图片本来截图非常清晰，但在显示的时候由于大小限制，图片有缩放，很模糊，看起来很low，修图还是很重要的。最近才通过Chrome浏览器F12来查看各个模块的大小布局，发现笔记显示的宽度为788px，之后笔记里的图尽量截为788的宽度，如果不够，就设置图片居中，一般不会超过788，以保证图片的清晰度。偶尔可以借助Keynote来画图。图片处理好之后最好进行无损压缩，以加快网页加载速度，之前的ImageAlpha是用来压缩png图像的，后来找了jpg压缩软件JPEGmini，挺好用的。</li>\n</ol>\n<p><img src=\"../../../images/blog/web/web_content_3.png\" alt=\"web_content_3.png\"></p>\n<ol start=\"2\">\n<li>网站图标 favicon.ico，在easyicon.net上找了个字母Z的图片，用的是64*64的，放在了网站的根目录。具体设置可参考张戈的博客: <a href=\"https://zhangge.net/4344.html\">关于网站图标favicon那些事儿</a></li>\n</ol>\n<p><img src=\"../../../images/blog/web/web_content.ico\" alt=\"web_content.ico\"></p>\n<ol start=\"3\">\n<li>修改了图片轮播div大小，切换方式，以前每次想想到轮播都会去无脑搜插件。现在觉得没什么就自己写了个简单的图片轮播，不过是手动切换的，代替了原先的大图，看起来效果还行。详情见我主页的轮播效果，代码可以直接查看主页源码。</li>\n</ol>\n<p><img src=\"../../../images/blog/web/web_content_4.png\" alt=\"web_content_4.png\"></p>\n<ol start=\"4\">\n<li>h1、h2等标签处理，在网上查了查，发现网页的标题最好是h1，一个页面只用一个h1，可以有多个h2。由于各个浏览器可能对h1渲染的方式不一样，首先都要对这些标签初始化，再同一设置大小，具体设置参见: <a href=\"http://www.divcss5.com/html/h328.shtml\">HTML之h1 h2 h3 h4标签知识经验篇</a></li>\n</ol>\n<h2 id=\"以后\">以后</h2>\n<p>之后在写内容时，会先列个简单的提纲，再填充内容，这样逻辑会稍微严谨点。通过最近对站点的修改优化，无意中发现了macOS的一些新功能，非常好用。于是总结了macbook的几个优点。1. 系统有自带的做笔记的工具都很方便；2. 自带数码测色剂应用，看到什么颜色，取一下就知道RGB数据了；3. Keynote画图很好使，界面优美；4. 截图功能非常好使，本站的截图大部分都是shift+command+4截的; 4.QuickTime 有自带的屏幕录制工具，可全屏或选择区域，生成的mov格式视频，可直接修改后缀为mp4，在web里用h5 的video标签就可以显示到网页上；5. 图片预览，选中图片，按空格键可预览。6. 基于unix系统，关于terminal下的开发模拟，再也不用依赖Ubuntu了；7. app资源丰富好用；8. 一般不关机，用完直接盖住，要用再打开；9. 薄，携带方便。总之macbook办公还是非常不错的，千万别买来装windows了，macOS还是非常出色的。</p>\n<p>参考资料:</p>\n<p><a href=\"http://zhanzhang.baidu.com/college/courseinfo?id=152\">百度站长学院 - 内容建设</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "seo内容建设",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "初衷"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "修改记录"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "以后"
            }
          ]
        }
      ],
      "config": {
        "source": "seo内容建设.md",
        "staticFileName": "web_content.html",
        "author": "guoqzuo",
        "createDate": "2017/01/17",
        "description": "我身边的很多朋友都曾抱怨过百度搜索的内容太杂，没有google搜索的内容质量高。之前感觉没什么，但有了这个站点后，写的内容也会提交给百度。当在百度搜索时，呈现的内容可能就是自己的笔记。如果我都没有用心去记录好内容，那还有什么理由去抱怨搜索引擎。",
        "keywords": "zuo11.com优化记录,内容建设,网站内容质量提升经验",
        "category": "网站建设与SEO",
        "year": "2017",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"404及500跳转处理\">404及500跳转处理</h1>\n<blockquote>\n<p>这几天百度的收录慢慢开始上升，但收录的有些页面是改版之前的旧内容，要么删了要么URL变了，造成访问出现404或者500的情况。404的问题可以提交死链，但500的问题就头疼了，当时在写后台的时候没有处理笔记id找不到的情况，如果随便输入id就会出现空指针异常，返回500。网上查了下，发现一般seo都需要专门对这些进行处理，于是就小改了一下。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/web/web_404_1.png\" alt=\"web_404_1.png\"></p>\n<h2 id=\"webxml配置404或500跳转\">web.xml配置404或500跳转</h2>\n<p>在web.xml设置error-page可以对404及500重定向到指定的页面，于是就弄了个链接/miss。</p>\n<pre><code class=\"language-xml\">&lt;web-app&gt;\n  &lt;error-page&gt;\n      &lt;error-code&gt;404&lt;/error-code&gt;\n      &lt;location&gt;/miss&lt;/location&gt;\n  &lt;/error-page&gt;\n  &lt;error-page&gt;\n      &lt;error-code&gt;500&lt;/error-code&gt;\n      &lt;location&gt;/miss&lt;/location&gt;\n  &lt;/error-page&gt;\n&lt;/web-app&gt;\n\n&lt;servlet&gt;\n  &lt;servlet-name&gt;Miss&lt;/servlet-name&gt;\n  &lt;servlet-class&gt;com.kevin.zblog.Tools.Miss&lt;/servlet-class&gt;\n&lt;/servlet&gt;\n&lt;servlet-mapping&gt;\n  &lt;servlet-name&gt;Miss&lt;/servlet-name&gt;\n  &lt;url-pattern&gt;/miss&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;</code></pre>\n<h2 id=\"跳转页面制作\">跳转页面制作</h2>\n<p>miss链接和笔记用的链接基本一样，一个页面处理的事情多了，比较混乱。于是就单独做了个页面来处理，这个页面更像是一篇特殊的笔记。笔记部分细节代码:</p>\n<pre><code class=\"language-html\">&lt;div class=&quot;note&quot;&gt;\n    &lt;h4&gt; &lt;font color=&quot;#ff7f00&quot;&gt;你可能访问了一个假网页&lt;/font&gt; &lt;/h4&gt;\n    &lt;%\n        java.text.SimpleDateFormat formatter = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);\n        java.util.Date currentTime = new java.util.Date(); //得到当前系统时间 \n    String str_date1 = formatter.format(currentTime);\n    %&gt;\n    Miss / &lt;%=str_date1 %&gt;\n    &lt;hr&gt;\n    &lt;p&gt;\n        访问页面不存在(404)或发生内部错误(500)，处理细节请参见: \n        &lt;a href=&quot;http://zuo11.com/Notes.woe?action=detail&amp;note_id=65&quot; title=&quot;404或500的跳转处理&quot;&gt;站点优化记录7 - 404及500的跳转处理&lt;/a&gt; \n    &lt;/p&gt;\n    &lt;p&gt;&lt;img src=&quot;images/miss.png&quot; width=&quot;3200&quot; height=&quot;280&quot; alt=&quot;你可能访问了一个假网页&quot;/&gt;&lt;/p&gt;\n    &lt;br&gt;\n    &lt;!-- 多说评论框 Start --&gt;\n    &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;miss&quot; data-title=&quot;你可能访问了一个假网页&quot; data-url=&quot;zuo11.com/miss&quot;&gt;&lt;/div&gt;\n    &lt;!-- 多说评论框 end --&gt;\n&lt;/div&gt;</code></pre>\n<p>显示效果: </p>\n<p><img src=\"../../../images/blog/web/web_404_2.png\" alt=\"web_404_2.png\"></p>\n<h2 id=\"总结\">总结</h2>\n<p>在pc端和移动端的的处理中，发现之前前端写的都很乱，能实现就行了。移动端mip改的也还不够彻底，不怎么满意，特别是a的_blank太影响用户体验了，还是得换成mip-link。有时间得改改，无意中发现技术好像比以前有了一定的进步，对页面的结构和布局更熟悉了。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "404及500跳转处理",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "web.xml配置404或500跳转"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "跳转页面制作"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "总结"
            }
          ]
        }
      ],
      "config": {
        "source": "404及500跳转处理.md",
        "staticFileName": "web_404.html",
        "author": "guoqzuo",
        "createDate": "2017/01/24",
        "description": "这几天百度的收录慢慢开始上升，但收录的有些页面是改版之前的旧内容，要么删了要么URL变了，造成访问出现404或者500的情况。404的问题可以提交死链，但500的问题就头疼了，当时在写后台的时候没有处理笔记id找不到的情况，如果随便输入id就会出现空指针异常，返回500。网上查了下，发现一般seo都需要专门对这些进行处理，于是就小改了一下。",
        "keywords": "404跳转,网站404跳转处,web 404跳转处理,web 500跳转处理,web.xml配置404和500的跳转",
        "category": "网站建设与SEO",
        "year": "2017",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios页面之间传值---segue、通知、代理\">iOS页面之间传值 - Segue、通知、代理</h1>\n<blockquote>\n<p>之前做通讯录的时候用的是navigation以代码的方式push跳转，tableView的传值只是用了控制器.h文件的一个变量。这里用拖线的方式跳转，通过添加和修改联系人练习segue、通知及代理传值。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/web/ios_pass_value_1.png\" alt=\"ios_pass_value_1.png\"></p>\n<h2 id=\"界面拖拽\">界面拖拽</h2>\n<p>打开storyboard，删除系统给的viewController，拖拽一个Navigation Controller。将导航控制器设置为Initial View Controller。在talbeView里设置里设置导航标题，拖拽一个UIBarButtonItem做添加按钮。拖拽两个viewController用来做修改和新增联系人界面。再分别选中添加按钮，tableView cell按controller键拖拽对应添加联系人控制器view，修改联系人控制器view，选择show。根据代码来看，show也是向导航栈添加了子控制器。新建3个类ContactsViewController、AddViewController、EditViewController分别对应tableView控制器，添加界面，修改界面。这里两个viewController视图里点击修改导航条的内容是不行的，需要在对应控制器view的属性里设置title。</p>\n<h2 id=\"tableview数据相关\">TableView数据相关</h2>\n<ol>\n<li>数据方面，由于只是练习页面之间传值，所以直接用一个模型数组，不做数据持久化。用了一个Contact类</li>\n</ol>\n<p><img src=\"../../../images/blog/web/ios_pass_value_2.png\" alt=\"ios_pass_value_2.png\"></p>\n<p><img src=\"../../../images/blog/web/ios_pass_value_3.png\" alt=\"ios_pass_value_3.png\"></p>\n<ol start=\"2\">\n<li>数据源</li>\n</ol>\n<p><img src=\"../../../images/blog/web/ios_pass_value_4.png\" alt=\"ios_pass_value_4.png\"></p>\n<h2 id=\"新增联系人传值---逆传\">新增联系人传值 - 逆传</h2>\n<h3 id=\"用通知notification传值\">用通知Notification传值</h3>\n<p>如果上面的UI拖拽没有问题，那点击添加会跳转到添加界面，输入姓名和电话点击添加，我们就用这个添加动作函数来处理传值。关于通知传值还可参考：<a href=\"http://blog.sina.com.cn/s/blog_6317728d0102v779.html\">iOS通知传值的使用</a></p>\n<p><img src=\"../../../images/blog/web/ios_pass_value_5.png\" alt=\"ios_pass_value_5.png\"></p>\n<ul>\n<li>通讯录界面监听通知，及处理</li>\n</ul>\n<p><img src=\"../../../images/blog/web/ios_pass_value_6.png\" alt=\"ios_pass_value_6.png\"></p>\n<ul>\n<li>注销通知，为什么要注销，详情可参考: <a href=\"http://www.cocoachina.com/ios/20151214/14596.html\">尽量不要在viewWillDisappear方法中移除通知</a></li>\n</ul>\n<p><img src=\"../../../images/blog/web/ios_pass_value_7.png\" alt=\"ios_pass_value_7.png\"></p>\n<h3 id=\"用代理传值\">用代理传值</h3>\n<p>在AddViewController里添加一个代理属性delegate，遵守协议AddViewControllerDelegate，在sugue跳转或pop跳转到下一个页面时，设置AddViewController的delegate为self，实现对应的方法用来处理数据。关于传值可以参见: <a href=\"http://www.jianshu.com/p/b5c5a8199b9b\">iOS界面传值总结 - 简书</a></p>\n<ol>\n<li>先新建一个协议，弄一个遵守该协议的delegate属性，到时将delegate设置为tableView控制器</li>\n</ol>\n<p><img src=\"../../../images/blog/web/ios_pass_value_8.png\" alt=\"ios_pass_value_8.png\"></p>\n<ol start=\"2\">\n<li>在添加按钮按下处理函数， 通知通讯录tableView控制器接收数据</li>\n</ol>\n<p><img src=\"../../../images/blog/web/ios_pass_value_9.png\" alt=\"ios_pass_value_9.png\"></p>\n<ol start=\"3\">\n<li>tableView遵守协议，segue里设置代理，处理值</li>\n</ol>\n<p><img src=\"../../../images/blog/web/ios_pass_value_10.png\" alt=\"ios_pass_value_10.png\"></p>\n<p><img src=\"../../../images/blog/web/ios_pass_value_11.png\" alt=\"ios_pass_value_11.png\"></p>\n<p><img src=\"../../../images/blog/web/ios_pass_value_12.png\" alt=\"ios_pass_value_12.png\"></p>\n<h2 id=\"修改联系人传值---顺传\">修改联系人传值 - 顺传</h2>\n<p>点击tableView的cell时跳转到修改页面，需要将数据对象传到下一个页面。由于segue跳转之前会执行函数-(void) prepareForSegue:(UIStoryboardSegue *)segue sender:(id) sender，这里可以用segue获取目的控制器view对象。我们在目的控制器view的.h文件里声明一个模型对象。在此时对这个模型对象赋值就可以了，修改完成后都不用再逆传回去了，用的都是数据源里的那个对象，需要注意的只是修改按钮完成赋值后，需通知tableView刷新数据。这里要发送一个通知，到时监听收到此通知后，[self.tableView reloadData]就可以了。</p>\n<h3 id=\"准备跳转前的传值\">准备跳转前的传值</h3>\n<p><img src=\"../../../images/blog/web/ios_pass_value_13.png\" alt=\"ios_pass_value_13.png\"></p>\n<h3 id=\"接收到值的处理\">接收到值的处理</h3>\n<p><img src=\"../../../images/blog/web/ios_pass_value_14.png\" alt=\"ios_pass_value_14.png\"></p>\n<h2 id=\"主要代码不含代理传值代码\">主要代码(不含代理传值代码)</h2>\n<p>ContactsViewController.m</p>\n<pre><code class=\"language-objectivec\">#import &quot;ContactsViewController.h&quot;\n#import &quot;Contact.h&quot;\n#import &quot;AddViewController.h&quot;\n#import &quot;EditViewController.h&quot;\n\n@interface ContactsViewController ()\n\n@property (strong, nonatomic)NSMutableArray* contactsArr; //通讯录数组\n\n@end\n\n@implementation ContactsViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 接收通知，修改联系人，提示刷新数据\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(updateTable) name:@&quot;updateTable&quot; object:nil];\n\n    // 接收通知, 添加联系人，用userInfo传回数据\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(addContact:) name:@&quot;addMessage&quot; object:nil];\n\n}\n\n// 接收到通知后的函数处理\n- (void)addContact:(NSNotification*) text\n{\n    Contact* temp = text.userInfo[@&quot;contact&quot;]; // 获取数据\n    if (!_contactsArr) {\n        _contactsArr = [[NSMutableArray alloc] init];\n    }\n    [self.contactsArr addObject:temp];\n    // NSLog(@&quot;%@,%@&quot;,temp.name,temp.cellPhone);\n    [self.tableView reloadData];\n}\n\n- (void)updateTable\n{\n    [self.tableView reloadData];\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n// 通讯录数组NSMutableArray* contactsArr; get方法\n- (NSMutableArray*)contantsArr\n{\n    if (!_contactsArr) {\n        _contactsArr = [[NSMutableArray alloc] init];\n    }\n    return _contactsArr;\n}\n\n#pragma mark - Table view data source\n\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return self.contactsArr.count;\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    static NSString* identifier = @&quot;cell&quot;;\n    UITableViewCell* cell = [tableView dequeueReusableCellWithIdentifier:identifier];\n    if (!cell) {\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:identifier];\n    }\n\n    Contact* c = self.contactsArr[indexPath.row];\n    cell.textLabel.text = c.name;\n    cell.detailTextLabel.text = c.cellPhone;\n    cell.imageView.image = [UIImage imageNamed:@&quot;火影&quot;];\n\n    return cell;\n}\n\n- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender\n{\n    NSString* distVc = NSStringFromClass([segue.destinationViewController class]);\n\n    // 由于有两个segue跳转，我们需要判断是跳转到哪一个界面\n    if ([distVc isEqualToString:@&quot;EditViewController&quot;]) { // 跳转到修改界面\n        EditViewController* editVc = segue.destinationViewController;\n        editVc.contact = _contactsArr[[self.tableView indexPathForSelectedRow].row];\n    } else { // 跳转到添加页面\n\n    }\n    // 修改返回按钮的文字\n    UIBarButtonItem* item = [[UIBarButtonItem alloc] init];\n    item.title = @&quot;返回&quot;;\n    self.navigationItem.backBarButtonItem = item;\n\n    NSLog(@&quot;%@&quot;, NSStringFromClass([segue.destinationViewController class]));\n}\n\n- (void)dealloc // 释放资源时，移除监听\n{\n    [[NSNotificationCenter defaultCenter] removeObserver:self]; //移除监听\n}\n\n@end</code></pre>\n<p>AddViewController.m</p>\n<pre><code class=\"language-objectivec\">#import &quot;AddViewController.h&quot;\n#import &quot;Contact.h&quot;\n\n@interface AddViewController ()\n\n@property (weak, nonatomic) IBOutlet UITextField *name; // 姓名\n@property (weak, nonatomic) IBOutlet UITextField *cellPhone; // 电话\n@property (strong, nonatomic)Contact* contact; // 传值用的对象\n\n@end\n\n@implementation AddViewController\n\n- (IBAction)addContact:(id)sender {\n    if([_name.text isEqualToString:@&quot;&quot;] || [_cellPhone.text isEqualToString:@&quot;&quot;]) {\n        UIAlertController* alertC = [UIAlertController alertControllerWithTitle:@&quot;添加失败&quot; message:@&quot;姓名或电话不能为空&quot;  preferredStyle:UIAlertControllerStyleActionSheet];\n        [alertC addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction* action){\n\n        }]];\n        [self presentViewController:alertC animated:YES completion:nil];\n    } else { // 两个框都有值，将添加的数据发送给上一个页面, 并返回上一个页面，刷新数据\n\n        // 准备数据\n        _contact = [Contact contactWithName:_name.text AndCellPhone:_cellPhone.text];\n        // userInfo需要用字典类型\n        NSDictionary* dict = [NSDictionary dictionaryWithObjectsAndKeys:_contact,@&quot;contact&quot;, nil];\n        // 创建通知\n        NSNotification* addMessage = [NSNotification notificationWithName:@&quot;addMessage&quot; object:nil userInfo:dict];\n        // 发送通知\n        [[NSNotificationCenter defaultCenter] postNotification:addMessage];\n        // 返回上一级页面\n        [self.navigationController popViewControllerAnimated:YES];\n    }\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n    NSLog(@&quot;%@&quot;, self.navigationController.childViewControllers);\n}\n\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n\n@end</code></pre>\n<p>EditViewController.m</p>\n<pre><code class=\"language-objectivec\">#import &quot;EditViewController.h&quot;\n#import &quot;Contact.h&quot;\n\n@interface EditViewController ()\n\n@property (weak, nonatomic) IBOutlet UITextField *name;\n@property (weak, nonatomic) IBOutlet UITextField *cellPhone;\n\n@end\n\n@implementation EditViewController\n\n// 修改按钮点击时，这里就不考虑空值的问题了\n- (IBAction)editContact:(id)sender {\n    _contact.name = _name.text;\n    _contact.cellPhone = _cellPhone.text;\n\n    [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;updateTable&quot; object:nil];\n\n    [self.navigationController popViewControllerAnimated:YES];\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // 设置默认数据\n    _name.text = _contact.name;\n    _cellPhone.text = _contact.cellPhone;\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n@end</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS页面之间传值 - Segue、通知、代理",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "界面拖拽"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "TableView数据相关"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "新增联系人传值 - 逆传",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "用通知Notification传值"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "用代理传值"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "修改联系人传值 - 顺传",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "准备跳转前的传值"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "接收到值的处理"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "主要代码(不含代理传值代码)"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS页面之间传值 - Segue、通知、代理.md",
        "staticFileName": "web_pass_data.html",
        "author": "guoqzuo",
        "createDate": "2017/01/26",
        "description": "之前做通讯录的时候用的是navigation以代码的方式push跳转，tableView的传值只是用了控制器.h文件的一个变量。这里用拖线的方式跳转，通过添加和修改联系人练习segue、通知及代理传值。",
        "keywords": "页面之间传值 iOS,iOS页面之间传值,iOS用通知传值,Segue传值,iOS代理传值",
        "category": "iOS",
        "year": "2017",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios通讯录小列子\">iOS通讯录小列子</h1>\n<blockquote>\n<p>小马哥视频里讲的通讯录小例子登录界面用了动画，用的是storyboard拖线跳转，顺便讲了segue，页面传值及发送通知。这里简单的实现通讯录的基本功能，动画就不做了，主要练习页面的跳转以及tableView相关使用，只是了解基本的使用，可以根据实际情况进行优化。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_address_list_1.png\" alt=\"ios_address_list_1.png\"></p>\n<h2 id=\"登录界面\">登录界面</h2>\n<ol>\n<li>从storyboard启动，拖拽一个导航控制器，将子控制器设置为默认给的View Controller，对应类ViewController，拖拽用户名密码控件什么的就不说了。</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_address_list_2.png\" alt=\"ios_address_list_2.png\"></p>\n<ol start=\"2\">\n<li>界面OK后，来看看逻辑：密码的输入框要有遮挡；两个输入框当输入文本的时右边出现删除按钮；登录按键先不让点击，等两个文本框有问题了才能点；登录时判断用户名或密码是否正确，错误弹一个alert框，正确跳转到TableView界面，也就是通讯录的主界面。</li>\n</ol>\n<p>首先我们需要将两个输入框和登录按钮拖拽到ViewController，分别对应的变量。从storyboard上拖拽下来的控件都不用再new，再进行上面的一些设置。</p>\n<p><img src=\"../../../images/blog/ios/ios_address_list_3.png\" alt=\"ios_address_list_3.png\"></p>\n<p>登录判断跳转，这里只是模拟，假设账号和密码都为a才能登录成功否则弹窗登录失败，这里会用到UIAlertController(UIActionSheet+UIAlertView后面通讯录页面的注销时有对比)。成功后跳转到通讯录tableview界面，在创建UITableViewController的子类ContactViewController时，勾选xib，用的时候直接alloc] init]就可以。再push该控制器到导航栈。</p>\n<p><img src=\"../../../images/blog/ios/ios_address_list_4.png\" alt=\"ios_address_list_4.png\"></p>\n<h2 id=\"通讯录界面\">通讯录界面</h2>\n<ol>\n<li>前面提到过ContactViewController，这个页面用xib来描述，不做任何拖拽。数据加载以及导航条的标题、左右按钮都用代码来实现。</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_address_list_5.png\" alt=\"ios_address_list_5.png\"></p>\n<ol start=\"2\">\n<li>导航条设置，在viewDidLoad里设置导航条内容，设置注销弹窗，注销时导航栈pop一次，返回登录页面，添加联系人的函数addContact后面会介绍。</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_address_list_6.png\" alt=\"ios_address_list_6.png\"></p>\n<p>关于弹窗，参见: <a href=\"http://www.itnose.net/detail/6235874.html\">iOS SDK详解之UIAlertController</a>，iOS8后代替AlertView和ActionSheet</p>\n<p><img src=\"../../../images/blog/ios/ios_address_list_7.png\" alt=\"ios_address_list_7.png\"></p>\n<p><img src=\"../../../images/blog/ios/ios_address_list_8.png\" alt=\"ios_address_list_8.png\"></p>\n<ol start=\"3\">\n<li>通讯录数据加载，这里用了一个数据模型，用了kvc</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_address_list_9.png\" alt=\"ios_address_list_9.png\"></p>\n<p><img src=\"../../../images/blog/ios/ios_address_list_10.png\" alt=\"ios_address_list_10.png\"></p>\n<p>数据载入，这里数据是存在沙盒的Library/Caches文件夹的data.plist里，以字典数组的形式存放。从文件中读入到数组arr，再将这个数组的元素逐一转化为模型，存入新的数组contactsArr，这些操作都在contactArr的get方法里进行。在tableView的数据源方法使用contactsArr时会执行。</p>\n<p><img src=\"../../../images/blog/ios/ios_address_list_11.png\" alt=\"ios_address_list_11.png\"></p>\n<ol start=\"4\">\n<li>tableView细节处理, 添加左滑删除功能，与点击后跳转到编辑界面。关于tableView的基本操作可参见：<a href=\"http://www.jianshu.com/p/bf6a60151dde\">tableview 添加左滑删除</a>，<a href=\"http://www.jianshu.com/p/284fd7d8c9e9\">iOS -- UITableView基本使用</a></li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_address_list_12.png\" alt=\"ios_address_list_12.png\"></p>\n<p>这里还有需要处理的是删除数据之后数据的重新写入文件，及当添加或修改联系人重新回到该界面时的数据刷新，其实可以用通知来实现。这里直接用了两个控制器的生命周期函数来处理。</p>\n<p><img src=\"../../../images/blog/ios/ios_address_list_13.png\" alt=\"ios_address_list_13.png\"></p>\n<h2 id=\"添加或修改内容\">添加或修改内容</h2>\n<ol>\n<li>添加联系人和修改联系人都是由xib加载。</li>\n</ol>\n<pre><code class=\"language-objectivec\">- (void)addContact\n{\n    AddViewController* addView = [[AddViewController alloc] init];\n    [self.navigationController pushViewController:addView animated:YES];\n}</code></pre>\n<ol start=\"2\">\n<li>add添加数据，从文件首次读入数据是在arr的get方法里。</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_address_list_14.png\" alt=\"ios_address_list_14.png\"></p>\n<ol start=\"3\">\n<li>修改数据，和上面一样，添加或修改完成后返回上一个界面。其实可以发个通知将添加或修改的数据发送给tableView界面，这里就不用读写文件了。</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_address_list_15.png\" alt=\"ios_address_list_15.png\"></p>\n<h2 id=\"主要代码\">主要代码</h2>\n<p>ContactViewController.m</p>\n<pre><code class=\"language-objectivec\">#import &quot;ContactViewController.h&quot;\n#import &quot;AddViewController.h&quot;\n#import &quot;Contact.h&quot;\n#import &quot;EditViewController.h&quot;\n@interface ContactViewController () &lt;UIActionSheetDelegate&gt;\n\n@property (strong, nonatomic) NSMutableArray* arr;\n@property (strong, nonatomic) NSMutableArray* contactsArr;\n@end\n\n@implementation ContactViewController\n\n// 页面切换时数据存入文件\n- (void)viewWillDisappear:(BOOL)animated\n{\n   [_arr writeToFile:[NSString stringWithFormat:@&quot;%@/Library/Caches/data.plist&quot;,NSHomeDirectory()]  atomically:YES];\n}\n\n// 视图将要出现时，重新载入数据\n- (void)viewWillAppear:(BOOL)animated\n{\n    _arr = [NSMutableArray arrayWithContentsOfFile:[NSString stringWithFormat:@&quot;%@/Library/Caches/data.plist&quot;, NSHomeDirectory()]];\n    _contactsArr = [[NSMutableArray alloc] init];\n    for (NSDictionary* dict in _arr) {\n        id c = [Contact contactWithDict:dict];\n        [_contactsArr addObject:c];\n    }\n    NSLog(@&quot;%@&quot;,self.arr);\n    [self.tableView reloadData];\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // 左边按钮，注销\n    self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@&quot;注销&quot; style:UIBarButtonItemStyleDone target:self action:@selector(logout)];\n    // 右边按钮，添加\n    self.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@&quot;添加&quot; style:UIBarButtonItemStyleDone target:self action:@selector(addContact)];\n    // 标题，为了传值，在.h文件设置了一个NSString属性，跳转到该页面之前就设置了该值。\n    self.navigationItem.title = [NSString stringWithFormat:@&quot;%@的联系人&quot;, _user];\n\n}\n\n// 注销按钮 新旧弹窗方式\n- (void)logout\n{\n    // 弹出对话框，确定要退出吗?\n    UIAlertController* alert = [UIAlertController alertControllerWithTitle:@&quot;确定要注销吗?&quot; message:nil preferredStyle:UIAlertControllerStyleActionSheet];\n    [alert addAction:[UIAlertAction actionWithTitle:@&quot;注销&quot; style:UIAlertActionStyleDestructive handler:^(UIAlertAction* action){\n        [self.navigationController popViewControllerAnimated:YES];\n    }]];\n    [alert addAction:[UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:nil]];\n    [self presentViewController:alert animated:YES completion:nil];\n\n    //UIAlertView* alertView = [[UIAlertView alloc] initWithTitle:@&quot;确定要注销吗?&quot; message:nil delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:nil];\n\n    //    UIActionSheet* alert = [[UIActionSheet alloc] initWithTitle:@&quot;确定要注销吗&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; destructiveButtonTitle:@&quot;注销&quot; otherButtonTitles: nil];\n    // 显示弹窗视图\n    //    [alert showInView:self.view];\n}\n// 需遵守协议 &lt;UIActionSheetDelegate&gt;\n//- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex\n//{\n//    if (buttonIndex == 0) {\n//        [self.navigationController popViewControllerAnimated:YES];\n//    }\n//}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n- (void)addContact\n{\n    AddViewController* addView = [[AddViewController alloc] init];\n    [self.navigationController pushViewController:addView animated:YES];\n}\n\n// 数据  NSMutableArray* arr; 字典数组，NSMutableArray* contactsArr; Contact数组\n- (NSMutableArray*)contactsArr\n{\n    if (!_contactsArr) {\n        _arr = [NSMutableArray arrayWithContentsOfFile:[NSString stringWithFormat:@&quot;%@/Library/Caches/data.plist&quot;, NSHomeDirectory()]];\n        _contactsArr = [[NSMutableArray alloc] init];\n        for (NSDictionary* dict in _arr) {\n            id c =\n             [Contact contactWithDict:dict];\n            [_contactsArr addObject:c];\n        }\n    }\n    return _contactsArr;\n}\n\n#pragma mark - Tableview data source\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return self.contactsArr.count;\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    static NSString* ID = @&quot;cell&quot;;\n    UITableViewCell* cell = [tableView dequeueReusableCellWithIdentifier:ID];\n    if (!cell) {\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleValue1                                      reuseIdentifier:ID];\n    }\n    Contact* con = self.contactsArr[indexPath.row];\n    cell.textLabel.text = con.name;\n    cell.detailTextLabel.text = con.tel;\n\n    return cell;\n}\n\n// 左滑删除 - 添加编辑模式\n- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    return YES;\n}\n\n// 左滑删除 - 左滑动时出现的文字\n- (NSString*)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    return @&quot;删除&quot;;\n}\n\n// 左滑删除 - 删除动作\n- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    // 从数据源删除\n    [self.arr removeObjectAtIndex:indexPath.row];\n    [self.contactsArr removeObjectAtIndex:indexPath.row];\n    // 从列表中删除\n    [tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];\n}\n\n// 选中时进入编辑界面\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(nonnull NSIndexPath *)indexPath {\n    EditViewController* add = [[EditViewController alloc] init];\n    Contact* con = self.contactsArr[indexPath.row];\n    add.name_tmp = con.name;\n    add.tel_tmp = con.tel;\n    add.index = indexPath.row;\n    [self.navigationController pushViewController:add animated:YES];\n}\n\n@end\nAddViewController.m\n\n#import &quot;AddViewController.h&quot;\n#import &quot;Contact.h&quot;\n@interface AddViewController ()\n\n@property (weak, nonatomic) IBOutlet UITextField *name;\n@property (weak, nonatomic) IBOutlet UITextField *tel;\n@property (weak, nonatomic) IBOutlet UIButton *addBtn;\n@property (strong, nonatomic) NSMutableArray* arr;\n\n@end\n\n@implementation AddViewController\n\n- (IBAction)add:(id)sender {\n    NSMutableDictionary* dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:_name.text,@&quot;name&quot;,_tel.text,@&quot;tel&quot;,nil];\n    if (self.arr == nil) {\n        self.arr = [[NSMutableArray alloc] init];\n    }\n    [self.arr addObject:dict];\n    NSLog(@&quot;%@&quot;,self.arr);\n    [self.arr writeToFile:[NSString stringWithFormat:@&quot;%@/Library/Caches/data.plist&quot;,NSHomeDirectory()] atomically:YES];\n    [self.navigationController popViewControllerAnimated:YES];\n    NSLog(@&quot;%s&quot;, __func__);\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    _addBtn.enabled = NO;\n    [_name addTarget:self action:@selector(textChanged) forControlEvents:UIControlEventEditingChanged];\n    [_tel addTarget:self action:@selector(textChanged) forControlEvents:UIControlEventEditingChanged];\n    _name.clearButtonMode = UITextFieldViewModeWhileEditing;\n    _tel.clearButtonMode = UITextFieldViewModeWhileEditing;\n\n    self.navigationItem.title = @&quot;添加联系人&quot;;\n    self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@&quot;取消&quot; style:UIBarButtonItemStyleDone target:self action:@selector(back)];\n\n    // Do any additional setup after loading the view from its nib.\n}\n\n- (void)textChanged\n{\n    _addBtn.enabled = ![_name.text isEqualToString:@&quot;&quot;] &amp;&amp; ![_tel.text isEqualToString:@&quot;&quot;];\n}\n\n- (void)back\n{\n    [self.navigationController popViewControllerAnimated:YES];\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n\n- (NSMutableArray*)arr\n{\n    if (!_arr) {\n        _arr = [NSMutableArray arrayWithContentsOfFile:[NSString stringWithFormat:@&quot;%@/Library/Caches/data.plist&quot;, NSHomeDirectory()]];\n    }\n    return _arr;\n}\n\n@end\nEditViewController.m\n\n#import &quot;EditViewController.h&quot;\n\n@interface EditViewController ()\n\n@property (weak, nonatomic) IBOutlet UITextField *name;\n@property (weak, nonatomic) IBOutlet UITextField *tel;\n@property (weak, nonatomic) IBOutlet UIButton *editBtn;\n@property (strong, nonatomic)NSMutableArray* arr;\n\n@end\n\n@implementation EditViewController\n\n// 修改\n- (IBAction)edit:(id)sender {\n    if ([_name.text isEqualToString:@&quot;&quot;] || [_tel.text isEqualToString:@&quot;&quot;]) {\n        // 有空的。\n        UIAlertController* alertC = [UIAlertController alertControllerWithTitle:@&quot;联系人或电话不能为空&quot; message:nil preferredStyle:UIAlertControllerStyleAlert];\n//        [alertC addAction:[UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction* action){\n//        \n//        }]];\n        [alertC addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction* action){\n\n        }]];\n        [self presentViewController:alertC animated:YES completion:nil];\n    } else {  // 修改\n        // 拿到原始数据\n        _arr = [NSMutableArray arrayWithContentsOfFile:[NSString stringWithFormat:@&quot;%@/Library/Caches/data.plist&quot;, NSHomeDirectory()]];\n        NSDictionary* dict = _arr[_index];\n        // 修改\n        [dict setValue:_name.text forKey:@&quot;name&quot;];\n        [dict setValue:_tel.text forKey:@&quot;tel&quot;];\n        // 存入文件\n        [_arr writeToFile:[NSString stringWithFormat:@&quot;%@/Library/Caches/data.plist&quot;, NSHomeDirectory()] atomically:YES];\n\n        [self.navigationController popViewControllerAnimated:YES];\n    }\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    _editBtn.hidden = YES;\n    _name.text = _name_tmp;\n    _tel.text = _tel_tmp;\n    _name.clearButtonMode = UITextFieldViewModeWhileEditing;\n     _tel.clearButtonMode = UITextFieldViewModeWhileEditing;\n    _name.enabled = NO;\n    _tel.enabled = NO;\n    self.navigationItem.title = @&quot;联系人详情&quot;;\n    self.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@&quot;编辑&quot; style:UIBarButtonItemStyleDone target:self action:@selector(enableEdit)];\n    // Do any additional setup after loading the view from its nib.\n}\n\n- (void)enableEdit\n{\n    _name.enabled = YES;\n    _tel.enabled = YES;\n    _editBtn.hidden = NO;\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n@end</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS通讯录小列子",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "登录界面"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "通讯录界面"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "添加或修改内容"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "主要代码"
            }
          ]
        }
      ],
      "config": {
        "source": "iOS通讯录小列子.md",
        "staticFileName": "web_address_list.html",
        "author": "guoqzuo",
        "createDate": "2017/01/22",
        "description": "小马哥视频里讲的通讯录小例子登录界面用了动画，用的是storyboard拖线跳转，顺便讲了segue，页面传值及发送通知。这里简单的实现通讯录的基本功能，动画就不做了，主要练习页面的跳转以及tableView相关使用，只是了解基本的使用，可以根据实际情况进行优化。",
        "keywords": "UITableView的使用,通讯录小例子,UITableView左滑删除功能",
        "category": "iOS",
        "year": "2017",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"站点优化-新增访客记录、新ui及mip等\">站点优化 新增访客记录、新UI及mip等</h1>\n<blockquote>\n<p>认真去做内容建设后，百度收录和索引量有了明显的提升。把之前笔记修改完后，发现mip限制的_blank属性用户体验非常差，加上之前没有做访客记录功能。就打算再改改移动端，顺便新增访客记录功能。花了4天时间勉强改完了，把页面效果提升了一个level，mip页面也新增了4个。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/web/web_optimize_2_1.png\" alt=\"web_optimize_2_1.png\"></p>\n<h2 id=\"前端页面修改\">前端页面修改</h2>\n<p>和之前改版一样，从阿里云入口远程登录到服务器，将线上版本代码打包，通过FileZilla下载到本地，再导入Eclipse。在增加访问记录功能之前，又感觉前端可以再改改。现在文章也才40篇左右，想把所有的文章链接都放到主页，且显示文章的评论数，阅读量，时间等信息。页面的基调模仿了张戈博客，footer是模仿了开源中国。以前改前端就是改改css，再看效果，现在学会了用safari开发的里查看元素，对整个页面的布局掌控更加得心应手，将别人的页面搬到自己的页面更加轻松，颜色不知道的就用系统自带的取色剂，就是每次需要将十进制的RGB转换为十六进制。有一点很赞，就是bootstrap自带了一些padding效果，以前都不知道是怎么回事，现在只要查看元素就可以了。对于页面布局，看到什么效果就能能模仿出什么效果的感觉不错。不足的是js方面提升较慢，对于响应式布局研究的还少，还是通过微信小程序才了解到相关基本设置，有时间得研究研究。在改About界面时，支付的图片经过keynote处理后效果还不错。</p>\n<p><img src=\"../../../images/blog/web/web_optimize_2_2.png\" alt=\"web_optimize_2_2.png\"></p>\n<pre><code class=\"language-css\">/* 4s/5s 根据屏幕宽度设置对应css */\n@media screen and (max-width: 320px) { \n  swiper {height: 230px}\n} \n\n/* 6s/6plus */\n@media screen and (min-width: 375px) { \n  swiper {height: 276px}\n}</code></pre>\n<h2 id=\"新增访问记录表\">新增访问记录表</h2>\n<p>PC前端的页面修改好后，就是数据库访问记录表的规划了。访客每次访问的信息需要存入数据库，这样就可以知道文章的访问量了。也可以统计移动端和PC端各自的访问量，先在记事本里初步记录，再创建对应的数据表。</p>\n<p><img src=\"../../../images/blog/web/web_optimize_2_3.png\" alt=\"web_optimize_2_3.png\"></p>\n<p>这次创建数据表增加了预留列，因为之前笔记里面没有增加description和keywords属性后来添加时改来改去的比较麻烦，这次修改了文章加载方式，文章概要用的description，图片由于懒得再加属性了，直接用了title_e。规划时多加几个预留的还是很有必要的。数据表OK后就是对应的Dao了，将这个表抽象为一个类。增加数据库相关dao方法。包括查询最近100次访问记录、新增行、查询所有总访问数、查询pc访问数、移动端访问数等。</p>\n<p><img src=\"../../../images/blog/web/web_optimize_2_4.png\" alt=\"web_optimize_2_4.png\"></p>\n<h2 id=\"servlet获取访问信息\">servlet获取访问信息</h2>\n<p>将数据表与对应的Dao弄好后就要开始在servlet准备数据时记录访客信息了。这就需要获取访问的ip，归属地，UA信息，访问链接，是否为移动端访问了。之前写过一个servlet判断是否为移动端访问的类，这次将这些信息的获取都封装成了一个类方法，只需要传入request，就会返回一个Access对像，记录访问信息。具体方法我额外写了一篇文章来记录。详情参见: servlet获取访问信息</p>\n<p><img src=\"../../../images/blog/web/web_optimize_2_5.png\" alt=\"web_optimize_2_5.png\"></p>\n<p>这里还有一些细节处理，插入访问记录后，如果是访问具体的文章，会将该文章对应的access访问量+1，About界面及404、500的跳转界面访问次数的统计无法写入对应表。如果之前将这两个界面规划为文章，那就好办了。还可以少写两个界面，现在也懒得再改了。关于UA，发现了很多奇怪的UA，大部分是蜘蛛，如果单独读取该表的记录数，那访客数是不准的，需要过滤掉这些蜘蛛，那样访问量才是准确的。‍将最近的UA看了下，发现了好几种蜘蛛，如下图:</p>\n<p><img src=\"../../../images/blog/web/web_optimize_2_6.png\" alt=\"web_optimize_2_6.png\"></p>\n<h2 id=\"prism代码高亮\">prism代码高亮</h2>\n<p>以前的代码高亮用的是UEditor里自带的SyntaxHighlighter，效果差，超出界限，还不支持OC语言。弄得之前写的iOS笔记代码很多都是截的图。顺带提一提fix在顶部的导航条，代码框pre或图片网上翻时会挡住导航条，在header里加了个属性z-index:999就可以了。这次UI都改了，就打算彻底弄一下这个，网上找了下，发现只要包含一个css文件一个js文件就可以用固定的格式来显示高亮代码。它是用pre标签里面增加code标签，用新页面调试好没问题后就打算用到UEditor的pre里，但操蛋的问题来了，UEditor过滤了pre下的code标签，怎么都添加不进去。网上查了很多资料，就是找不到解决方案，最后在前端用字符串替换的方法解决了这个问题。代码高亮js、css下载、文档：Prism，这里发现英文文档也没什么，只要用心去解决问题，多动手尝试，问题就可以迎刃而解了。</p>\n<pre><code class=\"language-html\">/* 这里是jstl将UEditor编辑的html富文本进行字符串替换 */\n&lt;c:set var=&quot;string2&quot; value=&quot;${fn:replace(note.content_c,&#39;false&quot;&gt;&#39;,&#39;false&quot;&gt;&lt;code class=&quot;language-objectivec&quot;&gt;&#39;)}&quot; /&gt;\n${fn:replace(string2,&#39;&lt;/pre&gt;&#39;,&#39;&lt;/code&gt;&lt;/pre&gt;&#39;)}</code></pre>\n<h2 id=\"第二次mip改造\">第二次mip改造</h2>\n<p>趁着mip改造的契机，将移动端也美化了下。查了官方文档，发现a标签的_blank不再是强制的了，本来还打算用mip-link的，看来没这个必要了。百度mip的css对图片增加了自适应放大处理，有图片需要保持一定的大小的，可以用单独的css来固定。mip好像又改进了不少，图片轮播也增加了新功能。百度统计，只需要一句话，引入一个js就OK了。这次将移动端主页，关于界面，分类的4个界面都转为了标准的mip。</p>\n<p><img src=\"../../../images/blog/web/web_optimize_2_7.png\" alt=\"web_optimize_2_7.png\"></p>\n<p>由于不准自定义js，只允许内联css。UEditor的富文本很难符合这一点。再说我还想要代码高亮呢。只要解决代码高亮、UEditor编辑出的富文本转mip标准文本、多说评论插件这三个问题就可以实现移动端全站都符合mip规范，但现在而言基本不可能。我能想到的UEditor编辑出的html富文本转mip规范html的唯一方法就是字符串的替换，或许可以写个插件，但暂时没这精力。目前已经尽力去mip化了。还有一点是mip在校验的时候不知道是不是移动UA蜘蛛抓取，而我是根据UA来判断访问设备类型，给出对应的页面的。除了百度站长里手动移动UA抓取测试，就没看见移动UA主动抓取过，百度蜘蛛抓的都是pc版，不知道提交的mip页面能否生效。</p>\n<p><img src=\"../../../images/blog/web/web_optimize_2_8.png\" alt=\"web_optimize_2_8.png\"></p>\n<h2 id=\"总结\">总结</h2>\n<p>现在访问记录功能还比较满意，还需要弄得是多说评论数同步到本地数据库的操作，访问量过滤掉蜘蛛访问。不算很重要，以后有时间弄都行，这次本来可以将笔记详情的URL变短，但考虑到对百度收录的影响，还是算了。这4天下来，收获不错，经验确实需要点滴积累，前期规划还是很重要的!</p>\n<p><img src=\"../../../images/blog/web/web_optimize_2_9.png\" alt=\"web_optimize_2_9.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "站点优化 新增访客记录、新UI及mip等",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "前端页面修改"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "新增访问记录表"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "servlet获取访问信息"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "prism代码高亮"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "第二次mip改造"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "总结"
            }
          ]
        }
      ],
      "config": {
        "source": "站点优化 新增访客记录、新UI及mip等.md",
        "staticFileName": "web_optimize_2.html",
        "author": "guoqzuo",
        "createDate": "2017/02/01",
        "description": "认真去做内容建设后，百度收录和索引量有了明显的提升。把之前笔记修改完后，发现mip限制的_blank属性用户体验非常差，加上之前没有做访客记录功能。就打算再改改移动端，顺便新增访客记录功能。花了4天时间勉强改完了，把页面效果提升了一个level，mip页面也新增了4个。",
        "keywords": "站点优化,mip改造,Servlet获取访问信息,web新增访客记录功解决方法能,prism代码高亮使用,UEditor过滤code便签的解决方法",
        "category": "网站建设与SEO",
        "year": "2017",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"java-web获取访客信息ip归属地等\">java web获取访客信息(ip,归属地等)</h1>\n<blockquote>\n<p>之前写过一篇servlet判断是否为移动端访问的文章，是为了代码适配移动端或PC。这次需要记录访客信息。写了个类方法来获取访问者的ip、归属地、UA、访问URL以及是否为PC端访问。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/web/web_access_log_1.png\" alt=\"web_access_log_1.png\"></p>\n<h2 id=\"获取访客信息\">获取访客信息</h2>\n<p>这里用Access类来存放相关信息，调用时只需要传入request就可以了。通过ip来查归属地用的是新浪的接口，为了减少代码量没有用json数据，改为str，新浪的接口速度还行。本来打算抽取ua里的浏览器版本及操作系统的，但接触的UA信息少，怕截取的不准确，就直接抓取完整的ua信息了，事实证明这是不错的选择。有意外收货，谁用谁知道...</p>\n<pre><code class=\"language-java\">package com.kevin.zblog.Tools;\n\nimport javax.servlet.http.HttpServletRequest;\nimport com.kevin.zblog.Dao.Access;\nimport org.apache.commons.lang.StringUtils;\nimport java.util.Scanner;\nimport java.net.URL;\nimport java.io.IOException;\n\npublic class UserInfo {\n    /*\n        private String ip; // ip地址\n        private String locatioin; // ip地址地域\n        private String browser; // 浏览器 --&gt; ua\n         ---- private String os; // 操作系统 --&gt; ua\n        private String url; // 访问地址\n        private int isPc; // 是否是pc端访问\n        private int count; // 本次是该ip第几次访问\n        private int isForbid; // 是否禁止该ip访问 \n        private String time; // 访问时间\n    */\n    public Access getUserInfor(HttpServletRequest request) {\n        Access user = new Access();\n\n        /**\n         * Java获取用户访问IP     http://blog.csdn.net/mydwr/article/details/9357187\n         * 1.获取访问者IP, 在一般情况下使用Request.getRemoteAddr()即可，但是经过nginx等反向代理软件后，这个方法会失效。\n         * 本方法先从Header中获取X-Real-IP，如果不存在再从X-Forwarded-For获得第一个IP(用,分割)，如果还不存在则调用Request .getRemoteAddr()。\n         */\n        String ip = request.getHeader(&quot;X-Real-IP&quot;);\n        if (!StringUtils.isBlank(ip) &amp;&amp; !&quot;unknown&quot;.equalsIgnoreCase(ip)) {\n            user.setIp(ip);\n        } else {\n            ip = request.getHeader(&quot;X-Forwarded-For&quot;);\n            if (!StringUtils.isBlank(ip) &amp;&amp; !&quot;unknown&quot;.equalsIgnoreCase(ip)) {\n                // 多次反向代理后会有多个IP值，第一个为真实IP。\n                int index = ip.indexOf(&#39;,&#39;);\n                if (index != -1) {\n                    user.setIp(ip.substring(0, index));\n                } else {\n                    user.setIp(ip);\n                }\n            } else {\n                user.setIp(request.getRemoteAddr());\n            }\n        }\n\n        /**\n         * 2.获取ip归属地的文本信息,可以获取json的format\n         * 新浪ip接口 http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=str&amp;ip=\n         * ip = &quot;58.60.124.75&quot;; // 1-1-1中国广东深圳\n         * ip = &quot;192.168.0.1&quot;;  // -1192.168.0.1\n         * 0:0:0:0:0:0:0:1   // -3 \n         */\n        ip = user.getIp();\n        try { \n            Scanner scanner; \n            StringBuilder ipStr = new StringBuilder(&quot;&quot;);  \n            String url = &quot;http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=str&amp;ip=&quot; + ip;  \n            scanner = new Scanner(new URL(url).openConnection().getInputStream(), &quot;GBK&quot;);  \n            while (scanner.hasNext()) {  \n                ipStr.append(scanner.next());  \n            }  \n            scanner.close();\n            // 结果处理,如果IP头两位数为-1，就截取后面的ip   -1192.168.0.1，否则截取\n            String ret = ipStr.substring(0, 2);\n            if (ret.equals(&quot;-1&quot;)) { //后面会接IP，局域网内部\n                user.setLocatioin(&quot;本地局域网&quot;);\n            } else if (ret.equals(&quot;1-&quot;)) { // 正常情况下截取1-1-1之后的内容\n                user.setLocatioin(ipStr.substring(5));\n            } else { // 未知+错误代码\n                user.setLocatioin(&quot;未知&quot;+ret);\n            }\n            //System.out.println(ipStr);\n        } catch (IOException e) {\n            // System.out.println(&quot;获取失败!&quot;);\n            user.setLocatioin(&quot;获取失败&quot;); //请求失败\n        }\n\n        /**\n         * 3.获取UA信息存入browser,本来打算将浏览器版本和操作系统提取出来，还是算了，怎样简单就怎样弄\n         */\n        String ua = request.getHeader(&quot;User-Agent&quot;);\n        user.setBrowser(ua);\n\n        /**\n         * 4. 获取访问url  \n         * 参考: JSP中获取当前访问URL、URL参数等信息的小结。 https://my.oschina.net/MiniBu/blog/83340  +\n         * http://www.cnblogs.com/tianyuchen/p/6004073.html\n         */\n//        String path = request.getContextPath();\n//        String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path; \n//        String url = basePath + request.getServletPath().substring(0,request.getServletPath().lastIndexOf(&quot;/&quot;)+1);\n        String url = request.getRequestURI();\n        if(request.getQueryString()!=null) {   \n            url+=&quot;?&quot;+request.getQueryString();           \n        } \n        user.setUrl(url);\n\n        /** \n         * 5.判断是否为移动端访问 \n         */\n        if(this.checkAgentIsMobile(ua)) { // 如果是移动端访问\n            user.setIsPc(0);\n        } else {\n            user.setIsPc(1);\n        }\n\n        /**\n         * 当前访问时间就省略了，写入数据库开始，该字段自动生成\n         */\n\n        System.out.println(&quot;ip地址：&quot; + user.getIp());\n        System.out.println(&quot;ip归属地：&quot; + user.getLocation());\n        System.out.println(&quot;ua信息：&quot; + user.getBrowser());\n        System.out.println(&quot;访问地址：&quot; + user.getUrl());\n        System.out.println(&quot;是否为PC端访问：&quot; + user.getIsPc());\n\n        /*  \n          PC访问测试\n              ip地址：0:0:0:0:0:0:0:1\n              ip归属地：未知-3\n              ua信息：Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12\n              访问地址：http://localhost:8080/KBlog\n              是否为PC端访问：1\n\n           手机访问测试：\n              ip地址：192.168.0.101\n              ip归属地：本地局域网\n              ua信息：Mozilla/5.0 (iPhone; CPU iPhone OS 10_2 like Mac OS X) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0 Mobile/14C92 Safari/602.1\n              访问地址：http://192.168.0.100:8080/KBlog\n              是否为PC端访问：0\n        */\n        return user;\n    }\n\n    /* 判断是否为移动端访问 */\n    public  boolean checkAgentIsMobile(String ua) {\n        boolean flag = false;\n        if (!ua.contains(&quot;Windows NT&quot;) || (ua.contains(&quot;Windows NT&quot;) &amp;&amp; ua.contains(&quot;compatible; MSIE 9.0;&quot;))) {\n            // 排除 苹果桌面系统\n            if (!ua.contains(&quot;Windows NT&quot;) &amp;&amp; !ua.contains(&quot;Macintosh&quot;)) {\n                for (String item : agent) {\n                    if (ua.contains(item)) {\n                        flag = true;\n                        break;\n                    }\n                }\n            }\n        }\n        return flag;\n    }\n    private final static String[] agent = { &quot;Android&quot;, &quot;iPhone&quot;, &quot;iPod&quot;,&quot;iPad&quot;, &quot;Windows Phone&quot;, &quot;MQQBrowser&quot; };\n}</code></pre>\n<p><img src=\"../../../images/blog/web/web_access_log_2.png\" alt=\"web_access_log_2.png\"></p>\n<h2 id=\"本站中的应用\">本站中的应用</h2>\n<p>在servlet的请求中，新建UserInfo类，调用方法，就可以获取信息了</p>\n<pre><code class=\"language-java\">UserInfo info = new UserInfo();\nAccess user = info.getUserInfor(request);\n\n// 将本次访问记录写入表，先查询本次ip是第几次访问\nAccessDao accessDao = new AccessDao();\nint n = accessDao.findCoutnByIp(user.getIp()); // 查询该ip是第几次访问\nn = n + 1;\nuser.setCount(n);\n//System.out.println(&quot;本次是第&quot;+n+&quot;次访问&quot;);\naccessDao.addAccess(user); // 写入表\n\nString url = &quot;index.jsp&quot;;\nif (user.getIsPc() == 0) { // 判断是否为移动端\n    url = &quot;m_index.jsp&quot;;\n}\nrequest.getRequestDispatcher(url).forward(request, response);</code></pre>\n<h2 id=\"搜索引擎蜘蛛ua\">搜索引擎蜘蛛UA</h2>\n<p>开启了这个功能后，发现了google、百度、360的蜘蛛，有点小激动。从数据库检索的最近的一些UA信息</p>\n<pre><code class=\"language-bash\">谷歌蜘蛛User-Agent\n中国台湾 | Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\n中国台湾 | Mozilla/5.0 (Linux; Android 6.0.1; Nexus 5X Build/MMB29P) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.96 Mobile Safari/537.36 (compatible; Googlebot/2.1; + \n\n360蜘蛛\n中国河南郑州 | Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36 QIHU 360SE; 360Spider\n中国河南郑州 | Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0); 360Spider \n中国北京北京 | 360spider(http://webscan.360.cn) \n\n百度蜘蛛\n中国广东广州 | baidumib\n中国北京北京 | mip\n中国陕西西安 | Baidu-YunGuanCe-SLABot(ce.baidu.com) \n中国北京北京 | Baiduspider+(+http://www.baidu.com/search/spider.htm)\n中国北京北京 | Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)  \n中国北京北京 | Mozilla/5.0 (Linux;u;Android 4.2.2;zh-cn;) AppleWebKit/534.46 (KHTML,like Gecko) Version/5.1 Mobile Safari/10600.6.3 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html£© \n\n奇怪的UA\n中国香港 | Cpanel-HTTP-Client/1.0\n中国北京北京 | Python-urllib/2.6\n中国北京北京 | Jakarta Commons-HttpClient/3.1\n英国伦敦 | Mozilla/5.0 (compatible; XML Sitemaps Generator; https://www.xml-sitemaps.com) Gecko XML-Sitemaps/1.0 \n中国上海上海| Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;Alibaba.Security.Heimdall.5448812.elasticsearch_unauthorized)</code></pre>\n<h2 id=\"延伸\">延伸</h2>\n<p>这里在每次访问页面时都有去请求新浪的接口，可能会对访问速度有影响，比较合理的方法是用js来获取这些信息。页面都载入后，再执行js是个不错的选择，js获取访问信息的版本等有机会会研究下...</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "java web获取访客信息(ip,归属地等)",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "获取访客信息"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "本站中的应用"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "搜索引擎蜘蛛UA"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "延伸"
            }
          ]
        }
      ],
      "config": {
        "source": "java web获取访客信息(ip,归属地等).md",
        "staticFileName": "web_access_log.html",
        "author": "guoqzuo",
        "createDate": "2017/02/01",
        "description": "之前写过一篇servlet判断是否为移动端访问的文章，是为了代码适配移动端或PC。这次需要记录访客信息。写了个类方法来获取访问者的ip、归属地、UA、访问URL以及是否为PC端访问。",
        "keywords": "servlet 获取ip,servlet获取访问信息,java获取访客信息,servlet获取访客ip,web获取用户访问信息,百度谷歌蜘蛛UA,java web获取访客信息",
        "category": "后端数据库等",
        "year": "2017",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"xcode8安装ksimagenamed插件后崩溃的解决方法\">Xcode8安装KSImageNamed插件后崩溃的解决方法</h1>\n<blockquote>\n<p>苹果在Xcode8中取消了对第三方插件的支持，安装了KSImageNamed插件后，Xcode8会不停的崩溃。这里总结了网上找到了一种重新签名Xcode(re-codesign Xcode)的方法，可以解决这个问题。对于是否影响上架还有待考证。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_image_1.png\" alt=\"ios_image_1.png\"></p>\n<ol>\n<li><p>删除已经安装的KSImageNamed插件</p>\n<pre><code class=\"language-sh\">rm -rf ~/Library/Developer/Xcode/Plug-ins/KSImageNamed.ideplugin/</code></pre>\n</li>\n<li><p>完全退出Xcode，创建代码签名证书XcodeSigner，打开应用程序 - 实用工具 - 钥匙串访问，创建证书</p>\n</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_image_2.png\" alt=\"ios_image_2.png\"></p>\n<p>后面会执行一条命令，这里的名称如果你填了其它的，那命令的名称也需要改过来。</p>\n<p><img src=\"../../../images/blog/ios/ios_image_3.png\" alt=\"ios_image_3.png\"></p>\n<ol start=\"3\">\n<li>重新签名Xcode(Re-signing Xcode)<pre><code class=\"language-sh\">sudo codesign -f -s XcodeSigner /Applications/Xcode.app</code></pre>\n这里需要注意的是这条命令执行可能需要点时间，稍等一下，让它执行完，就像真机调试时一样，不要急。</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_image_4.png\" alt=\"ios_image_4.png\"></p>\n<ol start=\"4\">\n<li><p>上面的命令执行后，会弹窗问你是否允许XcodeSigner的一些操作，点总是允许就可以了。再打开从GitHub上下载的KSimageNamed工程，Command+R运行一遍就会自动安装该插件到对应的目录了。如果不能直接打开该工程，请参考下面给的GitHub链接里AMEstudio的相关回答。</p>\n</li>\n<li><p>完全退出Xcode，再次打开会有一个弹窗，点击loadBundle就可以了，我的就是这样解决的。</p>\n</li>\n</ol>\n<p>参考及扩展:</p>\n<p><a href=\"https://github.com/XVimProject/XVim/blob/master/INSTALL_Xcode8.md\">Install XVim for Xcode8</a></p>\n<p><a href=\"https://github.com/ksuther/KSImageNamed-Xcode/issues/86\">Github KSImageNamed Xcode8 in crash AMEstudio‘s comment</a></p>\n<p><a href=\"https://www.zhihu.com/question/47925267/answer/122133690?from=profile_answer_card\">如何评价Xcode8不支持第三方插件? - 知乎</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Xcode8安装KSImageNamed插件后崩溃的解决方法"
        }
      ],
      "config": {
        "source": "Xcode8安装KSImageNamed插件后崩溃的解决方法.md",
        "staticFileName": "ios_image.html",
        "author": "guoqzuo",
        "createDate": "2017/02/04",
        "description": "苹果在Xcode8中取消了对第三方插件的支持，安装了KSImageNamed插件后，Xcode8会不停的崩溃。这里总结了网上找到了一种重新签名Xcode(re-codesign Xcode)的方法，可以解决这个问题。对于是否影响上架还有待考证。",
        "keywords": "Xcode安装KSImageNamed方法,Xcode8 安装KSImageNamed崩溃的解决方法",
        "category": "iOS",
        "year": "2017",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"cocoapods安装及使用\">CocoaPods安装及使用</h1>\n<blockquote>\n<p>在导入某个框架时，你可能还需要导入这个框架依赖的其他框架，这样就比较麻烦。如果用CocoaPods导入一个框架，它会自动导入这个框架所依赖的所有框架。在导入AFNetworking时用到了它，这里总结了安装方法及一些需要注意的细节。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/ios/ios_cocopods_1.png\" alt=\"ios_cocopods_1.png\"></p>\n<h2 id=\"cocoapods安装\">CocoaPods安装</h2>\n<ol>\n<li>安装ruby环境，下面的所有操作都在终端(Terminal)下输入命令执行</li>\n</ol>\n<pre><code class=\"language-bash\">gem source -a https://gems.ruby-china.com</code></pre>\n<ol start=\"2\">\n<li>检查上面命令是否执行成功</li>\n</ol>\n<pre><code class=\"language-bash\">gem sources -l\n# 执行结果:\n# kevindeMacBook-Air:~ kevin$ gem sources -l\n# *** CURRENT SOURCES ***\n\n# https://gems.ruby-china.com/</code></pre>\n<ol start=\"3\">\n<li>安装CocoaPods，这里需要等一会</li>\n</ol>\n<pre><code class=\"language-bash\">sudo gem install cocoapods\n执行结果:\nkevindeMacBook-Air:~ kevin$ sudo gem install cocoapods\nPassword:\nFetching: i18n-0.7.0.gem (100%)\nSuccessfully installed i18n-0.7.0\nFetching: thread_safe-0.3.5.gem (100%)\nSuccessfully installed thread_safe-0.3.5\nFetching: tzinfo-1.2.2.gem (100%)\nSuccessfully installed tzinfo-1.2.2\n...\n...\nParsing documentation for gh_inspector-1.0.2\nInstalling ri documentation for gh_inspector-1.0.2\nParsing documentation for cocoapods-1.1.1\nInstalling ri documentation for cocoapods-1.1.1\n26 gems installed\nkevindeMacBook-Air:~ kevin$</code></pre>\n<ol start=\"4\">\n<li>检查CocoPods是否安装成功，终端下直接输入pod命令，会显示帮助内容，如下图:</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_cocopods_2.png\" alt=\"ios_cocopods_2.png\"></p>\n<h2 id=\"用cocoapods导入afnetworking框架到xcode项目\">用CocoaPods导入AFNetworking框架到Xcode项目</h2>\n<ol>\n<li>搜索AFNetworking框架，这里好像会更新一些东西。出现Setting up CocoPods master repo，要等很久，如果有朋友或同事下载好的，可以拷贝一份，文件路径 ~/.cocoaPods</li>\n</ol>\n<pre><code class=\"language-bash\">pod search AFNetworking\n执行结果:\nkevindeMacBook-Air:~ kevin$ pod search AFNetworking\nSetting up CocoaPods master repo # 我第一次ctrl+c中断过一次，这次下载失败了\n[!] /usr/bin/git clone https://github.com/CocoaPods/Specs.git master\n\nCloning into &#39;master&#39;...\nerror: RPC failed; curl 18 transfer closed with outstanding read data remaining\nfatal: The remote end hung up unexpectedly\nfatal: early EOF\nfatal: index-pack failed\n\nkevindeMacBook-Air:~ kevin$ pod search AFNetworking # 重新输入该命令\nSetting up CocoaPods master repo   # 我在这里卡了很久等了几个小时\nSetup completed\nCreating search index for spec repo &#39;master&#39;.. Done!\n[!] Unable to find a pod with name, author, summary, or description matching `AFNetworking`\n[!] Skipping `0` because the podspec contains errors.\n[!] Skipping `1` because the podspec contains errors.\n...\nkevindeMacBook-Air:~ kevin$</code></pre>\n<p>刚开始我还以为卡死了，看其他教程，这一步只需要几秒。可能是改版了，等了n久。如果出现了上面执行结果里的错误，就再次执行该命令。可能跟网络环境有关系，第一次下载失败，再次下载。你可以按Command+t组合键再打开一个终端，输入命令查看安装进度</p>\n<pre><code class=\"language-bash\">du -sh ~/.cocoaPods\n# 隔一段时间查一次，下载的非常慢\nkevindeMacBook-Air:~ kevin$ du -sh ~/.cocoaPods\n 60K    /Users/kevin/.cocoaPods\nkevindeMacBook-Air:~ kevin$ du -sh ~/.cocoaPods\n168M    /Users/kevin/.cocoaPods\nkevindeMacBook-Air:~ kevin$ du -sh ~/.cocoaPods\n373M    /Users/kevin/.cocoaPods\nkevindeMacBook-Air:~ kevin$ du -sh ~/.cocoaPods\n965M    /Users/kevin/.cocoaPods\nkevindeMacBook-Air:~ kevin$</code></pre>\n<p>安装完成后出现了一个错误，搜索时出现问题: </p>\n<pre><code class=\"language-sh\">kevindeMacBook-Air:~ kevin$ pod search AFNetworking\n[!] Unable to find a pod with name, author, summary, or description matching `AFNetworking`</code></pre>\n<p>解决方法: 输入下面两条命令，再次查找，等一会就OK了。如果遇到问题可参见: CocoaPods: pod search 搜索类库失败的解决办法</p>\n<pre><code class=\"language-bash\">pod setup\nrm ~/Library/Caches/CocoaPods/search_index.json</code></pre>\n<pre><code class=\"language-bash\">pod search AFNetworking\nCreating search index for spec repo &#39;master&#39;.. Done! # 需要等一会，搜索结果如下</code></pre>\n<p><img src=\"../../../images/blog/ios/ios_cocopods_3.png\" alt=\"ios_cocopods_3.png\"></p>\n<ol start=\"2\">\n<li>search可以用了之后就开始正式准备导入Xcode项目了</li>\n</ol>\n<pre><code class=\"language-bash\">cd /Users/kevin/Desktop/Projects/BaiSi  # 进入项目目录\nls  # 查看是否是正确的目录\nBaiSi        BaiSi.xcodeproj    BaiSiTests    BaiSiUITests\ntouch podfile # 创建podfile文件\nopen podfile #打开文件\n# 输入如下内容:  (BaiSi为项目名，第二行为sreach里搜到的内容)\ntarget &#39;BaiSi&#39; do     \npod &#39;AFNetworking&#39;, &#39;~&gt; 3.1.0&#39;\nend\npod install # 安装，成功后的界面如下图</code></pre>\n<p><img src=\"../../../images/blog/ios/ios_cocopods_4.png\" alt=\"ios_cocopods_4.png\"></p>\n<ol start=\"3\">\n<li>进入工程目录，打开新生成的BaiSi.xcworkspace文件，进入工程，就可以使用AFNetworking框架了</li>\n</ol>\n<p><img src=\"../../../images/blog/ios/ios_cocopods_5.png\" alt=\"ios_cocopods_5.png\"></p>\n<p>参考资料: </p>\n<p><a href=\"http://blog.csdn.net/zhangjunjian127/article/details/47954981\">CocoaPods安装和使用及问题：Setting up CocoaPods master repo</a></p>\n<p><a href=\"http://code4app.com/article/cocoapods-install-usage\">CocoaPods安装和使用教程</a></p>\n<p><a href=\"http://www.jianshu.com/p/2ef8a38416c4\">2016最新CocoaPods安装和错误解决</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "CocoaPods安装及使用",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "CocoaPods安装"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "用CocoaPods导入AFNetworking框架到Xcode项目"
            }
          ]
        }
      ],
      "config": {
        "source": "CocoaPods安装及使用.md",
        "staticFileName": "ios_cocoapods.html",
        "author": "guoqzuo",
        "createDate": "2017/02/06",
        "description": "在导入某个框架时，你可能还需要导入这个框架依赖的其他框架，这样就比较麻烦。如果用CocoaPods导入一个框架，它会自动导入这个框架所依赖的所有框架。在导入AFNetworking时用到了它，这里总结了安装方法及一些需要注意的细节。",
        "keywords": "CocoaPods 2020,cocoapods 2020, CocoaPods安装2020,CocoaPods,2020 CocoPods安装,最新CocoaPods安装方法",
        "category": "iOS",
        "year": "2017",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"tomcat将多个域名解析到服务器的不同目录\">Tomcat将多个域名解析到服务器的不同目录</h1>\n<blockquote>\n<p>昨天好基友买了个域名limiaolei.com，并解析到了我的服务器。然后访问他的域名就进入了我的网站，于是就想怎么让同一ip上的两个域名访问不同的内容。由于不知道具体的方法，我用的搜索词都不怎么准确，找了好久才找到解决方法。就是配置Tomcat，当访问limiaolei.com时，指定为其它目录。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/web/web_tomcat_1.png\" alt=\"web_tomcat_1.png\"></p>\n<h2 id=\"将多个域名解析到不同的工程目录\">将多个域名解析到不同的工程目录</h2>\n<p>打开tomcat安装目录下的conf文件夹里的server.xml文件，找到Engine标签下的Host便签，在下面添加相应域名的目录配置，默认情况下，网站访问的是webapps目录下ROOT工程。Host标签的name属性可以配置域名，appBase属性可以配置该域名对应的目录。我这里将limiaolei.com的域名解析到了webapps2的目录，新建一个webapps2目录，将工程目录改为ROOT，放到这个目录，就可以访问对应的index了。</p>\n<p><img src=\"../../../images/blog/web/web_tomcat_2.png\" alt=\"web_tomcat_2.png\"></p>\n<h2 id=\"具体操作\">具体操作</h2>\n<p>在系统默认的<code>Host</code>标签的结束标签<code>Host</code>下面一行添加设置。默认Host的主机将localhost自动解析到webapps，如果没有额外添加对域名的解析处理，默认会访问webapps目录下的ROOT工程。</p>\n<pre><code class=\"language-xml\">// &lt;/Host&gt;下添加的内容，这里需要设置两个\n&lt;Host name=&quot;www.limiaolei.com&quot;  appBase=&quot;webapps2&quot;\n            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;\n&lt;/Host&gt;\n&lt;Host name=&quot;limiaolei.com&quot;  appBase=&quot;webapps2&quot;\n            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;\n&lt;/Host&gt;\n\n// 扩展，你也可以设置对应的二级域名,或其他域名，解析到不同的工程目录\n&lt;Host name=&quot;m.zuo11.com&quot;  appBase=&quot;webapps3&quot;\n            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;\n&lt;/Host&gt;</code></pre>\n<p>访问效果: </p>\n<p><img src=\"../../../images/blog/web/web_tomcat_3.png\" alt=\"web_tomcat_3.png\"></p>\n<h2 id=\"拓展问题\">拓展问题</h2>\n<ol>\n<li><p>将局域网电脑用做服务器，网上的教程一般都是要设置路由器，需要将外网的ip映射到局域网内用作服服务器的电脑。我的外网ip和路由器的wan口ip分配的不一致，可能是宽带运营商设置了什么，基本无解。</p>\n</li>\n<li><p>https的ssl证书也分种类，有可以给多个不同域名使用的，不知道阿里云的行不，现在limiaolei.com访问时会有证书错误的提示，我的域名配置解析多了ssl的一个解析，等他的域名开始用时，可能要想办法解决这个问题。</p>\n</li>\n<li><p>备案问题，域名如果解析到的是阿里云的服务器，且该域名没有备案，阿里云会自动将主页重定向到提示备案页面，如果以https开头来访问可避开重定向。备案需要服务号，一个阿里云ECS最多可以有5个备案服务号，也就是最多支持5个一级域名的备案。</p>\n</li>\n</ol>\n<p><img src=\"../../../images/blog/web/web_tomcat_4.png\" alt=\"web_tomcat_4.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Tomcat将多个域名解析到服务器的不同目录",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "将多个域名解析到不同的工程目录"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "具体操作"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "拓展问题"
            }
          ]
        }
      ],
      "config": {
        "source": "Tomcat将多个域名解析到服务器的不同目录.md",
        "staticFileName": "web_tomcat.html",
        "author": "guoqzuo",
        "createDate": "2017/02/08",
        "description": "昨天好基友买了个域名limiaolei.com，并解析到了我的服务器。然后访问他的域名就进入了我的网站，于是就想怎么让同一ip上的两个域名访问不同的内容。由于不知道具体的方法，我用的搜索词都不怎么准确，找了好久才找到解决方法。就是配置Tomcat，当访问limiaolei.com时，指定为其它目录。",
        "keywords": "将不同的域名解析到不同的目录,Tomcat设置将多个域名解析到同一个服务器的不同目录,tomcat配置二级域名的访问目录,tomcat如何设置二级域名的访问目录",
        "category": "运维部署与版本控制",
        "year": "2017",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"富文本编辑器使用execcommand插入图片不生效的问题\">富文本编辑器使用execCommand插入图片不生效的问题</h1>\n<blockquote>\n<p>最近打算实现一个评论系统，评论如果只能回复文字就太low了，于是就打算自己做一个简单的富文本编辑器。</p>\n</blockquote>\n<h2 id=\"思路\">思路</h2>\n<ul>\n<li>一般回复内容，我第一个想到的是textarea，做完回复文字的功能后，想着如果插入图片貌似不可行。</li>\n<li>百度了下富文本编辑器的实现，发现一般常规的做法是依靠contentEditable属性，让div成为可编辑元素。然后用execCommand命令来实现一些交互。后来在翻js高程3的时候发现在第14章表单脚本里面也有富文本编辑的介绍，也是用的同样的方法，就仔细看了下。</li>\n<li>确定方法后，就是实现了，于是有了如下图的demo</li>\n</ul>\n<p><img src=\"../../../images/blog/web/web_richtext_1.png\" alt=\"image\"></p>\n<ul>\n<li><p>搜索了一些人的demo后发现触发表情、斜体、粗体等操作一般用的是a或button元素，我用img元素发现document.execCommand执行的是否总是返回false操作不成功，后来就按照网上的方法用了，有时可以，就是又不行。我就很郁闷了，浏览器肯定是支持的，执行的命令也是正确的，难道document.execCommand对触发的标签有要求？网上搜了下没有答案。</p>\n</li>\n<li><p>于是我想着直接向div可编辑元素插入子元素的方式，可以是可以，但发现不能插入到编辑光标所在的位置，这种方式还是不行，还是必须用execCommand</p>\n<pre><code class=\"language-js\">// 在可编辑的富文本里插入图片\nvar img = `&lt;img src=&#39;http://img.baidu.com/hi/tsj/t_0002.gif&#39;&gt;`;\ndocument.getElementsByClassName(&quot;editor&quot;)[0].insertAdjacentHTML(&quot;beforeend&quot;, img)</code></pre>\n</li>\n<li><p>记得之前在使用css的calc功能是总是不成功，后来隔了好久才在某个地方看到使用calc(100% - 10px) 时，运算符中间必须有空格，而我习惯css是不加的calc(100%-10px) 这才恍然大悟。这里肯定也有某些类似的注意事项，于是我就写了个最简单的demo，如下: </p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Title&lt;/title&gt;\n  &lt;style&gt;\n      #editor {\n          width:300px;\n          height:300px;\n          border:1px solid #ccc;\n      }\n      img {\n          width:35px;\n          height:35px;\n      }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;editor&quot; contenteditable=&quot;true&quot;&gt;&lt;/div&gt;\n  &lt;img id=&quot;img&quot; src=&quot;http://img.baidu.com/hi/tsj/t_0002.gif&quot;&gt;\n  &lt;script&gt;\n      var img = document.getElementById(&quot;img&quot;);\n      // 点击img图片在div里插入一张图片\n      img.onclick = function (e) {\n          var value1 = document.execCommand(&#39;insertImage&#39;, false, &#39;http://img.baidu.com/hi/tsj/t_0002.gif&#39;);\n          console.log(value1)\n      }\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n</li>\n<li><p>然后我发现了一个问题，当div没有焦点时，点击img是不行的，只有当焦点在可编辑的div上使用这个命令才会生效。回过头来再看我的代码，也就知道为什么其他富文本编辑器菜单都用a或button元素了。这两个元素，不会让编辑中的div失去焦点。如果表情按钮为img，点击后弹出可选的表情，此时可编辑的div失去焦点，调用execCommand就会无效，返回false。而我之前的demo里面，a元素的中间有地方有空白位置，点击后相当于点击了div。找到原因后，就知道要用a元素将表情的点击区域铺满了。</p>\n</li>\n<li><p>可选的标签里面用到了 display:inline-block，发现系统还算生成了一些空白区域，百度下，也找到了去空格的方法，详情参见如下链接: \n<a href=\"https://blog.csdn.net/gladys_1111/article/details/77279985\">inline-block布局产生间隙的原因及解决办法（水平、垂直）</a></p>\n<pre><code class=\"language-css\">/* display:inline-block 父元素加上如下样式，可去掉系统自带的间隙 */\n#face {\n  font-size: 0;\n  letter-spacing: -3px;\n}</code></pre>\n</li>\n<li><p>自此富文本编辑器插入表情及更改斜等功能算是没什么问题了，:smiley: 下一步就是考虑插入图片，图片上传的问题。</p>\n</li>\n</ul>\n<hr>\n<p>2018/10/03 更新</p>\n<p>今天把插入表情的逻辑完善了下，发现当第一次进入，评论框还没聚焦，如果用户直接点标签按钮，发送表情，结果肯定是不成功的，于是觉得还是有必要在执行execCommand时如果没有聚焦就来个focus</p>\n<pre><code class=\"language-js\">var result = document.execCommand(&#39;insertImage&#39;, false, res.filePath);\n// 如果执行失败，手动focus\nif (!result) {\n    // 获得焦点，防止可编辑div无焦点时，无效的问题，这种情况，光标位置不准确，每次都是开头位置\n   document.getElementsByClassName(&quot;editor&quot;)[0].focus();\n   document.execCommand(&#39;insertImage&#39;, false, res.filePath);\n}</code></pre>\n<p>网上找了篇可以获取光标位置的函数，但发现兼容性貌似不怎么好，暂时保持这样。\n有一遍文章还不错，收藏了以后研究 <a href=\"https://segmentfault.com/a/1190000005869372\">html元素contenteditable属性如何定位光标和设置光标</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "富文本编辑器使用execCommand插入图片不生效的问题",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "思路"
            }
          ]
        }
      ],
      "config": {
        "source": "富文本编辑器使用execCommand插入图片不生效的问题.md",
        "staticFileName": "web_richtext.html",
        "author": "guoqzuo",
        "createDate": "2018/10/02",
        "description": "execcommand插入图片光标消失，最近打算实现一个评论系统，评论如果只能回复文字就太low了，于是就打算自己做一个简单的富文本编辑器。一般回复内容，我第一个想到的是textarea，做完回复文字的功能后，想着如果插入图片貌似不可行。",
        "keywords": "execcommand插入图片光标消失,富文本编辑器使用execCommand插入图片不生效的问题,execCommand插入图片不生效",
        "category": "JavaScript",
        "year": "2018",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"原生ajax上传图片，php后台处理总结\">原生ajax上传图片，php后台处理总结</h1>\n<blockquote>\n<p>开始做图片上传，发现之前的处理方式基本忘光了。看了下原来的源码才有了解，还是要总结经验，不然忘的太快。之前是用jQuery来处理的，也是ajax方式。现在改为用原生的ajax来处理，不依赖jQuery，整体还算是比较简单的。</p>\n</blockquote>\n<h2 id=\"前端表单提交\">前端表单提交</h2>\n<p>两种方式，一种是有form元素的，一种是没form元素的</p>\n<pre><code class=\"language-html\">&lt;!-- 有form的方式 --&gt;\n&lt;form name=&quot;form&quot;&gt;\n    &lt;input type=&quot;file&quot; name=&quot;editorImg&quot;  onchange=&quot;uploadImg(this)&quot; accept=&quot;image/*&quot;&gt;\n    &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;testttt&quot;&gt;\n&lt;/form&gt;\n\n&lt;!-- 没form的方式 --&gt;\n&lt;input type=&quot;file&quot; name=&quot;editorImg&quot;  onchange=&quot;uploadImg(this)&quot; accept=&quot;image/*&quot;&gt;\n\n&lt;script&gt;\n     // 当input元素触发onchange事件，如果选择了图片，上传图片\n     function uploadImg(obj) {\n        // 获取文件对象，信息包括: 文件名、文件大小、文件类型\n    console.log(obj.files[0]);\n    if (!obj.files[0]) {\n            console.log(&quot;打开的文件，点击了取消.&quot;);\n            return;\n        }\n\n        // 传值 - 有form的情况\n        // var form = document.getElementsByTagName(&#39;form&#39;)[0];\n        // var formData = new FormData(form);\n\n        // 传值 - 没有form的情况\n    var formData = new FormData();\n    formData.append(&quot;id&quot;, &quot;123&quot;);\n    formData.append(&quot;name&quot;, &quot;test&quot;);\n    formData.append(&quot;editorImg&quot;, obj.files[0]);\n    console.log(formData);\n\n         // ajax上传文件，及表单数据\n    var xhr = new XMLHttpRequest();\n    xhr.open(&quot;post&quot;, &quot;./server/post_info.php&quot;, false);\n        // 这里不用设置请求头等，默认为multipart/form-data; \n    xhr.send(formData);\n\n    var status = xhr.status;\n    if ((status &gt;= 200 &amp;&amp; status &lt; 300) || status == 304) {\n        // xhr.responseText;\n        var res = JSON.parse(xhr.responseText);  \n            // 上传图片成功后，进行后续逻辑，省略了错误处理等          \n        var result = document.execCommand(&#39;insertImage&#39;, false, res.filePath);\n            if (!result) {\n        // 获得焦点，防止可编辑div无焦点时，无效的问题\n        document.getElementsByClassName(&quot;editor&quot;)[0].focus();\n        document.execCommand(&#39;insertImage&#39;, false, res.filePath);\n        }\n    } else {\n        alert(xhr.status);\n    }\n}\n&lt;/script&gt;</code></pre>\n<h2 id=\"后端php处理\">后端php处理</h2>\n<p>./server/post_info.php 处理逻辑如下</p>\n<pre><code class=\"language-php\">&lt;?php\nheader(&quot;Content-type:application/json;charset=utf-8&quot;);\n# 添加响应头，防止中文乱码\n\n$result = move_uploaded_file($_FILES[&#39;editorImg&#39;][&#39;tmp_name&#39;],&quot;../uploads/&quot;.$_FILES[&quot;editorImg&quot;][&quot;name&quot;]);\n// echo &quot;result&quot;.$k.&quot;result&quot;;\nif ($result) { \n    echo json_encode(array(\n        &quot;error_code&quot; =&gt; 0,\n        &quot;error_msg&quot; =&gt; &quot;上传成功&quot;,\n        &quot;filePath&quot; =&gt; &quot;./uploads/&quot;.$_FILES[&quot;editorImg&quot;][&quot;name&quot;]\n    ));\n} else {\n    echo json_encode(array(\n        &quot;error_code&quot; =&gt; -1,\n        &quot;error_msg&quot; =&gt; &quot;上传失败&quot;,\n        &quot;filePath&quot; =&gt; &quot;./uploads/&quot;.$_FILES[&quot;editorImg&quot;][&quot;name&quot;]\n    ));\n}</code></pre>\n<h2 id=\"遇到的问题及处理过程\">遇到的问题及处理过程</h2>\n<p>乍一看，so easy，但功能跑通纠结了好一会儿</p>\n<h3 id=\"问题一-后端接收不到传值，乱码问题\">问题一 后端接收不到传值，乱码问题</h3>\n<p>以下三种都试了，除了不设置直接用系统的，以下三个请求头都会导致后台php获取文件数据异常</p>\n<pre><code class=\"language-js\">xhr.setRequestHeader(&quot;Content-type&quot;,&quot;text/plain;charset=UTF-8&quot;);\nxhr.setRequestHeader(&quot;Content-type&quot;,&quot;multipart/form-data;charset=UTF-8&quot;);\nxhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded;charset=UTF-8&quot;);</code></pre>\n<p>乱码的情况，添加了请求头没反应, header(&quot;Content-type:application/json;charset=utf-8&quot;);\n后来又突然好了，可能是我直接在apache上面跑的，有缓存。</p>\n<h3 id=\"问题二-文件保存失败-无任何错误提示\">问题二 文件保存失败, 无任何错误提示</h3>\n<p>最开始move_uploaded_file函数执行一点反应的没有，看了文档会返回 true or false，后来我测试，每次返回的是空字符串，也就是 &quot;&quot;，而且还不报任何错误。于是把前段时间弄文件上传的demo拿出来跑了跑居然是可以的，对比了下，发现应该是目录权限的问题，upload默认权限为 744(drwxr--r--)，一般用户没有写的权限，于是改成了777(drwxrwxrwx)的权限，然后就成功了。发现move_uploaded_file函数执行成功返回1。也就是这个函数返回&quot;&quot;或&quot;1&quot;，如果说返回 true / false 也行，但有误导的意思。定位不到错误时，让人怀疑人生。</p>\n<pre><code class=\"language-shell\">chmod 777 upload</code></pre>\n<p>然后我就郁闷了，怎么让move_uploaded_file这个函数在遇到问题时报错。由于没有用任何框架，直接将php放到apache的根目录直接跑项目，重新看了下php错误处理，搜了对应的内容。发现php默认提示错误居然是关闭的。举个最简单的例子，下面是页面1.php的代码，直接运行会显示空白页，什么都没有，但test是未定义的，且x=4明显语法错误都没提示。</p>\n<pre><code class=\"language-php\">&lt;?php\nx=4;\necho $test;\n?&gt;</code></pre>\n<p>有两种方法可以让系统提示错误</p>\n<ul>\n<li>自己捕获错误，加入如下代码，出现上面test未定义的情况，会提示错误，而非空白页，但x=4的语法错误还是不会提示。<pre><code class=\"language-js\">&lt;?php\nfunction customError($errno, $errstr)\n{\n  echo &quot;&lt;b&gt;Error:&lt;/b&gt; [$errno] $errstr&lt;br&gt;&quot;;\n  echo &quot;脚本结束&quot;;\n  die();\n}\nset_error_handler(&quot;customError&quot;);\nx=4;\necho $test;\n?&gt;</code></pre>\n</li>\n<li>将系统的错误提示打开，都会有提示\nphp.ini配置文件里面 display_errors = Off 默认设置是关闭的，改为On后重启apache服务即可生效。<pre><code>display_errors = On</code></pre></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "原生ajax上传图片，php后台处理总结",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "前端表单提交"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "后端php处理"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "遇到的问题及处理过程",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "问题一 后端接收不到传值，乱码问题"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "问题二 文件保存失败, 无任何错误提示"
                }
              ]
            }
          ]
        }
      ],
      "config": {
        "source": "原生ajax上传图片，php后台处理总结.md",
        "staticFileName": "web_upload_php.html",
        "author": "guoqzuo",
        "createDate": "2018/10/03",
        "description": "开始做图片上传，发现之前的处理方式基本忘光了。看了下原来的源码才有了解，还是要总结经验，不然忘的太快。之前是用jQuery来处理的，也是ajax方式。现在改为用原生的ajax来处理，不依赖jQuery，整体还算是比较简单的。",
        "keywords": "原生ajax上传图片，php后台处理图片上传",
        "category": "后端数据库等",
        "year": "2018",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"php发送邮件\">php发送邮件</h1>\n<blockquote>\n<p>邮件发送是一个很重要的功能，具体应用包括注册时邮箱验证、评论回复提醒、推送广告、线上异常报告等。一般网上php教程里面邮件发送很简单，一个mail()函数就搞定。但这个方法如果你去试，90%是不成功的。然后就会去搜php怎么发送邮件，搜到的答案基本没有直接使用mail()的，都是使用PHPMailer这个开源库，我一般的思路是在能不使用第三方库的时候尽量不去使用。但后面发现还是要使用这个库。</p>\n</blockquote>\n<h2 id=\"php发送邮件的两种方式\">php发送邮件的两种方式</h2>\n<h3 id=\"直接使用系统的mail函数需要本地邮件服务器\">直接使用系统的mail()函数(需要本地邮件服务器)</h3>\n<p>最开始使用这个一直发送不出去，后面就在想如果这个发送成功了，接收到邮件时，来源的邮箱、名称会是什么，貌似根本就没有设置过。</p>\n<pre><code class=\"language-php\">try {\n    // $email = $un;\n    $subject = &quot;[fastds] 评论系统注册链接&quot;.$un;\n    $message = &quot;Hi &quot;.$un.&quot;,&lt;br&gt; 你好，欢迎注册fastds评论系统。&lt;br&gt; 请在如下链接完成注册：&lt;br&gt; http://www.jstomp?f=reg&amp;key=sfsdfsdfs2342342sdsfmcvbjjw&lt;br&gt;fastds管理员 guoqzuo&lt;br&gt;i@zuoguoqing.com&quot;;\n    $k = mail($un, $subject, $message);\n    echo $k;\n    // echo &quot;邮件发送成功&quot;;\n} catch (Exception $e) {\n    echo $e;\n}</code></pre>\n<p>后面查了下，在php.ini可以设置相关参数，但后来在网上收了下，这个方法需要本地安装有邮件服务器，但这种方式显然是不可行的，自己去配置太麻烦，而且就算发出邮件了，可能会直接被屏蔽。关键是网上的教程不好找，很少有这么做的。我的想法是依托qq邮箱来发送邮件。这样会稳定一点。PHPMailer有很多这种教程，是大家比较推荐的。</p>\n<h3 id=\"使用phpmailer可使用qq发邮件\">使用PHPMailer(可使用qq发邮件)</h3>\n<p>关于 PHPMailer - A full-featured email creation and transfer class for PHP，在github开源，有1w+ star，应该比较靠谱。现有的百度PHPMailer使用qq发邮件的教程都是比较旧的，直接将项目考到根目录使用，且目录结构、文件名都有变化。最后还是打算以官方文档为主，于是知道了composer，是php里面的一个引入第三方包的工具，会自动安装依赖。类似于node的npm，python的pip。目前来说是比较主流的。</p>\n<h4 id=\"在项目中引入composer\">在项目中引入composer</h4>\n<ul>\n<li>在系统中安装composer</li>\n</ul>\n<pre><code class=\"language-js\">// 这个命令会将composer.phar文件下载到当前目录\n// curl -sS https://getcomposer.org/installer | php\n// 将这个文件改名为composer并移动到系统的环境变量里，方便在任何目录使用\n// mv composer.phar /usr/local/bin/composer</code></pre>\n<ul>\n<li>在项目根目录创建 composer.json文件</li>\n</ul>\n<pre><code class=\"language-json\">{\n    &quot;name&quot;: &quot;fastds/fastds&quot;,\n    &quot;description&quot;: &quot;comment system&quot;,\n    &quot;require&quot;: {\n        &quot;phpmailer/phpmailer&quot;: &quot;^6.0&quot;,\n        &quot;monolog/monolog&quot;: &quot;^1.23&quot;\n    }\n}</code></pre>\n<ul>\n<li>执行composer安装</li>\n</ul>\n<p>运行下面的命令(二选1)可以安装composer.json里面配置的依赖，如果没有composer.json文件会出错</p>\n<pre><code class=\"language-bash\"># 如果下载composer.phar后没改名移动到环境变量\nphp composer.phar install\n# 如果改名了且移动到了全局变量 \ncomposer install\n\n# 也可以在不配置composer.json里面的require，直接运行命令安装最新phpmailer最新版本的\ncomposer require phpmailer/phpmailer</code></pre>\n<ul>\n<li>安装完成后，会多出一个composer.lock文件和一个vendor目录，vendor目录相当于node的node_modules目录</li>\n</ul>\n<h4 id=\"开始发送邮件\">开始发送邮件</h4>\n<pre><code class=\"language-php\">&lt;?php\n// Import PHPMailer classes into the global namespace\n// These must be at the top of your script, not inside a function\nuse PHPMailer\\PHPMailer\\PHPMailer;\nuse PHPMailer\\PHPMailer\\Exception;\n\n//Load Composer&#39;s autoloader\nrequire &#39;../vendor/autoload.php&#39;;\n\n$mail = new PHPMailer(true);\n\ntry {\n    //Server settings\n    $mail-&gt;SMTPDebug = 1;                     // Enable verbose debug output\n    $mail-&gt;isSMTP();                                 // Set mailer to use SMTP\n    $mail-&gt;Host = &#39;smtp.qq.com&#39;;            // Specify main and backup SMTP servers\n    $mail-&gt;SMTPAuth = true;                   // Enable SMTP authentication\n    $mail-&gt;Username = &#39;916707888@qq.com&#39;;  // SMTP username                    \n    $mail-&gt;Password = &#39;xxxxxxxxxxxxxxx&#39;;      // SMTP password，这里隐去了密码\n    $mail-&gt;SMTPSecure = &#39;ssl&#39;;             // Enable TLS encryption, `ssl` also accepted\n    $mail-&gt;Port = 465;                         // TCP port to connect to\n    $mail-&gt;CharSet = &quot;UTF-8&quot;;       // 防止发送阿里云邮箱中文乱码\n\n    //Recipients\n    $mail-&gt;setFrom(&#39;i@zuoguoqing.com&#39;, &#39;fastds管理员&#39;);  // 设置来源的邮箱/名称\n    // $mail-&gt;addAddress(&#39;joe@example.net&#39;, &#39;Joe User&#39;);     // Add a recipient\n    $mail-&gt;addAddress($un);               // Name is optional, $un为目标邮件地址\n    $mail-&gt;addCC(&#39;i@zuoguoqing.com&#39;);  // add cc，抄送\n\n    //Attachments\n    // $mail-&gt;addAttachment(&#39;/var/tmp/file.tar.gz&#39;);         // Add attachments\n    // $mail-&gt;addAttachment(&#39;/tmp/image.jpg&#39;, &#39;new.jpg&#39;);    // Optional name\n\n    //Content\n    $mail-&gt;isHTML(true);                                  // Set email format to HTML\n    $mail-&gt;Subject = &quot;[fastds] 欢迎注册fastds评论系统, 点击链接继续完成注册&quot;;\n    $mail-&gt;Body    = &quot;Hi &quot;.$un.&quot;,&lt;br&gt; 你好，欢迎注册fastds评论系统。&lt;br&gt; 请在如下链接完成注册：&lt;br&gt; http://www.jstomp?f=reg&amp;key=sfsdfsdfs2342342sdsfmcvbjjw&lt;br&gt;fastds管理员 guoqzuo&lt;br&gt;i@zuoguoqing.com&quot;;\n    $mail-&gt;AltBody = &#39;This is the body in plain text for non-HTML mail clients&#39;;\n\n    $mail-&gt;send();\n    echo &#39;Message has been sent&#39;;\n} catch (Exception $e) {\n    echo &#39;Message could not be sent. Mailer Error: &#39;, $mail-&gt;ErrorInfo;\n}\n?&gt;</code></pre>\n<h2 id=\"发送邮件遇到的问题\">发送邮件遇到的问题</h2>\n<ol>\n<li>SMTP Error: Could not authenticate \n一开始一直报上面的错误，搜了很多答案。按照网上的方式改了PHPMailer.php里面的一个位置，都没用，还是这个提示<pre><code class=\"language-php\">public function isSMTP()\n {\n     $this-&gt;Mailer = &#39;SMTP&#39;;\n }</code></pre>\n后面才发现$mail-&gt;Password不是qq邮箱的登录密码，而是在qq邮箱后台服务设置开启pop3/smtp功能时，给出的一个密码。如果忘记了改密码，关闭这个功能，重新开启就可以获得新密码了。改完密码后就发送成功了。</li>\n</ol>\n<p><img src=\"../../../images/blog/web/web_php_mail_1.png\" alt=\"image\"></p>\n<ol start=\"2\">\n<li>阿里云收到邮件乱码的问题，直接被认定为垃圾箱</li>\n</ol>\n<p><img src=\"../../../images/blog/web/web_php_mail_2.png\" alt=\"image\"></p>\n<p>直接加一句 $mail-&gt;CharSet = &quot;UTF-8&quot;;  即可，再发邮件就正常了，不会归到垃圾邮件了</p>\n<p><img src=\"../../../images/blog/web/web_php_mail_3.png\" alt=\"image\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "php发送邮件",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "php发送邮件的两种方式",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "直接使用系统的mail()函数(需要本地邮件服务器)"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "使用PHPMailer(可使用qq发邮件)",
                  "children": [
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "在项目中引入composer"
                    },
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "开始发送邮件"
                    }
                  ]
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "发送邮件遇到的问题"
            }
          ]
        }
      ],
      "config": {
        "source": "php发送邮件.md",
        "staticFileName": "web_php_mail.html",
        "author": "guoqzuo",
        "createDate": "2018/10/05",
        "description": "邮件发送是一个很重要的功能，具体应用包括注册时邮箱验证、评论回复提醒、推送广告、线上异常报告等。一般网上php教程里面邮件发送很简单，一个mail()函数就搞定。但这个方法如果你去试，90%是不成功的。然后就会去搜php怎么发送邮件，搜到的答案基本没有直接使用mail()的，都是使用PHPMailer这个开源库，我一般的思路是在能不使用第三方库的时候尽量不去使用。但后面发现还是要使用这个库。",
        "keywords": "php发送邮件,php发送邮件乱码,php 发邮件,php使用qq邮箱发邮件",
        "category": "后端数据库等",
        "year": "2018",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"前端cookie的使用\">前端cookie的使用</h1>\n<p>http是基于请求和响应的无状态协议，无法保存状态，如果有数据需要在浏览器关闭后，下次进入还保存，就可以用cookie来解决这个问题。</p>\n<h2 id=\"前端cookie的读取\">前端cookie的读取</h2>\n<p>前端cookie可以用document.cookie来读取，格式为key=value;key=value键值对的形式，如下图</p>\n<p><img src=\"../../../images/blog/web/web_cookie_1.png\" alt=\"image\"></p>\n<p>如果需要读取特定key的值，需要写一个函数来实现，思路为字符串的查找与切分，也可以使用正则来匹配</p>\n<pre><code class=\"language-js\">// 获取cookie里的值\nfunction getCookie(name) {\n  let cookieStr = document.cookie\n  let tempName = `${name}=`\n  let indexStart = cookieStr.indexOf(tempName)\n\n  // cookie里面没值，或者不包含name cookie\n  if (name === &#39;&#39; || cookieStr.length &lt;= 0 || indexStart &lt; 0) {\n    return `no cookie: ${name}`\n  }\n  indexStart = indexStart + tempName.length\n  let indexEnd = cookieStr.indexOf(&#39;;&#39;, indexStart)\n  if (indexEnd === -1) {\n    indexEnd = cookieStr.length\n  }\n  // 解码\n  return decodeURIComponent(cookieStr.substring(indexStart, indexEnd))\n}</code></pre>\n<h2 id=\"前端cookie的写入，设置有效时间\">前端cookie的写入，设置有效时间</h2>\n<p>前端直接给document.cookie赋值就可以设置token，但默认不会覆盖原来的值，会将key=val添加进去</p>\n<pre><code class=\"language-js\">document.cookie = &quot;key=val&quot;</code></pre>\n<p>除了key=val外，我们对key这个属性可以添加一些其他参数，比如有效期expires，max-age，secure等cookie的主要构成如下</p>\n<pre><code class=\"language-js\">name:一个唯一确定的cookie名称。通常来讲cookie的名称是不区分大小写的。\nvalue:存储在cookie中的字符串值。最好为cookie的name和value进行url编码\ndomain:cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值可以包含子域(如：yq.aliyun.com)，也可以不包含它(如：.aliyun.com，则对于aliyun.com的所有子域都有效).\npath: 表示这个cookie影响到的路径，浏览器跟会根据这项配置，像指定域中匹配的路径发送cookie。\nexpires:失效时间，表示cookie何时应该被删除的时间戳(也就是，何时应该停止向服务器发送这个cookie)。如果不设置这个时间戳，浏览器会在页面关闭时即将删除所有cookie；不过也可以自己设置删除时间。这个值是GMT时间格式，如果客户端和服务器端时间不一致，使用expires就会存在偏差。\nmax-age: 与expires作用相同，用来告诉浏览器此cookie多久过期（单位是秒），而不是一个固定的时间点。正常情况下，max-age的优先级高于expires。\nHttpOnly: 告知浏览器不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见。但在http请求张仍然会携带这个cookie。注意这个值虽然在脚本中不可获取，但仍然在浏览器安装目录中以文件形式存在。这项设置通常在服务器端设置。\nsecure: 安全标志，指定后，只有在使用SSL链接时候才能发送到服务器，如果是http链接则不会传递该信息。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以不要把重要信息放cookie就对了</code></pre>\n<p>针对上面的一些属性，我们将前端设置cookie，封装为一个函数</p>\n<pre><code class=\"language-js\">function setCookie(name, value, options) {\n  // 传值校验\n  if (!name) {\n    return &#39;name不能为空&#39;\n  }\n  value = (value !== null &amp;&amp; value !== undefined) ? value.toString() : &#39;&#39;\n  options = options || {}\n\n  let resultArr = []\n  // 设置基础的name=value值\n  resultArr.push(`${encodeURIComponent(name)}=${encodeURIComponent(value)}`)\n\n  // 处理options，其他属性传值\n  if (options.domain) {   // domain中必须包含两个点号\n    resultArr.push(&quot;domain=&quot; + options.domain)\n  }\n  if (options.path) {\n    resultArr.push(&quot;path=&quot; + options.path)\n  }\n  // 如果不设置expires和max-age浏览器会在页面关闭时清空cookie\n  if (options.expires) {\n    resultArr.push(&quot;expires=&quot; + options.expires.toGMTString())\n  }\n  if (options.maxAge &amp;&amp; typeof options.maxAge === &quot;number&quot;) {\n    resultArr.push(&quot;max-age=&quot; + options.maxAge)\n  }\n  if (options.httpOnly) { \n     resultArr.push(&quot;HTTPOnly&quot;)\n  }\n  if (options.secure) {\n     resultArr.push(&quot;secure&quot;)\n  }\n  document.cookie = resultArr.join(&quot;;&quot;)\n}</code></pre>\n<h2 id=\"前端cookie的删除\">前端cookie的删除</h2>\n<p>如果给cookie设置一个过去的时间，浏览器会立即删除该cookie</p>\n<pre><code class=\"language-js\">// 从cookie中删除name\nsetCookie(name, null, {&#39;expires&#39;:new Date(0)})</code></pre>\n<h2 id=\"服务端写入cookie\">服务端写入cookie</h2>\n<p>待完善</p>\n<h2 id=\"服务端读cookie\">服务端读cookie</h2>\n<p>待完善</p>\n<h2 id=\"其他存储方式-localstorage\">其他存储方式 localStorage</h2>\n<p>待完善</p>\n<p>参考资料:</p>\n<p><a href=\"https://blog.csdn.net/qiqingjin/article/details/51760343\">HTTP-服务器端CooKie与浏览器端Cookie</a></p>\n<p><a href=\"https://www.jianshu.com/p/2d79d548c635\">阅读记录——利用httponly提高cookie安全性</a></p>\n<p><a href=\"https://msdn.microsoft.com/en-us/library/ms533046.aspx\">Mitigating Cross-site Scripting With HTTP-only Cookies</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "前端cookie的使用",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "前端cookie的读取"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "前端cookie的写入，设置有效时间"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "前端cookie的删除"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "服务端写入cookie"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "服务端读cookie"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "其他存储方式 localStorage"
            }
          ]
        }
      ],
      "config": {
        "source": "前端cookie的使用.md",
        "staticFileName": "web_cookie.html",
        "author": "guoqzuo",
        "createDate": "2018/10/26",
        "description": "http是基于请求和响应的无状态协议，无法保存状态，如果有数据需要在浏览器关闭后，下次进入还保存，就可以用cookie来解决这个问题。前端cookie可以用document.cookie来读取，格式为key=value;key=value键值对的形式",
        "keywords": "前端cookie的使用,cookie",
        "category": "JavaScript",
        "year": "2018",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"小程序web-view组件内嵌网页调用微信js-sdk\">小程序web-view组件内嵌网页调用微信JS-SDK</h1>\n<p>小程序web-view内置H5可以像公众号H5一样使用JS-SDK，但会有一定的限制，另外对于没有公众号H5调用JS-SDK经验的同学，可能会以为wx.config使用的参数是小程序的信息，下面以调用扫一扫为例子，介绍具体细节</p>\n<p><img src=\"../../../images/blog/mp/mp_jssdk_1.jpeg\" alt=\"mp_jssdk_1.jpeg\"></p>\n<p>小程序内嵌网页调用JSSDK与公众号网页里面调用基本一致，之前公众号h5可以直接嵌入到小程序里面使用，要注意的地方是：</p>\n<ul>\n<li>内嵌网页调用JS-SDK需要使用公众号的appid及appsecret，与小程序的appid没有关系</li>\n<li>小程序内嵌网页只支持部分JSSDK，详情参见： <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/component/web-view.html\">小程序web-view组件</a></li>\n<li>公众号需要将调用接口的域名加入JS接口安全域名，对应的ip加入ip白名单</li>\n</ul>\n<p>这里以调用微信的扫一扫为例子，来体验整个流程，前端html：</p>\n<pre><code class=\"language-html\">&lt;!-- 前端HTML --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\n    &lt;title&gt;扫一扫功能&lt;/title&gt;\n\n    &lt;!-- weui样式 --&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://res.wx.qq.com/open/libs/weui/1.1.2/weui.min.css&quot;&gt;\n\n    &lt;!-- 微信JS-SDK需要引入的js文件 --&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;https://res.wx.qq.com/open/js/jweixin-1.3.2.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div style=&quot;margin:10%&quot;&gt;\n        &lt;button class=&quot;weui-btn&quot; onclick=&quot;startScanning()&quot; style=&quot;background:#336699&quot;&gt;\n            调用扫一扫\n        &lt;/button&gt;\n    &lt;/div&gt;\n    &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.0/jquery.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;/public/js/common.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        // 是否在小程序内部打开的网页\n        function isOpenInWechat() {\n            return (window.__wxjs_environment === &#39;miniprogram&#39;);\n        }\n\n        // 非小程序内部打开，提示错误\n        if (!isOpenInWechat()) {\n            alert(&#39;请在小程序里打开页面&#39;);\n        }\n\n        // 获取signature及对应的时间戳，随机字符串\n        var obj = getSignature();\n\n        // 权限验证\n        wx.config({\n            debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\n            appId: &#39;wx90aaf3035f813f5a&#39;, // 必填，公众号的唯一标识，此处填写企业号corpid\n            timestamp: obj.timestamp, // 必填，生成签名的时间戳\n            nonceStr: obj.noncestr, // 必填，生成签名的随机串\n            signature: obj.signature,// 必填，签名，见附录1\n            jsApiList: [&#39;chooseImage&#39;,&#39;scanQRCode&#39;] // 必填，需要使用的JS接口列表\n        });\n\n        // 请求后台接口，得到signature等\n        function getSignature() {\n            var res = null;\n            // 自己封装的ajax函数，同步执行ajax，发送请求，后台去操作\n            ajax_request(&#39;GET&#39;, &#39;/initialize&#39;, &#39;getSignature&#39;, {}, function(result){\n                res = result;\n            },&#39;sync&#39;);\n            return res;\n        }\n\n        // scan\n        function startScanning() {\n            // 调用微信接口\n            wx.scanQRCode({\n                needResult: 0, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果，\n                scanType: [&quot;qrCode&quot;,&quot;barCode&quot;], // 可以指定扫二维码还是一维码，默认二者都有\n                success: function (res) {\n                    var result = res.resultStr; // 当needResult 为 1 时，扫码返回的结果\n                }\n            });\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>后台使用了nodejs+express，获取signature等信息</p>\n<pre><code class=\"language-js\">// 后台node代码\n\n// 发送get请求依赖\nvar https = require(&#39;https&#39;);\n// SHA 加密\nvar crypto = require(&#39;crypto&#39;);\n\n/**\n * signature 调用了initialize函数\n * 调用微信的接口获取access_token及jsapi_ticket，生成signature。这里只是演示，没有缓存数据\n * 注意调用接口有次数限制。获取access_token | 2000次/每天；获取jsapi_ticket | 1000000次/天\n * 正式环境下业务量大就需要将access_token和jsapi_ticket存入缓存，一般有效期为7200秒。\n */\nfunction initialize(app, data, req, res) {\n    // 获取access_token\n    var url = &#39;https://api.weixin.qq.com/cgi-bin/token&#39;;\n    var appid = &#39;wx90aaf3035f813f5a&#39;;\n    var appsecret = &#39;这里填公众号生成的appsecret&#39;;\n\n    var preRes = res;\n    url += &quot;?grant_type=client_credential&amp;appid=&quot;+appid+&quot;&amp;secret=&quot;+appsecret;\n\n    https.get(url, function(res) {\n        console.log(&quot;Got response: &quot; + res.statusCode);\n\n        res.on(&#39;data&#39;, function (d) {\n            d = JSON.parse(d.toString());\n            console.log(d);\n            var access_token = d.access_token;\n            var ticketUrl = &quot;https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=&quot;;\n            ticketUrl += access_token + &quot;&amp;type=jsapi&quot;;\n\n            // 获取ticket\n            https.get(ticketUrl, function (res) {\n                res.on(&#39;data&#39;, function (d) {\n                    var d = JSON.parse(d.toString());\n                    var jsapi_ticket = d.ticket;\n\n                    var timestamp = new Date().getTime();\n\n                    // 获取随机字符串\n                    // toString()默认是10进账，如果想包含字母，禁止要大于10 toString(32)\n                    // 0.66666666666xx =&gt; &quot;0.66666666666xx&quot; =&gt; &quot;66666666666xx&quot;\n                    var noncestr = Math.random().toString().substr(2);\n\n                    // 这里的url是调用接口时当前的url\n                    var url = &#39;https://zuo11.com/start&#39;;\n                    var targetStr = &quot;jsapi_ticket=&quot; + jsapi_ticket + &quot;&amp;noncestr=&quot;+noncestr+ &quot;&amp;timestamp=&quot;+timestamp + &quot;&amp;url=&quot;+url;\n                    console.log(targetStr);\n\n                    // SHA1加密\n                    var sha1_result = crypto.createHash(&#39;sha1&#39;).update(targetStr).digest(&#39;hex&#39;);\n                    console.log(sha1_result);\n\n                    // 将获取到的signature一级对应的时间错，随机字符串返回给前端\n                    preRes.json({\n                        &#39;signature&#39;: sha1_result,\n                        &#39;noncestr&#39;: noncestr,\n                        &#39;timestamp&#39;: timestamp\n                    })\n                });\n            }).on(&#39;error&#39;, function(e) {\n                console.log(&quot;Got error: &quot; + e.message);\n            });\n        })\n    }).on(&#39;error&#39;, function(e) {\n        console.log(&quot;Got error: &quot; + e.message);\n    });\n\n}</code></pre>\n<p>官方文档：<a href=\"https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115\">微信JS-SDK说明文档</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "小程序web-view组件内嵌网页调用微信JS-SDK"
        }
      ],
      "config": {
        "source": "小程序web-view组件内嵌网页调用微信JS-SDK.md",
        "staticFileName": "mp_jssdk.html",
        "author": "guoqzuo",
        "createDate": "2018/02/24",
        "description": "小程序web-view内置H5可以像公众号H5一样使用JS-SDK，但会有一定的限制，另外对于没有公众号H5调用JS-SDK经验的同学，可能会以为wx.config使用的参数是小程序的信息，下面以调用扫一扫为例子，介绍具体细节",
        "keywords": "web-view jssdk,小程序内嵌H5调用jssdk,微信JS-SDK使用",
        "category": "微信开发",
        "year": "2018",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"使用github的pages功能创建静态个人网站\">使用Github的Pages功能创建静态个人网站</h1>\n<p>本文根据官方文档  <a href=\"https://pages.github.com\">Github Pages</a> 整理</p>\n<p>通过Github Pages这个功能，我们可以创建一个开源的静态个人网站，通过xxx.github.io 可以访问. 示例页面 <a href=\"https://zuoxiaobai.github.io\">https://zuoxiaobai.github.io</a></p>\n<h2 id=\"第一步-创建一个仓库repository\">第一步: 创建一个仓库(repository)</h2>\n<p>仓库的名字必须是username.github.io, 这里的username必须是Github的用户名，我的是 zuoxiaobai.github.io</p>\n<h2 id=\"第二步-直接在该项目新建indexhtml\">第二步: 直接在该项目新建index.html</h2>\n<p>这里上面的教程基本都是先将代码clone到本地，创建index.html再push change，最简单粗暴的方式就是直接在github图形化界面上创建index.html，输入内容 hello world, 访问username.github.io就可以看到hello world了。</p>\n<h2 id=\"后续开发\">后续开发</h2>\n<p>可以用webstorm将代码拉取到本地再修改对应的代码，就可以丰富页面了，可以使用hexo等框架</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "使用Github的Pages功能创建静态个人网站",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "第一步: 创建一个仓库(repository)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "第二步: 直接在该项目新建index.html"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "后续开发"
            }
          ]
        }
      ],
      "config": {
        "source": "使用Github的Pages功能创建静态个人网站.md",
        "staticFileName": "web_github_pages.html",
        "author": "guoqzuo",
        "createDate": "2018/02/25",
        "description": "使用Github的Pages功能创建静态个人网站，通过Github Pages这个功能，我们可以创建一个开源的静态个人网站，通过xxx.github.io 可以访问. 示例页面 https://zuoxiaobai.github.io",
        "keywords": "github pages个人博客,使用github创建个人博客",
        "category": "网站建设与SEO",
        "year": "2018",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"使用hexo搭建个人博客\">使用Hexo搭建个人博客</h1>\n<p>用Github Pages弄了一个简单的页面后，琢磨着用Hexo来搭一个博客。把大致的过程梳理了一下。</p>\n<p>首先百度了Hexo，找到了<a href=\"https://hexo.io/zh-cn/docs/\">Hexo的中文文档</a>，由于之前没接触过，就按着流程一步步来了。</p>\n<h2 id=\"先安装hexo\">先安装Hexo</h2>\n<p>之前已经安装了node 及 git，直接用npm装，全局安装</p>\n<pre><code class=\"language-bash\">npm install -g hexo-cli</code></pre>\n<h2 id=\"创建一个hexo项目-testhexo\">创建一个hexo项目, testHexo</h2>\n<pre><code class=\"language-bash\"># 初始化项目，会在当前目录下创建一个testHexo目录，生成标准的项目结构文件\nhexo init testHexo\n# 进入对应的目录\ncd testHexo\n# 安装项目依赖的一些包\nnpm install</code></pre>\n<p>生成的目录结构如下</p>\n<pre><code class=\"language-bash\">├── _config.yml // 网站的配置信息，您可以在此配置大部分的参数。如标题、语言、git信息，主题等\n├── package.json // 应用程序信息，需要安装的一些npm包信息\n├── scaffolds // 模板文件夹，当写文章时，每次new的文章使用的就是里面的模板\n├── source // 资源文件夹\n| ├── _drafts // 存放草稿目录，我在mac下，初始化没有生成这个目录，可以手动mkdir一个\n| └── _posts // 存放文章的目录，一般是.md格式的文章，展示的核心内容\n└── themes // 主题 文件夹。Hexo 会根据主题来生成静态页面。</code></pre>\n<h2 id=\"运行初始化项目\">运行初始化项目</h2>\n<pre><code class=\"language-bash\">hexo generate # 根据配置，生成静态的项目文件，可简写为 hexo g\nhexo server # 启动服务器。默认情况下，访问网址为： http://localhost:4000/。\n# 访问http://localhost:4000/就可以看到Hexo默认的主题了。只有一篇hello world的文章。</code></pre>\n<h2 id=\"写博客文章\">写博客文章</h2>\n<p>用hex new 写文章后，再运行hexo g;hexo server 就可以看到新的文章了</p>\n<pre><code class=\"language-bash\"># 新建一篇文章\nhexo new 文章标题 # 可以指定使用的模板布局 hexo new [layout] 文章标题\n# 默认会使用scaffolds目录下的post.md模板在source/_posts目录下生成对应的md文件\n# 后面新建分类页和标签页时会使用 pages布局 hexo new page tags\n\n# 打开生成的文件，按照md语法写内容就可以了。最上面用--- ---包含的内容为Front-matter\n# 用来修改标题、时间、标签、分类等\n# 例子:\n---\ntitle: 用Github的Pages功能创建静态个人网站\ndate: 2018-02-25 14:57:10\ncategories:\n- 其他\ntags:\n- Github\n- 个人博客\n---</code></pre>\n<h2 id=\"使用主题themes\">使用主题(themes)</h2>\n<p>不需要样式美化可跳过这一步，直接看后面的项目部署</p>\n<p>页面默认的风格很单一，Hexo有很多主题可以使用，<a href=\"https://www.zhihu.com/question/24422335\">有哪些好看的 Hexo 主题？- 知乎</a></p>\n<p>我选了star最多的next主题 <a href=\"https://github.com/iissnan/hexo-theme-next\">iissnan/hexo-theme-next · GitHub</a></p>\n<p>找到了一个比较易懂的中文文档: <a href=\"http://theme-next.iissnan.com/getting-started.html\">开始使用 - NexT 使用文档</a></p>\n<p>修改网页的标题、下载主题后使用</p>\n<pre><code class=\"language-c\">// 下载next主题到项目的themes/next目录 \n$ git clone https://github.com/iissnan/hexo-theme-next themes/next\n\n// 修改项目目录下_config.yml文件，使用next主题\ntheme: next\n\n// 重新生成一下，hexo g; hexo server 运行项目，就可以看到next主题的效果了</code></pre>\n<p>对主题的一些细节进行配置、修改</p>\n<pre><code class=\"language-c\">// 如果是英文，需要在项目目录下的_config.yml里做修改，注意不是next主题目录下的_config.yml\nlanguage: zh-Hans\n\n// 下面修改的配置是修改的next目录下的_config.yml\n// 修改主题, next有几种主题，我这里选的是Pisces主题\nscheme: Pisces\n// 生成关于、分类、标签页面，默认都是404的\n$ hexo new page about // 这里的内容需要自己写\n$ hexo new page categories  // 会更具写文章时对应的categories来自动载入\n$ hexo new page tags // 会更具写文章时对应的tags来自动载入\n\n// 使用评论系统 disqus（需要翻墙），先去官方申请一个账号或使用google账号登录\n// 登录后 选择 I want to install Disqus on my site，填网站名称等信息就会生成对应的shortname\n# Disqus\ndisqus:\n  enable: true\n  shortname: zuoxiaobais-blog  // 这里填对应的网站shortname\n  count: true\n\n// 使用 hexo g;hexo server 重新生成运行项目就可以看到效果了。</code></pre>\n<h2 id=\"部署代码到zuoxiaobaigithubio\">部署代码到zuoxiaobai.github.io</h2>\n<pre><code class=\"language-c\">// 每次修改配置，或写文章后都需要重新生成静态文件\n$ hexo g \n\n// 配置部署到github，修改项目目录下的_config.yml文件\ndeploy:\n  type: git\n  repo: git@github.com:zuoxiaobai/zuoxiaobai.github.io.git // 这里填仓库（Repository）地址\n  branch: master\n  message: update note // commit信息, 默认为 Site updated: {{ now(&#39;YYYY-MM-DD HH:mm:ss&#39;) }}\n\n// 部署\n$ hexo deploy // 简写为 hexo d \n\n// 看到INFO  Deploy done: git 信息就是部署OK了\n// 通过zuoxiaobai.github.io就可以看到最新改动的内容了\n</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "使用Hexo搭建个人博客",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "先安装Hexo"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "创建一个hexo项目, testHexo"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "运行初始化项目"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "写博客文章"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "使用主题(themes)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "部署代码到zuoxiaobai.github.io"
            }
          ]
        }
      ],
      "config": {
        "source": "使用Hexo搭建个人博客.md",
        "staticFileName": "web_hexo.html",
        "author": "guoqzuo",
        "createDate": "2018/02/26",
        "description": "用Github Pages弄了一个简单的页面后，琢磨着用Hexo来搭一个博客。把大致的过程梳理了一下。首先百度了Hexo，找到了[Hexo的中文文档](https://hexo.io/zh-cn/docs/)，由于之前没接触过，就按着流程一步步来了。",
        "keywords": "使用hexo搭建个人博客,hexo 个人博客",
        "category": "网站建设与SEO",
        "year": "2018",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"github向他人的项目提交代码及添加域名解析\">github向他人的项目提交代码及添加域名解析</h1>\n<h2 id=\"向他人的项目提交代码\">向他人的项目提交代码</h2>\n<p>在Github新建的仓库，如果是项目拥有者，进入项目，就会看到setting的入口，这个位置配置当前项目的一些信息，删除该仓库。如果想要其他的github用户可以把代码直接提交到该仓库，可以在这里把对应的用户名添加到合作者，collaborators下。添加后，对方需要同意，可以把链接发给对方。这样，其他账号就可以直接提交到项目了。使用hexo g 可直接提交生效。</p>\n<h2 id=\"将自己的域名解析到github-pages\">将自己的域名解析到Github Pages</h2>\n<p>如果希望当访问自己的域名时，自动跳转到xxx.github.io的页面，需要两步操作:</p>\n<h3 id=\"将域名解析到github的ip\">将域名解析到github的ip</h3>\n<p>先通过ping自己的xxx.github.io的域名，得到对应的ip，再在域名的管理控制台，将域名解析到这个IP.</p>\n<h3 id=\"设置项目的github-pages\">设置项目的Github Pages</h3>\n<p>在项目的设置页面，Github Pages 里，可以看到Your site is published at <a href=\"https://xxx.github.io%E3%80%82%E5%9C%A8%E4%B8%8B%E9%9D%A2%E7%9A%84Custom\">https://xxx.github.io。在下面的Custom</a> domain里面添加自己的域名，点击保存，就可以了。</p>\n<h3 id=\"关于hexo-d-后需要重新设置custom-domain的问题\">关于hexo d 后需要重新设置custom domain的问题</h3>\n<p>设置自定义解析后，可以通过自己的域名访问对应的项目了，但写一篇文章后，hexo g 提交到仓库后，设置里面默认域名又变成xxx.github.io了，自定义域名的设置失效了。我们可以在hexo工程目录下的source目录下，新建一个名为CNAME的文件，里面写入自定义的域名。之后修改的每次提交就不会出现这种问题了。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "github向他人的项目提交代码及添加域名解析",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "向他人的项目提交代码"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "将自己的域名解析到Github Pages",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "将域名解析到github的ip"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "设置项目的Github Pages"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "关于hexo d 后需要重新设置custom domain的问题"
                }
              ]
            }
          ]
        }
      ],
      "config": {
        "source": "github向他人的项目提交代码及添加域名解析.md",
        "staticFileName": "web_github_push.html",
        "author": "guoqzuo",
        "createDate": "2018/03/04",
        "description": "在Github新建的仓库，如果是项目拥有者，进入项目，就会看到setting的入口，这个位置配置当前项目的一些信息，删除该仓库。如果想要其他的github用户可以把代码直接提交到该仓库，可以在这里把对应的用户名添加到合作者，collaborators下。添加后，对方需要同意，可以把链接发给对方。这样，其他账号就可以直接提交到项目了。使用hexo g 可直接提交生效。",
        "keywords": "github向他人项目提交代码,github使用自定义域名",
        "category": "运维部署与版本控制",
        "year": "2018",
        "month": "3"
      }
    },
    {
      "htmlStr": "<h1 id=\"单行文本截断与多行文本截断\">单行文本截断与多行文本截断</h1>\n<p>文本溢出处理，在HTML5权威指南这本书里是没有讲到这个知识点。一般使用 text-overflow: ellipsis</p>\n<h2 id=\"单行文本截断\">单行文本截断</h2>\n<p>对于单行文本，一般使用text-overflow: ellipsis即可。注意：使用这个样式的前提是需要先给定容器宽度、overflow:hidden等属性，来看一个实例:</p>\n<p><img src=\"../../../images/blog/css/css_text_overflow_1.png\" alt=\"css_text_overflow_1.png\"></p>\n<pre><code class=\"language-html\">&lt;head&gt;\n  &lt;meta chaset=&quot;utf-8&quot;&gt;\n  &lt;title&gt;单行文本截断测试&lt;/title&gt;\n  &lt;style&gt;\n    .test {\n      width: 20em;          /* 指定宽度 */\n      white-space: nowrap;  /* 不换行，如果是span就可以不用这个 */\n      overflow: hidden;     /* 溢出内容隐藏 */\n      text-overflow: ellipsis; /* 文本溢出时显示省略号 */\n    }\n  &lt;/style&gt;\n&lt;head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;test&quot;&gt;\n    我是一个很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的文本\n  &lt;/div&gt;\n&lt;/body&gt;</code></pre>\n<h2 id=\"多行文本截断\">多行文本截断</h2>\n<p>多行文本截断有很多方法，这里主要介绍三种方法，先来看看效果：</p>\n<p><img src=\"../../../images/blog/css/css_text_overflow_2.png\" alt=\"css_text_overflow_2.png\"></p>\n<h3 id=\"1使用伪元素绝对布局用线性渐变背景遮挡\">1.使用伪元素绝对布局用线性渐变背景遮挡</h3>\n<p>使用伪元素选择器，绝对布局，将线性渐变的一个背景覆盖到文本内容的右下角</p>\n<pre><code class=\"language-css\">.method-a {\n  line-height: 1.2rem;\n  max-height: 3.6rem;\n  overflow: hidden;\n  position: relative;\n}\n.method-a::after {\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  width: 30%;\n  max-width: 100px;\n  content: &#39;&#39;;\n  height: 1.2rem;\n  background: linear-gradient(to right, rgba(255,255,255,0), rgba(255,255,255,1) 90%);\n}</code></pre>\n<h3 id=\"2使用line-clamp属性\">2.使用line-clamp属性</h3>\n<p>兼容性方面不怎么好，不支持IE</p>\n<pre><code class=\"language-css\">.method-b {\n  overflow: hidden;\n  display: -webkit-box;\n  -webkit-line-clamp: 3;\n  -webkit-box-orient: vertical;\n}</code></pre>\n<h3 id=\"3使用伪元素绝对布局用遮挡\">3.使用伪元素绝对布局用...遮挡</h3>\n<p>可能会挡住文字内容</p>\n<pre><code class=\"language-css\">.method-c {\n  line-height: 1.2rem;\n  max-height: 3.6rem;\n  overflow: hidden;\n  position: relative;\n}\n.method-c::after {\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  width: 20px;\n  content: &#39;...&#39;;\n  height: 1.2rem;\n  background:white;\n}</code></pre>\n<h3 id=\"完整demo\">完整demo</h3>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;style&gt;\n    .module {\n      width: 300px;\n      margin: 20px;\n    }\n    .module p {\n      margin: 0;\n    }\n    .method-inline {\n      width: 100%;\n      white-space: nowrap;\n      display: inline-block;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n    .method-a {\n      line-height: 1.2rem;\n      max-height: 3.6rem;\n      overflow: hidden;\n      position: relative;\n    }\n    .method-a::after {\n      position: absolute;\n      bottom: 0;\n      right: 0;\n      width: 30%;\n      max-width: 100px;\n      content: &#39;&#39;;\n      height: 1.2rem;\n      background: linear-gradient(to right, rgba(255,255,255,0), rgba(255,255,255,1) 90%);\n    }\n    .method-b {\n      overflow: hidden;\n      display: -webkit-box;\n      -webkit-line-clamp: 3;\n      -webkit-box-orient: vertical;\n    }\n\n    .method-c {\n      line-height: 1.2rem;\n      max-height: 3.6rem;\n      overflow: hidden;\n      position: relative;\n    }\n    .method-c::after {\n      position: absolute;\n      bottom: 0;\n      right: 0;\n      width: 20px;\n      content: &#39;...&#39;;\n      height: 1.2rem;\n      background:white;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;module&quot;&gt;\n    &lt;span class=&#39;method-inline&#39;&gt;单行隐藏：”不忘初心、牢记使命”主题教育从去年5月底开始自上而下分两批进行，目前已基本结束，整个主题教育达到了预期目的，取得了重大成果：各级党组织&lt;/span&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;module&quot;&gt;\n    &lt;p&gt;”不忘初心、牢记使命”主题教育从去年5月底开始自上而下分两批进行，目前已基本结束，整个主题教育达到了预期目的，取得了重大成果：各级党组织和广大党员、干部深入学习实践习近平新时代中国特色社会主义思想&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;module method-a&quot;&gt;\n    &lt;p&gt;”不忘初心、牢记使命”主题教育从去年5月底开始自上而下分两批进行，目前已基本结束，整个主题教育达到了预期目的，取得了重大成果：各级党组织和广大党员、干部深入学习实践习近平新时代中国特色社会主义思想&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;module method-b&quot;&gt;\n    &lt;p&gt;”不忘初心、牢记使命”主题教育从去年5月底开始自上而下分两批进行，目前已基本结束，整个主题教育达到了预期目的，取得了重大成果：各级党组织和广大党员、干部深入学习实践习近平新时代中国特色社会主义思想&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;module method-c&quot;&gt;\n    &lt;p&gt;”不忘初心、牢记使命”主题教育从去年5月底开始自上而下分两批进行，目前已基本结束，整个主题教育达到了预期目的，取得了重大成果：各级党组织和广大党员、干部深入学习实践习近平新时代中国特色社会主义思想&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>参考: <a href=\"https://css-tricks.com/line-clampin/\">Line Clampin&#39; (Truncating Multiple Line Text) | CSS-Tricks</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "单行文本截断与多行文本截断",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "单行文本截断"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "多行文本截断",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "1.使用伪元素绝对布局用线性渐变背景遮挡"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "2.使用line-clamp属性"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "3.使用伪元素绝对布局用...遮挡"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "完整demo"
                }
              ]
            }
          ]
        }
      ],
      "config": {
        "source": "单行文本截断与多行文本截断.md",
        "staticFileName": "css_text_overflow.html",
        "author": "guoqzuo",
        "createDate": "2019/10/08",
        "description": "单行文本截断与多行文本截断，文本溢出处理，在HTML5权威指南这本书里是没有讲到这个知识点。一般使用 text-overflow: ellipsis，对于单行文本，一般使用text-overflow: ellipsis即可。注意：使用这个样式的前提是需要先给定容器宽度、overflow:hidden等属性，来看一个实例",
        "keywords": "单行文本截断,文本溢出处理,多行文本截断,text-overflow: ellipsis,line-clamp",
        "category": "CSS",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"macos安装nginx\">macOS安装nginx</h1>\n<h2 id=\"使用命令安装\">使用命令安装</h2>\n<p>mac下直接使brew install用命令安装，注意：mac自带的xcode不要随意卸载，不然会出各种奇怪的问题: 包括svn安装问题、nginx安装问题等</p>\n<pre><code class=\"language-bash\">brew install nginx</code></pre>\n<p>安装完成后的log如下：</p>\n<pre><code class=\"language-bash\"># brew install nginx 安装后部分log\n==&gt; nginx\nDocroot is: /usr/local/var/www\n\nThe default port has been set in /usr/local/etc/nginx/nginx.conf to 8080 so that\nnginx can run without sudo.\n\nnginx will load all files in /usr/local/etc/nginx/servers/.\n\nTo have launchd start nginx now and restart at login:\n  brew services start nginx\nOr, if you do not want or need a background service you can just run: nginx\nbrew install nginx</code></pre>\n<p>需要保存下2个重要的信息</p>\n<ul>\n<li>Docroot: /usr/local/var/www</li>\n<li>默认配置文件路径 /usr/local/etc/nginx/nginx.conf</li>\n</ul>\n<h2 id=\"开启nginx\">开启nginx</h2>\n<p>直接 sudo nginx 即可，nginx默认占用使用80端口</p>\n<pre><code class=\"language-bash\">kevindeMacBook-Air:~ kevin$ sudo nginx # 一般这里都会成功\nPassword:\nnginx: [emerg] bind() to 0.0.0.0:8080 failed (48: Address already in use)\nnginx: [emerg] bind() to 0.0.0.0:8080 failed (48: Address already in use)\n\n# 我这里运行nginx，出现端口占用的情况，\n# 是由于我之前调试过php，开启了apache服务占用了80端口\n# 我这里将端口修改为81\nkevindeMacBook-Air:~ kevin$ vi /usr/local/etc/nginx/nginx.conf # 打开配置文件修改端口</code></pre>\n<h2 id=\"配置文件修改\">配置文件修改</h2>\n<p>配置文件修改时，如下图所示：</p>\n<p><img src=\"../../../images/blog/ops/ops_mac_install_nginx_2.png\" alt=\"ops_mac_install_nginx_2.png\"></p>\n<h2 id=\"运行效果\">运行效果</h2>\n<p>修改好端口保存后，再sudo nginx，运行nginx，<a href=\"http://127.0.0.1:81/\">http://127.0.0.1:81/</a> 可正常访问，如下图</p>\n<p><img src=\"../../../images/blog/ops/ops_mac_install_nginx_1.png\" alt=\"ops_mac_install_nginx_1.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "macOS安装nginx",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "使用命令安装"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "开启nginx"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "配置文件修改"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "运行效果"
            }
          ]
        }
      ],
      "config": {
        "source": "macOS安装nginx.md",
        "staticFileName": "mac_nginx_install.html",
        "author": "guoqzuo",
        "createDate": "2019/10/08",
        "description": "mac下直接使brew install用命令安装，注意：mac自带的xcode不要随意卸载，不然会出各种奇怪的问题: 包括svn安装问题、nginx安装问题等",
        "keywords": "mac nginx,mac 安装nginx,macos安装nginx,macos nginx,nginx安装",
        "category": "运维部署与版本控制",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"js页面滚动相关操作\">js页面滚动相关操作</h1>\n<p>通过一个URL进入一个页面，需要滚动到对应的锚点位置，可以用什么方法呢，下面我们来总结下页面滚动相关的一些方法，例如：Element.scrollIntoView、window.scroll、window.scrollTo、window.scrollBy、Element.scrollTop等</p>\n<h2 id=\"windowscrollto\">window.scrollTo()</h2>\n<p>滚动到页面指定位置</p>\n<pre><code class=\"language-js\">// https://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollTo\nwindow.scrollTo(x-coord,y-coord )\nwindow.scrollTo(options)\n// * x-coord 是文档中的横轴坐标。\n// * y-coord 是文档中的纵轴坐标。\n// * options 是一个包含三个属性的对象:\n//  1. top 等同于  y-coord\n//  2. left 等同于  x-coord\n//  3. behavior  类型String,表示滚动行为,支持参数 smooth(平滑滚动),instant(瞬间滚动),默认值auto,实测效果等同于instant\n\nwindow.scrollTo( 0, 1000 );\n\n// 设置滚动行为改为平滑的滚动\nwindow.scrollTo({ \n    top: 1000, \n    behavior: &quot;smooth&quot; \n});</code></pre>\n<h2 id=\"windowscroll\">window.scroll()</h2>\n<p>method scrolls the window to a particular place in the document. 滚动到指定位置，与window.scrollTo功能一样，在MDN有这样一行解释: Window.scrollTo() is effectively the same as this method.</p>\n<pre><code class=\"language-js\">// https://developer.mozilla.org/en-US/docs/Web/API/Window/scroll\n// 进入一个有滚动条的页面，打开Chrome的Console来测试\nscroll(0, 50) // 页面y轴滚动了50\nscroll(0, 10000) // 页面直接滚动到了最底部\n\n// 设置滚动行为改为平滑的滚动\nwindow.scroll({ \n    top: 1000, \n    behavior: &quot;smooth&quot; \n});</code></pre>\n<h2 id=\"windowscrollby\">window.scrollBy()</h2>\n<p>相对于当前位置滚动</p>\n<pre><code class=\"language-js\">window.scrollBy(x-coord, y-coord);\nwindow.scrollBy(options)\n// * x是水平滚动的偏移量，单位：像素。\n// * Y 是垂直滚动的偏移量，单位：像素。\n// 正数坐标会朝页面的右下方滚动，负数坐标会滚向页面的左上方。\n\nwindow.scrollBy(0, window.innerHeight);  // 向下滚动 一页(浏览器可视高度)</code></pre>\n<h2 id=\"elementscrolltop与elementscrollleft\">Element.scrollTop与Element.scrollLeft</h2>\n<p>Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。返回文档在垂直方向已滚动的像素值。</p>\n<pre><code class=\"language-js\">document.documentElement.scrollTop = 100 // 页面滚动\n// 获取或设置水平方向的滚动值就可以使用Element.scrollLeft了，如果设置的值 &gt; 滚动距离，会滚动到底</code></pre>\n<h2 id=\"elementscrollintoviewaligntotop\">Element.scrollIntoView(alignToTop)</h2>\n<p>参数是一个布尔值alignToTop，默认为true，滚动到元素顶部，如果设置为false，滚动到元素底部。</p>\n<pre><code class=\"language-js\">document.getElementById(&#39;注意&#39;).scrollIntoView(true)\n// https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView#%E7%A4%BA%E4%BE%8B\ndocument.getElementById(id).scrollIntoView(true)\ndocument.documentElement.scrollBy(0, -70) // 顶部固定有遮挡时，fix方案，70这个值取决于顶部高度\n\n// 下面功能目前还属于实验性功能，兼容性有待提高，暂不考虑\n// element.scrollIntoView(scrollIntoViewOptions); // Object型参数</code></pre>\n<h2 id=\"使用hash\">使用hash</h2>\n<p>url设置hash，可以滚动到对应的id位置，对于有顶部fix的情况，会有遮挡需要处理下。页面再向下滚动一点距离</p>\n<pre><code class=\"language-js\">document.documentElement.scrollBy(0, -70)</code></pre>\n<h2 id=\"vue中vue-router滚动\">vue中vue-router滚动</h2>\n<p>创建Router实例时，可以提供scrollBehavior方法，来设置对应的滚动效果。参考: <a href=\"https://www.yuque.com/guoqzuo/yyxr05/brzgg7#8bab95a6\">vue-router滚动行为</a></p>\n<h2 id=\"end\">end</h2>\n<p>对于非标准的 Window.scrollByLines(), and Window.scrollByPages(). 这里暂不讨论详情参见MDN</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "js页面滚动相关操作",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "window.scrollTo()"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "window.scroll()"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "window.scrollBy()"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Element.scrollTop与Element.scrollLeft"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Element.scrollIntoView(alignToTop)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "使用hash"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "vue中vue-router滚动"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "end"
            }
          ]
        }
      ],
      "config": {
        "source": "js页面滚动相关操作.md",
        "staticFileName": "web_js_scroll.html",
        "author": "guoqzuo",
        "createDate": "2019/10/09",
        "description": "通过一个URL进入一个页面，需要滚动到对应的锚点位置，可以用什么方法呢，下面我们来总结下页面滚动相关的一些方法，例如：Element.scrollIntoView、window.scroll、window.scrollTo、window.scrollBy、Element.scrollTop等",
        "keywords": "js页面滚动,页面滚动,scroll,scrollTo,scrollBy,scrollTop,scrollLeft,scrollIntoView,使用hash滚动,vue中vue-router滚动",
        "category": "JavaScript",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue中img的src是动态参数时不显示的问题\">Vue中img的src是动态参数时不显示的问题</h1>\n<p>在vue 2.x中，img的src如果是变量，会出现无法显示的问题，需要使用require才行</p>\n<pre><code class=\"language-html\">&lt;!-- 使用require来加载图片 --&gt;\n&lt;img :src=&quot;&#39;url ? url : require(../assets/images/avatar.png)&quot;&gt;</code></pre>\n<p>参考: <a href=\"https://blog.csdn.net/laishaojiang/article/details/80950995\">Vue中img的src是动态渲染时不显示</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue中img的src是动态参数时不显示的问题"
        }
      ],
      "config": {
        "source": "Vue中img的src是动态参数时不显示的问题.md",
        "staticFileName": "vue_img_src_var.html",
        "author": "guoqzuo",
        "createDate": "2019/10/09",
        "description": "在Vue2.x中img的src如果是动态参数，图片会无法显示，需要使用require来加载图片",
        "keywords": "vue img src图片加载不了,Vue中img的src是动态参数时不显示的问题,vue 图片src是变量时无法显示",
        "category": "Vue",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"element使用js全局触发消息\">Element使用JS全局触发消息</h1>\n<p>在Vue中，单文件组件xx.vue里如果想触发ElementUI的提示消息（如错误信息、警告信息），怎么通过一行js就能触发呢？下面来看看调用方法</p>\n<h2 id=\"1在mainjs里引入element\">1.在main.js里引入Element</h2>\n<pre><code class=\"language-js\">// main.js\nimport Vue from &#39;vue&#39;\nimport ElementUI from &#39;element-ui&#39; // 这里\nimport &#39;element-ui/lib/theme-chalk/index.css&#39;\n\nVue.use(ElementUI)</code></pre>\n<h2 id=\"2将element的相关函数绑定到vue实例属性\">2.将Element的相关函数绑定到Vue实例属性</h2>\n<p>将Element的相关函数绑定到Vue实例属性，绑定到实例属性后，就可以全局调用了，在单文件组件里 this.$xxx 就可以调用了。</p>\n<pre><code class=\"language-js\">// main.js\n// 在 Vue.use(ElementUI) 后\nVue.prototype.$message = ElementUI.Message\nVue.prototype.$alert = ElementUI.MessageBox.alert\nVue.prototype.$confirm = MessageBox.confirm\nVue.prototype.$notify = ElementUI.Notification</code></pre>\n<h2 id=\"3在单文件组件xxvue中调用\">3.在单文件组件xx.vue中调用</h2>\n<p>以消息提示为例子，介绍怎么在单文件组件中触发Element全局的消息提示</p>\n<pre><code class=\"language-js\">// 触发消息提示\nthis.$message({\n  type: &#39;error&#39;, // warning、success\n  message: &#39;这是一条消息&#39; \n})\n\n// 错误信息\nthis.$message.error(&#39;错误提示信息&#39;)\n\n// 示例\ntry {\n\n} catch(e) {\n  // 当捕捉到错误时提示错误信息\n  this.$message.error(e.message)\n}</code></pre>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7\">Vue 实例属性</a></li>\n<li><a href=\"https://element.eleme.cn/#/zh-CN/component/quickstart\">组件 | Element - 快速上手</a></li>\n<li><a href=\"https://element.eleme.cn/#/zh-CN/component/message\">Element Message 消息提示</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Element使用JS全局触发消息",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "1.在main.js里引入Element"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "2.将Element的相关函数绑定到Vue实例属性"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "3.在单文件组件xx.vue中调用"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "Element使用JS全局触发消息.md",
        "staticFileName": "vue_element_globalmsg.html",
        "author": "guoqzuo",
        "createDate": "2019/10/10",
        "description": "在Vue中，单文件组件xx.vue里如果想触发ElementUI的提示消息（如错误信息、警告信息），怎么通过一行js就能触发呢？下面来看看调用方法",
        "keywords": "elementUI 全局触发消息,element使用js全局触发消息,element提示错误信息,element message,element 提示信息",
        "category": "Vue",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"前端ajax请求时，设置cookie请求头无效\">前端ajax请求时，设置Cookie请求头无效</h1>\n<p>前端设置请求头无效，header 设置cookie 无效，ajax 强制设置cookie无效，在前端mock接口时，对于需要设置请求头校验的情况，可能会想着在前端发送请求时设置对应的请求头，但发现前端设置了Cookie请求头，会出错。这是什么原因呢？</p>\n<p>查资料后，了解到在前端发送AJAX请求时，有些请求头是无法设置的，比如：</p>\n<pre><code class=\"language-js\">Accept-Charset\nAccept-Encoding\nAccess-Control-Request-Headers\nAccess-Control-Request-Method\nConnection\nContent-Length\nCookie\nCookie2\nDate\nDNT\nExpect\nHost\nKeep-Alive\nOrigin\nProxy-\nSec-\nReferer\nTE\nTrailer\nTransfer-Encoding\nUpgrade\nVia</code></pre>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\">Forbidden header name - MDN Web Docs Glossary: Definitions of Web-related terms | MDN</a></li>\n<li><a href=\"https://blog.csdn.net/qq_33679504/article/details/80736865\">前端设置Cookie请求头报错 Refused to set unsafe header Cookie_JavaScript_Lan77-CSDN博客</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "前端ajax请求时，设置Cookie请求头无效"
        }
      ],
      "config": {
        "source": "前端ajax请求时，设置Cookie请求头无效.md",
        "staticFileName": "http_request_header.html",
        "author": "guoqzuo",
        "createDate": "2019/10/10",
        "description": "前端设置请求头无效，header 设置cookie 无效，ajax 强制设置cookie无效，在前端mock接口时，对于需要设置请求头校验的情况，可能会想着在前端发送请求时设置对应的请求头，但发现前端设置了Cookie请求头，会出错。这是什么原因呢？",
        "keywords": "ajax中请求头的cookie,是否可以手动更改,前端设置请求头无效,Refused to set unsafe header Cookie,前端设置cookie请求头无效,axios添加请求头不生效,",
        "category": "http与https",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"urlsearchparams-url查询字符串处理\">URLSearchParams URL查询字符串处理</h1>\n<p>一般在通过url传参时会使用查询字符串，一般使用字符串相加的方法，当参数比较多时，就显得不够优雅了，这时就可以使用专门用于处理 URL 查询字符串API: URLSearchParams</p>\n<h2 id=\"以面向对象的方法操作查询字符串\">以面向对象的方法操作查询字符串</h2>\n<pre><code class=\"language-js\">var searchParams = new URLSearchParams()\nsearchParams.append(&#39;a&#39;, 1212)\nsearchParams.append(&#39;b&#39;, &#39;xxx&#39;)\nsearchParams.toString()   // &quot;a=1212&amp;b=xxxx&quot;\n\n// 传参\nvar paramsString = &quot;q=URLUtils.searchParams&amp;topic=api&quot;\nvar searchParams = new URLSearchParams(paramsString);\n\nfor (let p of searchParams) {\n  console.log(p);\n}\n// 打印值\n// [&quot;q&quot;, &quot;URLUtils.searchParams&quot;]\n// [&quot;topic&quot;, &quot;api&quot;]</code></pre>\n<h2 id=\"urlsearchparams构造函数注意事项\">URLSearchParams构造函数注意事项</h2>\n<p>URLSearchParams构造函数不会解析完整 URL，但是如果字符串起始位置有 ? 会被去除，如果需要处理完整的url，可以先用new URL(url)中转一下</p>\n<pre><code class=\"language-js\">var paramsString1 = &quot;http://example.com/search?query=%40&quot;;\nvar searchParams1 = new URLSearchParams(paramsString1);\n\nsearchParams1.has(&quot;query&quot;); // false \nsearchParams1.has(&quot;http://example.com/search?query&quot;); // true\n\nsearchParams1.get(&quot;query&quot;); // null\nsearchParams1.get(&quot;http://example.com/search?query&quot;); // &quot;@&quot; (equivalent to decodeURIComponent(&#39;%40&#39;))\n\nvar paramsString2 = &quot;?query=value&quot;;\nvar searchParams2 = new URLSearchParams(paramsString2);\nsearchParams2.has(&quot;query&quot;); // true \n\nvar url = new URL(&quot;http://example.com/search?query=%40&quot;);\nvar searchParams3 = new URLSearchParams(url.search);\nsearchParams3.has(&quot;query&quot;) // true</code></pre>\n<h2 id=\"结合objectfromentries解析查询字符串\">结合Object.fromEntries解析查询字符串</h2>\n<p>Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。</p>\n<pre><code class=\"language-js\">Object.fromEntries([\n  [&#39;foo&#39;, &#39;bar&#39;],\n  [&#39;baz&#39;, 42]\n])\n// { foo: &quot;bar&quot;, baz: 42 }\n\n// 用来处理查询字符串\nObject.fromEntries(new URLSearchParams(&#39;foo=bar&amp;baz=qux&#39;))\n// { foo: &quot;bar&quot;, baz: &quot;qux&quot; }</code></pre>\n<p>注意：<strong>Object.fromEntries() 暂时不支持 Edge、IE，详情参见下面的MDN文档链接</strong></p>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://www.yuque.com/guoqzuo/js_es6/rxu7ms#e6a375d4\">Object.fromEntries() - 对象的扩展与新增方法 | 语雀</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries\">Object.fromEntries() - MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams\">URLSearchParams - Web API 接口参考 | MDN</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "URLSearchParams URL查询字符串处理",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "以面向对象的方法操作查询字符串"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "URLSearchParams构造函数注意事项"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "结合Object.fromEntries解析查询字符串"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "URLSearchParams URL查询字符串处理.md",
        "staticFileName": "web_url_searchparams.html",
        "author": "guoqzuo",
        "createDate": "2019/10/10",
        "description": "一般在通过url传参时会使用查询字符串，一般使用字符串相加的方法，当参数比较多时，就显得不够优雅了，这时就可以使用专门用于处理 URL 查询字符串API: URLSearchParams",
        "keywords": "URLSearchParams URL查询字符串处理,url查询字符串处理,URLSearchParams,处理查询字符串优雅的方法",
        "category": "JavaScript",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-v-cloak指定防止页面内容显示抖动的问题\">vue v-cloak指定防止页面内容显示抖动的问题</h1>\n<p>v-clock主要用于防止由于网络原因vue.js未渲染时，页面显示类似 {{username}} 的问题，下面来看看实现</p>\n<pre><code class=\"language-html\">&lt;!-- 加上 v-clock 指令--&gt;\n&lt;div v-cloak&gt;\n  {{message/}}\n&lt;/div&gt;</code></pre>\n<p><strong>记住，需要配合css来使用</strong></p>\n<blockquote>\n<p>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p>\n</blockquote>\n<pre><code class=\"language-css\">/* 当编译完成后，v-clock属性会被自动移除。*/ \n[v-cloak] {\n  display: none;\n}</code></pre>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/api/#v-cloak\">v-cloak | vue.js</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue v-cloak指定防止页面内容显示抖动的问题"
        }
      ],
      "config": {
        "source": "vue v-cloak指定防止页面内容显示抖动的问题.md",
        "staticFileName": "vue_v_clock.html",
        "author": "guoqzuo",
        "createDate": "2019/10/11",
        "description": "v-clock主要用于防止由于网络原因vue.js未渲染时，页面显示类似 {{username}} 的问题，下面来看看实现",
        "keywords": "v-clock,vue v-clock,页面显示前vue未渲染内容一闪而过的问题,vue页面显示抖动",
        "category": "Vue",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"axios请求拦截与响应拦截\">axios请求拦截与响应拦截</h1>\n<p>axios提供了请求拦截与响应拦截的函数axios.interceptors，请求拦截器有什么用呢？具体怎么使用？下面来看看</p>\n<h2 id=\"请求拦截函数\">请求拦截函数</h2>\n<p>向后台发起实际请求前，会进入axios.interceptors.request，参数config是请求的相关参数。作用如下</p>\n<ol>\n<li>可以对请求参数作出一些配置。<strong>比如加一些公共参数</strong></li>\n<li>在函数里面可以接触发全局的loading提示，一般可以用于移动端</li>\n</ol>\n<pre><code class=\"language-js\">// axios.interceptors.request.use(resolve func, reject func)\n// Add a request interceptor\naxios.interceptors.request.use(async function (config) {\n  // Do something before request is sent\n  console.log(&#39;request 拦截: &#39;, config)\n\n  // 为所有请求加一个时间戳参数\n  config.url  += (config.url.includes(&#39;?&#39;) ? &#39;&amp;&#39; : &#39;?&#39;)  + &#39;t=&#39; + (+new Date())\n  // Request URL: https://zuo11.com/getList?num=5&amp;start=5&amp;t=1575620590972\n\n  await new Promise((resolve, reject) =&gt; {\n    console.log(&#39;开始等待中...&#39;)\n    setTimeout(()=&gt; {\n      resolve(&#39;结束等待&#39;)\n    }, 5000)\n  })\n\n  return config; // 用来请求的参数\n}, function (error) {\n  // Do something with request error\n  return Promise.reject(error);\n});</code></pre>\n<p>config 里的内容，包括url，method，参数等</p>\n<pre><code class=\"language-js\">// axios.get(&#39;https://zuo11.com/getList?num=5&amp;start=5&#39;) 请求后config内容\n// 打印内容格式如下：\n// {\n//   &quot;url&quot;: &quot;https://zuo11.com/getList?num=5&amp;start=5&quot;,\n//   &quot;data&quot;: undefined\n//   &quot;method&quot;: &quot;get&quot;,\n//   &quot;headers&quot;: {\n//     &quot;common&quot;: {\n//       &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;\n//     }\n//   },\n//   &quot;timeout&quot;: 0,\n//   &quot;xsrfCookieName&quot;: &quot;XSRF-TOKEN&quot;,\n//   &quot;xsrfHeaderName&quot;: &quot;X-XSRF-TOKEN&quot;,\n//   &quot;maxContentLength&quot;: -1\n// }</code></pre>\n<h2 id=\"响应拦截函数\">响应拦截函数</h2>\n<p>后端接收到请求处理后，响应给前端，axios请求 Promise状态变更，进入then后面的逻辑前，会进入响应拦截的逻辑，作用如下</p>\n<ol>\n<li>对某个特定的错误码处理，比如返回登录过期的code，指定重定向到登录页，而不用每次请求都处理</li>\n<li>返回数据过滤，一般返回的data位于 res.data.data 可以将结果过滤为res.data，使用更方便</li>\n</ol>\n<pre><code class=\"language-js\">// axios.interceptors.response.use(resolve func, reject func)\n// Add a response interceptor\naxios.interceptors.response.use(function (response) {\n  // Any status code that lie within the range of 2xx cause this function to trigger\n  // Do something with response data\n  console.log(&#39;响应拦截&#39;, response)\n\n  // 如果身份校验失败，返回登录页\n  response.data.code === 111  &amp;&amp; (window.location.href = response.data)\n\n  return response.data // 过滤掉除data参数外的其它参数，响应接收到的值。\n  // return response;\n}, function (error) {\n  // Any status codes that falls outside the range of 2xx cause this function to trigger\n  // Do something with response error\n  return Promise.reject(error);\n});</code></pre>\n<h2 id=\"执行顺序问题\">执行顺序问题</h2>\n<ol>\n<li>先执行请求拦截（特意在拦截中加了一个阻塞5s的await）</li>\n<li>向后端发送请求</li>\n<li>触发响应拦截(这里也可能存在等待时间)</li>\n<li>最后才会执行axios请求then后面的内容</li>\n</ol>\n<h2 id=\"完整demo\">完整demo</h2>\n<p>代码以放到github: <a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/axios%E6%8B%A6%E6%88%AA%E5%99%A8/index.html\">axios拦截器demo - github</a></p>\n<pre><code class=\"language-html\">&lt;!-- demo --&gt;\n&lt;body&gt;\n  &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    // Add a request interceptor\n    axios.interceptors.request.use(async function (config) {\n      // Do something before request is sent\n      console.log(&#39;request 拦截: &#39;, config)\n\n      // 为所有请求加一个时间戳参数\n      config.url  += (config.url.includes(&#39;?&#39;) ? &#39;&amp;&#39; : &#39;?&#39;)  + &#39;t=&#39; + (+new Date())\n      // Request URL: https://zuo11.com/getList?num=5&amp;start=5&amp;t=1575620590972\n\n      await new Promise((resolve, reject) =&gt; {\n        console.log(&#39;开始等待中...&#39;)\n        setTimeout(()=&gt; {\n          resolve(&#39;结束等待&#39;)\n        }, 5000)\n      })\n\n      return config; // 用来请求的参数\n    }, function (error) {\n      // Do something with request error\n      return Promise.reject(error);\n    });\n\n    // Add a response interceptor\n    axios.interceptors.response.use(function (response) {\n      // Any status code that lie within the range of 2xx cause this function to trigger\n      // Do something with response data\n      console.log(&#39;响应拦截&#39;, response)\n\n      // 如果身份校验失败，返回登录页\n      response.data.code === 111  &amp;&amp; (window.location.href = response.data)\n\n      return response.data // 过滤掉除data参数外的其它参数，响应接收到的值。\n      // return response;\n    }, function (error) {\n      // Any status codes that falls outside the range of 2xx cause this function to trigger\n      // Do something with response error\n      return Promise.reject(error);\n    });\n\n    axios.get(&#39;https://zuo11.com/getList?num=5&amp;start=5&#39;).then((res) =&gt; {\n      console.log(&#39;请求成功，&#39;, res)\n    }, (err)=&gt; {\n      console.log(&#39;请求发生了错误,&#39;, err)\n    })\n  &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p>参考文档: <a href=\"https://github.com/axios/axios#interceptors\">https://github.com/axios/axios#interceptors</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "axios请求拦截与响应拦截",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "请求拦截函数"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "响应拦截函数"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "执行顺序问题"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "完整demo"
            }
          ]
        }
      ],
      "config": {
        "source": "axios请求拦截与响应拦截.md",
        "staticFileName": "http_axios_interceptors.html",
        "author": "guoqzuo",
        "createDate": "2019/10/12",
        "description": "axios提供了请求拦截与响应拦截的函数axios.interceptors，请求拦截器有什么用呢？具体怎么使用？下面来看看",
        "keywords": "axios请求拦截,axios响应拦截,axios.interceptors,axios拦截器",
        "category": "http与https",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"全局修改element组件样式而不影响其他页面\">全局修改element组件样式而不影响其他页面</h1>\n<p>改element样式不影响其他，element全局样改element样式不影响其他式，修改element样式如何不影响同类其他组件？vue项目中，虽然UI基于element设计，但有些情况还是需要修改element组件的默认样式，怎么修改element的默认样式呢</p>\n<p>.vue单文件组件style元素加上scope后，当前页面修改el-tree的默认样式无效需要去掉scope，将样式暴露到全局，</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n&lt;/template&gt;\n&lt;script&gt;\n&lt;/script&gt;\n&lt;style lang=&#39;less&#39; scoped&gt;\n  /* 这里面如果修改element样式可能会不生效，需要去掉  scoped ,将样式暴露到全局 */\n&lt;/style&gt;</code></pre>\n<p>当样式暴露到全局后，怎么避免影响其他样式呢，需要使用一个class来包裹，防止造成全局污染</p>\n<pre><code class=\"language-html\">&lt;style lang=&quot;less&quot;&gt;\n  .root-menu-left {\n    /* el样式修改 */  \n  }\n&lt;/style&gt;</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "全局修改element组件样式而不影响其他页面"
        }
      ],
      "config": {
        "source": "全局修改element组件样式而不影响其他页面.md",
        "staticFileName": "css_global.html",
        "author": "guoqzuo",
        "createDate": "2019/10/12",
        "description": "改element样式不影响其他，element全局样式，修改element样式如何不影响同类其他组件？vue项目中，虽然UI基于element设计，但有些情况还是需要修改element组件的默认样式，怎么修改element的默认样式呢",
        "keywords": "element全局样式,全局修改element组件样式而不影响其他页面,修改element默认样式",
        "category": "CSS",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"2020-vscode配置eslint保存后自动fix\">2020 vscode配置eslint保存后自动fix</h1>\n<p>vscode默认的autofix只能fix js格式文件(.js)，无法fix vue格式文件(.js)，怎么设置ctrl+s保存后自动fix呢？</p>\n<p>需要修改eslint的配置文件</p>\n<h2 id=\"在扩展里搜索eslint找到设置入口\">在扩展里搜索eslint找到设置入口</h2>\n<p>点击第三方扩展，搜索eslint，如果没安装先安装，点击管理按钮。如下图：</p>\n<p><img src=\"../../../images/blog/devtools/vscode_autofix_1.png\" alt=\"vscode_autofix_1.png\"></p>\n<p>点击配置扩展扩展设置</p>\n<p><img src=\"../../../images/blog/devtools/vscode_autofix_2.png\" alt=\"vscode_autofix_2.png\"></p>\n<p>点击在settings.json里编辑</p>\n<p><img src=\"../../../images/blog/devtools/vscode_autofix_3.png\" alt=\"vscode_autofix_3.png\"></p>\n<h2 id=\"eslint插件新版本保存自动fix配置变更\">ESLint插件新版本保存自动fix配置变更</h2>\n<p>最近换了个办公电脑，重装了vscode，发现eslint的配置和以前不一样了，新版本废弃了原先的一些配置，配置更简洁了，最新配置vscode自动fix</p>\n<pre><code class=\"language-js\">{\n  &quot;editor.codeActionsOnSave&quot;: {\n    &quot;source.fixAll&quot;: true\n  }\n}</code></pre>\n<p>The old <code>eslint.autoFixOnSave</code> setting is now deprecated and can safely be removed</p>\n<p><strong>ESLint插件检测、自动修复机制，依赖当前目录下的package.json对应的eslint配置</strong>，vue项目、node项目、react项目、ts支持都对应不同的npm依赖包，比较难以理解</p>\n<p><strong>另外如果项目目录层级太深，可能会导致插件不生效，尽量保持在vscode中打开的目录下就有package.json，而不是套多个层级</strong></p>\n<p><strong>当我们从远程仓库拉取vue项目代码后，在没有npm install的情况下，vscode的eslint插件不会起任何作用，需要npm install 安装必要的插件后，重启vscode，才会生效</strong></p>\n<h2 id=\"旧eslint插件版本配置\">旧eslint插件版本配置</h2>\n<p><code>eslint.autoFixOnSave</code>未被废弃时，保存后自动fix配置</p>\n<pre><code class=\"language-json\">{\n  &quot;edit.formatOnSave&quot;: false,   // 取消自带fix，使用eslint自动保存fix\n  &quot;eslint.autoFixOnSave&quot;: true, // 每次保存的时候将代码按eslint格式进行修复\n  &quot;eslint.validate&quot;: [\n    &quot;javascript&quot;,\n    &quot;javascriptreact&quot;,\n    {\n      &quot;language&quot;: &quot;vue&quot;,\n      &quot;autoFix&quot;: true\n    },\n    &quot;html&quot;\n  ]\n}</code></pre>\n<h2 id=\"自动fix偶尔失效的问题\">自动fix偶尔失效的问题</h2>\n<p>有时候ctrl+s保存后自动fix失效了，可能是工具的bug，关闭vscode重新打开可能就好了。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "2020 vscode配置eslint保存后自动fix",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "在扩展里搜索eslint找到设置入口"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "ESLint插件新版本保存自动fix配置变更"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "旧eslint插件版本配置"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "自动fix偶尔失效的问题"
            }
          ]
        }
      ],
      "config": {
        "source": "2020 vscode配置eslint保存后自动fix.md",
        "staticFileName": "devtools_autofix.html",
        "author": "guoqzuo",
        "createDate": "2019/10/12",
        "description": "2020/06/17更新，vscode最新eslint插件保存自动fix配置，vscode 保存执行fix, eslint 保存自动fix, vscode默认的autofix只能fix js格式文件(.js)，无法fix vue格式文件(.js)，怎么设置ctrl+s保存后自动fix呢？",
        "keywords": "vscode 保存自动fix,vscode 保存执行fix,eslint 保存自动fix,vscode 配置eslint保存后自动fix.md,vscode ctrl+s后自动fix,eslint 自动fix,vscode 自动fix,react vscode 自动保存,vscode *.ts 自动fix,eslint 保存的时候自动执行 --fix",
        "category": "计算机基础与开发工具",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"fffff与fff的区别\">#fffff与#fff的区别</h1>\n<p>css的颜色可以使用rgb和十六进制表示法。有时十六进制色彩是6位，而有时是3位，比如白色可以是#ffffff，也可以写成#fff。有什么区别呢？</p>\n<ol>\n<li><p>一般3位是6位的缩写，比如#ccc就是#cccccc的缩写。</p>\n</li>\n<li><p>并不是所有的都可以缩写，必须符合一定的格式。</p>\n</li>\n</ol>\n<pre><code class=\"language-js\">// 缩写都是以每两位为缩写的单位\n// #abc  =&gt; #aabbcc\n// #1D2  =&gt; #11DD22</code></pre>\n<p>最后注意：<strong>与移动端原生交互时，颜色尽量不要使用缩写，可能会显示异常</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "#fffff与#fff的区别"
        }
      ],
      "config": {
        "source": "#ffffff与#fff的区别.md",
        "staticFileName": "css_hex_color.html",
        "author": "guoqzuo",
        "createDate": "2019/10/12",
        "description": "css的颜色可以使用rgb和十六进制表示法。有时十六进制色彩是6位，而有时是3位，比如白色可以是#ffffff，也可以写成#fff。有什么区别呢？",
        "keywords": "#ffffff与#fff的区别,css颜色简写,十六进制颜色简写",
        "category": "CSS",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"滚动条滚到底部消失的问题\">滚动条滚到底部消失的问题</h1>\n<p>在写一个功能时，测试反馈一个关于滚动条的bug，当菜单子项非常多时，滚动条滚到底部时滚动条居然消失了。</p>\n<p><strong>最后debug发现是高度设置的有问题</strong></p>\n<pre><code class=\"language-css\">/* 没有减去top区域高度， 减去就好了 */\nmin-height: calc(100vh - top高度)</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "滚动条滚到底部消失的问题"
        }
      ],
      "config": {
        "source": "滚动条滚到底部消失的问题.md",
        "staticFileName": "css_scroll_disappear.html",
        "author": "guoqzuo",
        "createDate": "2019/10/15",
        "description": "在写一个功能时，测试反馈一个关于滚动条的bug，当菜单子项非常多时，滚动条滚到底部时滚动条居然消失了。",
        "keywords": "滚动条滚到底部消失的问题",
        "category": "CSS",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-deep-样式\">vue /deep/ 样式</h1>\n<p>vue /deep/什么意思呢？/deep/ 样式为深度选择器，Vue单文件组件中如果style标签有scope属性，当前页面定义的样式对子组件会不生效。如果想让某些样式在子组件里面生效，可以使用/deep/</p>\n<p>一般对于 layout.vue 这样的父组件，如果多个子组件有通用的样式可以抽取出来到当前页面，然后使用 /deep/ 使子组件也继承对应的样式</p>\n<pre><code class=\"language-html\">&lt;style lang=&quot;less&quot; scoped&gt;\n/deep/ .el-checkbox {\n  min-width: 180px;\n  margin-bottom: 4px;\n}  \n&lt;/style&gt;</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue /deep/ 样式"
        }
      ],
      "config": {
        "source": "vue deep样式.md",
        "staticFileName": "vue_css_deep.html",
        "author": "guoqzuo",
        "createDate": "2019/10/16",
        "description": "vue /deep/什么意思呢？/deep/ 样式为深度选择器，Vue单文件组件中如果style标签有scope属性，当前页面定义的样式对子组件会不生效。如果想让某些样式在子组件里面生效，可以使用/deep/",
        "keywords": "vue /deep/什么意思,/deep/,/deep/深度选择器,vue /deep/",
        "category": "Vue",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"eslint禁止在return语句中使用赋值\">eslint禁止在return语句中使用赋值</h1>\n<p>在项目中，有一次为了少写一行，将设置值和return语句写成了一行，发现eslint报错，为什么会有这个错误呢？下面我们来看看。</p>\n<h2 id=\"在项目中使用的代码\">在项目中使用的代码</h2>\n<pre><code class=\"language-js\">// xx.vue 代码methods片段\ntest() {\n  // 更改data里message的值，且返回\n  return this.message = &#39;some value&#39;\n}</code></pre>\n<p>eslint 对应的限制规则是 <strong>no-return-assign</strong></p>\n<pre><code class=\"language-js\">function doSomething() {\n  return foo = bar + 2\n}</code></pre>\n<h2 id=\"官方的解释\">官方的解释</h2>\n<p>为什么会禁止return里赋值了，官方的解释是：<strong>对于上面的代码，很难说明return的意图，该函数返回的结果是bar + 2 为什么要赋值给foo，目的还可能是比较运算符，如 ==，这样会存在歧义</strong>，因此最好不要在return语句中使用赋值操作</p>\n<h2 id=\"怎么消除vscode红色标记提示\">怎么消除vscode红色标记提示?</h2>\n<p>鼠标移动到错误的位置，直到出现快速修复的按钮，选择Disabled no-return-assgin for this line，就会添加异常注释，// eslint-disabled-next-line on-return-assign</p>\n<p>为了增强代码可读性有些自动修复去掉的括号可以加上，在配合上面的注释即可让eslint忽略</p>\n<p>参考: <a href=\"https://eslint.org/docs/rules/no-return-assign\">no-return-assign - Rules - ESLint - Pluggable JavaScript linter</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "eslint禁止在return语句中使用赋值",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "在项目中使用的代码"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "官方的解释"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "怎么消除vscode红色标记提示?"
            }
          ]
        }
      ],
      "config": {
        "source": "eslint禁止在return语句中使用赋值.md",
        "staticFileName": "devtools_eslint.html",
        "author": "guoqzuo",
        "createDate": "2019/10/17",
        "description": "在项目中，有一次为了少写一行，将设置值和return语句写成了一行，发现eslint报错，为什么会有这个错误呢？下面我们来看看。",
        "keywords": "eslintno-return-assign,eslint禁止在return中使用赋值,no-return-assign, eslint no-return-assign",
        "category": "计算机基础与开发工具",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"下载文件进度显示以及koa下载接口mock\">下载文件进度显示以及koa下载接口mock</h1>\n<p>在前端做导出功能的时候，需要请求一个接口去导出数据，一般是execl，然后接口会返回execl的文件数据。对于比较大的文件，我们怎么获取文件的下载进度呢？前端怎么用koa来mock导出的接口呢？下面来看看</p>\n<h2 id=\"前端代码\">前端代码</h2>\n<p>用input写一个导出按钮，用progress div来显示进度信息</p>\n<pre><code class=\"language-html\">&lt;input type=&quot;button&quot; value=&quot;导出&quot; id=&quot;export&quot;&gt;\n&lt;div id=&quot;progress&quot;&gt;&lt;/div&gt;</code></pre>\n<p>再用js来监听导出的点击事件，如果用传统的window.open来打开文件，这样会没有进度信息，我们为了获取进度信息，还是直接用axios来发起请求进行下载文件，下面来看代码:</p>\n<pre><code class=\"language-html\">&lt;!-- 利用axios来做请求 --&gt;\n&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n  let exportBtn = document.getElementById(&#39;export&#39;)\n  let progress = document.getElementById(&#39;progress&#39;)\n  // 导出事件点击\n  exportBtn.onclick = async (e) =&gt; {\n    try {\n      let res = await axios.get(&#39;/download&#39;, {\n        // 参考: https://github.com/axios/axios#request-config\n        onDownloadProgress: function (progressEvent) {\n          // Do whatever you want with the native progress event\n          console.log(progressEvent)\n          progress.innerHTML = `\n          下载百分比:\n          ${ Math.floor((progressEvent.loaded / progressEvent.total) * 100)} %\n          ${progressEvent.loaded} / ${progressEvent.total}\n          `\n        },\n      })\n      console.log(res)\n\n      // res.data 为文件的buffer数据，将buffer数据转为Blob对象，然后再下载\n      // 假设下载的是一个x-tar文件\n      // 下载文件\n      downloadFile(res.data, &#39;application/x-tar&#39;, &#39;这是一个文件&#39;)\n    } catch(e) {\n      console.error(e)\n    }\n  }\n&lt;/script&gt;</code></pre>\n<h2 id=\"通用下载函数\">通用下载函数</h2>\n<p>一般使用a便签来下载，IE进行特殊处理</p>\n<pre><code class=\"language-js\">// data 后端返回的文件数据\nfunction downloadFile(data, fileType, fileName) {\n  // window.open(dataUrl)\n\n  // fileType 文件的MIME类型\n  // 参考: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types\n  const blobData = new Blob([data], {\n    type: fileType \n  })\n  console.log(blobData) // 检查数据是否正常\n\n  // 如果是IE，特殊处理，防止IE下提提示 &quot;拒绝访问&quot;\n  // blob拒绝访问文件 fix\n  if (window.navigator.msSaveBlob) {\n    try {\n      // 根据实际情况加后缀名\n      window.navigator.msSaveBlob(blobData, fileName, + &#39;.tar&#39;)\n    } catch(e) {\n      console.log(&#39;msSaveBlob异常&#39;, e)\n    }\n    return\n  }\n\n  // 创建下载链接，并触发下载\n  // https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a#浏览器兼容性\n  // &lt;a&gt; download attribute not support IE, iOS safari\n  const dataUrl = window.URL.createObjectUrl(blobData)\n  const downloadElement = document.createElement(&#39;a&#39;)\n  downloadElement.href = dataUrl\n  downloadElement.download = fileName // download文件名\n\n  // 触发点击，下载\n  document.body.appendChild(downloadElement)\n  documentElement.click()\n\n  // 移除辅助下载DOM及对象URL\n  document.body.removeChild(downloadElement)\n  window.URL.revokeObjectURL(dataUrl)\n}</code></pre>\n<h2 id=\"后端koa代码\">后端koa代码</h2>\n<p>利用koa来mock下载接口，读取文件内容，返回buffer后，直接用ctx.body返回给前端即可</p>\n<pre><code class=\"language-js\">\nconst Koa = require(&#39;koa&#39;)\nconst Router = require(&#39;koa-router&#39;)\nconst  static = require(&#39;koa-static&#39;)\nconst app = new Koa()\nconst router = new Router()\nconst uitl = require(&#39;util&#39;)\nconst fs = require(&#39;fs&#39;)\n\napp.use(static(__dirname + &#39;/public&#39;))\n\nrouter.get(&#39;/download&#39;, async (ctx, next) =&gt; {\n\n  let filePath = [\n    &#39;/upload/ffe73f4c-c160-49ff-b01d-53da5c544714.mongodb-macos-x86_64-4.2.2.tar&#39;,\n    // &#39;/upload/35f17dcc-9f87-40cf-968d-8880951440d8.屏幕快照 2020-02-28 23.19.02.png&#39;\n  ]\n  let readFilePromise = uitl.promisify(fs.readFile)\n  let res = await readFilePromise(__dirname + filePath[0])\n  console.log(res)\n  const fileName = encodeURIComponent(&#39;这是一一个文件&#39;)\n  ctx.set({\n    // &#39;Content-Type&#39;: &#39;image/png&#39;,\n    &#39;Content-Type&#39;: &#39;application/x-tar&#39;,\n    &#39;Content-Disposition&#39;: `attachment; filename=&quot;${fileName}.tar&quot;`\n  })\n  ctx.body = res\n})\n\napp.use(router.routes())\n\napp.listen(3000, () =&gt; {\n  console.log(&#39;服务开启成功，3000端口&#39;)\n})</code></pre>\n<h2 id=\"进度信息total为0，只有loaded的情况\">进度信息total为0，只有loaded的情况</h2>\n<p>我们在koa文档里，可以找到ctx.body 的值可以是buffer与流，流类似管道。<strong>当接口返回的数据不是buffer，而是流时，就会有这种情况</strong></p>\n<pre><code class=\"language-js\">// 可以用下面的代码改写上面的koa，不使用fs.readFile，而创建一个读的流，直接响应给前端\nlet res = fs.createReadStream(__dirname + filePath[0])\nctx.body = res</code></pre>\n<p><strong>对于这种情况，前端怎么判断进度事件呢？建议每触发一次进度事件，加10个百分点，加到90停止，直到加载完成。10%的粒度可以自己调整</strong></p>\n<h2 id=\"注意事项\">注意事项</h2>\n<ol>\n<li><p>理论上filename 不需要后缀名，可以根据fileType的MIME类型自动生成后缀，但有些情况比如execl 2003可能是没有后缀的，所以最好还是filename里加上后缀名</p>\n</li>\n<li><p>上面可以看到需要自己设置文件类型，后缀名，但一般情况后端会在响应头 Content-Type里设置好文件类型</p>\n</li>\n<li><p>window.open 虽然没有进度，但优点是前端不用处理文件名这种问题，都是后端来处理</p>\n</li>\n<li><p>上面的例子写的比较糙，实际情况对于文件种类比较多的需要进行判断，做一些适配处理</p>\n</li>\n</ol>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><p><a href=\"https://github.com/axios/axios#request-config\">axios onDownloadProgress config参数 - github</a></p>\n</li>\n<li><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types\">fileType 文件的MIME类型 - MDN</a></p>\n</li>\n<li><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7\">a标签download属性兼容性 - MDN</a></p>\n</li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "下载文件进度显示以及koa下载接口mock",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "前端代码"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "通用下载函数"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "后端koa代码"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "进度信息total为0，只有loaded的情况"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "注意事项"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "下载文件进度显示以及koa下载接口mock.md",
        "staticFileName": "http_download_progress.html",
        "author": "guoqzuo",
        "createDate": "2019/10/18",
        "description": "blob拒绝访问文件，下载进度，通用下载函数，IE下blob拒绝访问文件兼容处理了，在前端做导出功能的时候，需要请求一个接口去导出数据，一般是execl，然后接口会返回execl的文件数据。对于比较大的文件，我们怎么获取文件的下载进度呢？前端怎么用koa来mock导出的接口呢？下面来看看",
        "keywords": "blob拒绝访问文件,下载文件进度,axios下载文件进度,下载接口mock,koa导出文件接口,前端下载进度,进度信息total为0，只有loaded的情况",
        "category": "http与https",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"骨架屏研究\">骨架屏研究</h1>\n<p>目前骨架屏在app端用的比较多，主要是从国外转过来的。国内大厂JD、知乎、淘宝等都有用，相比原来用loading 菊花图来表示加载中，骨架屏用户体验更好一点，这里我们来自己实现一个简单的骨架屏样式效果</p>\n<p><img src=\"../../../images/blog/css/css_skeleton.png\" alt=\"css_骨架屏.png\"></p>\n<p>实现的思路是使用background-image线性渐变来做动画效果，下面是一个比较简单的实现：</p>\n<pre><code class=\"language-css\">&lt;head&gt;\n  &lt;style&gt;\n    .fast-loading {\n      height: 20px;\n      margin: 10px 0;\n      width: 200px;\n      background-color: rgb(245, 245, 245);\n      background-image: repeating-linear-gradient(90deg, #eee, #f5f5f5 100%);\n\n      animation-name: fastLoading;\n      animation-timing-function: linear;\n      animation-duration: 1s;\n      animation-iteration-count: infinite;\n    }\n    @keyframes fastLoading {\n      from {\n        background-position: 0 0;\n      }\n      to {\n        background-position: 100px 0;\n      }\n    }\n    .w100 { width: 100% }\n    .w80 { width: 80% }\n    .w60 { width: 60% }\n    .w40 { width: 50% }\n    .w30 { width: 30% }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div style=&quot;width: 50%;margin: 50px auto;&quot;&gt;\n    &lt;div class=&quot;fast-loading&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;fast-loading w40&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;fast-loading w80&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;fast-loading w60&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;fast-loading w30&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;fast-loading w30&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;fast-loading w50&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;fast-loading w60&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;</code></pre>\n<p>在线演示色地址: <a href=\"https://zuoxiaobai.github.io/fedemo/src/DebugDemo/%E7%AE%80%E5%8D%95%E7%9A%84%E9%AA%A8%E6%9E%B6%E5%B1%8F/index.html\">https://zuoxiaobai.github.io/fedemo/src/DebugDemo/简单的骨架屏/index.html</a></p>\n<p>参考</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/sinat_17775997/article/details/83443744\">一种自动化生成骨架屏的方案</a> </li>\n<li><a href=\"http://www.dxcu.com/news/show-531569.html\">教你实现超流行的骨架屏预加载动态效果</a> </li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "骨架屏研究"
        }
      ],
      "config": {
        "source": "骨架屏研究.md",
        "staticFileName": "css_skeleton.html",
        "author": "guoqzuo",
        "createDate": "2019/10/18",
        "description": "目前骨架屏在app端用的比较多，主要是从国外转过来的。国内大厂JD、知乎、淘宝等都有用，相比原来用loading 菊花图来表示加载中，骨架屏用户体验更好一点，这里我们来自己实现一个简单的骨架屏样式效果",
        "keywords": "骨架屏",
        "category": "CSS",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"el-progress-custom-validator-check-failed-for-prop-percentage\">el-progress custom validator check failed for prop &quot;percentage&quot;</h1>\n<p>在使用element的 el-progress 组件时，出现 custom validator check failed for prop &quot;percentage&quot; 的错误，后来发现是 percentage 属性设置的值超过了100，我们可以在js逻辑理加一个判断，set percentage 的值时，不能超过100，如果大于100，就直接设置为100</p>\n<pre><code class=\"language-html\">&lt;el-progress type=&quot;circle&quot; :percentage=&quot;0&quot;&gt;&lt;/el-progress&gt;</code></pre>\n<p>参考:</p>\n<p><a href=\"https://element.eleme.cn/#/zh-CN/component/progress#huan-xing-jin-du-tiao\">el-progress组件 - ElemntUI</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "el-progress custom validator check failed for prop \"percentage\""
        }
      ],
      "config": {
        "source": "custom validator check failed for prop 'percentage'.md",
        "staticFileName": "css_element_progress.html",
        "author": "guoqzuo",
        "createDate": "2019/10/24",
        "description": "在使用element的 el-progress 组件时，出现 custom validator check failed for prop 'percentage' 的错误，后来发现是 percentage 属性设置的值超过了100，我们可以在js逻辑理加一个判断，set percentage 的值时，不能超过100，如果大于100，就直接设置为100",
        "keywords": "custom validator check failed for prop 'percentage'",
        "category": "CSS",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"原生js实现美元图片四周散开的动画效果\">原生JS实现美元图片四周散开的动画效果</h1>\n<p>之前一朋友在微信群里问，是否能做一个动画，在每次进入页面的时候，实现美元钞票向四周扩散的效果，也就是一个遮罩动画。当时刚看完js高程3不久，就用原生js写了个动画，如果页面需要这个动画，只需要引入一个js就可以。</p>\n<ul>\n<li><p>demo github地址：<a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/DebugDemo/%E9%81%AE%E7%BD%A9%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C\">原生JS实现遮罩动画demo - github</a></p>\n</li>\n<li><p>在线演示：<a href=\"https://zuoxiaobai.github.io/fedemo/src/DebugDemo/%E9%81%AE%E7%BD%A9%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/index.html\">演示效果</a></p>\n</li>\n</ul>\n<p><img src=\"../../../images/blog/css/css_js_mask_animation.png\" alt=\"css_js_mask_animation.png\"></p>\n<p>思路是，一进入页面，在4个边角的区域生成 n 张图片，这个n可配置。然后每个区块设置不同的css，指定不同的动画效果，像四散开，下面是核心代码</p>\n<pre><code class=\"language-js\">// 立即执行函数，防止污染全局作用域\n(function() {\n  console.log(&#39;&gt;&gt;&gt; mask Animation load.&#39;)\n\n  const MA_CONFIG = {\n    count: 10, // 每个区块 count 张图片\n    part: 8, // part 个区块\n    imgSrc: &#39;./demo.png&#39;,\n    imgWidth: &quot;60vw&quot;, // 图片宽度\n    partArr: [ // 区块定位\n      [&quot;top&quot;, &quot;left&quot;],\n      [&quot;top&quot;, &quot;right&quot;],\n      [&quot;bottom&quot;, &quot;left&quot;],\n      [&quot;bottom&quot;, &quot;right&quot;],\n      [&quot;top&quot;, &quot;left&quot;],\n      [&quot;top&quot;, &quot;right&quot;],\n      [&quot;bottom&quot;, &quot;left&quot;],\n      [&quot;bottom&quot;, &quot;right&quot;],\n      [&quot;top&quot;, &quot;left&quot;],\n      [&quot;bottom&quot;, &quot;right&quot;],\n    ]\n  }\n\n  // 函数\n  let _getCountGap = item =&gt; Math.round(Math.random() * 400 - 100)\n  let _getRotate = item =&gt; Math.round(Math.random() * 360)\n  let _getArr = count =&gt; new Array(count).fill(&#39;-&#39;)\n\n  let tempFragment = document.createDocumentFragment()\n  let tempArrCount = _getArr(MA_CONFIG.count)\n  let tempArrPart = _getArr(MA_CONFIG.part)\n\n  // 处理图片\n  tempArrCount.forEach(() =&gt; {\n    tempArrPart.forEach((item, index)=&gt; {\n      let img = new Image()\n      img.src = MA_CONFIG.imgSrc\n      img.setAttribute(&#39;class&#39;, &quot;ma_&quot; + MA_CONFIG.partArr[index].join(&#39;-&#39;))\n\n      Object.assign(img.style, {\n        width: MA_CONFIG.imgWidth,\n        position: &quot;absolute&quot;,\n        transform: `rotate(${_getRotate()}deg)`,\n        [MA_CONFIG.partArr[index][0]]: `${_getCountGap()}px`,\n        [MA_CONFIG.partArr[index][1]]: `${_getCountGap()}px`,\n      })\n\n      tempFragment.appendChild(img)\n    })\n  })\n\n  window.onload = ()=&gt; {\n    // 将图片挂载到dom\n    const div = document.createElement(&#39;div&#39;)\n    div.appendChild(tempFragment)\n    document.body.appendChild(div)\n\n    // 准备挂载样式\n    const styleElement = document.createElement(&#39;style&#39;)\n    document.head.appendChild(styleElement)\n    let sheet = document.styleSheets[0];\n\n    // 暂时写死，其实可以用js处理下，更健壮，但可读性会降低\n    const styleArr = [\n      `.ma_top-left {\n        animation: ma_moveTopLeft ease-in 2s; \n      }`,\n      `.ma_top-right {\n        animation: ma_moveTopRight ease-in 2s; \n      }`,\n      `.ma_bottom-left{\n        animation: ma_moveBottomLeft ease-in 2s; \n      }`,\n      `.ma_bottom-right {\n        animation: ma_moveBottomRight ease-in 2s; \n      }`,\n      `@keyframes ma_moveTopLeft {\n        from {}\n        to {\n          top: -1000px;\n          left: -1000px;\n        }    \n      }`,\n      `@keyframes ma_moveTopRight {\n        from {}\n        to {\n          top: -1000px;\n          right: -1000px;\n        }    \n      }`,\n      `@keyframes ma_moveBottomLeft {\n        from {}\n        to {\n          bottom: -1000px;\n          left: -1000px;\n        }    \n      }`,\n      `@keyframes ma_moveBottomRight {\n        from {}\n        to {\n          bottom: -1000px;\n          right: -1000px;\n        }    \n      }`\n    ]\n\n    // 挂载样式\n    styleArr.forEach((item)=&gt; {\n      sheet.insertRule(item, 0)\n    })\n\n    // 2s 后卸载样式及dom\n    setTimeout(()=&gt; {\n      document.body.removeChild(div)\n      document.head.removeChild(styleElement)\n    }, 2000)\n  }\n})()</code></pre>\n<p>参考：<a href=\"https://www.yuque.com/guoqzuo/js_es6/eig0iu#4e7192e3\">JS操作样式表笔记 - 语雀</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "原生JS实现美元图片四周散开的动画效果"
        }
      ],
      "config": {
        "source": "原生JS实现美元图片四周散开的动画效果.md",
        "staticFileName": "css_mask_animation.html",
        "author": "guoqzuo",
        "createDate": "2019/10/26",
        "description": "之前一朋友在微信群里问，是否能做一个动画，在每次进入页面的时候，实现美元钞票向四周扩散的效果，也就是一个遮罩动画。当时刚看完js高程3不久，就用原生js写了个动画，如果页面需要这个动画，只需要引入一个js就可以。",
        "keywords": "原生JS实现遮罩动画,js实现美元图片四周散开动画效果,js实现美元各方向散开的动画效果",
        "category": "JavaScript",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"nginx默认配置对前端开发的一些影响\">nginx默认配置对前端开发的一些影响</h1>\n<p>一般前端代码开发好后，会部署到nginx，但nginx的某些默认配置，会使前端页面受到影响，比如默认请求超时限制，默认文件上传大小限制，默认字符编码问题等。下面来看具体的问题，以及怎么解决这些问题。</p>\n<h2 id=\"nginx请求超时时间默认60s\">nginx请求超时时间默认60s</h2>\n<p>axios请求时，配置config里有一个是设置请求超时时间的，有一次接口响应巨慢，超过了1分钟，于是我在axios里设置了超时时间为2分钟，但没效果。后来发现是nginx的默认配置限制了。</p>\n<pre><code class=\"language-js\">// `timeout` specifies the number of milliseconds before the request times out.\n// If the request takes longer than `timeout`, the request will be aborted.\ntimeout: 1000, // default is `0` (no timeout)</code></pre>\n<p>综上：前端就算超时设置为2分钟，但如果前端代码部署到了nginx上，也会导致1分钟超时，你也可以修改nginx的默认配置项</p>\n<pre><code class=\"language-conf\">location / {\n  root d:/test/;\n  fastcgi_connect_timeout 600; # set timeout\n  fastcgi_send_timeout 600; \n  fastcgi_read_timeout 600;\n}</code></pre>\n<h2 id=\"nginx默认文件上传大小限制为1m\">nginx默认文件上传大小限制为1M</h2>\n<p>在做图片上传功能时，和后台本地联调都挺好的。但部署到服务器后，发现图片上传有时候会失败，后来用charles抓包发现，当图片大于1M时，就会超时。最开始以为是后端的问题，找后端调试时，返现后端根本没有收到上传的请求，然后我就想到可能是nginx这里直接拦截了请求，查资料后发现果然是这样。</p>\n<p>所以，对于有文件 &gt; 1M 需要上传的，需要修改下 nginx默认配置</p>\n<pre><code class=\"language-conf\">server {\n  listen       80;\n  server_name  localhost;\n  client_max_body_size 10M; #增加这个参数就可以指定最大上传文件大小为10m了；\n}</code></pre>\n<h2 id=\"nginx字符编码与系统字符编码不一致导致中文图片路径404的问题\">nginx字符编码与系统字符编码不一致导致中文图片路径404的问题</h2>\n<p>上一次更新博客时，在mac本地调试时，都是ok的，部署到windows服务器上后时，发现一个图片出现了404的问题，最开始以为是缓存的问题，清了缓存后还是404。这张图片是中文路径，之前全部用的是英文的，没发现这个问题。试了下英文的图片链接是ok的。百度了下，发现确实有这种问题。是nginx设置的编码与操作系统的编码不一致的问题。</p>\n<pre><code class=\"language-bash\"># linux查看电脑默认编码\necho  $LANG\n# zh_CN.UTF-8\n\n# windows下查看默认字符编码\nchcp\n# 如果显示 活动代码页 936 表示GBK编码  我的服务器就是这个编码，修改了nginx charset utf-8;没效果\n# 65001 表示utf-8\n\n# 设置字符编码，但发现只在当前控制台生效，重新开一个就没了。\nchcp 65001\n\n# 有个修改注册表的方法：不知道是否可行，但怕影响服务器的其它服务，还是算了，改英文名比较稳。。。。\n# https://blog.csdn.net/yangzhong0808/article/details/79012628?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "nginx默认配置对前端开发的一些影响",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "nginx请求超时时间默认60s"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "nginx默认文件上传大小限制为1M"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "nginx字符编码与系统字符编码不一致导致中文图片路径404的问题"
            }
          ]
        }
      ],
      "config": {
        "source": "nginx默认配置对前端开发的一些影响.md",
        "staticFileName": "nginx_effect_web.html",
        "author": "guoqzuo",
        "createDate": "2019/10/28",
        "description": "一般前端代码开发好后，会部署到nginx，但nginx的某些默认配置，会使前端页面受到影响，比如默认请求超时限制，默认文件上传大小限制，默认字符编码问题等。下面来看具体的问题，以及怎么解决这些问题。",
        "keywords": "nginx默认配置对前端开发的一些影响,ngnix请求超时时间默认60s,nginx默认文件上传大小限制为1M,nginx中文图片路径404的问题,nginx会影响前端页面超时吗",
        "category": "运维部署与版本控制",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"js到底是解释型语言还是编译型语言\">JS到底是解释型语言还是编译型语言</h1>\n<blockquote>\n<p>本文整理自 <a href=\"https://segmentfault.com/a/1190000013126460\">https://segmentfault.com/a/1190000013126460</a></p>\n</blockquote>\n<p>Is JavaScript really interpreted or compiled language ?</p>\n<h2 id=\"js是一种解释型语言，令人困惑的地方\">Js是一种解释型语言，令人困惑的地方</h2>\n<ul>\n<li>—般解释型语言是逐行解释执行的，为什么JS会有変曩提升(hoisting)的能力？</li>\n<li>执行JS时会用到JIT, JIT(just in time compilers 及时编译）会做代码优化(同时也会创建代码的编译版本),解释型语言无法做到这些变量提升问题</li>\n</ul>\n<p>在函数作用域内的任何变量声明都会被提升到顶部，且值为undefined，</p>\n<h2 id=\"js处理声明语句的过程\">JS处理声明语句的过程</h2>\n<ul>\n<li>一旦v8引擎进入一个执行具体代码的执行上下文(函数)，会对代码进行词法分析或分词(lexing and tokenizing the code), 会将代码切分为原子性的令牌(atomic token) , 比 如foo = 10 </li>\n<li>在分析完当前作用域后，它会将翻译后的版本解析为AST(抽象语法树)</li>\n<li>每次遇到声明都会将其发送到作用域，并创建绑定，每次声明都会为变量分配内存，只是分配内存，并不会通过修改源代码来将变最声明语句提升，在JS中分配内存，意味着将变量默认设置为undefined</li>\n<li>在这之后，引擎每次遇到赋值或者取值，都会通过作用域(scope)查找绑定。如果当前作用域中没有找到，就接着向上级作用域中查找，直到找到为止 </li>\n<li>接着引擎生成CPU可执行的机器码 </li>\n<li>最后，代码执行完毕</li>\n</ul>\n<h2 id=\"jit是什么\">JIT是什么</h2>\n<p>JS start out slow, but then got faster thanks to something colled the JIT, but how does the JiT work ?\n通俗一点说：浏览器在解释执行JS时，如果遇到某些语句多次执行，会将对应的语句编译，并存储。下次再执行相同的语句时，不用再重新编译，而是直接执行之前存储的该语句编译的版本。当然里面不止这么简单，还有很多优化， 详情參考: A crash course in just-in-time (JIT) compilers</p>\n<h2 id=\"总结\">总结</h2>\n<ul>\n<li>JS需要有JS引擎解析才能执行。这是解释型语需要的，编译型语言程序你能直接运行。</li>\n<li>变量提升只是JS解释器处理事情的方式导致的，</li>\n<li>JIT 是唯一一点可以对JS是否是解释型语言提出疑问的理由。但JIT不是完整的编译器，它仅在执行前编译，且JIT只是Mozilla 和 Google开发人员为了提升浏览器性能才引入的，JS或TC39从没有强制要求使用JIT，\n综上：JS是解释型语言或混合型语言(编译型型和解释型的混合)，而不是编译型语亩。</li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JS到底是解释型语言还是编译型语言",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "Js是一种解释型语言，令人困惑的地方"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "JS处理声明语句的过程"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "JIT是什么"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "总结"
            }
          ]
        }
      ],
      "config": {
        "source": "JS到底是解释型语言还是编译型语言.md",
        "staticFileName": "js_language.html",
        "author": "guoqzuo",
        "createDate": "2019/10/28",
        "description": "JS到底是解释型语言还是编译型语言呢？一般的书里都写的是js是一种解释型语言，但令人令人困惑的地方是：—般解释型语言是逐行解释执行的，为什么JS会有変曩提升(hoisting)的能力？执行JS时会用到JIT, JIT(just in time compilers 及时编译）会做代码优化(同时也会创建代码的编译版本),解释型语言无法做到这些变量提升问题",
        "keywords": "JS到底是解释型语言还是编译型语言",
        "category": "JavaScript",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"mac没安装xcode怎么安装svn以及怎么用命令操作svn\">mac没安装xcode怎么安装svn以及怎么用命令操作svn</h1>\n<p>一般在mac下，如果安装了xcode貌似有自动安装svn，如果卸载了xcode，那怎么安装svn呢？还有svn怎么使用命令来拉取更新，一般的git命令对应svn的命令是什么呢？下面我们来看看。</p>\n<h2 id=\"如果mac没有装xcode，怎么安装svn\">如果mac没有装xcode，怎么安装svn</h2>\n<p>最简单的方法：安装idea或webstorm等工具，在里面chenckout svn项目，会提示安装，按照提示来即可。</p>\n<p>建议还是装会xcode，没xode对其他也会有影响，为了少踩点坑，建议还是装上为好。</p>\n<h2 id=\"使用命令操作svn\">使用命令操作svn</h2>\n<pre><code class=\"language-bash\"># checkout svn，注意如果密码错误，会不提示重新输入，如果403forbidden，就是没权限\nsvn checkout http://仓库地址 --username=用户名\n\n# git与svn常用命令对比\n# 整理自 https://blog.csdn.net/scythe666/article/details/51941622\nsvnadmin create  ------------------------------&gt; git init\nsvn co                 ------------------------------&gt; git clone\nsvn update          ------------------------------&gt; git pull\nsvn add              ------------------------------&gt; git add\nsvn commit        ------------------------------&gt;  git add, git commit\nsvn status          ------------------------------&gt;  git status\nsvn switch &lt;branch&gt;  ------------------------&gt;  git checkout &lt;branch&gt;\nsvn merge &lt;branch&gt;  ------------------------&gt;  git merge &lt;branch&gt;\nsvn revert &lt;file&gt;  ------------------------------&gt; git checkout &lt;file&gt;</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "mac没安装xcode怎么安装svn以及怎么用命令操作svn",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "如果mac没有装xcode，怎么安装svn"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "使用命令操作svn"
            }
          ]
        }
      ],
      "config": {
        "source": "mac没安装xcode怎么安装svn以及怎么用命令操作svn.md",
        "staticFileName": "mac_svn.html",
        "author": "guoqzuo",
        "createDate": "2019/10/30",
        "description": "一般在mac下，如果安装了xcode貌似有自动安装svn，如果卸载了xcode，那怎么安装svn呢？还有svn怎么使用命令来拉取更新，一般的git命令对应svn的命令是什么呢？下面我们来看看。",
        "keywords": "mac没安装xcode怎么安装svn,怎么用命令操作svn,svn拉取代码命令",
        "category": "运维部署与版本控制",
        "year": "2019",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"用mac做前端开发遇到的问题总结\">用mac做前端开发遇到的问题总结</h1>\n<p>在用mac开发的过程中，会遇到过一些问题，比如怎么显示文件的扩展名；mac隐藏文件 .DS_Store 对node遍历文件产生的影响；mac怎么修改环境变量；mac安装yarn的方法；mac加密zip文件；mac使用触控板来进行复制和拖动窗口等，下面来逐一介绍下。</p>\n<h2 id=\"mac-隐藏文件-ds_store-对node遍历文件产生的影响\">mac 隐藏文件 .DS_Store 对node遍历文件产生的影响</h2>\n<p>node遍历文件夹下的文件名再require对应的文件出错，在使用koa mock接口时，一个模块有很多接口，就写了十几个js，每个js对应一个接口数据。如果每增加一个接口，再添加一个require就很麻烦，于是写了个index.js来遍历文件夹，进行动态引入。以后写好js，就不用再手动require了。之前都运行正常的，最近再运行时发现一直报错，require异常。后来打印遍历的fileName，发现居然有 .DS_Store 文件，require这个文件时错误。这个文件属于mac系统自动生成的文件，之前都没有的。在程序中过滤调这个文件即可。</p>\n<pre><code class=\"language-bash\"># 目录结构\nmock\n├── pm\n│   ├── index.js # 入口\n│   ├── 接口1.js\n│   ├── 接口2.js\n│   └── 接口n.js\n├── user \n├── product\n└── sever.js # 入口文件，require(&#39;./pm/index.js&#39;)(router) 将接口添加到路由</code></pre>\n<p>pm/index.js 代码如下：</p>\n<pre><code class=\"language-js\">const fs = require(&#39;fs&#39;)\n\nmodule.exports = router =&gt; {\n  fs.readdirSync(__dirname).forEach(fileName =&gt; {\n    if (fileName === &#39;index.js&#39; || fileName.startsWith(&#39;.&#39;)) return\n    require(&#39;./&#39; + item)(router)\n  })\n}</code></pre>\n<h2 id=\"mac-export-path-后关闭termial就失效了\">mac export PATH 后关闭termial就失效了</h2>\n<p>mac 修改环境变量，以便能在任何地方使用 mongod 命令</p>\n<pre><code class=\"language-bash\"># 运行该命令后，当前terminal生效了，但关闭后，打开其他terminal就无效\nexport PATH=/usr/local/mongodb/bin:$PATH</code></pre>\n<p>这种情况需要在 .bash_profile 文件里，加入 export PATH=/usr/local/mongodb/bin:$PATH 才行，<strong>上面是旧的方法，新mac系统，bash是zsh，文件不再是.bash_profile，而是.zshrc</strong></p>\n<pre><code class=\"language-bash\"># 打开主目录下的 .bash_profile 文件\nvi ~/.bash_profile</code></pre>\n<p>修改后的 .bash_profile 文件，之前还修改过mysql的环境变量</p>\n<pre><code class=\"language-js\">export PATH=${PATH}:/usr/local/mysql/bin\nexport PATH=&quot;$HOME/.rbenv/bin:$PATH&quot;\nexport PATH=/usr/local/mongodb/bin:$PATH\nif which rbenv &gt; /dev/null; then eval &quot;$(rbenv init -)&quot;; fi</code></pre>\n<h2 id=\"macos安装yarn方法\">macos安装Yarn方法</h2>\n<p>注意尽量不要卸载xcode，这样问题会少很多</p>\n<pre><code class=\"language-bash\"># 使用brew安装yarn\nbrew install yarn</code></pre>\n<h2 id=\"mac-zip压缩加密\">mac zip压缩加密</h2>\n<pre><code class=\"language-bash\">zip -e 目标文件名.zip 需要加密的zip文件\n# 输入上面的命令后，会提示输入两次密码</code></pre>\n<p>更多zip命令相关用法，可以在控制台使用 <strong>man zip</strong> 查看文档</p>\n<p><img src=\"../../../images/blog/devtools/mac_zip_encrypt.png\" alt=\"mac_zip_encrypt.png\"></p>\n<h2 id=\"mac显示文件扩展名\">mac显示文件扩展名</h2>\n<p>点击屏幕下方第一个图标：访达(Finder) =&gt; 屏幕左上方苹果logo右侧 点击 访达(Finder) =&gt; 偏好设置 =&gt;  高级 =&gt; 勾选显示所有文件扩展名</p>\n<p><img src=\"../../../images/blog/devtools/mac_file_extension.png\" alt=\"mac_file_extension.png\"></p>\n<h2 id=\"mac使用触控板拖动复制、移动窗口\">mac使用触控板拖动复制、移动窗口</h2>\n<p>今天才意识到，每次要复制一段文字或移动某个应用窗口，我都是点击触控板再拖动。而且Mac Air的触控板按的声音比较响，于是找了下是否有手势可以支持。</p>\n<p>发现可以设置使用 三指拖移 复制文字和拖动窗口，三个手指放上去拖动就可以了。</p>\n<p>设置方法：打开系统统偏好设置 =&gt; 点 “辅助功能” =&gt; 点 “鼠标与触控板” =&gt; 点 “触控板选项” =&gt; 先勾上启用拖移，然后选择“三指拖移”，点击 “好”</p>\n<p><img src=\"../../../images/blog/devtools/mac_touchpad_copy.png\" alt=\"mac_touchpad_copy.png\"></p>\n<p>图文详情参考: <a href=\"https://jingyan.baidu.com/article/bea41d43b236feb4c51be639.html\">MacBook触控板选中/复制</a></p>\n<h2 id=\"macos-查看ip\">macos 查看ip</h2>\n<p>按住option，再点击右上角wifi图标即可看到本机局域网ip、路由ip</p>\n<p><img src=\"../../../images/blog/devtools/mac_option_showip.png\" alt=\"mac_option_showip.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "用mac做前端开发遇到的问题总结",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "mac 隐藏文件 .DS_Store 对node遍历文件产生的影响"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "mac export PATH 后关闭termial就失效了"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "macos安装Yarn方法"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "mac zip压缩加密"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "mac显示文件扩展名"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "mac使用触控板拖动复制、移动窗口"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "macos 查看ip"
            }
          ]
        }
      ],
      "config": {
        "source": "用mac做前端开发遇到的问题总结.md",
        "staticFileName": "mac_dev.html",
        "author": "guoqzuo",
        "createDate": "2019/11/04",
        "description": "在用mac开发的过程中，会遇到过一些问题，比如怎么显示文件的扩展名；mac隐藏文件 .DS_Store 对node遍历文件产生的影响；mac怎么修改环境变量；mac安装yarn的方法；mac加密zip文件；mac使用触控板来进行复制和拖动窗口等，下面来逐一介绍下。",
        "keywords": "小白用mac做前端,mac 隐藏文件 .DS_Store 对node遍历文件产生的影响,mac export PATH 后关闭termial就失效了,mac修改环境变量,macos安装Yarn方法,mac安装yarn方法,mac zip文件加密,mac显示文件扩展名,mac使用触控板拖动复制、移动窗口,mac三指拖动",
        "category": "计算机基础与开发工具",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue仅开发环境下能看到的路由\">vue仅开发环境下能看到的路由</h1>\n<p>通过vue-cli创建的项目，npm run build 的代码是可以根据开发环境的不同而调整的，使用 process.env.NODE_ENV 可以做一些只有开发环境有的逻辑，比如下面的例子中，仅开发环境，才能看到相应的路由</p>\n<pre><code class=\"language-js\">let routes = []\n\n// 路由信息仅开发环境可见\nif (process.env.NODE_ENV === &#39;development&#39;) { \n  routes = [\n    {\n      path: ‘/xxxx’,\n      component: () =&gt; import(‘xxx’)\n    }\n  ]\n}\n\nexport default routes</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue仅开发环境下能看到的路由"
        }
      ],
      "config": {
        "source": "vue仅开发环境下能看到的路由.md",
        "staticFileName": "vue_dev_router.html",
        "author": "guoqzuo",
        "createDate": "2019/11/04",
        "description": "通过vue-cli创建的项目，npm run build 的代码是可以根据开发环境的不同而调整的，使用 process.env.NODE_ENV 可以做一些只有开发环境有的逻辑，比如下面的例子中，仅开发环境，才能看到相应的路由",
        "keywords": "vue仅开发环境下能看到的路由",
        "category": "Vue",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"根据vue-router路由传参配置keep-alive以及登录校验\">根据vue-router路由传参配置keep-alive以及登录校验</h1>\n<blockquote>\n<p>登录校验这块 From <a href=\"https://www.jianshu.com/p/33c9e7454028\">vue 中路由meta</a></p>\n</blockquote>\n<p>在vue开发中，路由配置的时候，给每个路由添加一个自定义的meta对象，在meta对象中可以设置一些状态，来进行一些操作。可以用来设置是否使用keep-alive，以及登录校验，先来看看配置</p>\n<pre><code class=\"language-js\">{\n  path: &#39;/actile&#39;,\n  name: &#39;Actile&#39;,\n  component: Actile,\n  meta: {\n    login_require: false,\n    iskeepAlive: false\n  },\n},\n{\n  path: &#39;/goodslist&#39;,\n  name: &#39;goodslist&#39;,\n  component: Goodslist,\n  meta: {\n    login_require: true,\n    iskeepAlive: true\n  },\n  children:[\n    {\n      path: &#39;online&#39;,\n      component: GoodslistOnline\n    }\n  ]\n}</code></pre>\n<p>keep-alive 相关前端设置</p>\n<pre><code class=\"language-html\">&lt;keep-alive&gt;\n  &lt;router-view v-if=&quot;$route.meta.iskeepAlive&quot; :key=&quot;routeKey&quot;&gt;\n&lt;/keep-alive&gt;\n&lt;router-view v-if=&quot;!$route.meta.iskeepAlive&quot; :key=&quot;routeKey&quot;&gt;</code></pre>\n<p>页面登录校验时，路由钩子</p>\n<pre><code class=\"language-js\">router.beforeEach((to, from, next) =&gt; {\n  if (to.matched.some(function (item) {\n    return item.meta.login_require\n  })) {\n    next(&#39;/login&#39;)\n  } else \n    next()\n})</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "根据vue-router路由传参配置keep-alive以及登录校验"
        }
      ],
      "config": {
        "source": "根据vue-router路由传参配置keep-alive以及登录校验.md",
        "staticFileName": "vue_router_params.html",
        "author": "guoqzuo",
        "createDate": "2019/11/04",
        "description": "在vue开发中，路由配置的时候，给每个路由添加一个自定义的meta对象，在meta对象中可以设置一些状态，来进行一些操作。可以用来设置是否使用keep-alive，以及登录校验，先来看看配置",
        "keywords": "vue 中路由meta,根据路由配置做登录验证,根据vue-router路由传参配置keep-alive",
        "category": "Vue",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"版本号中的rc是什么意思\">版本号中的rc是什么意思</h1>\n<p>在看html2canvas的历史版本信息时，发现有rc版本，不知道是什么意思，于是查了下，rc版本代表比较成熟的版本，是release之前版本，除此之外还有aplpha、beta等版本，下面来看看</p>\n<ul>\n<li><p>Alpha版: 此版本表示该软件在此阶段主要是以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的Bug较多，需要继续修改。</p>\n</li>\n<li><p>Beta版: 该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对像是软件的UI。</p>\n</li>\n<li><p>RC版: 该版本已经相当成熟了，基本上不存在导致错误的BUG，与即将发行的正式版相差无几。</p>\n</li>\n<li><p>Release版: 该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(R)。</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">// html2canvas Releases note\nv1.0.0-rc.5\nv1.0.0-rc.4\n…\nv1.0.0-rc.0\nv1.0.0-alpha.12\n…\nv1.0.0-alpha.1\n\nv0.5.0-beta4\nv0.5.0-beta3\n0.5.0-alpha1\nv0.4.1 - 7.9.2013\nv0.3.3 - 2.3.2012\nv0.3.2 - 20.2.2012\n0.3.1\nv0.3.0 - 7.9.2011</code></pre>\n<p>参考：<a href=\"https://www.cnblogs.com/lanmiao/articles/2184282.html\">什么是 Alpha、Beta、RC、Release版</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "版本号中的rc是什么意思"
        }
      ],
      "config": {
        "source": "版本号中的rc是什么意思.md",
        "staticFileName": "version_rc.html",
        "author": "guoqzuo",
        "createDate": "2019/11/05",
        "description": "在看html2canvas的历史版本信息时，发现有rc版本，不知道是什么意思，于是查了下，rc版本代表比较成熟的版本，是release之前版本，除此之外还有aplpha、beta等版本，下面来看看",
        "keywords": "版本号中的rc是什么意思",
        "category": "运维部署与版本控制",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"jpg、png、bmp、gif图片格式区别，什么是webp？\">jpg、png、bmp、gif图片格式区别，什么是webp？</h1>\n<p>在网页开发中一般用的都是png，现在比较流行或者说以后的趋势应该是webp，现有的一些图片格式都些有什么区别的？一般图片主要从两个方面来看：是否能无损压缩，图片大小、是否放大后不失真，下面来具体看看</p>\n<h2 id=\"webp\">webp</h2>\n<ul>\n<li>一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式</li>\n<li>比png更小</li>\n<li>2010年发布，目标减少文件大小，且达到JPEG格式相同的图片质量，希望可以减少图片在网络上的发送时间</li>\n<li>由Google在购买On2 Technologies后发展出来，以BSD授权条款发布</li>\n</ul>\n<h2 id=\"jpegjpg-joint-photographic-experts-group\">jpeg/jpg (Joint Photographic Experts Group)</h2>\n<ul>\n<li>jpeg和jpg格式一样，没有区别。</li>\n<li>兼容性高、传输速度快，内容小，大部分数码相机都能拍JPEG</li>\n<li>有损压缩方案，压缩会降低细节和质量</li>\n</ul>\n<h2 id=\"tifftif-tagged-image-file-format\">tiff/tif (Tagged Image File Format)</h2>\n<ul>\n<li>位图，工业标准格式，印刷</li>\n</ul>\n<h2 id=\"png-portable-network-graphics\">png (Portable Network Graphics)</h2>\n<ul>\n<li>可移植网络图形格式</li>\n<li>设计目的是试图代替gif何tiff文件格式。</li>\n<li>支持压缩不失真，透明背景、渐变图像</li>\n<li>非常适合在网络上使用。但不足以用作印刷</li>\n<li>能够相容半透明、透明图像，文档比JPEG大</li>\n</ul>\n<h2 id=\"gif-graphics-interchange-format\">gif (Graphics Interchange Format)</h2>\n<ul>\n<li>gif分为静态和动态两种</li>\n<li>动态的gif图片是由多张图片保存为一个图片，形成动画效果</li>\n<li>文档小、非常适合在网络上使用。包容颜色太少</li>\n</ul>\n<h2 id=\"bmp-bitmap\">bmp (Bitmap)</h2>\n<p>位图，文件较大，参考：<a href=\"https://zhidao.baidu.com/question/24130156.html\">BMP是什么文件?</a></p>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://baijiahao.baidu.com/s?id=1599728202992947939&amp;wfr=spider&amp;for=pc\">图片格式分不清？JPG、TIF、PNG，不同格式区别到底在哪里</a></li>\n<li><a href=\"https://baike.baidu.com/item/webp%E6%A0%BC%E5%BC%8F/4077671?fr=aladdin\">webp格式 - 百度百科</a></li>\n<li><a href=\"https://www.jianshu.com/p/73ca9e8b986a\">webp在项目中的实战 - 简书</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "jpg、png、bmp、gif图片格式区别，什么是webp？",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "webp"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "jpeg/jpg (Joint Photographic Experts Group)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "tiff/tif (Tagged Image File Format)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "png (Portable Network Graphics)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "gif (Graphics Interchange Format)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "bmp (Bitmap)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "jpg、png、bmp、gif图片格式区别，什么是webp？.md",
        "staticFileName": "image_type.html",
        "author": "guoqzuo",
        "createDate": "2019/11/05",
        "description": "在网页开发中一般用的都是png，现在比较流行或者说以后的趋势应该是webp，现有的一些图片格式都些有什么区别的？一般图片主要从两个方面来看：是否能无损压缩，图片大小、是否放大后不失真，下面来具体看看",
        "keywords": "jpg、png、bmp、gif图片格式区别,什么是webp",
        "category": "计算机基础与开发工具",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"html2canvas将网页转换为图片\">html2canvas将网页转换为图片</h1>\n<p>在web开发中，我们需要生成图片时，可以使用html2canvas，他可以将html转为png，pc端还好，移动端css的坑比较多，这里只是简单的介绍下怎么使用。</p>\n<p>先引入 html2canvas.js，根据其api调用，来看看具体示例</p>\n<pre><code class=\"language-html\">&lt;!-- 核心代码 --&gt;\n&lt;head&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;script src=&quot;html2canvas.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;test&quot; style=&quot;background-image: url(&#39;bg.jpg&#39;);height:707px;width:500px;color: #fff;&quot;&gt;\n    &lt;div style=&quot;padding-top:250px;padding-left:100px;&quot;&gt;\n        &lt;h1&gt;邀请函&lt;/h1&gt;\n        &lt;div style=&quot;width: 200px;\n        word-break: break-word;&quot;&gt;\n          你好，邀请你xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n        &lt;/div&gt;\n        &lt;p&gt;\n          --- guoqzuo\n        &lt;/p&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script&gt;\n    let testElement = document.getElementById(&#39;test&#39;)\n    html2canvas(testElement).then(function(canvas) {\n      console.log(canvas)\n      let img = new Image()\n      img.src = canvas.toDataURL()\n      img.onload = function() {\n        document.body.appendChild(img);\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p>完整demo地址: <a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/html2canvas/index.html\">html2canvas demo - github</a></p>\n<p>上面的例子是原生开发的例子，还可以使用node模块的方式引用</p>\n<p><a href=\"http://html2canvas.hertzen.com/documentation\">html2canvas文档</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "html2canvas将网页转换为图片"
        }
      ],
      "config": {
        "source": "html2canvas将网页转换为图片.md",
        "staticFileName": "html2vanvas.html",
        "author": "guoqzuo",
        "createDate": "2019/11/05",
        "description": "在web开发中，我们需要生成图片时，可以使用html2canvas，他可以将html转为png，pc端还好，移动端css的坑比较多，这里只是简单的介绍下怎么使用。先引入 html2canvas.js，根据其api调用，来看看具体示例",
        "keywords": "html2canvas将网页转换为图片,html2canvas使用示例",
        "category": "JavaScript",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"怎么使用chrome断点调试功能，断点调试使用场景\">怎么使用Chrome断点调试功能，断点调试使用场景</h1>\n<p>在前端开发中，我们调试时一般都会使用console.log在控制台打log看程序执行情况，断点调试的功能好像用的比较少，那什么情况下就需要使用断点调试功能了呢？下面来讨论下</p>\n<h2 id=\"断点调试功能介绍\">断点调试功能介绍</h2>\n<p>断点调试可以在某个js代码位置加断点，刷新页面后，会停留在断点位置，点击下一步会执行到下面的断点，这样可以追踪代码的执行情况。对调试复杂的逻辑非常有帮助</p>\n<h2 id=\"chrome断点调试功能使用\">chrome断点调试功能使用</h2>\n<ol>\n<li>在逻辑异常前一句js位置，加一个console.log</li>\n</ol>\n<p><img src=\"../../../images/blog/devtools/devtools_breakpoint_1.png\" alt=\"devtools_breakpoint_1.png\"></p>\n<p>打开console，点击log后面的文件会直接进入chrome源码位置</p>\n<p><img src=\"../../../images/blog/devtools/devtools_breakpoint_2.png\" alt=\"devtools_breakpoint_2.png\"></p>\n<ol start=\"2\">\n<li><p>点击源码行号区域位置打断点</p>\n</li>\n<li><p>下好断点后刷新页面，页面会卡在第一个下断点的位置，页面出现一个可以单步调试的面板，点击蓝色按钮，就可以往下执行到下一个断点位置</p>\n</li>\n</ol>\n<p><img src=\"../../../images/blog/devtools/devtools_breakpoint_3.png\" alt=\"devtools_breakpoint_3.png\"></p>\n<h2 id=\"断点调试使用场景\">断点调试使用场景</h2>\n<p>一般如果是自己写的代码逻辑很清晰易懂、代码量不是非常大的情况是完全没必要使用断点调试功能，console.log就可以了，但有下面几种情况，断点调试才会真正发挥它的威力</p>\n<ol>\n<li>如果代码功能异常且业务逻辑复杂，用console.log也找不到具体异常逻辑时</li>\n<li>代码改动后不方便实时调试时，意味着每次加console.log都很麻烦</li>\n<li>了解源码执行过程</li>\n</ol>\n<p>总结，如果是调试复杂代码，console.log不方便或搞不定时再使用断点调试；如果想快速了解源码执行具体执行顺序逻辑，直接用断点调试，单步执行</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "怎么使用Chrome断点调试功能，断点调试使用场景",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "断点调试功能介绍"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "chrome断点调试功能使用"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "断点调试使用场景"
            }
          ]
        }
      ],
      "config": {
        "source": "怎么使用Chrome断点调试功能，断点调试使用场景.md",
        "staticFileName": "breakpoint.html",
        "author": "guoqzuo",
        "createDate": "2019/11/07",
        "description": "在前端开发中，我们调试时一般都会使用console.log在控制台打log看程序执行情况，断点调试的功能好像用的比较少，那什么情况下就需要使用断点调试功能了呢？下面来讨论下",
        "keywords": "怎么使用Chrome断点调试功能,断点调试使用场景",
        "category": "计算机基础与开发工具",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"positionabsolute元素高度自适应，换成relative设置top试试\">position:absolute元素高度自适应，换成relative设置top试试</h1>\n<p>一般元素设置position:absolute后，就已经脱离了文档流，用css是无法计算其高度的，只能用js获取dom来计算。另外不要把自己限制死了，对于自适应高度的，为什么一定要使用position:absolute呢？<strong>换position:relative也可以设置top、left等css属性</strong>，如果自己真的想不到好的方法，问问其他同事或社群里的人试试？下面来看看我之前由于知识盲点踩的一个坑</p>\n<h2 id=\"一个例子\">一个例子</h2>\n<pre><code class=\"language-html\">&lt;!--\n页面布局：\n顶部背景图 // 非透明   \n中间主内容 // 中间内容也有背景，内容里的title需要有一部分放到top背景区域\n底部背景图\n--&gt;\n&lt;div class=&quot;container&quot;&gt;\n  &lt;!-- 顶部背景区域 --&gt;\n  &lt;section class=&quot;top&quot;&gt;&lt;/section&gt;\n  &lt;!-- 中间主要内容--&gt;\n  &lt;section class=&quot;main&quot;&gt;\n    &lt;div class=&quot;main-title&quot; id=&quot;autoHeightTitle&quot;&gt;我是标题&lt;/div&gt;\n    &lt;div id=&quot;autoMarginTop&quot;&gt;产品信息&lt;/div&gt;\n  &lt;/section&gt;\n  &lt;!-- 顶部背景区域--&gt;\n  &lt;section class=&quot;bottom&quot;&gt;&lt;/section&gt;\n&lt;/div&gt;</code></pre>\n<p>最开始的思路：</p>\n<ol>\n<li>直接将main-title 设置margin-top: -20px，但这样会导致中间主内容整体上移，覆盖顶部部分内容，不可行</li>\n<li>然后想到使用background-position属性将中间部分内容背景顶部开始位置设置20px左右，这样margin上去后，部分内容使用的就会是顶部的背景。但中间部分内容又设置了backgroud-repeat属性，导致background-position设置失效。不可行</li>\n<li>换个思路，将main-title再用一层div包裹，外层div position设置为relative, main-title设置为position:absolute，这样 top:-20px 即可实现需求。</li>\n</ol>\n<p>但问题来了。标题如果过长，会分行显示(可能是2行，3行，4行)，这样会覆盖下面的产品信息。所以需要知道标题的高度。但标题是position：absolute的，已经脱离的文档流，无法对现有文档布局造成影响。</p>\n<p>貌似没有css的解决方法，只能通过dom，计算title高度，然后将产品信息设置对应的margin-top，js计算div高度</p>\n<pre><code class=\"language-js\">let heigt = document.getElementById(&#39;autoHeightTitle&#39;).clientHeight - relatvie包裹元素高度 + &#39;px&#39;\ndocument.getElementById(&#39;autoMarginTop&#39;).style.marginTop = height</code></pre>\n<p><img src=\"../../../images/blog/css/css_absolute_auto_height.png\" alt=\"css_absolute_auto_height.png\"></p>\n<h2 id=\"更好的方法positionrelative\">更好的方法position:relative</h2>\n<p>标题使用 position:relative; top:-10px 就可以了，之前一直不知道position:relative也可以设置top等属性，看来基础还是欠缺</p>\n<p>完整demo源码: <a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/css%E5%B0%86%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E6%94%BE%E5%88%B0%E5%85%B6%E4%BB%96%E5%8C%BA%E5%9F%9F/index.html\">css将部分内容放到其他区域 - github</a></p>\n<p>demo地址：<a href=\"https://zuoxiaobai.github.io/fedemo//src/DebugDemo/css%E5%B0%86%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E6%94%BE%E5%88%B0%E5%85%B6%E4%BB%96%E5%8C%BA%E5%9F%9F/index.html\">css将部分内容放到其他区域 - 在线演示</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "position:absolute元素高度自适应，换成relative设置top试试",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "一个例子"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "更好的方法position:relative"
            }
          ]
        }
      ],
      "config": {
        "source": "position:absolute元素高度自适应，换成relative设置top试试.md",
        "staticFileName": "absolute_auto_height.html",
        "author": "guoqzuo",
        "createDate": "2019/11/08",
        "description": "一般元素设置position:absolute后，就已经脱离了文档流，用css是无法计算其高度的，只能用js获取dom来计算。另外不要把自己限制死了，对于自适应高度的，为什么一定要使用position:absolute呢？**换position:relative也可以设置top、left等css属性**，如果自己真的想不到好的方法，问问其他同事或社群里的人试试？下面来看看我之前由于知识盲点踩的一个坑",
        "keywords": "position:absolute元素高度自适应,怎么用js计算元素高度",
        "category": "CSS",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"background-repeat与background-position冲突\">background-repeat与background-position冲突</h1>\n<p>background-repeat和background-position最好不要一起使用，background-repeat可能会导致background-position设置失效</p>\n<p>当设置是background-repeat在y轴重复背景时，background-position设置的顶部开始具体位置会无效</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "background-repeat与background-position冲突"
        }
      ],
      "config": {
        "source": "background-repeat与background-position冲突.md",
        "staticFileName": "repeat_position.html",
        "author": "guoqzuo",
        "createDate": "2019/11/08",
        "description": "background-repeat和background-position最好不要一起使用，background-repeat可能会导致background-position设置失效，当设置是background-repeat在y轴重复背景时，background-position设置的顶部开始具体位置会无效",
        "keywords": "background-repeat与background-position冲突,background-repeat导致background-position失效",
        "category": "CSS",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"函数命名validate和verify的区别\">函数命名validate和verify的区别</h1>\n<p>verify validate区别，一般我们在命名校验的函数时，发现validate和verify都有校验的意思，具体用那个呢？我们来看看</p>\n<ol>\n<li><strong>validate</strong> 指要付出一段程序化的核实过程。从事物的多个方面来说的，具有充分证据，<strong>且已实施，从多个方面论证</strong>。</li>\n<li><strong>verify</strong> 是一般的检验，检查，倾向于一个动作, 从事情或事物的一个方面来说的，具有证据，且<strong>已实施，但只从一个方面实施</strong>；</li>\n<li><strong>confirm</strong> 则是确认，是<strong>从主观判断来说的，可能有一些证据，但未实施</strong></li>\n</ol>\n<p>其实区别只是在于证实的强度：confirm &lt; verify &lt; validate</p>\n<p>参考：<a href=\"https://zhidao.baidu.com/question/486470512.html\">https://zhidao.baidu.com/question/486470512.html</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "函数命名validate和verify的区别"
        }
      ],
      "config": {
        "source": "函数命名validate和verify的区别.md",
        "staticFileName": "validate_verify.html",
        "author": "guoqzuo",
        "createDate": "2019/11/09",
        "description": "verify validate区别，一般我们在命名校验的函数时，发现validate和verify都有校验的意思，具体用那个呢？其实区别只是在于证实的强度：confirm < verify < validate，我们来看看",
        "keywords": "函数命名validate和verify的区别,verify validate区别,verify和validate,",
        "category": "计算机基础与开发工具",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"css样式优先级，防止外部样式污染组件\">css样式优先级，防止外部样式污染组件</h1>\n<p>一般在写全局的样式时，总担心污染其他位置的样式，但我们怎么防止别人的样式来污染我们的样式了。一句话总结：对于很重要，不要被污染的用!important，如果不想用!important，那最前面加id，或者多加一个或多个优先级高的选择器，来提高整体优先级</p>\n<p>这里复习下之前看HTML权威指南css部分及CSS权威指南里<a href=\"https://www.yuque.com/guoqzuo/js_es6/dg9u82#4944cc9c\">css优先级的问题</a></p>\n<p>如果两条定义于同一层次的样式都能应用于同一个元素。且都包含同样的属性值，就需要根据特殊性来决定到底使用哪种。</p>\n<ul>\n<li>a. 样式的选择器中id值的数目(#)</li>\n<li>b. 选择器中其他属性和伪类的数目(.class等属性)</li>\n<li>c. 选择器中元素名和伪元素数目（元素名等）</li>\n</ul>\n<p>a的特殊性最高，b其次，c最低。按a-b-c来表示。比如如果a值相等，才会去比较b。1-0-0的特殊性比0-5-5高。在 CSS权特威指南 中，有4位，最高位为内嵌(Inline)样式设置的样式。关于特殊性，建议看CSS权威指南，个人认为比这里要好理解一点。如果层级一样，谁后定义的，优先级就越高</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "css样式优先级，防止外部样式污染组件"
        }
      ],
      "config": {
        "source": "css样式优先级，防止外部样式污染组件.md",
        "staticFileName": "css_style_priority.html",
        "author": "guoqzuo",
        "createDate": "2019/11/09",
        "description": "一般在写全局的样式时，总担心污染其他位置的样式，但我们怎么防止别人的样式来污染我们的样式了。一句话总结：对于很重要，不要被污染的用!import，如果不想用!important，那最前面加id，或者多加一个或多个优先级高的选择器，来提高整体优先级",
        "keywords": "css样式优先级,css样式优先级计算,css选择器样式优先级,css防止外部样式污染组件",
        "category": "CSS",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"非箭头函数作为参数时this问题\">非箭头函数作为参数时this问题</h1>\n<p>复习下JS高程3里面将的函数做参数时this的问题，如果是非箭头函数，参数函数中使用了this，那么this取决于执行函数的this指向，而非参数函数执行环境的this，怎么将this绑定呢？有三种方法</p>\n<ol>\n<li>使用bind绑定一个作用域 </li>\n<li>使用闭包 </li>\n<li>使用箭头函数</li>\n</ol>\n<p>来看 demo</p>\n<pre><code class=\"language-js\">var a = 5\n\nfunction callback() {\n  console.log(&#39;-- callback this&#39;, this, this.a, &#39;--&#39;)\n}\nfunction validate() {\n  console.log(&#39;-- validate this&#39;, this, this.a, &#39;--&#39;)\n}\nfunction showPrompt(title, validate, callback) {\n  validate()\n  callback()\n}\nshowPrompt(&#39;1&#39;, validate, callback) // 5 5 \nshowPrompt(&#39;1&#39;, validate.bind({a: 2}), callback.bind({a: 1})) // 2 1</code></pre>\n<p>或者</p>\n<pre><code class=\"language-js\">var a = 5\nvar callback = {\n  a: 1,\n  handler() {\n    console.log(this, this.a)\n  }\n}\nvar validate = {\n  a: 2,\n  handler() {\n    console.log(this, this.a)\n  }\n}\nfunction showPrompt(title, validate, callback) {\n  validate()\n  callback()\n}\nshowPrompt(&#39;1&#39;, validate.handler, callback.handler) // 5 5 \nshowPrompt(&#39;1&#39;, validate.handler.bind(validate), callback.handler.bind(callback)) // 2 1</code></pre>\n<p>使用箭头函数</p>\n<pre><code class=\"language-js\">var a = 5\nvar callback = {\n  a: 1,\n  handler: () =&gt; {\n    console.log(this, this.a)\n  }\n}\nvar validate = {\n  a: 2,\n  handler: () =&gt; {\n    console.log(this, this.a)\n  }\n}\nfunction showPrompt(title, validate, callback) {\n  validate()\n  callback()\n}\nshowPrompt(&#39;1&#39;, validate.handler, callback.handler) // 5 5 \nshowPrompt(&#39;1&#39;, validate.handler.bind(validate), callback.handler.bind(callback)) // 5 5</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "非箭头函数作为参数时this问题"
        }
      ],
      "config": {
        "source": "非箭头函数作为参数时this问题.md",
        "staticFileName": "js_this.html",
        "author": "guoqzuo",
        "createDate": "2019/11/09",
        "description": "复习下JS高程3里面将的函数做参数时this的问题，如果是非箭头函数，参数函数中使用了this，那么this取决于执行函数的this指向，而非参数函数执行环境的this，怎么将this绑定呢？有三种方法，1.使用bind绑定一个作用域 2.使用闭包 3.使用箭头函数",
        "keywords": "非箭头函数作为参数时this问题",
        "category": "JavaScript",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"点击外部关闭div---js阻止事件冒泡实例\">点击外部关闭div - js阻止事件冒泡实例</h1>\n<p>一般在做弹窗div时，需要做点击div外部关闭div的功能，怎么做到的呢？一句话总结：用一个父元素(铺满屏幕，绝对布局)包裹该div(绝对布局，水平垂直居中，固定宽高)，<strong>父元素监听点击事件后移除div，子元素div监听点击后阻止事件冒泡</strong>。这样就实现了，点击外部关闭div，点击内部区域不关不div。</p>\n<p>来看测试demo</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n  &lt;button id=&quot;clickme&quot;&gt;点击我弹窗对话框&lt;/button&gt;\n  &lt;script&gt;\n    function showPopup(event) {\n      let tempHtml = `\n        &lt;!-- 遮罩 --&gt;\n        &lt;div class=&quot;mask&quot; style=&quot;position:absolute;z-index:25555;top:0;bottom:0;width:100%;background:#888;opacity:0.5&quot;&gt;&lt;/div&gt;\n        &lt;!-- 内容区域--&gt;\n        &lt;div id=&quot;popup-content-container&quot; class=&quot;content-container&quot; style=&quot;position:absolute;z-index:25556;top:0;bottom:0;width:100%&quot;&gt;\n          &lt;div id=&quot;popup-content-main&quot; class=&quot;content-main&quot; style=&quot;position:absolute;top:50%;left:50%; transform: translate(-50%, -50%); width:300px;height:200px;background:#fff;border:1px solid #ddd;&quot;&gt;\n            我是弹窗盒子  \n            &lt;button id=&quot;closebtn&quot;&gt;关闭&lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      `\n\n      // 创建div\n      let div = document.createElement(&#39;div&#39;)\n      div.setAttribute(&#39;id&#39;, &#39;popup-div&#39;)\n      div.innerHTML = tempHtml\n\n      // 挂载到dom\n      document.body.appendChild(div)\n\n      // 事件监听\n      // 关闭弹窗\n      document.getElementById(&#39;closebtn&#39;).onclick = function(e) {\n        document.body.removeChild(div)  // 移除元素\n      }\n\n      // 点击外部关闭div 关键代码  \n      document.getElementById(&#39;popup-content-container&#39;).onclick = function(e) {\n        document.body.removeChild(div)  // 移除元素\n      }\n      document.getElementById(&#39;popup-content-main&#39;).onclick = function(e) {\n        e.stopPropagation() \n      }\n    }\n\n    // 简单的弹窗框封装，只为测试点击外部关闭div\n    document.getElementById(&#39;clickme&#39;).onclick = (event) =&gt; {\n      showPopup(event)\n    }\n  &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p>完整demo地址：<a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/%E7%82%B9%E5%87%BB%E5%A4%96%E9%83%A8%E5%85%B3%E9%97%ADdiv/index.html\">点击外部关闭div - github</a></p>\n<p>在线演示地址: <a href=\"https://zuoxiaobai.github.io/fedemo/src/DebugDemo/%E7%82%B9%E5%87%BB%E5%A4%96%E9%83%A8%E5%85%B3%E9%97%ADdiv/index.html\">点击外部关闭div - 在线演示</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "点击外部关闭div - js阻止事件冒泡实例"
        }
      ],
      "config": {
        "source": "点击外部关闭div - js阻止事件冒泡实例.md",
        "staticFileName": "click_external_close.html",
        "author": "guoqzuo",
        "createDate": "2019/11/09",
        "description": "点击外部关闭div，一般在做弹窗div时，需要做点击div外部关闭div的功能，怎么做到的呢？一句话总结：用一个父元素(铺满屏幕，绝对布局)包裹该div(绝对布局，水平垂直居中，固定宽高)，**父元素监听点击事件后移除div，子元素div监听点击后阻止事件冒泡**。这样就实现了，点击外部关闭div，点击内部区域不关不div。",
        "keywords": "点击div外部关闭div,js点击外部关闭div,点击外部关闭div,js阻止事件冒泡实例",
        "category": "JavaScript",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"原生js封装prompt组件\">原生JS封装prompt组件</h1>\n<p>旧项目中要用到prompt功能，但需要优化下UI，整体导入elementUI不合适，就自己用原生JS写了个。样式、div结构，直接从elementUI message-box审查元素里面抽离，相关点击事件，校验，自己封装。</p>\n<p>先来看看效果：<a href=\"https://zuoxiaobai.github.io/fedemo/src/DebugDemo/prompt/\">自定义prompt组件 - 在线演示</a></p>\n<p><img src=\"../../../images/blog/js/el_prompt.png\" alt=\"el_prompt.png\"></p>\n<h2 id=\"系统默认windowprompt样式\">系统默认window.prompt()样式</h2>\n<p>先来看原生的prompt</p>\n<pre><code class=\"language-js\">// prompt打开一个对话框，里面包含一个文本输入框，第一个参数为提示内容，第二个参数为输入框的默认值\n// 当点击取消返回null，更改内容后返回对应输入框的内容，如果填写为空，返回&quot;&quot;\nalert(prompt(&#39;请输入你的姓名?&#39;, &#39;张三&#39;));</code></pre>\n<p><img src=\"../../../images/blog/js/default_prompt.png\" alt=\"default_prompt.png\"></p>\n<h2 id=\"自己封装一个prompt组件\">自己封装一个prompt组件</h2>\n<p>为什么我们要自己封装呢？原生prompt的不足:</p>\n<ol>\n<li>标题会附带网站url信息</li>\n<li>无法提示校验错误信息</li>\n<li>各个浏览器的弹窗样式不统一，与UI稿设计给的不一致</li>\n</ol>\n<h3 id=\"封装函数\">封装函数</h3>\n<pre><code class=\"language-js\">/**\n * 向window挂载 elcustomPrompt 函数，代替系统的prompt\n * window.elCustomPrompt  IE9+\n * 从 element UI中抽出messagebox样式结构\n */\n(function() {\n  /**\n   * @description elementUI风格自定义propmt封装\n   * @param { String } title  标题propmt第一个参数\n   * @param { String } placeholder input的placeholder\n   * @param { Function } validateFunc 动态校验值函数\n   *   - 点击确认后，执行的函数，参数为当前值， \n   *   - return格式:\n   *     { result: true, msg: &#39;成功&#39;}\n   *     { result: false, msg: &#39;自定义错误信息&#39; }\n   * 考虑到阻塞程序向下执行，兼容性问题，不使用promise，使用回调函数。\n   * @param { Function } callback 获取到值后的回调\n   */\n  function elCustomPrompt(title, placeholder, validateFunc, callback) {\n    console.log(&#39;show elCustomPrompt&#39;)\n    var deleteImgUrl = &#39;delete.png&#39; // 16 * 16\n    var errMsg = &#39;&#39; // 错误信息\n\n    // 创建dom并挂载\n    var domStr = &#39;&lt;!--遮罩--&gt;&lt;div class=&quot;v-modal&quot; tabindex=&quot;0&quot; style=&quot;z-index:2054;&quot;&gt;&lt;/div&gt;&lt;!--弹窗_start--&gt;&lt;div id=&quot;elCustomPromptMain&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; class=&quot;el-message-box__wrapper&quot; style=&quot;z-index:2055;&quot;&gt;&lt;!--消息盒子_Start--&gt;&lt;div class=&quot;el-message-box&quot; id=&quot;elCustomPromptMessageBox&quot;&gt;&lt;!--顶部title以及关闭按钮--&gt;&lt;div class=&quot;el-message-box__header&quot;&gt;&lt;div class=&quot;el-message-box__title&quot;&gt;&lt;span&gt;&#39;+title+&#39;&lt;/span&gt;&lt;/div&gt;&lt;button type=&quot;button&quot; aria-label=&quot;Close&quot; class=&quot;el-message-box__headerbtn&quot; id=&quot;elCustomPromptCloseBtn&quot;&gt;&lt;img src=&quot;&#39;+deleteImgUrl+&#39;&quot; style=&quot;width:16px;height:16px&quot;&gt;&lt;/button&gt;&lt;/div&gt;&lt;!--内容--&gt;&lt;div class=&quot;el-message-box__content&quot;&gt;&lt;div class=&quot;el-message-box__input&quot;&gt;&lt;div class=&quot;el-input&quot;&gt;&lt;input type=&quot;text&quot; id=&quot;elCustomPromptInput&quot; autocomplete=&quot;off&quot; placeholder=&quot;&#39;+placeholder+&#39;&quot; class=&quot;el-input__inner&quot;&gt;&lt;/div&gt;&lt;div class=&quot;el-message-box__errormsg&quot; id=&quot;elCustomPromptErrMsgDiv&quot; style=&quot;visibility:hidden;&quot;&gt;&#39;+errMsg+&#39;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--底部按钮--&gt;&lt;div class=&quot;el-message-box__btns&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;el-button el-button--default el-button--small&quot; id=&quot;elCustomPromptCancelBtn&quot;&gt;&lt;span&gt;取消&lt;/span&gt;&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;el-button el-button--default el-button--small el-button--primary&quot; id=&quot;elCustomPromptOkBtn&quot; disabled=&quot;disabled&quot;&gt;&lt;span&gt;确定&lt;/span&gt;&lt;/button&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--消息盒子_end--&gt;&lt;/div&gt;&lt;!--弹窗_end--&gt;&#39;\n\n    var div = document.createElement(&#39;div&#39;)\n    div.setAttribute(&#39;id&#39;, &#39;elCustomPromptDiv&#39;)\n    div.innerHTML = domStr\n    document.body.appendChild(div)\n\n    // 移除弹窗框\n    function removeDiv() {\n      document.body.removeChild(div)\n    }\n\n    // 绑定事件\n    var elCustomPromptErrMsgDiv = document.getElementById(&#39;elCustomPromptErrMsgDiv&#39;), \n        elCustomPromptCloseBtn = document.getElementById(&#39;elCustomPromptCloseBtn&#39;),\n        elCustomPromptCancelBtn = document.getElementById(&#39;elCustomPromptCancelBtn&#39;),\n        elCustomPromptOkBtn = document.getElementById(&#39;elCustomPromptOkBtn&#39;),\n        elCustomPromptInput = document.getElementById(&#39;elCustomPromptInput&#39;),\n        elCustomPromptMain = document.getElementById(&#39;elCustomPromptMain&#39;)\n        elCustomPromptMessageBox = document.getElementById(&#39;elCustomPromptMessageBox&#39;)\n\n    // 关闭弹窗、取消事件\n    elCustomPromptCloseBtn.onclick = function() {\n      removeDiv()\n    }\n    elCustomPromptCancelBtn.onclick = function() {\n      removeDiv()\n    }\n\n    // 点击确定后的操作\n    elCustomPromptOkBtn.onclick = function() {\n      console.log(&#39;点击了确定&#39;)\n\n      // 再次校验\n      let tempResult = validateFunc(elCustomPromptInput.value)\n      if (!tempResult.result) {\n        elCustomPromptErrMsgDiv.style.visibility = &#39;visible&#39;\n        elCustomPromptErrMsgDiv.innerHTML = tempResult.msg\n        elCustomPromptOkBtn.setAttribute(&#39;disabled&#39;, &#39;disabled&#39;)\n        return\n      }\n\n      // 关闭 弹窗，调用callback\n      removeDiv()\n      callback(elCustomPromptInput.value)\n    }\n\n    // 输入事件\n    elCustomPromptInput.oninput = function(e) {\n      console.log(elCustomPromptInput.value)\n\n      // 校验并显示信息\n      var tempResult = validateFunc(elCustomPromptInput.value)\n      console.log(tempResult)\n      if (tempResult.result) {\n        console.log(&#39;成功&#39;)\n        // 校验成功\n        elCustomPromptErrMsgDiv.style.visibility = &#39;hidden&#39;\n        elCustomPromptErrMsgDiv.innerHTML = &#39;&#39;\n        elCustomPromptOkBtn.removeAttribute(&#39;disabled&#39;)\n      } else {\n        // 校验失败\n        console.log(&#39;失败&#39;)\n        elCustomPromptErrMsgDiv.style.visibility = &#39;visible&#39;\n        elCustomPromptErrMsgDiv.innerHTML = tempResult.msg\n        elCustomPromptOkBtn.setAttribute(&#39;disabled&#39;, &#39;disabled&#39;)\n      }\n    }\n\n    // 空白位置点击关闭弹窗\n    elCustomPromptMain.onclick = function() {\n      removeDiv()\n    }\n    elCustomPromptMessageBox.onclick = function(e) {\n      event.stopPropagation()\n    }\n  }\n\n  window.elCustomPrompt = elCustomPrompt\n})()\n</code></pre>\n<h3 id=\"调用示例\">调用示例</h3>\n<pre><code class=\"language-html\">&lt;button onclick=&quot;showMsg()&quot;&gt;弹窗&lt;/button&gt;\n&lt;script&gt;\nvar title = &#39;自定义客户属性标签&#39;,\n    placeholder = &#39;请输入标签，最多5个汉字或英文&#39;\n\n// 校验函数    \nvar validateFunc = function() {\n  var that = this\n  return function(text) {\n    var MSG_FORMAT_ERROR = &#39;格式错误，只能是1-5个汉字或字符串&#39;\n    var MSG_TAG_EXIST = &#39;该客户属性已存在，无法添加&#39;\n    var MSG_NOT_EMPTY = &#39;内容不能为空&#39;\n\n    // 格式校验\n    if (text === &#39;&#39;) {\n      return { result: false, msg: MSG_NOT_EMPTY }  \n    }\n    if (!/^[\\u4E00-\\u9FA5a-zA-Z]{1,5}$/.test(text)) {\n      return { result: false, msg: MSG_FORMAT_ERROR } \n    }\n\n    // 是否有重复\n    return { result: true, msg: &#39;成功&#39; }\n  }\n}\n\n// 回调\nvar callback = function() {\n  var that = this\n  return function(text) {\n    // 执行后续操作\n    console.log(&#39;执行成功&#39;, text)\n  }\n}\n\n// elCustomPrompt(title, placeholder, validateFunc, callback)\nfunction showMsg() {\n  elCustomPrompt(title, placeholder, validateFunc(), callback())\n}\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"github完整代码\">github完整代码</h3>\n<p>上面是没有element样式的，完整demo参见 <a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/prompt/index.html\">自定义prompt | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "原生JS封装prompt组件",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "系统默认window.prompt()样式"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "自己封装一个prompt组件",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "封装函数"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "调用示例"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "github完整代码"
                }
              ]
            }
          ]
        }
      ],
      "config": {
        "source": "原生JS封装prompt组件.md",
        "staticFileName": "custom_prompt.html",
        "author": "guoqzuo",
        "createDate": "2019/11/09",
        "description": "自定义prompt组件，原生JS封装prompt，就项目中要用到prompt功能，但需要优化下UI，整体导入elementUI不合适，就自己用原生JS写了个。样式、div结构，直接从elementUI message-box审查元素里面抽离，相关点击事件，校验，自己封装。",
        "keywords": "自定义prompt,原生js自定义prompt组件",
        "category": "JavaScript",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"docker与k8s集群\">Docker与K8S集群</h1>\n<p>现在前端项目很多部署在docker容器上，相比之前的实体服务器、虚拟机来讲，docker不需要自己安装软件，可以直接配置使用，比较方便。下面来简单了解下</p>\n<h2 id=\"docker容器\">Docker容器</h2>\n<p>容器是虚拟机的一个发展，相对传统的虚拟机，容器的优点:</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>虚拟机</th>\n<th>容器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>隔离级别</td>\n<td>操作系统级</td>\n<td>进程级</td>\n</tr>\n<tr>\n<td>隔离策略</td>\n<td>Hypervisor</td>\n<td>CGroups</td>\n</tr>\n<tr>\n<td>系统资源</td>\n<td>5-15%</td>\n<td>0-5%</td>\n</tr>\n<tr>\n<td>启动时间</td>\n<td>分钟级</td>\n<td>秒级</td>\n</tr>\n<tr>\n<td>镜像存储</td>\n<td>GB-TB</td>\n<td>KB-MB</td>\n</tr>\n<tr>\n<td>集群规模</td>\n<td>上百</td>\n<td>上万</td>\n</tr>\n<tr>\n<td>高可用策略</td>\n<td>备份、容灾、迁移</td>\n<td>弹性、负载、动态</td>\n</tr>\n</tbody></table>\n<h2 id=\"k8s集群\">K8S集群</h2>\n<p>K8S是基于容器的集群管理平台，它的全称，是kubernetes。</p>\n<ul>\n<li>Kubernetes这个单词来自于希腊语，含义是舵手或领航员。K8S是它的缩写，用“8”字替代了“ubernete”这8个字符。</li>\n<li>和Docker不同，K8S的创造者，是众人皆知的行业巨头——Google。K8S是2014年6月由Google公司正式公布出来并宣布开源的。</li>\n<li>一个K8S系统，通常称为一个K8S集群（Cluster）。这个集群主要包括两个部分：<ul>\n<li>一个Master节点（主节点）主要负责管理和控制<ul>\n<li>API Server 是整个系统的对外借款，供客户端何其他组件调用，相当于营业厅</li>\n<li>Scheduler 负责对集群内的资源进行调度，相当于调度室</li>\n<li>Controller manager负责管理控制器，相当于大总管</li>\n</ul>\n</li>\n<li>一群Node节点（计算节点）Node节点是工作负载节点，里面是具体的容器<ul>\n<li>Docker 用来创建容器 </li>\n<li>kubelet 主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等</li>\n<li>kebu-proxy 主要负责为Pod对象提供代理</li>\n<li>Fluentd 主要负责日志收集、存储与查询</li>\n<li>kube-dns（可选）</li>\n<li>Pod, Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考\">参考</h2>\n<p><a href=\"https://my.oschina.net/jamesview/blog/2994112\">干货满满！10分钟看懂Docker和K8S</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Docker与K8S集群",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "Docker容器"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "K8S集群"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "Docker与K8S集群.md",
        "staticFileName": "docker_k8s.html",
        "author": "guoqzuo",
        "createDate": "2019/11/11",
        "description": "现在前端项目很多部署在docker容器上，相比之前的实体服务器、虚拟机来讲，docker不需要自己安装软件，可以直接配置使用，比较方便。下面来简单了解下",
        "keywords": "Docker与K8S集群",
        "category": "运维部署与版本控制",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"ci、cd、co是什么意思\">CI、CD、CO是什么意思</h1>\n<p>CI CD CO 是什么意思呢？在开发中他们分别代表 CI持续集成 =&gt; CD持续交付/持续部署 =&gt; CO持续运营，下面来看看</p>\n<h2 id=\"ci持续集成continuous-integration\">CI持续集成(continuous integration)</h2>\n<p>CI 指的是持续集成，从研发团队提交代码作为起点，经过构建扫描测试等环节，以版本仓库为终点</p>\n<p>这中间，需要对每个新功能或者问题修复创建自动化测试用例。对新提交的代码执行自动化测试。</p>\n<p>通过自动化测试可以提早拿到测试结果，测试成本也大幅降低，CI服务器可以在几秒钟运行上百条测试。</p>\n<p>一般从程序员开发的角度来讲，持续集成 CI，包含了持续部署CD。比如代码 merge 到 master 分支时，会触发一个 action，自动将代码部署到服务器。</p>\n<p>但在某些比较细分的情况，CI就不包含部署了。比如多个功能、版本可能会同时开发。但测试环境只有两个。不可能直接提交代码，就自动部署到测试环境了。测试环境可能在验证其他功能。这就需要在devops平台手动点击部署，并选择对应的测试环境。这种情况，代码提交到仓库就算是 CI 持续集成了。</p>\n<h2 id=\"cd持续交付部署continuous-deliverycontinuous-deployment\">CD持续交付/部署(continuous delivery/continuous deployment)</h2>\n<p>CD 有两种解释：持续交付/持续部署，以版本仓库为起点，经过各模块自动化部署，到业务上线提供服务为终点，可以一键部署，自动触发发布流程</p>\n<p>CD 更偏向于把功能进行上线。一键部署或自动部署（合并到master）。</p>\n<h2 id=\"co持续运营continuous-operation\">CO持续运营(continuous operation)</h2>\n<p>CO 指的是持续运营，从业务上线服务为起点，到业务下线终止服务，期间包含各种运营事件。</p>\n<p>总之这些都是概念性的，它们用于描述软件开发中的一些过程，大家心里有自己的一个理解就好，没有标准的答案。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/31097868\">一文帮你秒懂CI, CD AND CD</a></li>\n<li><a href=\"https://www.sohu.com/a/275215574_355140\">腾讯这种级别的大厂是怎么做运维转型的？</a></li>\n<li><a href=\"http://www.360doc.com/content/18/0903/11/19960613_783492490.shtml\">详解CI、CD &amp; CD – 运维生存时间</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "CI、CD、CO是什么意思",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "CI持续集成(continuous integration)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "CD持续交付/部署(continuous delivery/continuous deployment)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "CO持续运营(continuous operation)"
            }
          ]
        }
      ],
      "config": {
        "source": "CI、CD、CO是什么意思.md",
        "staticFileName": "ci_cd_co.html",
        "author": "guoqzuo",
        "createDate": "2019/11/11",
        "description": "CI CD CO 是什么意思呢？在开发中他们分别代表 CI持续集成 => CD持续交付/持续部署 => CO持续运营，下面来看看",
        "keywords": "CI CD CO,CI、CD、CO是什么意思,CI,CD,CO,CI持续集成,CD持续交付,CO持续运营",
        "category": "运维部署与版本控制",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"什么是serverless\">什么是serverless</h1>\n<p>什么是serverless，最近在前端开发领域是一个比较火的概念，字面意思是无服务器，小程序云开发就是一种</p>\n<p>主要是弱化服务器概念，把原来需要后端开发的内容搬到前端，让前端可以不用管数据库建表、部署方面的事情，写好代码一提交就可以自动生成对应的接口服务。</p>\n<h2 id=\"发展过程\">发展过程</h2>\n<p>物理设备 =&gt; 虚拟机 =&gt; 容器 =&gt; serverless（只需关注业务逻辑，不需要关心服务器资源等）</p>\n<h2 id=\"severless优势\">severless优势</h2>\n<ol>\n<li>减少人力成本7-8人开发  =&gt; 2-3人</li>\n<li>弹性伸缩，所需耗时: 虚拟机(小时级) =&gt; 容器(分钟级) =&gt; serverless(毫秒级)</li>\n<li>故障恢复方面优势</li>\n</ol>\n<h2 id=\"serverless-支持语言\">serverless 支持语言</h2>\n<p>现在一般支持nodejs，java，go，php，python</p>\n<h2 id=\"注意\">注意</h2>\n<p>注意serverless强依赖某个平台及其开放的服务</p>\n<p>参考：<a href=\"https://cloud.tencent.com/product/scf\">云函数 Serverless Cloud Function</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "什么是serverless",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "发展过程"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "severless优势"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "serverless 支持语言"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "注意"
            }
          ]
        }
      ],
      "config": {
        "source": "什么是serverless.md",
        "staticFileName": "serverless.html",
        "author": "guoqzuo",
        "createDate": "2019/11/11",
        "description": "什么是serverless，最近在前端开发领域是一个比较火的概念，字面意思是无服务器，小程序云开发就是一种，主要是弱化服务器概念，把原来需要后端开发的内容搬到前端，让前端可以不用管数据库建表、部署方面的事情，写好代码一提交就可以自动生成对应的接口服务。",
        "keywords": "什么是serverless,serverless,severless是什么,serverless优点,serverless发展过程",
        "category": "计算机基础与开发工具",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"什么是devops\">什么是DevOps</h1>\n<p>DevOps 是 Development（开发）和 Operations（运维） 的组合词，目前学术界和从业人员还没有为 &quot;DevOps&quot; 建立唯一的定义</p>\n<h2 id=\"devops可以做什么\">DevOps可以做什么</h2>\n<p>DevOps可以改变 运营、开发、测试人员在开发和交付过程中协作的方式。</p>\n<p>DevOps 强调的是高效组织团队之间如何通过自动化的工具协作和沟通来完成软件的生命周期管理，从而更快、更频繁地交付更稳定的软件</p>\n<h2 id=\"为什么会出现devops\">为什么会出现DevOps</h2>\n<p>DevOps 的出现是由于软件行业日益清晰地认识到，为了按时交付软件产品和服务，开发部门和运维部门必须紧密合作。</p>\n<h2 id=\"企业为什么需要devops\">企业为什么需要DevOps</h2>\n<ol>\n<li><strong>为了抓住商业机会，业务需要快速迭代，不断试错</strong>，因此，企业需要依赖拥有持续交付的能力，这些不仅包括技术需求还包括产品的需求，如何能拥有持续交付的能力，大而全的架构因为效率低下，显然是不合适的。于是演变出微服务架构来满足需求，通过把系统划分出一个个独立的个体，每个个体服务的设计依赖需要通过12要素的原则来规范完成。</li>\n<li>系统被分成了几十个甚至几百个服务组件，则需要借助DevOps 才能很好地满足业务协作和发布等流程。</li>\n</ol>\n<h2 id=\"devops有什么依赖？\">DevOps有什么依赖？</h2>\n<p>DevOps 的有效实施需要依赖一定的土壤，即敏捷的基础设施服务，现实只有云计算的模式才能满足整体要求。</p>\n<p>DevOps 希望做到的是软件产品交付过程中IT工具链的打通，使得各个团队减少时间损耗，更加高效地协同工作。</p>\n<p>参考: <a href=\"https://www.zhihu.com/question/58702398/answer/235777073\">什么是DevOps？ - 网易云 知乎回答</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "什么是DevOps",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "DevOps可以做什么"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "为什么会出现DevOps"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "企业为什么需要DevOps"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "DevOps有什么依赖？"
            }
          ]
        }
      ],
      "config": {
        "source": "什么是DevOps.md",
        "staticFileName": "devops.html",
        "author": "guoqzuo",
        "createDate": "2019/11/11",
        "description": "DevOps 是 Development（开发）和 Operations（运维） 的组合词，DevOps可以做什么？为什么会出现DevOps？企业为什么需要DevOps？DevOps有什么依赖？目前学术界和从业人员还没有为 'DevOps' 建立唯一的定义",
        "keywords": "DevOps",
        "category": "计算机基础与开发工具",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"移动端屏幕尺寸大小\">移动端屏幕尺寸大小</h1>\n<p>在开发中，我们一般需要知道常用手机型号的屏幕尺寸，这样才能更好的适配移动端，下面来看看小程序开发工具中提供的各个手机型号尺寸</p>\n<p><img src=\"../../../images/blog/devtools/screen_size.png\" alt=\"screen_size.png\"></p>\n<p>一般我认为比较标准的是 iphone 6/7/8</p>\n<p>对于全面屏来讲，宽度和 ihpone 7/8 一致，但页面长度却长很多，一般 高度 / 宽度 &gt;=2 的就是全面屏，页面布局需要特殊处理下</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "移动端屏幕尺寸大小"
        }
      ],
      "config": {
        "source": "移动端屏幕尺寸大小.md",
        "staticFileName": "screen_size.html",
        "author": "guoqzuo",
        "createDate": "2019/11/11",
        "description": "在开发中，我们一般需要知道常用手机型号的屏幕尺寸，这样才能更好的适配移动端，下面来看看小程序开发工具中提供的各个手机型号尺寸，对于全面屏来讲，宽度和 ihpone 7/8 一致，但页面长度却长很多，一般 高度 / 宽度 >=2 的就是全面屏，页面布局需要特殊处理下",
        "keywords": "移动端屏幕尺寸大小,常用手机屏幕大小,怎么判断是全面屏",
        "category": "CSS",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"为什么说tofixed是不准确的\">为什么说toFixed是不准确的</h1>\n<p>Number.prototype.toFixed() 对number取整或保留指定小数位，但它是不准确的，就类似 0.1 + 0.2 ≠ 0.3 一样，下面来看看怎么处理</p>\n<h2 id=\"numberprototypetofixed\">Number.prototype.toFixed()</h2>\n<pre><code class=\"language-js\">/**\n * Number.prototype.toFixed()\n * The toFixed() method formats a number using fixed-point notation.\n * 使用方法：\n * numObj.toFixed(digits) \n * @params { Integer } digits 可选 保留精度，为空时，默认为0，即取整\n * @returns { String } 返回转换后的字符串\n */\nvar a = 1.235\na.toFixed()  // &quot;1&quot;\ntypeof a.toFixed()  // &quot;string&quot;\na.toFixed(2) // &quot;1.23&quot;</code></pre>\n<h2 id=\"tofixed四舍五入不准确的问题\">toFixed四舍五入不准确的问题</h2>\n<pre><code class=\"language-js\">var a = 0.15\nvar b = 0.25\na.toFixed(1) // &quot;0.1&quot;  注意这里四舍五入异常\nb.toFixed(1) // &quot;0.3&quot;  这里四舍五入又是成功的</code></pre>\n<p>怎么改善呢？假如想对0.15保留1位小数，先乘以10, 再使用Math.round四舍五入，再除以10，再用toFixed()，0.15保留1位小数就是正常的0.2了。以此类推</p>\n<p>我们可以来写一个通用的myToFixed方法处理</p>\n<pre><code class=\"language-js\">// 如果希望精准的保留1位小数可以   Math.round(a*10) / 10, 如果是两位 100，n位  Math.pow(10, n)\nNumber.prototype.myToFixed = function (num) {\n  // 在原型方法注入 myToFixed函数，这里怎么获取当前的值呢？可以使用this\n  // 注意 this 是一个Number对象\n  // var a = Number(2)  // 2  typeof a 为 &quot;number&quot;\n  // var b = new Number(2) // Number{2}  typeof b 为 &quot;object&quot;\n  // 获取值需要使用 b.valueOf()  // 2\n\n  // 如果没有传参数\n  if (num === undefined) {\n    return Math.round(this.valueOf())\n  }\n\n  // 如果有传参，且为整数\n  if (Number.isInteger(num)) {\n    var tempCount = Math.pow(10, num)\n    var tempNum = Math.round(this.valueOf() * tempCount) / tempCount\n    // 这一步其实已经就可以了。但对于保留整数后面两位小数来说，会有bug\n    // var a = 2\n    // a.myToFixed(2)  =&gt;  2  而不是 2.00\n    // 需要再转换下\n    return tempNum.toFixed(num)\n  } else {\n    throw new Error(&#39;参数必须是number类型，且必须是整数&#39;)\n  }\n}</code></pre>\n<h2 id=\"num100100与num10000的区别\">num*100*100与num*10000的区别</h2>\n<p>注意js浮点运算精度</p>\n<pre><code class=\"language-js\">0.61115 * 100 * 100\n// 6111.499999999999\n0.61115 * 10000\n// 6111.5</code></pre>\n<h2 id=\"负数的运算符优先级问题\">负数的运算符优先级问题</h2>\n<pre><code class=\"language-js\">-2.12.toFixed(1) // -2.1  注意返回的字符串，被 - 操作后就是number了\n(-2.12).toFixed(1) // &quot;-2.1&quot;</code></pre>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed\">Number.prototype.toFixed() - MDN</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "为什么说toFixed是不准确的",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "Number.prototype.toFixed()"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "toFixed四舍五入不准确的问题"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "num\\*100\\*100与num*10000的区别"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "负数的运算符优先级问题"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "为什么说toFixed是不准确的.md",
        "staticFileName": "toFixed.html",
        "author": "guoqzuo",
        "createDate": "2019/11/12",
        "description": "Number.prototype.toFixed() 对number取整或保留指定小数位，但它是不准确的，就类似 0.1 + 0.2 ≠ 0.3 一样，下面来看看怎么处理",
        "keywords": "toFixed不精确的问题,toFixed保留小数点不准确的问题",
        "category": "JavaScript",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"vscode-插件推荐，前端开发-vscode-常用插件\">vscode 插件推荐，前端开发 vscode 常用插件</h1>\n<p>vscode 好用的插件推荐，在前端开发中，一般使用 vscode 来做开发，下面是一些开发中用的较多的插件推荐：Vetur、Vue VSCode snippets、GitLens、Preview on Web Server、ESLint 等</p>\n<h2 id=\"vetur\">Vetur</h2>\n<p>Vue 语法高亮、错误检查，Vue 开发必备</p>\n<p><img src=\"../../../images/blog/devtools/vetur-snippets.png\" alt=\"vetur-snippets\"></p>\n<h2 id=\"vue-vscode-snippets\">Vue VSCode snippets</h2>\n<p>v 系列指令可以快速写功能。不用手动去敲。比如基本结构 vbase 回车即可创建基本 vue 单文件结构, vdata 可以快速创建 data，vmethods 可以快速创建 methods，等等</p>\n<h2 id=\"gitlens\">GitLens</h2>\n<p>vscode插件名称: &quot;GitLens -- Git supercharged&quot;，安装后点击某一行代码，都会显示最近的 git 提交记录，在维护代码时，可以很快的知道代码最近是谁修改的，做了哪些更改等。</p>\n<p><img src=\"../../../images/blog/devtools/vscode_plugin_git.png\" alt=\"vscode_plugin_git.png\"></p>\n<h2 id=\"preview-on-web-server\">Preview on Web Server</h2>\n<p>使用 http 方式（非默认的文件方式）快速调试单个 html 文件。在 html 文件编辑区域，右键 =&gt; Launch on browser，可以快速以 http 的方式打开 html 并实时更新，不需要自己搭建 node 服务或 nginx </p>\n<p><img src=\"../../../images/blog/devtools/preview-on-server.png\" alt=\"preview-on-server.png\"></p>\n<p>右键可以选择浏览器打开，或者在 vscode 侧边栏预览</p>\n<p><img src=\"../../../images/blog/devtools/launch-on-browser.png\" alt=\"launch-on-browser.png\"></p>\n<h2 id=\"eslint\">ESLint</h2>\n<p><img src=\"../../../images/blog/devtools/eslint_vscode_plugin.png\" alt=\"eslint_vscode_plugin\"></p>\n<p>对于依赖 eslint/prettier 的项目，安装该插件后，可以配置保存后，自动 fix，参考：<a href=\"http://www.zuo11.com/blog/2019/10/devtools_autofix.html\">2020 vscode配置eslint保存后自动fix | 左小白的技术日常</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vscode 插件推荐，前端开发 vscode 常用插件",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "Vetur"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Vue VSCode snippets"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "GitLens"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Preview on Web Server"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "ESLint"
            }
          ]
        }
      ],
      "config": {
        "source": "vscode 插件推荐，前端开发 vscode 常用插件.md",
        "staticFileName": "vscode_plugin.html",
        "author": "guoqzuo",
        "createDate": "2019/11/12",
        "description": "vscode 好用的插件推荐，在前端开发中，一般使用 vscode 来做开发，下面是一些开发中用的较多的插件推荐：Vetur、Vue VSCode snippets、GitLens、Preview on Web Server、ESLint 等",
        "keywords": "vscode好用的插件,vscode实用插件",
        "category": "计算机基础与开发工具",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"传数据全局变量就可以了，为什么需要状态管理\">传数据全局变量就可以了，为什么需要状态管理</h1>\n<p>在vue开发中，我之前很少使用状态管理vuex，总觉得没有太大的实际用途。后面项目实践后，才能真正体会状态管理的强大。为什么需要状态管理，这个需要在开发实践中慢慢体会。</p>\n<h2 id=\"开发过程中遇到的相关真实场景\">开发过程中遇到的相关真实场景</h2>\n<h3 id=\"全局变量较多场景\">全局变量较多场景</h3>\n<p>场景A：在19年11月份左右我当时负责为一个jsp项目做一些更新，在维护别人写的代码时，发现之前的人虽然把select等组件封装为了一个个固定的对象。但不同的模块js里，相互引用，你会发现各种莫名其妙的全局变量，不知道是哪里注入的（由于只要主页面引入了两个js文件，这两个js的变量是互通的）。</p>\n<p>比如有两个组件：组件A对象为objA，组件B对象为objB，我在组件C里想获取组件A、B的结果，我需要调用objA或objB的全局变量。你可以想象当表单字段很多时，你要通过访问很多个对象的变量才行</p>\n<p>虽然他们都是全局变量，但是太零散了，如果我们建立一个全局变量专门用来管理各个组件对象的数据这块，每个组件对象通过操作这个专门管理数据的全局变量那样逻辑就会很明确。功能是功能，数据是数据。这就离vuex很近了，其实vuex本质上也相当于一个全局变量。</p>\n<h3 id=\"组件多且组件间数据耦合性强的场景\">组件多且组件间数据耦合性强的场景</h3>\n<p>场景B：app内嵌H5需要做创建喜报的功能，分成了7个页面</p>\n<ol>\n<li>step1 单页面组件 填写基本信息</li>\n<li>step2 单页面组件 选择对应的关联项目（依赖step1里的一个参数）</li>\n<li>step3 单页面组件 选择项目规模（依赖step2的参数）</li>\n<li>step4 单页面组件 选择喜报模板 </li>\n<li>step5 单页面组件 填写喜报标题等信息</li>\n<li>step6 单页面组件 step1-step5填写信息确认、有返回各个页面修改的入口</li>\n<li>step7 单页面组件 将 step1-step5填写的信息生成喜报预览，可发布或返回编辑</li>\n</ol>\n<p>这里页面较多，数据之间可能相互影响，如果通过组件之间相互传值，显然很乱。如果使用vuex就会好很多，数据统一在vuex中处理，每个页面共享对应的数据，很好取。</p>\n<h3 id=\"同页面中不同组件数据依赖的问题\">同页面中不同组件数据依赖的问题</h3>\n<p>在一个页面中，拆分为了多个不同的组件，A组件需要显示B组件通过接口请求返回的数据的总数，如果利用组件间相互传值。可以用bus，但如果这个数据其他组件也要用呢？最好的方法还是通过vuex来管理数据，A组件在computed导入对应的state少字段。B组件获取到数据后，利用mutation更新该state数据，这样A组件页面会实时渲染对应state的值</p>\n<h2 id=\"为什么需要使用vuex状态管理？\">为什么需要使用Vuex状态管理？</h2>\n<p>当多个组件共享状态时，单向数据流的简洁性很容易被破坏：</p>\n<ul>\n<li>多个视图依赖同一状态，多层嵌套组件里传递参数会非常繁琐，且无法进行兄弟组件间的状态传递</li>\n<li>来自不同视图的行为需要变更同一状态，用下面的两种方法变更和同步状态的多份拷贝，会非常脆弱，通常会导致代码难以维护<ul>\n<li>通过父子组件直接引用 this.$refs，this.$root, this.$parent, this.$children</li>\n<li>通过事件，props 和 this.$emit</li>\n</ul>\n</li>\n</ul>\n<p>为了解决上面的问题，就需要用到Vuex了，Vuex把组件的共享状态抽取出来，以一个全局单例模式管理，不管在树的哪个位置，任何组件都能获取状态或者触发行为，这样就易于维护了。</p>\n<h2 id=\"全局对象也可以管理状态，为什么需要vuex\">全局对象也可以管理状态，为什么需要vuex?</h2>\n<p>Vuex和单纯的全局对象，有以下两点不同:</p>\n<ul>\n<li>vuex不能直接改变store中的状态，改变store中的状态唯一的途径是显示的提交(commit) mutation。(为什么这样做？这样做 可以方便跟踪每一个状态的变化，可以实现一些工具来更好地了解应用的执行，方便debug)</li>\n<li>vuex的状态存储是响应式的，当Vue组件从store中读取状态的时候，如果store中的状态发生变化，name相应的组件也会进行高效更新。</li>\n</ul>\n<p>综上所述，什么情况下需要使用状态管理？<strong>多个组件之间数据相互依赖，多组件存在数据联动时</strong> 这样可以更加优雅的管理数据，可扩展性强</p>\n<p>参考之前的笔记: <a href=\"https://www.yuque.com/guoqzuo/yyxr05/xbhuii#35e092ea\">vuex状态管理 - vue官网学习笔记</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "传数据全局变量就可以了，为什么需要状态管理",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "开发过程中遇到的相关真实场景",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "全局变量较多场景"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "组件多且组件间数据耦合性强的场景"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "同页面中不同组件数据依赖的问题"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "为什么需要使用Vuex状态管理？"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "全局对象也可以管理状态，为什么需要vuex?"
            }
          ]
        }
      ],
      "config": {
        "source": "传数据全局变量就可以了，为什么需要状态管理.md",
        "staticFileName": "why_vuex.html",
        "author": "guoqzuo",
        "createDate": "2019/11/14",
        "description": "开发过程中遇到的相关真实场景，为什么需要使用Vuex状态管理？全局对象也可以管理状态，为什么需要vuex? 在vue开发中，我之前很少使用状态管理vuex，总觉得没有太大的实际用途。后面项目实践后，才能真正体会状态管理的强大。为什么需要状态管理，这个需要在开发实践中慢慢体会。",
        "keywords": "vuex使用场景,vue相对全局变量有什么优势,为什么需要使用Vuex状态管理,全局对象也可以管理状态，为什么需要vuex",
        "category": "Vue",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"tolocalestring将数字转为逗号分隔的字符串\">toLocaleString将数字转为逗号分隔的字符串</h1>\n<p>Number.prototype.toLocaleString()可以将数字转换为千分位逗号分隔的字符串，而且该方法还内置了数字转人民币、美元等字符串的方法，这样我们在处理金钱相关的数据时就可以很方便使用了，来看一个列子</p>\n<pre><code class=\"language-js\">var number = 12123\nnumber.toLocaleString() // &quot;12,123&quot;\nnumber.toLocaleString(&#39;en&#39;, {style:&#39;currency&#39;, currency:&#39;USD&#39;}) // &quot;$12,123.00&quot;\nnumber.toLocaleString(&#39;cn&#39;, {style:&#39;currency&#39;, currency:&#39;CNY&#39;}) // &quot;￥12,123.00&quot;</code></pre>\n<p>参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\">Number.prototype.toLocaleString() - MDN</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "toLocaleString将数字转为逗号分隔的字符串"
        }
      ],
      "config": {
        "source": "toLocaleString将数字转为逗号分隔的字符串.md",
        "staticFileName": "num_str.html",
        "author": "guoqzuo",
        "createDate": "2019/11/14",
        "description": "Number.prototype.toLocaleString()可以将数字转换为千分位逗号分隔的字符串，而且该方法还内置了数字转人民币、美元等字符串的方法，这样我们在处理金钱相关的数据时就可以很方便使用了，来看一个列子",
        "keywords": "toLocaleString将数字转为逗号分隔的字符串,toLocaleString,Number.prototype.toLocaleString",
        "category": "JavaScript",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"什么是yarn\">什么是yarn</h1>\n<p>Yarn 是一个快速、可靠、安全的依赖管理工具。是 NPM 的替代品。今天看看了ts实战指南这本书，里面是这样介绍Yarn的：</p>\n<p>Yarn [jɑːn] 是facebook，google等公司共同开发的一款新的js包管理工具，并没有试图完全取代npm，Yarn同样是从npm获取包。存在的目的是：解决团队使用npm面临的少数问题，如版本锁定，并行安装、文案输出等</p>\n<h2 id=\"macos安装yarn方法\">macos安装Yarn方法</h2>\n<pre><code class=\"language-js\">brew install yarn</code></pre>\n<h2 id=\"yarn基本用法\">Yarn基本用法</h2>\n<pre><code class=\"language-bash\"># 初始化一个新项目\nyarn init\n# 添加依赖包\nyarn add [package]\nyarn add [package]@[version]\nyarn add [package]@[tag]\n# 添加到不同依赖类别\nyarn add [package] --dev\nyarn add [package] --peer\nyarn add [package] --optional\n# 更新依赖包\nyarn upgrade [package]\nyarn upgrade [package]@[version]\nyarn upgrade [package]@[tag]\n# 移除依赖包\nyarn remove [package]\n# 安装项目的全部依赖\nyarn 或者 yarn install</code></pre>\n<p>参考: <a href=\"https://yarn.bootcss.com/\">yarn 官方文档</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "什么是yarn",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "macos安装Yarn方法"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Yarn基本用法"
            }
          ]
        }
      ],
      "config": {
        "source": "什么是yarn.md",
        "staticFileName": "yarn.html",
        "author": "guoqzuo",
        "createDate": "2019/11/15",
        "description": "Yarn 是一个快速、可靠、安全的依赖管理工具。是 NPM 的替代品。今天看看了ts实战指南这本书，里面是这样介绍Yarn的：Yarn [jɑːn] 是facebook，google等公司共同开发的一款新的js包管理工具，并没有试图完全取代npm，Yarn同样是从npm获取包。存在的目的是：解决团队使用npm面临的少数问题，如版本锁定，并行安装、文案输出等",
        "keywords": "什么是yarn,yarn基本用法,macos安装yarn",
        "category": "前端工程化",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"space-between与space-around的区别\">space-between与space-around的区别</h1>\n<p>flex布局justify-content属性值区别</p>\n<ul>\n<li>space-between 最左、最右item贴合左侧或右侧边框，item与item之间间距相等。</li>\n<li>space-around 每个item 左右方向的margin相等。两个item中间的间距会比较大</li>\n</ul>\n<p><img src=\"../../../images/blog/css/flex_justify.png\" alt=\"flex_justify.png\"></p>\n<p>参考之前的笔记：<a href=\"https://www.yuque.com/guoqzuo/js_es6/kg7660#fab40284\">justify-content(主轴对齐) - flex与grid布局</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "space-between与space-around的区别"
        }
      ],
      "config": {
        "source": "space-between与space-around的区别.md",
        "staticFileName": "flex_justify.html",
        "author": "guoqzuo",
        "createDate": "2019/11/15",
        "description": "flex布局justify-content属性值区别，space-between 最左、最右item贴合左侧或右侧边框，item与item之间间距相等。space-around 每个item 左右方向的margin相等。两个item中间的间距会比较大",
        "keywords": "space-between 间距,space-around怎么使用,space-between与space-around的区别,space-around什么意思,space-around,space-around 三个 不居中,space-around调距离,",
        "category": "CSS",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"flex布局align-self使用场景\">flex布局align-self使用场景</h1>\n<p>一般flex布局，使用algin-items: center垂直居中后，item子项某一个高度比较高，其他子项的高度也会是高度最高的子项高度。设置border时会特别明显。如果需要让item高度适应内容，就可以使用 align-self: flex-start。</p>\n<p><img src=\"../../../images/blog/css/align-self.png\" alt=\"align-self.png\"></p>\n<p>参考之前的笔记：<a href=\"https://www.yuque.com/guoqzuo/js_es6/kg7660#45717a91\">align-self（item独立对齐方式）- flex与grid布局</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "flex布局align-self使用场景"
        }
      ],
      "config": {
        "source": "flex布局align-self使用场景.md",
        "staticFileName": "align_self.html",
        "author": "guoqzuo",
        "createDate": "2019/11/21",
        "description": "一般flex布局，使用algin-items: center垂直居中后，item子项某一个高度比较高，其他子项的高度也会是高度最高的子项高度。设置border时会特别明显。如果需要让item高度适应内容，就可以使用 align-self: flex-start。",
        "keywords": "align-self,flex align-self使用场景",
        "category": "CSS",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"部分安卓机型scale后border显示不全的问题\">部分安卓机型scale后border显示不全的问题</h1>\n<p>由于border需要画比1px还细的线，也就是0.5px，在移动端你设置px是没用的，一般会使用scale(0.5)缩放来实现</p>\n<p>但在某些安卓机型上，发现这样实现的border边框会有显示不全的情况。</p>\n<p>重点来了</p>\n<p><strong>解决方法是将对应scale等样式用style写在内联样式里</strong>，刚开始不相信写成内联样式就可以解决这个问题，但实践后发现确实可以解决这个问题。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "部分安卓机型scale后border显示不全的问题"
        }
      ],
      "config": {
        "source": "部分安卓机型scale后border显示不全的问题.md",
        "staticFileName": "scale_line.html",
        "author": "guoqzuo",
        "createDate": "2019/11/21",
        "description": "由于border需要画比1px还细的线，也就是0.5px，在移动端你设置px是没用的，一般会使用scale(0.5)缩放来实现,但在某些安卓机型上，发现这样实现的border边框会有显示不全的情况，重点来了，解决方法是将对应scale等样式用style写在内联样式里，刚开始不相信写成内联样式就可以解决这个问题，但实践后发现确实可以解决这个问题。",
        "keywords": "scale border消失,部分安卓机型scale后border显示不全的问题,border在手机上显示不全的问题s",
        "category": "CSS",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"画比1px还细的线或border\">画比1px还细的线或border</h1>\n<p>一般使用transform缩小0.5倍来实现，如果是border先将元素放大2倍，再缩小0.5倍，放大缩小后还是以放大的空间来占位，使用positon:absolute脱离标准文档流，就不会有两倍的占位了。</p>\n<pre><code class=\"language-js\">/* 比1px还细的线 */\n.thinline {\n  height: 1px;width:100%;\n  -webkit-transform-origin: 0 0;\n  transform-origin: 0 0;\n  -webkit-transform: scaleY(0.5);\n  transform: scaleY(0.5);\n  background:#ccc;\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "画比1px还细的线或border"
        }
      ],
      "config": {
        "source": "画比1px还细的线或border.md",
        "staticFileName": "border_thin.html",
        "author": "guoqzuo",
        "createDate": "2019/11/21",
        "description": "画比1px还细的线或border",
        "keywords": "一般使用transform缩小0.5倍来实现，如果是border先将元素放大2倍，再缩小0.5倍，放大缩小后还是以放大的空间来占位，使用positon:absolute脱离标准文档流，就不会有两倍的占位了。",
        "category": "CSS",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"git创建新分支并提交到远程仓库origin\">git创建新分支并提交到远程仓库origin</h1>\n<p>当我们加入到一个项目组开发项目，一般最开始的一件事情就是从远程仓库clone代码，然后新创建一个分支进行开发。显然你需要把每天写的代码上传到服务器，那怎么将本地创建的分支推送到远程并与之关联呢，下面来看一下对应的流程</p>\n<p>假设在 pc-v2 分支，新建一个分支 pc-v2-zuo，推送到远程步骤</p>\n<pre><code class=\"language-bash\"># 基于当前分支创建一个pc-v2-zuo分支并切换到该分支\ngit checkout -b pc-v2-zuo \n\n# 先push\ngit push origin pc-v2-zuo:pc-v2-zuo # 将分支推送到远程分支\n\n# 再将当前分支关联到远程分支\ngit branch --set-upstream-to=origin/pc-v2-zuo pc-v2-zuo</code></pre>\n<p>记得每次git commit、git push前都要git pull更新</p>\n<p>如果在pc-v2-zuo这个分支开发完成后，怎么将更新合并到某个特定的分支呢(加上为v1.2.0)？一般我的方法是</p>\n<ol>\n<li><p>在当前分支 git merge origin/v1.2.0 将目标分支的内容先merge到自己分支。解决冲突后提交到远程</p>\n</li>\n<li><p>然后再切到v1.2.0，在将自己的分支合并到当前分支git merge pc-v2-zuo，再push</p>\n</li>\n</ol>\n<p>参考之前的笔记：<a href=\"https://www.yuque.com/guoqzuo/csm14e/gn4bpl\">廖雪峰 git教程笔记</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "git创建新分支并提交到远程仓库origin"
        }
      ],
      "config": {
        "source": "git创建新分支并提交到远程仓库origin.md",
        "staticFileName": "git_push_branch.html",
        "author": "guoqzuo",
        "createDate": "2019/11/26",
        "description": "git如何建立新的origin，这里主要介绍下自己平常在工作中创建分支，将分支推送到远程的方法以及将分支合并到版本分支的方法。当我们加入到一个项目组开发项目，一般最开始的一件事情就是从远程仓库clone代码，然后新创建一个分支进行开发。显然你需要把每天写的代码上传到服务器，那怎么将本地创建的分支推送到远程并与之关联呢，下面来看一下对应的流程",
        "keywords": "git如何建立新的origin,git创建新分支并提交到远程仓库origin",
        "category": "运维部署与版本控制",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"v-if里使用filters无效的问题\">v-if里使用filters无效的问题</h1>\n<p>v-if 不能用filters，在项目中，想在v-if里使用filters发现不生效，于是查了下vue的文档，发现v-if里是不支持使用filters的。一般filters只能在两种情况下使用</p>\n<p><strong>双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示。</p>\n<pre><code class=\"language-html\">&lt;!-- 在双花括号中 --&gt;\n{{ message | capitalize }}\n\n&lt;!-- 在 `v-bind` 中 --&gt;\n&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</code></pre>\n<p>对应的js</p>\n<pre><code class=\"language-js\">filters: {\n  capitalize: function (value) {\n    if (!value) return &#39;&#39;\n    value = value.toString()\n    return value.charAt(0).toUpperCase() + value.slice(1)\n  }\n}</code></pre>\n<p>参考 <a href=\"https://cn.vuejs.org/v2/guide/filters.html\">过滤器 — Vue.js官方文档</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "v-if里使用filters无效的问题"
        }
      ],
      "config": {
        "source": "v-if里使用filters无效的问题.md",
        "staticFileName": "v-if_filters.html",
        "author": "guoqzuo",
        "createDate": "2019/11/22",
        "description": "v-if 不能用filters,在项目中，想在v-if里使用filters发现不生效，于是查了下vue的文档，发现v-if里是不支持使用filters的。一般filters只能在两种情况下使用：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由'管道'符号指示。",
        "keywords": "v-if里使用filters无效的问题,v-if里使用filters无效,v-if中使用filter无效,v-if中使用过滤器无效",
        "category": "Vue",
        "year": "2019",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"failed-at-the-phantomjs-prebuilt2116-intsall-script\">failed at the <a href=\"mailto:phantomjs-prebuilt@2.1.16\">phantomjs-prebuilt@2.1.16</a> intsall script</h1>\n<p>从远程仓库拉取代码，npm install，发现提示failed at the <a href=\"mailto:phantomjs-prebuilt@2.1.16\">phantomjs-prebuilt@2.1.16</a> intsall script，怎么解决呢？</p>\n<p>使用 <strong>npm install —ignore-scripts</strong> 忽略package.json中设置的脚本，意思就是避免package.json中的脚本影响包的正常安装。</p>\n<p>The --ignore-scripts argument will cause npm to not execute any scripts defined in the package.json. See npm-scripts.</p>\n<p><a href=\"https://docs.npmjs.com/cli/install\">https://docs.npmjs.com/cli/install</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "failed at the phantomjs-prebuilt@2.1.16 intsall script"
        }
      ],
      "config": {
        "source": "failed at the phantomjs-prebuilt@2.1.16  intsall script.md",
        "staticFileName": "phantomjs-prebuilt.html",
        "author": "guoqzuo",
        "createDate": "2019/12/04",
        "description": "从远程仓库拉取代码，npm install，发现提示failed at the phantomjs-prebuilt@2.1.16 intsall script，怎么解决呢？ 使用 npm install —ignore-scripts** 忽略package.json中设置的脚本，意思就是避免package.json中的脚本影响包的正常安装。The --ignore-scripts argument will cause npm to not execute any scripts defined in the package.json. See npm-scripts.",
        "keywords": "failed at the phantomjs-prebuilt@2.1.16  intsall script",
        "category": "前端工程化",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"cant-find-module-buildreleasenode_sleepnode\">can&#39;t find module &#39;./build/Release/node_sleep.node&#39;</h1>\n<p>看了具体报错是sleep包引起的，到node_modules里面对应的目录查看，发现根本就没有build目录</p>\n<p><strong>解决方法：之前的版本是5.2.4，修改package.json将版本改为5.1.1，让后删除package-lock.json 再npm install就ok 了</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "can't find module './build/Release/node_sleep.node'"
        }
      ],
      "config": {
        "source": "can't find module node_sleep.node.md",
        "staticFileName": "node_sleep_module.html",
        "author": "guoqzuo",
        "createDate": "2019/12/04",
        "description": "can't find module './build/Release/node_sleep.node'，看了具体报错是sleep包引起的，到node_modules里面对应的目录查看，发现根本就没有build目录，解决方法：之前的版本是5.2.4，修改package.json将版本改为5.1.1，让后删除package-lock.json 再npm install就ok 了",
        "keywords": "can't find module './build/Release/node_sleep.node'",
        "category": "前端工程化",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"npm设置下载源\">npm设置下载源</h1>\n<p>在设置npm下载源之前，我们先来看看怎么查看当前npm的下载源</p>\n<pre><code class=\"language-bash\">npm config list # 查看当前npm配置项，包括源(registry)信息</code></pre>\n<p><img src=\"../../../images/blog/devtools/npm_config.png\" alt=\"npm_config.png\"></p>\n<p><strong>修改源</strong></p>\n<pre><code class=\"language-bash\"># 设置源\nnpm config set registry http://registry.npm.taobao.org\n\n# 查看帮助文档\nkevindeMacBook-Air:svnclone kevin$ npm config -h\nnpm config set &lt;key&gt; &lt;value&gt;\nnpm config get [&lt;key&gt;]\nnpm config delete &lt;key&gt;\nnpm config list [--json]\nnpm config edit\nnpm set &lt;key&gt; &lt;value&gt;\nnpm get [&lt;key&gt;]\n\nalias: c\n\n# 根据上面的命令，查看源\nguoqzuo-mac:test kevin$ npm config get registry \nhttps://registry.npm.taobao.org/</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "npm设置下载源"
        }
      ],
      "config": {
        "source": "npm设置下载源.md",
        "staticFileName": "npm_resource.html",
        "author": "guoqzuo",
        "createDate": "2019/12/04",
        "description": "npm设置下载源，在设置npm下载源之前，我们先来看看怎么查看当前npm的下载源，npm config list 可以查看当前npm配置项，包括源(registry)信息，npm config set命令可以设置对应npm源",
        "keywords": "npm设置下载源,npm查看当前配置",
        "category": "前端工程化",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"git-clone大文件仓库超时问题\">git clone大文件仓库超时问题</h1>\n<p>当远程仓库比较大，或者弱网的情况，可能会出现git clone超时的问题，一直clone不下来，一般可以用两种方法来解决：一是git clone时使用 depth参数；二是使用ssh拉取方式</p>\n<h2 id=\"使用depth参数\">使用depth参数</h2>\n<pre><code class=\"language-bash\">git clone --depth=1 git://someserver/somerepo\n\n# depth用于指定克隆深度，为1即表示只克隆最近一次commit.\n\n# 参考:\n# https://segmentfault.com/q/1010000007700727</code></pre>\n<h2 id=\"使用ssh方式clone\">使用ssh方式clone</h2>\n<p><img src=\"../../../images/blog/git/use_ssh_clone.png\" alt=\"npm_config.png\"></p>\n<p>参考：<a href=\"https://help.github.com/en/github/using-git/which-remote-url-should-i-use#cloning-with-ssh-urls\">Cloning with SSH URLs</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "git clone大文件仓库超时问题",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "使用depth参数"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "使用ssh方式clone"
            }
          ]
        }
      ],
      "config": {
        "source": "git clone大文件仓库超时问题.md",
        "staticFileName": "git_clone_timeout.html",
        "author": "guoqzuo",
        "createDate": "2019/12/04",
        "description": "当远程仓库比较大，或者弱网的情况，可能会出现git clone超时的问题，一直clone不下来，一般可以用两种方法来解决：一是git clone时使用 depth参数；二是使用ssh拉取方式",
        "keywords": "git clone大文件仓库超时问题,git clone超时,git无法拉取文件,git克隆文件超时",
        "category": "运维部署与版本控制",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"sessionstorage和localstorage的区别\">sessionStorage和localstorage的区别</h1>\n<p>sessionStorage和localstorage都属于Web Storage，在JS高程3中有讲，这里来回顾下，一般sessionStorage关闭浏览器后会消失，localstorage不会。</p>\n<h2 id=\"web存储机制web-storage\">web存储机制(Web Storage)</h2>\n<p>Web Storage的目的是克服cookie的限制，当数据需要严格控制在客户端时，无需持续的将数据发回服务器，IE8+支持, Web Storage的两个主要目标是:</p>\n<ul>\n<li>提供了一种cookie之外存储会话数据的途径</li>\n<li>提供了一种存储大量可以跨会话存在的数据机制</li>\n</ul>\n<h2 id=\"storage类型\">Storage类型</h2>\n<p>Storage类型（localStorage、sessionStorage）提供最大的存储空间来存储键值对数据。Storage类型只能存储字符串，非字符串存储前需要转换为字符串。Storage实例与其对象有如下方法:</p>\n<pre><code class=\"language-js\">setItem(name, value) // 设置键值对\ngetItem(name) // 根据指定的名字name获取对应的值，如果没值返回null\nremoveItem(name) // 删除指定name的值。\nclear() // 删除所有值\nkey(index) // 获取index位置处的key的名称, 可以用来遍历值\nlenth // 获取键值对数量\n.name // 点语法支持，设置或获取值</code></pre>\n<h2 id=\"sessionstorage\">sessionStorage</h2>\n<p>sessionStorage数据浏览器关闭后，会消失。主要用于仅针对会话的小段数据存储。2.5M - 5M</p>\n<pre><code class=\"language-js\">// MDN\nsessionStorage maintains a separate storage area for each given origin that&#39;s available for the duration of the page session (as long as the browser is open, including page reloads and restores)\n- Stores data only for a session, meaning that the data is stored until the browser (or tab) is closed.\n- Data is never transferred to the server.\n- Storage limit is larger than a cookie (at most 5MB).</code></pre>\n<h2 id=\"localstorage\">localStorage</h2>\n<p>修订过的HTML5规范中，localStorage取代globalStorage，作为持久保存客户端的数据的方案。要访问同一个localStorage对象，页面必须来自同一个域名(子域名无效)。使用同一种协议，同一个端口， 2.5M - 5M，localStorage没有过期时间，如果想要这个功能，那只能自己封装函数来实现了。</p>\n<pre><code class=\"language-js\">// MDN\nlocalStorage does the same thing, but persists even when the browser is closed and reopened.\n- Stores data with no expiration date, and gets cleared only through JavaScript, or clearing the Browser cache / Locally Stored Data.\n- Storage limit is the maximum amongst the three.</code></pre>\n<h2 id=\"storage事件\">storage事件</h2>\n<pre><code class=\"language-js\">// 单个页面里面storage事件不会触发，需要由其他tab页面触发, 触发的条件：\n// - 同一浏览器打开了两个同源页面\n// - 其中一个页面修改了localStorage或sessionStorage\n// - 另一个网页注册了这个事件\n// 参考资料: Storage事件无法触发解决(https://blog.csdn.net/jlin991/article/details/55855524)\nwindow.addEventListener(&#39;storage&#39;, function (event) {\n  console.log(&#39;storage chage&#39;);\n  console.log(event);\n}, false);</code></pre>\n<p>参考</p>\n<ul>\n<li><a href=\"https://www.yuque.com/guoqzuo/js_es6/sp2k81#sessionStorage\">sessionStorage - JS高程3笔记</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage\">Window.sessionStorage - Web API 接口参考 | MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage\">Window.localStorage - Web API 接口参考 | MDN</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "sessionStorage和localstorage的区别",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "web存储机制(Web Storage)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Storage类型"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "sessionStorage"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "localStorage"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "storage事件"
            }
          ]
        }
      ],
      "config": {
        "source": "sessionStorage和localstorage的区别.md",
        "staticFileName": "web_storage.html",
        "author": "guoqzuo",
        "createDate": "2019/12/04",
        "description": "sessionStorage和localstorage都属于Web Storage，在JS高程3中有讲，这里来回顾下，一般sessionStorage关闭浏览器后会消失，localstorage不会。",
        "keywords": "sessionStorage和localstorage的区别",
        "category": "JavaScript",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"使用urlsearchparams将对象转为url查询字符串\">使用URLSearchParams将对象转为url查询字符串</h1>\n<p>在做get请求时，我们需要传一些参数，单纯的字符串拼接的方法不够优雅，下面来看怎么用URLSearchParams将对象直接转为查询字符串，另外查看axios源码，看看axios内部是怎么将params对象拼接到url上的</p>\n<h2 id=\"对象转查询参数\">对象转查询参数</h2>\n<pre><code class=\"language-js\">let obj = {a: 1, b: 2}\nlet queryParams = new URLSearchParams()\nObject.entries(obj).forEach(([key, value]) =&gt; {\n  queryParams.append(key, value)\n})\nconsole.log(queryParams.toString()) // a=1&amp;b=2s</code></pre>\n<p>更多URLSearchParams的细节操作参见之前的一篇文章 <a href=\"http://www.zuo11.com/blog/2019/10/web_url_searchparams.html\">URLSearchParams URL查询字符串处理</a></p>\n<h2 id=\"axios是怎么将config里的params对象转url查询参数的\">axios是怎么将config里的params对象转url查询参数的</h2>\n<p>在axios中，如果我们想在url后面添加查询字符串，只需要在config参数里加一个params属性，传入对象即可</p>\n<pre><code class=\"language-js\">{\n  // ...\n  // `params` are the URL parameters to be sent with the request\n  // Must be a plain object or a URLSearchParams object\n  params: {\n    ID: 12345\n  },\n\n  // `paramsSerializer` is an optional function in charge of serializing `params`\n  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n  paramsSerializer: function (params) {\n    return Qs.stringify(params, {arrayFormat: &#39;brackets&#39;})\n  },\n  // ....\n}</code></pre>\n<p>那axios内部是怎么将对象转为字符串的呢？来看下axios的源码</p>\n<pre><code class=\"language-js\">// 生成path用的是buildURL方法\n// lib/adapters/http.js\npath: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, &#39;&#39;),\n\n// lib/helpers/buildURL.js\n&#39;use strict&#39;;\n\nvar utils = require(&#39;./../utils&#39;);\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, &#39;@&#39;).\n    replace(/%3A/gi, &#39;:&#39;).\n    replace(/%24/g, &#39;$&#39;).\n    replace(/%2C/gi, &#39;,&#39;).\n    replace(/%20/g, &#39;+&#39;).\n    replace(/%5B/gi, &#39;[&#39;).\n    replace(/%5D/gi, &#39;]&#39;);\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === &#39;undefined&#39;) {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + &#39;[]&#39;;\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + &#39;=&#39; + encode(v));\n      });\n    });\n\n    serializedParams = parts.join(&#39;&amp;&#39;);\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf(&#39;#&#39;);\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + serializedParams;\n  }\n\n  return url;\n};\n</code></pre>\n<p>可以看到axios拼接url的过程</p>\n<ul>\n<li><p>序列化</p>\n<ul>\n<li>如果config里有传入paramsSerializer参数，就使用这个函数来转换，一般是使用的是一个qs的npm包，<a href=\"https://www.npmjs.com/package/qs\">https://www.npmjs.com/package/qs</a></li>\n<li>如果是is URLSearchParams，直接toString()</li>\n<li>如果非上面两种情况，在不支持URLSearchParams的情况下也能用，使用utils.forEach去转成</li>\n</ul>\n</li>\n<li><p>拼接 &#39;?&#39; 或 &#39;&amp;&#39;</p>\n</li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "使用URLSearchParams将对象转为url查询字符串",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "对象转查询参数"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "axios是怎么将config里的params对象转url查询参数的"
            }
          ]
        }
      ],
      "config": {
        "source": "使用URLSearchParams将对象转为url查询字符串.md",
        "staticFileName": "url_query.html",
        "author": "guoqzuo",
        "createDate": "2019/12/05",
        "description": "在做get请求时，我们需要传一些参数，单纯的字符串拼接的方法不够优雅，下面来看怎么用URLSearchParams将对象直接转为查询字符串，另外查看axios源码，看看axios内部是怎么将params对象拼接到url上的",
        "keywords": "对象转url查询字符串,axios是怎么将params对象转查询字符串的",
        "category": "JavaScript",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"文件结构目录树自动生成\">文件结构目录树自动生成</h1>\n<p>在我们写README.md时，如果需要描述一个文件的目录结构，就需要使用可以自动生成文件目录树的工具了，这里总结下一些实践经验</p>\n<h2 id=\"使用treer-npm命令行工具\">使用treer npm命令行工具</h2>\n<pre><code class=\"language-bash\">npm install treer -g # 全局安装treer</code></pre>\n<p>安装成功后，系统里就会多出一个treer命令，使用方法</p>\n<pre><code class=\"language-js\">$ treer --help\n\n  Usage: treer [options]\n\n  Options:\n\n    -h, --help             output usage information\n    -V, --version          output the version number\n    -d, --directory [dir]  Please specify a directory to generate structure tree\n    -i, --ignore [ig]      You can ignore specific directory name\n    -e, --export [epath]   export into file</code></pre>\n<p>示例: 查看指定目录的目录树</p>\n<pre><code class=\"language-bash\">$ treer -d ./src/notes/2019/12 # 查看目录结构\n12\n├─:not和:nth 混用的问题.md\n├─ES2020 &#39;?.&#39; 与 &#39;??&#39; 操作符.md\n├─_info.json\n├─can&#39;t find module node_sleep.node.md\n├─failed at the phantomjs-prebuilt@2.1.16  intsall script.md\n├─git clone大文件仓库超时问题.md\n├─iconfont icon是如何加载成功的.md\n├─npm设置下载源.md\n├─sessionStorage和localstorage的区别.md\n├─vue路由懒加载时import里面不能是变量的问题.md\n├─使用URLSearchParams将对象转为url查询字符串.md\n└文件结构目录树自动生成.md</code></pre>\n<h2 id=\"更好看的一种风格\">更好看的一种风格</h2>\n<p>上面的样式不怎么好看，且不支持js引用操作，有时间可以优化下，好的样式</p>\n<p><img src=\"../../../images/blog/devtools/fs_strut_treer.png\" alt=\"fs_strut_treer.png\"></p>\n<h2 id=\"实例\">实例</h2>\n<p>在 zuo11.com的README.md里就是结合上面两种方法来生成的目录树结构，效果查看: <a href=\"https://github.com/zuoxiaobai/zuo11.com\">zuo11.com - github</a></p>\n<pre><code class=\"language-bash\">├── src # 写博客文章的目录\n│   ├── _config.json # 全局配置文件\n│   ├── global.js # 全局js\n│   ├── global.css # 全局css \n│   ├── images # 图片目录\n│   │   ├── blog # 专门放博客图片的目录\n│   │   └── favicon.ico # 站点icon\n│   └── notes # 博客文章，按年月分目录\n│       ├── 2016\n│       │   ├── 10 # 每个月份目录下放当月写的文章及当前月的配置文件\n│       │   │   ├── _info.json # 配置文件记录了当前目录下每篇文章的配置、seo参数等\n│       │   │   ├── xxx1.md # 博客文章\n│       │   │   └── xxx2.md\n│       │   ├── 11\n│       │   └── 12\n│       ├── ...\n│       └── 2020 # 2020年目录\n│           ├── 1 # 2020年1月目录\n│           │   ├──  _info.json\n│           │   └──  xx45.md\n│           └── 2 \n├── LICENSE # 开源协议 Apache 2.0\n└── README.md # 说明文档</code></pre>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://github.com/derycktse/treer\">treer | github</a></li>\n<li><a href=\"https://vuex.vuejs.org/guide/structure.html\">vux官网 - 好的目录结构样式</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "文件结构目录树自动生成",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "使用treer npm命令行工具"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "更好看的一种风格"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "实例"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "文件结构目录树自动生成.md",
        "staticFileName": "file_struct.html",
        "author": "guoqzuo",
        "createDate": "2019/12/05",
        "description": "在我们写README.md时，如果需要描述一个文件的目录结构，就需要使用可以自动生成文件目录树的工具了，这里总结下一些实践经验",
        "keywords": "文件结构生成,文件目录树生成",
        "category": "计算机基础与开发工具",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"使用iconfont时icon是如何加载成功的，字体图片？\">使用iconfont时icon是如何加载成功的，字体图片？</h1>\n<p>在前端开发中，经常会使用图标，而iconfont是很好的一种管理图标的方式。这里总结下iconfont的几种使用方式，以及iconfont通过设置class来显示图标内部做了哪些操作</p>\n<h2 id=\"iconfont的两种使用方式\">iconfont的两种使用方式</h2>\n<p>iconfont.cn 有两种icon使用方式：下载代码、或直接下载图片</p>\n<h3 id=\"下载代码downloadzip\">下载代码download.zip</h3>\n<p>将图标转换为字体，便于前端工程师自由调整与调用，download.zip 解压缩后目录如下，下面的文件很多，但不一定都会用到，下面详细介绍三种使用图片的方式：</p>\n<pre><code class=\"language-bash\">├─demo.css        # 非必要，只是文档样式\n├─demo_index.html # 非必要，只是文档\n├─iconfont.css    # 重要重要重要重要重要重要文件\n├─iconfont.eot    # 非必要，可以不引入\n├─iconfont.js     # 重要重要重要重要重要重要文件\n├─iconfont.json   # 非必要，可以不引入\n├─iconfont.svg    # 非必要，可以不引入\n├─iconfont.ttf    # 非必要，可以不引入\n├─iconfont.woff   # 非必要，可以不引入\n├─iconfont.woff2  # 非必要，可以不引入</code></pre>\n<h4 id=\"symbol-引用\">Symbol 引用</h4>\n<blockquote>\n<p>这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。相关介绍可以参考这篇文章 这种用法其实是做了一个 SVG 的集合，与另外两种相比具有如下特点：\n支持多色图标了，不再受单色限制.\n通过一些技巧，支持像字体那样，通过 font-size, color 来调整样式。\n兼容性较差，支持 IE9+，及现代浏览器。\n浏览器渲染 SVG 的性能一般，还不如 png。</p>\n</blockquote>\n<pre><code class=\"language-html\">&lt;!-- \n  使用demo \n  只需要额外引入下载包里的 iconfont.js + copy 一小段css 即可使用\n  iconfont.js里面是一段js代码，每个icon的svg path写死放到了字符串里，然后通过一定的方式供外部引用，不涉及网络请求\n--&gt;\n&lt;head&gt;\n  &lt;style&gt;\n    /* 1.引入 默认icon样式，高宽、颜色 */\n    .icon {\n      width: 1em;\n      height: 1em;\n      vertical-align: -0.15em;\n      fill: currentColor;\n      overflow: hidden;\n    }\n  &lt;/style&gt;\n  &lt;!-- 2.引入js --&gt;\n  &lt;!-- &lt;script src=&quot;iconfont.js&quot;&gt;&lt;/script&gt; --&gt;\n  &lt;script src=&quot;iconfont_delete_fill.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- \n    3.使用\n    这里发现设置color无效，网上百度了，发现 iconfont.js里面写死了fill的颜色  批量替换 fill=&quot;#181818&quot; 为空字符串即可 \n    参考: [iconfont图标symbol引用方式，有的图标不能通过设置color样式来修改颜色的解决办法] https://www.cnblogs.com/jopny/p/9454785.html\n  --&gt;\n  &lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot; style=&quot;font-size:10em;color:blue&quot;&gt;\n    &lt;use xlink:href=&quot;#icon-icon-test&quot;&gt;&lt;/use&gt;\n  &lt;/svg&gt;\n  &lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot; style=&quot;font-size:5em;color:red&quot;&gt;\n    &lt;use xlink:href=&quot;#icon-icon-test7&quot;&gt;&lt;/use&gt;\n  &lt;/svg&gt;\n&lt;/body&gt;</code></pre>\n<h4 id=\"font-class-引用\">font-class 引用</h4>\n<blockquote>\n<p>font-class 是 Unicode 使用方式的一种变种，主要是解决 Unicode 书写不直观，语意不明确的问题。与 Unicode 使用方式相比，具有如下特点：\n兼容性良好，支持 IE8+，及所有现代浏览器。\n相比于 Unicode 语意明确，书写更直观。可以很容易分辨这个 icon 是什么。\n因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 Unicode 引用。\n不过因为本质上还是使用的字体，所以多色图标(这里指多种颜色的图标, 单一的颜色不算)还是不支持的。</p>\n</blockquote>\n<pre><code class=\"language-html\">&lt;!-- \n  demo 直接引入 iconfont.css 即可使用，iconfont.css 文件里面有base64字体文件，所以不涉及网络请求\n  - 也可以使用color、font-size来设置大小和颜色 \n--&gt;\n&lt;head&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;./iconfont.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;span class=&quot;iconfont icon-icon-test4&quot; style=&quot;color:red;font-size:80px;&quot;&gt;&lt;/span&gt;\n\n  &lt;span class=&quot;iconfont icon-icon-test4&quot;&gt;&lt;/span&gt;\n&lt;/body&gt;</code></pre>\n<h4 id=\"unicode-引用\">Unicode 引用</h4>\n<blockquote>\n<p>Unicode 是字体在网页端最原始的应用方式，特点是：\n  兼容性最好，支持 IE6+，及所有现代浏览器。\n  支持按字体的方式去动态调整图标大小，颜色等等。<br>  但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。\n  注意：新版 iconfont 支持多色图标，这些多色图标在 Unicode 模式下将不能使用，如果有需求建议使用symbol 的引用方式</p>\n</blockquote>\n<pre><code class=\"language-html\">&lt;!-- \n  demo 将iconfont.css里面的font-face拷贝到这里，拷贝样式，就可以直接使用了，\n  不涉及网络请求\n--&gt;\n&lt;head&gt;\n    &lt;style&gt;\n    @font-face {font-family: &quot;iconfont&quot;;\n      src: url(&#39;iconfont.eot?t=1575623500554&#39;); /* IE9 */\n      src: url(&#39;iconfont.eot?t=1575623500554#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */\n      url(&#39;data:application/x-font-woff2;charset=utf-8;base64.xxx&#39;) format(&#39;woff2&#39;),\n      url(&#39;iconfont.woff?t=1575623500554&#39;) format(&#39;woff&#39;),\n      url(&#39;iconfont.ttf?t=1575623500554&#39;) format(&#39;truetype&#39;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */\n      url(&#39;iconfont.svg?t=1575623500554#iconfont&#39;) format(&#39;svg&#39;); /* iOS 4.1- */\n    }\n    .iconfont {\n      font-family: &quot;iconfont&quot; !important;\n      font-size: 16px;\n      font-style: normal;\n      -webkit-font-smoothing: antialiased;\n      -moz-osx-font-smoothing: grayscale;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;span class=&quot;iconfont&quot; style=&quot;font-size:20px;color: red;&quot;&gt;&amp;#xe640;&lt;/span&gt;\n\n    &lt;span class=&quot;iconfont&quot;&gt;&amp;#xe639;&lt;/span&gt;\n&lt;/body&gt;</code></pre>\n<h3 id=\"下载素材-（直接下载多种格式icon）\">下载素材 （直接下载多种格式icon）</h3>\n<ul>\n<li>SVG 下载的是 .svg文件格式，矢量图形，放大缩小不会失真, 打开文件，将文件中的svg标签的内容拷贝到html中就可以使用，颜色用fill来指定，大小由height指定</li>\n<li>在Firefox、IE9+、Chrome和Safari中，可以直接在HTML嵌入SVG代码。</li>\n<li>SVG 文件可通过以下标签嵌入 HTML 文档：embed、object 或者 iframe。参考: <a href=\"https://www.runoob.com/svg/svg-inhtml.html\">SVG 在 HTML 页面</a> <pre><code class=\"language-html\">&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg class=&quot;icon&quot; width=&quot;16px&quot; height=&quot;16.00px&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;path fill=&quot;#333333&quot; d=&quot;M176 130.752l-45.248 45.248 22.72 22.528L466.752 512l-336 336 45.248 45.248L512 557.248l313.28 313.472 22.72 22.528 45.248-45.248-22.528-22.72L557.248 512l336-336-45.248-45.248L512 466.752 198.528 153.472z&quot;  /&gt;&lt;/svg&gt;</code></pre>\n</li>\n<li>AI 下载的是 .eps 文件，用AI（Adobe Illustrator CC）可以打开, 一般UI设计用，前端不会直接使用</li>\n<li>PNG 下载的是.png文件，直接可以用img标签src引入，下载时需要指定大小，非矢量图形，放大缩小会失真、模糊。</li>\n</ul>\n<h2 id=\"iconfont通过设置class来显示图标内部做了哪些操作\">iconfont通过设置class来显示图标内部做了哪些操作</h2>\n<p>注意我们在用class使用iconfont图标时，为什么可以使用，主要是iconfont.css里面做了三步操作:</p>\n<ol>\n<li>定义iconfont的 font-familay</li>\n<li>为.iconfont设置默认样式，指定为font-family字体</li>\n<li>为每个图标的class设置before的content</li>\n</ol>\n<p>来看具体的demo，示例</p>\n<pre><code class=\"language-css\">@font-face {\n  font-family: &quot;iconfont&quot;;\n  src: url(&#39;iconfont.eot?t=1586579952536&#39;); /* IE9 */\n  src: url(&#39;iconfont.eot?t=1586579952536#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */\n  url(&#39;data:application/x-font-woff2;charset=utf-8;base64,省略...&#39;) format(&#39;woff2&#39;),\n  url(&#39;iconfont.woff?t=1586579952536&#39;) format(&#39;woff&#39;),\n  url(&#39;iconfont.ttf?t=1586579952536&#39;) format(&#39;truetype&#39;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */\n  url(&#39;iconfont.svg?t=1586579952536#iconfont&#39;) format(&#39;svg&#39;); /* iOS 4.1- */\n}\n\n.iconfont {\n  font-family: &quot;iconfont&quot; !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.iconok:before {\n  content: &quot;\\e63c&quot;;\n}\n\n.iconerror1:before {\n  content: &quot;\\e651&quot;;\n}</code></pre>\n<p>参考: <a href=\"https://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.d8d11a391&amp;helptype=code\">Iconfont-阿里巴巴矢量图标库 Web端使用</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "使用iconfont时icon是如何加载成功的，字体图片？",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "iconfont的两种使用方式",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "下载代码download.zip",
                  "children": [
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "Symbol 引用"
                    },
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "font-class 引用"
                    },
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "Unicode 引用"
                    }
                  ]
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "下载素材 （直接下载多种格式icon）"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "iconfont通过设置class来显示图标内部做了哪些操作"
            }
          ]
        }
      ],
      "config": {
        "source": "使用iconfont时icon是如何加载成功的，字体图片？.md",
        "staticFileName": "iconfont.html",
        "author": "guoqzuo",
        "createDate": "2019/12/06",
        "description": "iconfont icon是如何加载成功的 字体图片？在前端开发中，经常会使用图标，而iconfont是很好的一种管理图标的方式。这里总结下iconfont的几种使用方式，以及iconfont通过设置class来显示图标内部做了哪些操作",
        "keywords": "iconfont使用,iconfont为什么可以加载图标,iconfont详细介绍",
        "category": "CSS",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"es2020--与--操作符\">ES2020 &#39;?.&#39; 与 &#39;??&#39; 操作符</h1>\n<p>Optional chaining operator(?.) 与 Nullish coalescing Operator(??) 目前正式进入 stg4，确定会成为ES2020标准，阮一峰老师已经在他的es6入门教程里更新了，下面来看看具体怎么使用</p>\n<h2 id=\"optional-chaining-operator\">Optional chaining operator(?.)</h2>\n<p>可选链操作符，阮一峰ES6入门里称之为&quot;链判断运算符&quot;，<strong>作用：当对象的属性或方法不存在时，需要先判断是否有值再使用。对于比较多层级的子属性判断就更复杂了，可选链操作符用于简化该场景的写法</strong></p>\n<pre><code class=\"language-js\">// 示例1：当obj.sayHi存在，则执行该函数\nobj.sayHi &amp;&amp; obj.sayHi()\n// 简化写法:\nobj.sayHi?.() \n\n// 示例2: 如果当user.address为undefined，再访问子集元素会报错\nvar street = user.address ? user.address.street : undefined\n// 简化写法: \nvar street = user.address?.street\n\n// 示例3\nvar argName = &#39;name&#39;\nobj?.[argName] \n\n// 语法\nobj?.prop       // optional static property access\nobj?.[expr]     // optional dynamic property access\nfunc?.(...args) // optional function or method call\n</code></pre>\n<h2 id=\"nullish-coalescing-operator\">Nullish coalescing Operator(??)</h2>\n<p><strong>Null判断运算符，主要用来替代 || 判断变量是否是null和undifined这两种情况，排除0，&#39;&#39;，false的误判</strong>，一般我们在判空时可能会出现问题，来看个例子</p>\n<pre><code class=\"language-js\">// 示例\nconst response = {\n  settings: {\n    nullValue: null,\n    height: 400,\n    animationDuration: 0,\n    headerText: &#39;&#39;,\n    showSplashScreen: false\n  }\n};\n\n// 一般需求是，如果某个值非null 或undefined 就使用默认值\nconst undefinedValue = response.settings.undefinedValue || &#39;some other default&#39;; // result: &#39;some other default&#39;\nconst nullValue = response.settings.nullValue || &#39;some other default&#39;; // result: &#39;some other default&#39;\n\n// 但 || 这种写法，只要左侧为false(比如(&#39;&#39;、0、false))，也会使用默认值 \nconst headerText = response.settings.headerText || &#39;Hello, world!&#39;; // Potentially unintended. &#39;&#39; is falsy, result: &#39;Hello, world!&#39;\nconst animationDuration = response.settings.animationDuration || 300; // Potentially unintended. 0 is falsy, result: 300\nconst showSplashScreen = response.settings.showSplashScreen || true; // Potentially unintended. false is falsy, result: true\n</code></pre>\n<p><strong>?? 就是为了解决这种问题需求的，只有当左侧值为null或undefined，才使用右侧的默认值</strong></p>\n<pre><code class=\"language-js\">const undefinedValue = response.settings.undefinedValue ?? &#39;some other default&#39;; // result: &#39;some other default&#39;\nconst nullValue = response.settings.nullValue ?? &#39;some other default&#39;; // result: &#39;some other default&#39;\nconst headerText = response.settings.headerText ?? &#39;Hello, world!&#39;; // result: &#39;&#39;\nconst animationDuration = response.settings.animationDuration ?? 300; // result: 0\nconst showSplashScreen = response.settings.showSplashScreen ?? true; // result: false</code></pre>\n<p>参考文档：</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/%E5%8F%AF%E9%80%89%E9%93%BE\">可选链 - JavaScript | MDN</a></p>\n<p><a href=\"http://es6.ruanyifeng.com/#docs/object#%E9%93%BE%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6\">对象的扩展 - ECMAScript 6入门</a></p>\n<p><a href=\"https://github.com/tc39/proposals/blob/master/finished-proposals.md\">tc39 - Finished Proposals</a></p>\n<p><a href=\"https://github.com/tc39/proposal-optional-chaining\">tc39 - proposal-optional-chaining</a></p>\n<p><a href=\"https://github.com/tc39/proposal-nullish-coalescing\">proposal-nullish-coalescing</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "ES2020 '?.' 与 '??' 操作符",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "Optional chaining operator(?.)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Nullish coalescing Operator(??)"
            }
          ]
        }
      ],
      "config": {
        "source": "ES2020 '?.' 与 '??' 操作符.md",
        "staticFileName": "es2020_operator.html",
        "author": "guoqzuo",
        "createDate": "2019/12/09",
        "description": "Optional chaining operator(?.) 与 Nullish coalescing Operator(??) 目前正式进入 stg4，确定会成为ES2020标准，阮一峰老师已经在他的es6入门教程里更新了，下面来看看具体怎么使用",
        "keywords": "??与?.,js ??是什么意思,js ?.是什么意思",
        "category": "JavaScript",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"not和nth混用的问题\">:not和:nth混用的问题</h1>\n<p>:not() 不支持在其参数中使用其他伪类。例如，h1:not(p:first-of-type) 不能匹配任何元素，所以不能混用，额外加个class吧</p>\n<p>参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/:not\">:not() - CSS（层叠样式表） | MDN</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": ":not和:nth混用的问题"
        }
      ],
      "config": {
        "source": ":not和:nth混用的问题.md",
        "staticFileName": "not_nth.html",
        "author": "guoqzuo",
        "createDate": "2019/12/09",
        "description": ":not() 不支持在其参数中使用其他伪类。例如，h1:not(p:first-of-type) 不能匹配任何元素，所以不能混用，额外加个class吧",
        "keywords": ":not和:nth混用的问题",
        "category": "CSS",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue路由懒加载时import里面不能是变量的问题\">vue路由懒加载时import里面不能是变量的问题</h1>\n<p>路由懒加载地址不能有变量，当在vue里面需要将路由组件按需加载时，import里面开头不能是变量，webpack编译会无法加载对应的组件，解决方法是前面加一部分写死的字符串路径，后面的使用变量即可</p>\n<pre><code class=\"language-js\">// `前面加写死的字符串+${变量字符串}` 是可行的，会加载path目录下的所有\n{ \n  path: &#39;/path&#39;,\n  // components: () =&gt; import(`${myFile}`)  // 找不到组件路径\n  components: () =&gt; import(`./path/${myFile}`)  // ok\n\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue路由懒加载时import里面不能是变量的问题"
        }
      ],
      "config": {
        "source": "vue路由懒加载时import里面不能是变量的问题.md",
        "staticFileName": "vue_import_var.html",
        "author": "guoqzuo",
        "createDate": "2019/12/11",
        "description": "路由懒加载地址不能有变量，当在vue里面需要将路由组件按需加载时，import里面开头不能是变量，webpack编译会无法加载对应的组件，解决方法是前面加一部分写死的字符串路径，后面的使用变量即可",
        "keywords": "路由懒加载地址不能有变量，路由懒加载import变量无效,路由懒加载import里面使用变量不生效",
        "category": "Vue",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"以b站app为例实战charles抓包以及将本地的h5代理到app内嵌h5运行\">以B站app为例实战Charles抓包以及将本地的H5代理到app内嵌H5运行</h1>\n<p>当我们在开发app内嵌的H5页面时，怎么调试是一个问题。看内嵌H5运行时，接口的返回情况，可以使用Charles进行抓包查看，另外charles也可以将我们本地的H5页面直接代理到app内嵌H5里运行。这里以B站app为例，来进行相应的测试</p>\n<p>这里有两个前提条件</p>\n<ol>\n<li>有现成的app，且app里面访问了一个H5页面，我们拿到这个页面的URL，将这个url代理到局域网内我们本地的H5页面</li>\n<li>手机和电脑需要连接到同一个局域网</li>\n</ol>\n<p>来看下具体步骤</p>\n<h2 id=\"使用charles抓包\">使用Charles抓包</h2>\n<p>这里注意，需要将手机和运行charles的电脑连接到同一个局域网里</p>\n<ul>\n<li>打开charles软件</li>\n<li>查看运行charles软件电脑的本地ip地址，我这个是 192.168.31.67</li>\n<li>将手机的网络代理到电脑的ip地址上，以iPhone为例<ul>\n<li>设置 - 点击无线局域网 - 点击连接上的wifi右侧的 i 图标，进入详情页 - 往下翻，点击配置代理 - 手动 - 输入服务器/端口</li>\n<li>服务器输入刚才记录的电脑的ip：192.168.31.67，端口设置为8888（一般设置为这个，具体的端口可以在 Charles的菜单栏 Proxy - Proxy Settings... - Proxies - HTTP Proxy Port 里面可以看到）</li>\n</ul>\n</li>\n<li>打开B站app，可以看到Charles软件捕捉到了很多b站的请求</li>\n</ul>\n<p><img src=\"../../../images/blog/devtools/charles_catch_package.png\" alt=\"charles_catch_package.png\"></p>\n<h2 id=\"使用charles将本地h5代理到app内嵌h5执行\">使用charles将本地H5代理到app内嵌h5执行</h2>\n<p>以bilibili app为例，我们通过charles看哪些功能使用了内嵌的H5，通过测试发现会员购 - 新人专属，使用的是内嵌H5</p>\n<p><img src=\"../../../images/blog/devtools/bilibili_h5_1.png\" alt=\"bilibili_h5_1.png\"></p>\n<p>链接为：<a href=\"https://www.bilibili.com/blackboard/mall/activity-yrW-GWas.html?msource=new_feedcard_20200426&amp;native.theme=1&amp;night=0\">https://www.bilibili.com/blackboard/mall/activity-yrW-GWas.html?msource=new_feedcard_20200426&amp;native.theme=1&amp;night=0</a></p>\n<p>我们现在把Charels配置下，当bilibili app访问这个链接时，直接代理到我们电脑本地的 <a href=\"http://127.0.0.1:81/\">http://127.0.0.1:81/</a> 页面，这样可以让本地的页面在B站的app里面运行</p>\n<p>配置代理方法：使用charles 顶部菜单 Tools - Map remote，配置将访问的内嵌H5地址，代理到局域网内本地网页路径即可，如下图</p>\n<p><img src=\"../../../images/blog/devtools/bilibili_h5_3.png\" alt=\"bilibili_h5_3.png\"></p>\n<p>当我们点击会员购 - 新人专属 就可以访问电脑本地的页面了，如下图</p>\n<p><img src=\"../../../images/blog/devtools/bilibili_h5_2.png\" alt=\"bilibili_h5_2.png\"></p>\n<p>这样就可以看本地的H5在app内嵌时运行的效果了，如果想要看console里面打印了什么，推荐在页面中引入 vconsole 模块，这样就可以查看console的信息了。</p>\n<h2 id=\"实时调试app内嵌h5的样式、dom\">实时调试app内嵌H5的样式、DOM</h2>\n<p>使用web调试代理工具Whistle, 可查看dom样式，这是一个思路</p>\n<h2 id=\"使用charles抓包或代理时可能会出现的一些问题\">使用Charles抓包或代理时可能会出现的一些问题</h2>\n<p><strong>问题1：Connection established</strong></p>\n<p>不同的电脑，对同一台手机抓包，需要安装不同的证书</p>\n<ul>\n<li>证书安装: help - SSL Proxying - install Charles Root Certificate，然后信任</li>\n<li>手机证书安装 help - SSL Proxying - install Charles Root Certificate on a Mobile Device …, 代理到本地后，访问chls.pro/ssl 下载安装，然后再Settings &gt; General &gt; About &gt; Certificate Trust Testings 信任证书</li>\n</ul>\n<p><strong>问题2：SSL handshake with client failed - Remote host terminated the handshake</strong></p>\n<p>一般是证书信任问题: Settings &gt; General &gt; About &gt; Certificate Trust Testings</p>\n<p><strong>问题3: 使用Charles抓包时，需要关闭电脑的vpn代理</strong></p>\n<p>使用Charles抓包，设置了网络代理，一切设置都正常，但是电脑上还是接收不到请求，发现vpn开启了，关掉后，就可以接收到请求的数据了。</p>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://www.charlesproxy.com/\">charles官网</a></li>\n<li><a href=\"https://www.jianshu.com/p/82f63277d50f\">mac下charles使用简介(包含破解方法)</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "以B站app为例实战Charles抓包以及将本地的H5代理到app内嵌H5运行",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "使用Charles抓包"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "使用charles将本地H5代理到app内嵌h5执行"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "实时调试app内嵌H5的样式、DOM"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "使用Charles抓包或代理时可能会出现的一些问题"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "以B站app为例实战Charles抓包以及将本地的H5代理到app内嵌H5运行.md",
        "staticFileName": "b_charles.html",
        "author": "guoqzuo",
        "createDate": "2019/12/18",
        "description": "当我们在开发app内嵌的H5页面时，怎么调试是一个问题。看内嵌H5运行时，接口的返回情况，可以使用Charles进行抓包查看，另外charles也可以将我们本地的H5页面直接代理到app内嵌H5里运行。这里以B站app为例，来进行相应的测试",
        "keywords": "Charles抓包,将本地的H5代理到app内嵌H5运行,charles,抓包,app内嵌H5调试技巧",
        "category": "计算机基础与开发工具",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"安卓input键盘弹起导致底部按钮也被抬起的问题\">安卓input键盘弹起导致底部按钮也被抬起的问题</h1>\n<p>在写app内嵌H5页面时，之前遇到过这个问题，当输入时，键盘弹起导致底部按钮也被抬起了，这里用监听视窗高度变换的方法来fix这个问题</p>\n<p>监听window.onresize，如果与之前的视窗高度不一致：变小了，就隐藏底部button，完成输入后，监听到视窗高度变大再次显示底部按钮</p>\n<pre><code class=\"language-js\">let oriH = document.documentElement.clientHeight;\nwindow.onresize = () =&gt; {\n  if (document.documentElement.clientHeight &lt; oriH) {\n    document.getElementById(&#39;bttombtn&#39;).style.display = &#39;none&#39;;\n  }else{\n    document.getElementById(&#39;bttombtn&#39;).style.display = &#39;原来的显示方式&#39;;\n  }\n})</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "安卓input键盘弹起导致底部按钮也被抬起的问题"
        }
      ],
      "config": {
        "source": "安卓input键盘弹起导致底部按钮也被抬起的问题.md",
        "staticFileName": "android_h5.html",
        "author": "guoqzuo",
        "createDate": "2019/12/18",
        "description": "在写app内嵌H5页面时，之前遇到过这个问题，当输入时，键盘弹起导致底部按钮也被抬起了，这里用监听视窗高度变换的方法来fix这个问题,监听window.onresize，如果与之前的视窗高度不一致：变小了，就隐藏底部button，完成输入后，监听到视窗高度变大再次显示底部按钮",
        "keywords": "安卓input键盘弹起导致底部按钮也被抬起的问题,app内嵌H5安卓键盘抬起相关问题",
        "category": "JavaScript",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"npm查询包信息以及安装指定版本\">npm查询包信息以及安装指定版本</h1>\n<p>当我们需要安装某个npm包的指定版本时，我们可以使用 npm view 先查看某个包的一些版本信息，npm install时，可以通过在包名后面加@版本号来指定安装对应的版本</p>\n<pre><code class=\"language-bash\"># npm view -h  帮助文档\nnpm view [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;] [&lt;field&gt;[.subfield]...]\n\naliases: v, info, show\n\n# npm 查询某个包的信息：最新版本、tags记录、github地址等\nnpm view 某个包名\n\n# 安装指定版本\nnpm install 某个包名@版本号</code></pre>\n<h2 id=\"npm-install以及加参数后的一些区别\">npm install以及加参数后的一些区别</h2>\n<h3 id=\"npm-install-modulename\">npm install moduleName</h3>\n<ol>\n<li>安装模块到项目node_modules目录下。</li>\n<li>不会将模块依赖写入devDependencies或dependencies 节点。</li>\n<li>运行 npm install 初始化项目时不会下载模块。</li>\n</ol>\n<h3 id=\"npm-install--g-modulename\">npm install -g moduleName</h3>\n<ol>\n<li>安装模块到全局，不会在项目node_modules目录中保存模块包。</li>\n<li>不会将模块依赖写入devDependencies或dependencies 节点。</li>\n<li>运行 npm install 初始化项目时不会下载模块。</li>\n</ol>\n<h3 id=\"npm-install--save-modulename\">npm install -save moduleName</h3>\n<ol>\n<li>安装模块到项目node_modules目录下。</li>\n<li>会将模块依赖写入dependencies 节点。</li>\n<li>运行 npm install 初始化项目时，会将模块下载到项目目录下。</li>\n<li>运行npm install --production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。</li>\n</ol>\n<h3 id=\"npm-install--save-dev-modulename\">npm install -save-dev moduleName</h3>\n<ol>\n<li>安装模块到项目node_modules目录下。</li>\n<li>会将模块依赖写入devDependencies 节点。</li>\n<li>运行 npm install 初始化项目时，会将模块下载到项目目录下。</li>\n<li>运行npm install --production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。</li>\n</ol>\n<p>对于只有在开发中使用的，比如node中间件、gulp、压缩css、js的模块，可以使用 --save-dev形式安装，如果线上代码必须依赖的模块，需要使用--save</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "npm查询包信息以及安装指定版本",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "npm install以及加参数后的一些区别",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "npm install moduleName"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "npm install -g moduleName"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "npm install -save moduleName"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "npm install -save-dev moduleName"
                }
              ]
            }
          ]
        }
      ],
      "config": {
        "source": "npm查询包信息以及安装指定版本.md",
        "staticFileName": "npm_package_info.html",
        "author": "guoqzuo",
        "createDate": "2019/12/17",
        "description": "当我们需要安装某个npm包的指定版本时，我们可以使用 npm view 先查看某个包的一些版本信息，npm install时，可以通过在包名后面加@版本号来指定安装对应的版本",
        "keywords": "npm查询包信息,npm安装指定版本,npm install以及加参数后的一些区别",
        "category": "前端工程化",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue组件里click事件监听可能会产生的性能问题\">vue组件里click事件监听可能会产生的性能问题</h1>\n<p>之前在看JS高程3里面有一个知识点，就是当多个子元素需要绑定click事件时，大量添加处理程序，会影响性能，尽量少添加处理事件。</p>\n<p>但写vue习惯后，突然忘了这一点，其实vue监听事件我们也可以遵循这个原则：把事件放到其父元素上监听，然后通过 data-key属性来指定每个子元素对应的值。e.target.getAttribute(&#39;data-key&#39;)有值就表示子元素点击了</p>\n<p><strong>这样做的好处是，内存占用更小</strong></p>\n<p>JS高程3第13章事件 - 内存和性能 - 事件委托有介绍，相关描述及demo如下</p>\n<p>事件委托，大量添加处理程序，会影响性能，尽量少添加处理事件，比如下面的代码：</p>\n<pre><code class=\"language-js\">/*\n&lt;ul id=&quot;myLinks&quot;&gt;\n  &lt;li id=&quot;goSomeWhere&quot;&gt;goSomeWhere&lt;/li&gt;\n  &lt;li id=&quot;doSomething&quot;&gt;doSomething&lt;/li&gt;\n  &lt;li id=&quot;sayHi&quot;&gt;sayHi&lt;/li&gt;\n&lt;/ul&gt;\n*/\nvar item1 = document.getElementById(&#39;goSomeWhere&#39;);\nvar item2 = document.getElementById(&#39;doSomething&#39;);\nvar item3 = document.getElementById(&#39;sayHi&#39;);\n\nEventUtil.addHandler(item1, &#39;click&#39;, function(event) {\n  location.href = &#39;http://www.zuo11.com&#39;;\n});\nEventUtil.addHandler(item2, &#39;click&#39;, function(event) {\n  document.title = &quot;I change the title&quot;;\n});\nEventUtil.addHandler(item3, &#39;click&#39;, function(event) {\n  alert(&#39;hi&#39;);\n});</code></pre>\n<p>优化后的代码</p>\n<pre><code class=\"language-js\">var links = document.getElementById(&#39;myLinks&#39;);\nEventUtil.addHandler(links, &#39;click&#39;, function(event) {\n  event = EventUtil.getEvent(event);\n  var target = EventUtil.getTarget(event);\n  switch (target.id) {\n    case &#39;goSomeWhere&#39;:\n      location.href = &#39;http://www.zuo11.com&#39;;\n      break;\n    case &#39;doSomething&#39;:\n      document.title = &quot;I change the title&quot;;\n      break;\n    case &#39;sayHi&#39;:\n      alert(&#39;hi&#39;);\n      break;\n  }\n});</code></pre>\n<p>参考之前的笔记 <a href=\"https://www.yuque.com/guoqzuo/js_es6/elgng1#0ea56e91\">事件 内存和性能 | JS高程3</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue组件里click事件监听可能会产生的性能问题"
        }
      ],
      "config": {
        "source": "vue组件里click事件监听可能会产生的性能问题.md",
        "staticFileName": "vue_click.html",
        "author": "guoqzuo",
        "createDate": "2019/12/13",
        "description": "vue click会不会影响性能？之前在看JS高程3里面有一个知识点，就是当多个子元素需要绑定click事件时，大量添加处理程序，会影响性能，尽量少添加处理事件。但写vue习惯后，突然忘了这一点，其实vue监听事件我们也可以遵循这个原则：把事件放到其父元素上监听，然后通过 data-key属性来指定每个子元素对应的值。e.target.getAttribute('data-key')有值就表示子元素点击了",
        "keywords": "vue click会不会影响性能？vue组件里click事件监听可能导致的性能问题,vue监听click事件注意事项",
        "category": "Vue",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"function和method区别\">function和method区别</h1>\n<p>在写程序时，你会发现function和method都代表函数，但他们又什么区别呢？</p>\n<ul>\n<li>function为函数，一般指外部定义的函数。</li>\n<li>method为方法，一般指类(class)内部的方法，类方法一般分为staic method，private method, instance method</li>\n</ul>\n<p>参考: <a href=\"https://www.zhihu.com/question/299219511\">python的method和function有什么区别？</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "function和method区别"
        }
      ],
      "config": {
        "source": "function和method区别.md",
        "staticFileName": "function_method.html",
        "author": "guoqzuo",
        "createDate": "2019/12/13",
        "description": "在写程序时，你会发现function和method都代表函数，但他们又什么区别呢？function为函数，一般指外部定义的函数; method为方法，一般指类(class)内部的方法，类方法一般分为staic method，private method, instance method",
        "keywords": "function和method区别",
        "category": "计算机基础与开发工具",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"vuex状态更新后，一直没生效的问题\">vuex状态更新后，一直没生效的问题</h1>\n<p>今天写一个功能时，push数据更新state变量可以刷新到页面，但用slice改变state变量时，页面报错，提示 &#39;TypeError: Cannot rad property &#39;wrapper&#39; of undefined&#39;。</p>\n<p>百度了下可能是@click方法没定义报的错，但我这里只是改了vuex状态，而且push新增数据都可以，就是slice删除数据会报错，最后发现是有一个@click方法确实没有定义，但这种情况很奇怪。</p>\n<p>为什么push又不报错，可能涉及到了diff的一些检测、算法。</p>\n<p><strong>所以，页面有consloe.error的错误，一定要先解决，不要以为对功能没影响就不管，不然可能会遇到一些奇怪的问题。</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vuex状态更新后，一直没生效的问题"
        }
      ],
      "config": {
        "source": "vuex状态更新后一直没生效的问题.md",
        "staticFileName": "vuex_issue.html",
        "author": "guoqzuo",
        "createDate": "2019/12/12",
        "description": "今天写一个功能时，push数据更新state变量可以刷新到页面，但用slice改变state变量时，页面报错，提示 'TypeError: Cannot rad property 'wrapper' of undefined'，百度了下可能是@click方法没定义报的错，但我这里只是改了vuex状态，而且push新增数据都可以，就是slice删除数据会报错，最后发现是有一个@click方法确实没有定义，但这种情况很奇怪。为什么push又不报错，可能涉及到了diff的一些检测、算法。所以，页面有consloe.error的错误，一定要先解决，不要以为对功能没影响就不管，不然可能会遇到一些奇怪的问题。",
        "keywords": "vuex状态更新后一直没生效的问题,vuex TypeError: Cannot rad property 'wrapper' of undefined'",
        "category": "Vue",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue组件updated钩子使用场景\">vue组件updated钩子使用场景</h1>\n<p>updated钩子，在vue中，只要data变更就会触发，子组件的列表数据会根据接口请求的数据来刷新，当列表数据更新后，会调用子组件updated钩子函数，我们可以在这里里处理列表数据刷新后的一些操作。比如清除所有focus状态，滚动页面等</p>\n<p>一般data每改动一次，就会触发一次updated钩子函数，对于data属性比较多的情况，可能会触发上百次的updated钩子函数，这种情况就不要使用updated了，它适用于data属性比较少的情况。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue组件updated钩子使用场景"
        }
      ],
      "config": {
        "source": "vue组件updated钩子使用场景.md",
        "staticFileName": "vue_updated.html",
        "author": "guoqzuo",
        "createDate": "2019/12/12",
        "description": "updated钩子，在vue中，只要data变更就会触发，子组件的列表数据会根据接口请求的数据来刷新，当列表数据更新后，会调用子组件updated钩子函数，我们可以在这里里处理列表数据刷新后的一些操作。比如清除所有focus状态，滚动页面等",
        "keywords": "updated钩子,vue组件updated钩子使用场景",
        "category": "Vue",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"怎么遍历localstorage\">怎么遍历localStorage</h1>\n<p>localStorage本身没有提供对应的遍历方法，我们可以使用 localStorage.key(index) 结合for循环来遍历</p>\n<pre><code class=\"language-js\">let len = localStorage.length\nfor (let i = 0; i &lt; len; i++) {\n  let keyName = localStorage.key(i)\n  console.log(keyName, localStorage.getItem(keyName))\n}</code></pre>\n<p>同理，sessionStorage也可以用类似的方法来遍历</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "怎么遍历localStorage"
        }
      ],
      "config": {
        "source": "怎么遍历localStorage.md",
        "staticFileName": "localstorage_iterator.html",
        "author": "guoqzuo",
        "createDate": "2019/12/19",
        "description": "localStorage本身没有提供对应的遍历方法，我们可以使用 localStorage.key(index) 结合for循环来遍历",
        "keywords": "怎么遍历localStorage,怎么遍历sessionStorage",
        "category": "JavaScript",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"ios环境下点击输入框页面被顶起不能自动回弹底部的问题\">iOS环境下点击输入框页面被顶起不能自动回弹底部的问题</h1>\n<p>在开发app内嵌H5时，iOS系统里，输入框输入时，页面会被抬起，但输入完成后，页面不会自动回弹，这里需要特殊处理下</p>\n<p><strong>解决方法：在对应的input元素加 @blur 事件，input失去焦点时，手动滚动页面 window.scroll(0,0)</strong></p>\n<p>参考：<a href=\"https://blog.csdn.net/YY110621/article/details/87919966\">解决ios环境下点击输入框页面被顶起不能自动回弹到底部问题</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iOS环境下点击输入框页面被顶起不能自动回弹底部的问题"
        }
      ],
      "config": {
        "source": "iOS环境下点击输入框页面被顶起不能自动回弹底部的问题.md",
        "staticFileName": "ios_kb_rebound.html",
        "author": "guoqzuo",
        "createDate": "2019/12/19",
        "description": "在开发app内嵌H5时，iOS系统里，输入框输入时，页面会被抬起，但输入完成后，页面不会自动回弹，这里需要特殊处理下，解决方法：在对应的input元素加 @blur 事件，input失去焦点时，手动滚动页面 window.scroll(0,0)",
        "keywords": "iOS环境下点击输入框页面被顶起不能自动回弹底部的问题",
        "category": "JavaScript",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"长英文单词不换行的问题\">长英文单词不换行的问题</h1>\n<p>关于换行问题，属于文本类的css样式，在css中有三个和换行有关的属性他们分别是：white-space、word-break、word-wrap，由于他们有点类似且特性比较怪，不容易理解，这里来总结下</p>\n<h2 id=\"white-space\">white-space</h2>\n<p>主要用于处理空白符，但它也可以用于换行</p>\n<pre><code class=\"language-css\">span {\n  white-space: normal; /* 默认值 */\n  white-space: nowrap; /* 不换行，在一行显示 */\n}</code></pre>\n<p>white-space默认值为normal：文本超出父容器后，会自动换行，压缩空白符(当多个空白时，只显示一个空白符)。</p>\n<p><strong>white-space设置为nowrap时</strong>，文本不会换行，在一行显示，更多细节参考之前的笔记 <a href=\"https://www.yuque.com/guoqzuo/js_es6/xd5io5#ba923c63\">white-space 处理空白 | HTML权威指南笔记</a></p>\n<p>white-space: nowrap 常结合 overflow:hidden; text-overflow: ellipsis; 用于实现单行文本截断。</p>\n<h2 id=\"word-wrap-溢出文本断行\">word-wrap 溢出文本断行</h2>\n<p>当一个单词的长度超出包含块的宽度时如何处理</p>\n<ul>\n<li>normal 默认，单词不断开，即使无法完全放入包含块。</li>\n<li>break-word 断开单词，使其放入包含块。</li>\n</ul>\n<p><img src=\"../../../images/blog/css/css_word_wrap.png\" alt=\"css_word_wrap.png\"></p>\n<h2 id=\"word-break\">word-break</h2>\n<p>文本换行截断处理</p>\n<ul>\n<li>normal: 使用默认的换行规则</li>\n<li>break-all: 允许任意非CJK(Chinese/Jpanese/Korean)文本间的单词断行</li>\n</ul>\n<h2 id=\"通过一个demo来看他们之间的区别\">通过一个demo来看他们之间的区别</h2>\n<pre><code class=\"language-html\">&lt;head&gt;\n  &lt;style&gt;\n    .sec {\n      width: 200px;\n      margin: 20px;\n      border: 1px solid #ccc;\n    }\n    .fix1 {\n      word-break: break-all;\n    }\n    .fix2 {\n      word-wrap: break-word;\n    }\n    .nowrap {\n      white-space: nowrap;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&#39;sec&#39;&gt;\n    我是汉字 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa我是汉字\n  &lt;/div&gt;\n  &lt;div class=&#39;sec nowrap&#39;&gt;\n    我是汉字 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa我是汉字\n  &lt;/div&gt;\n  &lt;div class=&#39;sec fix1&#39;&gt;\n    我是汉字 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa我是汉字\n  &lt;/div&gt;\n  &lt;div class=&#39;sec fix2&#39;&gt;\n    我是汉字 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa我是汉字\n  &lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p><img src=\"../../../images/blog/css/css_wrap.png\" alt=\"css_wrap.png\"></p>\n<p>word-break: break-all 和 word-wrap: break-word 同样都是换行，前者不会在单词前或后面换行，而后者会</p>\n<p>word-break和word-warp比较相似，容易混淆，在CSS3规范中，word-wrap 改为了 overflow-wrap，但浏览器兼容性不好，现在还是使用word-wrap</p>\n<p>参考：</p>\n<ul>\n<li>《CSS世界 | 张鑫旭》 264页 第8章 强大的文本处理能力</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-wrap\">CSS word-wrap | MDN</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "长英文单词不换行的问题",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "white-space"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "word-wrap 溢出文本断行"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "word-break"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "通过一个demo来看他们之间的区别"
            }
          ]
        }
      ],
      "config": {
        "source": "长英文单词不换行的问题.md",
        "staticFileName": "css_wrap.html",
        "author": "guoqzuo",
        "createDate": "2019/12/20",
        "description": "关于换行问题，属于文本类的css样式，在css中有三个和换行有关的属性他们分别是：white-space、word-break、word-wrap，由于他们有点类似且特性比较怪，不容易理解，这里来总结下",
        "keywords": "长英文单词不换行的问题,css换行,white-space、word-break、word-wrap,word-break和word-wrap的区别",
        "category": "CSS",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"postcss-pxtorem-px自动转rem怎么保持使用px\">postcss-pxtorem px自动转rem怎么保持使用px</h1>\n<p>如果vue-cli3中配置了postcass-pxtorem，css中写的px单位都会自动转为rem，如果需要固定px，而不是转为rem，有两种方法</p>\n<pre><code class=\"language-css\">/* 使用Px 或 PX */\n .ignore {\n   border: 1Px solid;\n   border-width: 2PX;\n }</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "postcss-pxtorem px自动转rem怎么保持使用px"
        }
      ],
      "config": {
        "source": "postcss-pxtorem px自动转rem怎么保持使用px.md",
        "staticFileName": "pxtorem_px.html",
        "author": "guoqzuo",
        "createDate": "2019/12/23",
        "description": "如果vue-cli3中配置了postcass-pxtorem，css中写的px单位都会自动转为rem，如果需要固定px，而不是转为rem，有两种方法",
        "keywords": "postcss-pxtorem px自动转rem怎么保持使用px",
        "category": "CSS",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"html2canvas在移动端使用时的问题\">html2canvas在移动端使用时的问题</h1>\n<p>在需要生成海报、图片的需求里，一般 html2canvas 是一种比较好的解决方案，pc端的问题还是比较少的，移动端兼容性问题就比较坑了，要特别注意多测试一些机型，下面总结下我之前遇到的两个移动端的问题</p>\n<h2 id=\"html2canvas-生成图片时，background-image模糊的问题\">html2canvas 生成图片时，background-image模糊的问题</h2>\n<p>PC端一般不会出现这个问题，主要是移动端，有两种解决方法：</p>\n<ol>\n<li>使用固定宽度，不要使用百分比单位(比如 1500px)</li>\n<li>用 img 标签使用 absolute 定位做背景，不使用background-image</li>\n</ol>\n<h2 id=\"html2canvas-移动端生成图片文字重叠的问题\">html2canvas 移动端生成图片文字重叠的问题</h2>\n<p>text-align:center 可能会导移动端，生成图片的文字重叠的问题，改为text-align:left或其他即可。但需要特别注意兼容性的问题，移动端安卓、iPhone、安卓平板 啥的都要看看。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "html2canvas在移动端使用时的问题",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "html2canvas 生成图片时，background-image模糊的问题"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "html2canvas 移动端生成图片文字重叠的问题"
            }
          ]
        }
      ],
      "config": {
        "source": "html2canvas在移动端使用时的问题.md",
        "staticFileName": "html2canvas_notice.html",
        "author": "guoqzuo",
        "createDate": "2019/12/23",
        "description": "html2canvas 生成图片时，background-image模糊的问题,html2canvas 移动端生成图片文字重叠的问题，在需要生成海报、图片的需求里，一般 html2canvas 是一种比较好的解决方案，pc端的问题还是比较少的，移动端兼容性问题就比较坑了，要特别注意多测试一些机型，下面总结下我之前遇到的两个移动端的问题",
        "keywords": "html2canvas在移动端使用时的问题,html2canvas 生成图片时，background-image模糊的问题,html2canvas 移动端生成图片文字重叠的问题",
        "category": "CSS",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"移动端兼容性问题：vuex设置后立即调用thisrouterback按钮无法点击的问题\">移动端兼容性问题：vuex设置后立即调用this.$router.back()按钮无法点击的问题</h1>\n<p>今天测试机iPhone 7 plus，系统大概是iOS 11.3，vuex mutation操作后，立即调用 this.$router.back() 会导致页面里的下一步无法点击。</p>\n<p>而我自己的机型iPhone8是没问题的，解决方法是：在 vue mutaion操作后，不立即调用 back，而是使用 nextTick包裹，在下次 DOM 更新循环结束之后再执行</p>\n<pre><code class=\"language-js\">// 解决方法\n// vuex mutation操作 =&gt;  this.$nextTick(() =&gt; { 将 this.$router.back() 放到这里即可 })</code></pre>\n<p>参考：<a href=\"https://cn.vuejs.org/v2/api/#Vue-nextTick\">Vue-nextTick | Vue.js官方文档</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "移动端兼容性问题：vuex设置后立即调用this.$router.back()按钮无法点击的问题"
        }
      ],
      "config": {
        "source": "移动端兼容性问题：vuex设置后立即调用this.$router.back()按钮无法点击的问题.md",
        "staticFileName": "vuex_nexttick.html",
        "author": "guoqzuo",
        "createDate": "2019/12/24",
        "description": "今天测试机iPhone 7 plus，系统大概是iOS 11.3，vuex mutation操作后，立即调用 this.$router.back() 会导致页面里的下一步无法点击。而我自己的机型iPhone8是没问题的，解决方法是：在 vue mutaion操作后，不立即调用 back，而是使用 nextTick包裹，在下次 DOM 更新循环结束之后再执行",
        "keywords": "vuex设置后立即调用this.$router.back()按钮无法点击的问题",
        "category": "Vue",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue性能优化---webpack包体积优化\">vue性能优化 - webpack包体积优化</h1>\n<ol>\n<li><p>安装 <strong>webpack-bundle-analyzer</strong> npm包</p>\n<pre><code class=\"language-bash\"># 安装包\nnpm install webpack-bundle-analyzer --save-dev</code></pre>\n</li>\n<li><p>在package.json的scripts加入对应的命令，运行npm run report 即可build，并在dist目录生成report.html，打开就可以各个模块包对应的大小，这样就可以开始优化了</p>\n<pre><code class=\"language-js\">scripts: {\n&quot;report&quot;: &quot;vue-cli-service build --report&quot;\n}</code></pre>\n</li>\n<li><p>路由都弄成懒加载，js懒加载可以使用import()，如果使用import xx from &#39;xx&#39;，会直接打包到主包，就需要弄成懒加载的逻辑。但如果使用该js，怎么判断js已懒加载完？setTimeout 1s后再调用，弱网呢？怎么监听？这就需要了解懒加载的逻辑了，示例如下：</p>\n<pre><code class=\"language-html\">&lt;!-- 监听是否加载完成 --&gt;\n&lt;!-- 在浏览器中，import 语句只能在声明了 type=&quot;module&quot; 的 script 的标签中使用。--&gt;\n&lt;script type=&quot;module&quot;&gt;\nlet myModule = () =&gt; import(&#39;./testModule.js&#39;)\n\n// testModule.js   内容 export default { a: 1, b: &quot;test&quot; }\n\n// 类似于路由组件component懒加载逻辑。myModule仅是一个函数，返回promise，需要调用时 myModule().then() 即可\nwindow.onload = () =&gt; {\n console.log(&#39;onload&#39;)\n\n // dom已加载，3秒后加载模块\n setTimeout(() =&gt; {\n   console.log(myModule, typeof myModule) // () =&gt; import(&#39;./testModule.js&#39;) &quot;function&quot;\n   // myModule() 函数执行后，返回promise\n   myModule().then((res) =&gt; {\n     console.log(&#39;模块加载成功&#39;, res) // 加载成功 Module {Symbol(Symbol.toStringTag): &quot;Module&quot;}\n     let data = res.default // {a: 1, b: &quot;test&quot;}\n     console.log(data.a) // 1\n   },(e) =&gt; {\n     console.log(&#39;import 加载异常&#39;)\n   })\n }, 3000)\n}\n&lt;/script&gt;</code></pre>\n</li>\n</ol>\n<p>参考: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import\">import - JavaScript | MDN</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue性能优化 - webpack包体积优化"
        }
      ],
      "config": {
        "source": "vue性能优化 - webpack包体积优化.md",
        "staticFileName": "vue_webpack_optimization.html",
        "author": "guoqzuo",
        "createDate": "2019/12/25",
        "description": "安装 webpack-bundle-analyzer npm包， 在package.json的scripts加入对应的命令，运行npm run report 即可build，并在dist目录生成report.html，打开就可以各个模块包对应的大小，这样就可以开始优化了",
        "keywords": "webpack-bundle-analyzer,webpack包体积优化",
        "category": "Vue",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"transform-两个动作怎么写？scale缩小后，依旧占用空间的问题\">transform 两个动作怎么写？scale缩小后，依旧占用空间的问题</h1>\n<p>transform对某个元素使用两个及以上变换时，用空格分隔，scale缩小0.5倍后，dom占用依旧，可以用translate移动下，矫正位置。</p>\n<pre><code class=\"language-css\">/* 两个transform */\ndiv {\n  transform: scale(0.5) translate(-50%, -50%)\n}</code></pre>\n<p>参考: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform\">transform | MDN</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "transform 两个动作怎么写？scale缩小后，依旧占用空间的问题"
        }
      ],
      "config": {
        "source": "transform 两个动作怎么写？scale缩小后，依旧占用空间的问题.md",
        "staticFileName": "transform.html",
        "author": "guoqzuo",
        "createDate": "2019/12/25",
        "description": "transform对某个元素使用两个及以上变换时，用空格分隔，scale缩小0.5倍后，dom占用依旧，可以用translate移动下，矫正位置。",
        "keywords": "transform 两个动作怎么写？scale缩小后，依旧占用空间的问题",
        "category": "CSS",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"v-model为什么不能监听中文输入法实时输入，内部是怎么实现的？\">v-model为什么不能监听中文输入法实时输入，内部是怎么实现的？</h1>\n<p>在看vue文档时，有备注说 v-model 不会在输入法组合文字的过程中得到更新，这是为什么呢？内部是怎么实现的，我们来看看</p>\n<blockquote>\n<p>对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 input 事件。</p>\n</blockquote>\n<h2 id=\"v-model本质是语法糖\">v-model本质是语法糖</h2>\n<p>我们知道v-model其实是语法糖，等价于绑定value属性，以及当输入改变时再次赋值给value，以input text为例</p>\n<pre><code class=\"language-html\">&lt;input v-model=&quot;name&quot;&gt;\n&lt;!-- 可以理解为 等价于 --&gt;\n&lt;input :value=&quot;name&quot; @input=&quot;e =&gt; { name =  e.target.value }&quot;&gt;</code></pre>\n<p>唯一的不同是，非v-model的写法是支持检测输入法组合文字的过程的，但v-model内部加了处理，双向绑定的值不会在输入法组合文字的过程中得到更新</p>\n<h2 id=\"input相关基础知识\">input相关基础知识</h2>\n<p>input text change事件只有在输入框失去焦点时才会触发，而v-model是实时双向绑定的，那应该用的是input</p>\n<p>input text input事件触发时，其事件对象e里的data属性不是当前input完整的输入内容，而是当前的字符，来看个原生input的例子</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n  &lt;input id=&quot;input&quot; type=&quot;text&quot;&gt;\n  &lt;script&gt;\n    let inputEl = document.querySelector(&#39;#input&#39;)\n    inputEl.addEventListener(&#39;input&#39;, (e) =&gt; {\n      console.log(e) // e.data 只是拿到的 当前输入的字符，而不是input里输入的整体内容\n      console.log(inputEl.value) // 这个才是整体内容\n    })\n  &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p>实时输入内容测试</p>\n<p><img src=\"../../../images/blog/vue/input_event.png\" alt=\"input_event.png\"></p>\n<h2 id=\"v-model为什么不监听输入法的组合文字的过程呢？\">v-model为什么不监听输入法的组合文字的过程呢？</h2>\n<p>通过上面的例子我们知道，其实监听输入法组合文字的过程是非常容易的，但为什么vue在v-model的处理时加了逻辑来不实时更新输入法组合文字的过程呢？</p>\n<p>我的理解是，输入法组合文字的过程中更新值是比较鸡肋的，一般用户在输入法组合文字的过程中是不需要实时校验输入内容准确性的。</p>\n<p>如果不过滤，输入法组合文字的过程也会触发输入内容校验的逻辑，所以才会加入对应的逻辑</p>\n<h2 id=\"v-model-是怎么实现在输入法组合文字的过程中不更新值的\">v-model 是怎么实现在输入法组合文字的过程中不更新值的</h2>\n<p>在下面的示例里，是可以实时检测输入法输入过程的，那我们要怎么加逻辑来处理，在输入法未组合完文字前不更新value的值</p>\n<pre><code class=\"language-html\">&lt;input :value=&quot;name&quot; @input=&quot;e =&gt; { name =  e.target.value }&quot;&gt;</code></pre>\n<p>我们需要了解一个知识点：输入法组合文字过程监听</p>\n<p>他们是 compositionstart, compositionend 两个事件，输入法开始组合文字事件，以及输入法停止组合事件，注意，输入法在组合文件结束时，需要手动触发一次设置value的值。我们需要用一个中间变量 compositioin 来存储当前是否处于组合文字的过程，如果是，就不更新value，等组合文字结束后再更新value</p>\n<p>v-model 在监听input type为text的输入过程时，等价于下面的实例，不监听输入法的组合文字过程</p>\n<pre><code class=\"language-html\">&lt;!-- 需要在data里面定义一个 compositioin 属性，默认值为false --&gt;\n&lt;input :value=&quot;name&quot; @input=&quot;e =&gt; { !compositioin &amp;&amp; (name =  e.target.value) }&quot; @compositionstart=&quot;compositioin = true&quot; @compositionend=&quot;(e) =&gt; { compositioin = false; name = e.target.value }&quot;&gt;</code></pre>\n<h2 id=\"完整demo\">完整demo</h2>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n    &lt;title&gt;vue&lt;/title&gt;\n    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n      {{message}}     \n      &lt;div&gt;{{name}}&lt;/div&gt;\n      &lt;!-- &lt;div&gt;&lt;input v-model=&quot;name&quot;&gt;&lt;/div&gt; --&gt;\n      &lt;!-- &lt;input :value=&quot;name&quot; @input=&quot;e =&gt; { name =  e.target.value }&quot;&gt; --&gt;\n      {{compositioin}}\n      &lt;input :value=&quot;name&quot; @input=&quot;e =&gt; { !compositioin &amp;&amp; (name =  e.target.value) }&quot; @compositionstart=&quot;compositioin = true&quot; @compositionend=&quot;(e) =&gt; { compositioin = false; name = e.target.value }&quot;&gt;\n      &lt;div&gt;{{name2}}&lt;/div&gt;\n      &lt;div&gt;&lt;input :value=&quot;name2&quot; @input=&quot;inputChange&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      var app = new Vue({\n        el: &#39;#app&#39;,\n        data: {\n          message: &#39;Hello Vue&#39;,\n          name: &#39;&#39;,\n          name2: &#39;&#39;,\n          compositioin: false,\n        },\n        methods: {\n          inputChange(e) {\n            console.log(e.target.value)\n            this.name2 = e.target.value\n          }\n        }\n      })\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/forms.html#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95\">v-model基础用法 | Vue.js基础用法</a></li>\n<li><a href=\"https://www.cnblogs.com/gaidalou/p/10593667.html\">输入法组合文字过程监听</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "v-model为什么不能监听中文输入法实时输入，内部是怎么实现的？",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "v-model本质是语法糖"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "input相关基础知识"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "v-model为什么不监听输入法的组合文字的过程呢？"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "v-model 是怎么实现在输入法组合文字的过程中不更新值的"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "完整demo"
            }
          ]
        }
      ],
      "config": {
        "source": "v-model为什么不能监听中文输入法实时输入，内部是怎么实现的？.md",
        "staticFileName": "v_model_text.html",
        "author": "guoqzuo",
        "createDate": "2019/12/20",
        "description": "在看vue文档时，有备注说 v-model 不会在输入法组合文字的过程中得到更新，这是为什么呢？内部是怎么实现的，我们来看看",
        "keywords": "v-model为什么不能监听中文输入法实时输入,输入法组合文字过程监听",
        "category": "Vue",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"es2020-bigint数据类型，为什么要新增这个数据类型\">ES2020 bigint数据类型，为什么要新增这个数据类型?</h1>\n<p>ES5之前，基本数据类型有五个 boolean, string, number, null, undefined, ES6(ES2015)新增了一个symbol，ES2020 新增了 bigint，它用于表示大于 2的53次方 - 1的数据，即 &gt; 9007199254740991</p>\n<h2 id=\"a--1--a--2\">a + 1 === a + 2</h2>\n<p>我们可以先来看一个神奇的例子：a + 1 === a + 2，居然可以成立，注意这里是全等？当a等于 2的53次方 - 1 时，就会出现这种情况</p>\n<pre><code class=\"language-js\">var a = Math.pow(2, 53) - 1 // 正好是 Number.MAX_SAFE_INTEGER\na + 1 === a + 2 // true</code></pre>\n<p>以下是 tc39/proposal bigint 官方示例</p>\n<pre><code class=\"language-js\">const x = Number.MAX_SAFE_INTEGER; // 最大的安全integer\n// ↪ 9007199254740991, this is 1 less than 2^53\n\nconst y = x + 1;  \n// ↪ 9007199254740992, ok, checks out\n\nconst z = x + 2\n// ↪ 9007199254740992, wait, that’s the same as above!\n\n// 不安全的integer，结果不符合预期\nnum = Number.MAX_SAFE_INTEGER // 9007199254740991\nnum + 1 // 9007199254740992\nnum + 2 // 9007199254740992\nnum + 3 // 9007199254740994\nnum + 4 // 9007199254740996\nnum + 5 // 9007199254740996\nnum + 6 // 9007199254740996\nnum + 7 // 9007199254740998\nnum + 8 // 9007199254741000\nnum + 9 // 9007199254741000\nnum + 10 // 9007199254741000</code></pre>\n<h2 id=\"怎么解决上面的问题呢？使用bigint处理\">怎么解决上面的问题呢？使用bigint处理</h2>\n<p>BigInt数据类型有以下一个特性:</p>\n<ol>\n<li>BigInt 类型的数据，需要通过 BingInt函数来创建</li>\n<li>BigInt 类型的数据后面都会携带一个&#39;n&#39;的后缀，</li>\n<li>BigInt 类型的数据不能和 number 数据类型相加</li>\n<li>BigInt 类型的数据可以通过 toString转换为字符串，转后为字符串时，会默认去掉末尾的 &#39;n&#39;</li>\n<li>typeof BigInt数据类型，值为 &#39;bignit&#39;</li>\n</ol>\n<pre><code class=\"language-js\">const previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER);\n// ↪ 9007199254740991n\n\nconst maxPlusOne = previousMaxSafe + 1n;\n// ↪ 9007199254740992n\n\nconst theFuture = previousMaxSafe + 2n;\n// ↪ 9007199254740993n, this works now!\n\nBigInt(1) // 1n\nlet theBiggestInt = BigInt(2 ** 53) // 9007199254740992n\ntheBiggestInt + 2 // Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions\n9007199254740994n.toString()  // &quot;9007199254740994&quot;</code></pre>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-bigint\">tc39/proposal-bigint: Arbitrary precision integers in JavaScript</a></li>\n<li><a href=\"https://www.yuque.com/guoqzuo/csm14e/mig1pq\">BigInts in JavaScript_ A case study in TC39.pptx</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000019912017?utm_source=tag-newest\">JS最新基本数据类型:BigInt</a></li>\n<li><a href=\"https://github.com/tc39/proposals/blob/master/finished-proposals.md\">tc39 Finished Proposals</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "ES2020 bigint数据类型，为什么要新增这个数据类型?",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "a + 1 === a + 2"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "怎么解决上面的问题呢？使用bigint处理"
            }
          ]
        }
      ],
      "config": {
        "source": "ES2020 bigint数据类型，为什么要新增这个数据类型?.md",
        "staticFileName": "bigint.html",
        "author": "guoqzuo",
        "createDate": "2019/12/26",
        "description": "ES5之前，基本数据类型有五个 boolean, string, number, null, undefined, ES6(ES2015)新增了一个symbol，ES2019 新增了 bigint，它用于表示大于 2的53次方 - 1的数据，即 > 9007199254740991",
        "keywords": "a + 1 === a + 2为true的场景,es2019 bigint数据类型",
        "category": "JavaScript",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"为什么我们使用html代替htm\">为什么我们使用.html代替.htm?</h1>\n<blockquote>\n<p>why do we use .html instead of .htm？</p>\n</blockquote>\n<p>DOS was a massive operating system for PCs for a long time and it had a three-character limit on file extensions.</p>\n<p>All HTML documents should have filenames that end with the extension .html unless the files reside on a DOS system, in which case they should have the extension .htm</p>\n<p>DOS操作系统上文件后缀限制为3个字符，所以才会使用.htm的后缀，排除系统限制，所有的HTML文件应该使用.html的后缀名</p>\n<p>参考：<a href=\"https://css-tricks.com/why-do-we-use-html-instead-of-htm/\">Why do we use .html instead of .htm? | CSS-Tricks</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "为什么我们使用.html代替.htm?"
        }
      ],
      "config": {
        "source": "为什么我们使用.html代替.htm?",
        "staticFileName": "htm.html",
        "author": "guoqzuo",
        "createDate": "2019/12/27",
        "description": "why do we use .html instead of .htm？DOS操作系统上文件后缀限制为3个字符，所以才会使用.htm的后缀，排除系统限制，所有的HTML文件应该使用.html的后缀名",
        "keywords": "为什么我们使用.html代替.htm,why do we use .html instead of .htm,.htm是什么文件类型",
        "category": "计算机基础与开发工具",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"symbol、bigint不能new，而string、number可以new，为什么？\">Symbol、BigInt不能new，而String、Number可以new，为什么？</h1>\n<p>在基本数据类型中，我们发现像 String, Number 是可以通过 new 来创建的，而 Symbol，BigInt 却不能使用 new 创建，这是为什么呢？ BigInt 内部是怎么检测用户使用了new来调用的？下面来看看</p>\n<pre><code class=\"language-js\">BigInt(&#39;1&#39;) // 1n\nnew BigInt(1)\n// Uncaught TypeError: BigInt is not a constructor\n//     at new BigInt (&lt;anonymous&gt;)\n//     at &lt;anonymous&gt;:1:1</code></pre>\n<p>可以看到BigInt并不是构造函数，没有 constructor，就是一个普通的函数。我们来对比下Number。</p>\n<pre><code class=\"language-js\">var a = Number(&#39;1&#39;) // 这个创建了一个 number 类型的数据, 非对象\ntypeof a  // &quot;number&quot;\nvar b = new Number(&#39;1&#39;) // 这个是创建了一个Number对象,是对象\ntypeof b // &quot;object&quot;\nb // Number {1}\nb.valueOf() // 1\nb.__proto__ === a.__proto__ // true</code></pre>\n<p>可以看到其实 Number 不仅可以当构造函数用，也可以直接当普通函数用，内部有处理，而 BigInt 它是不支持 new 调用的。</p>\n<h2 id=\"为什么-bigint、symbol-不能-new\">为什么 BigInt、Symbol 不能 new</h2>\n<p>最近看 JavaScript 高级程序设计第四版，在 Symbol 类型 p45 有介绍，Symbol 不支持 new。<strong>这样做是为了避免创建 Symbol 原始值包装对象</strong> </p>\n<p>在引用类型中，有三种原始值包装类型：String、Number、Boolean。原始值类型 &quot;abc&quot;、123 不是对象，<strong>原始值包装类型</strong> 是用来把原始值包装成对象的引用类型。</p>\n<p>除了 JS 自身内部处理可能会使用外，我们在开发的实际场景中，一般都不会使用。一般使用字面量的形式，不会创建对应的对象。对开发体验来讲是比较鸡肋的功能。新增的 Symbol、BigInt 没有必要向开发者提供创建对应原始值对象的 API。一般也不会使用，多此一举。</p>\n<p>以 Symbol 为例，如果你要创建 Symbol 包装对象，可以使用 Object()，代码如下</p>\n<pre><code class=\"language-js\">let mySymbol = Symbol() \nmySymbol // Symbol()\ntypeof mySymbol // &quot;symbol&quot;\nlet myWrappedSymbol = Object(mySymbol)\nmyWrappedSymbol // Symbol {Symbol()}\ntypeof myWrappedSymbol // &quot;object&quot;</code></pre>\n<h2 id=\"symbol、bigint内部是怎么检测用户使用了new来调用的？\">Symbol、BigInt内部是怎么检测用户使用了new来调用的？</h2>\n<p>对于函数来讲，怎么区分是new调用，还是直接调用? 复习下JS高程3中 <a href=\"https://www.yuque.com/guoqzuo/js_es6/aquxsq#482800ea\">作用域安全的构造函数</a> 的内容，在构造函数中，通过 this instanseof XX 来判断是new 调用的，还是直接调用的构造函数，像BigInt这种，当new调用时，直接就抛出了异常，来用个例子试试</p>\n<pre><code class=\"language-js\">// 模拟实现\nfunction A() {\n  console.log(this)\n  if (this instanceof A) {\n    throw new Error(&#39;Uncaught TypeError: A is not a constructor&#39;)\n  }\n  return &#39;&#39;\n}\n// 测试\nA() // window   &#39;&#39;\nnew A() // A {}  Uncaught TypeError: A is not a constructor</code></pre>\n<p>再复习一下class，class 创建的类型也是function，且只能通过new调用，应该函数内部也是加了类似上面的校验，当this instanceof 不等于当前class时，就直接抛异常</p>\n<p>总结：核心问题是 this 的指向问题，一般直接调用A()时this指向window</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Symbol、BigInt不能new，而String、Number可以new，为什么？",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "为什么 BigInt、Symbol 不能 new"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Symbol、BigInt内部是怎么检测用户使用了new来调用的？"
            }
          ]
        }
      ],
      "config": {
        "source": "Symbol、BigInt不能new，而String、Number可以new，为什么？.md",
        "staticFileName": "new_check.html",
        "author": "guoqzuo",
        "createDate": "2019/12/27",
        "description": "在基本数据类型中，我们发现像String, Number是可以通过 new 来创建的，而 Symbol，BigInt 却不能使用new创建，这是为什么呢？ BigInt内部是怎么检测用户使用了new来调用的？下面来看看",
        "keywords": "Symbol、BigInt不能new，而Stirng、Number可以new，为什么,BigInt内部是怎么检测用户使用了new来调用的",
        "category": "JavaScript",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"怎么清除app内嵌h5的localstorage\">怎么清除app内嵌H5的localStorage</h1>\n<p>当你在app内容H5中使用了localStorage又担心可能会超出5M的限制时，就要注意localStorage的清除了。那怎么才能清除app内嵌H5的localStorage呢？我做了一些测试</p>\n<p>测试手机: iPhone8, 红米6，内嵌H5使用localStorage存储了一些数据，尝试清除</p>\n<ul>\n<li>完全退出app 安卓、iOS都无法清除</li>\n<li>退出登录 安卓、iOS都无法清除</li>\n<li>使用app内置缓存清理功能 安卓、iOS都无法清除</li>\n<li>使用系统的清除app数据方法：安卓清除app所有数据可以，iOS不可以(长按关机键，出现滑动关机，长按home键，直至滑动关机关闭)</li>\n<li>使用H5内置的 localStorage.clear() 都可以清除，注意域名</li>\n<li>删除app肯定可以清除</li>\n</ul>\n<p>总结，<strong>在不删除app以及使用H5内置的清除函数的情况下，安卓可以使用系统的清除app所有数据来清除，但iOS暂未发现清除的方法。</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "怎么清除app内嵌H5的localStorage"
        }
      ],
      "config": {
        "source": "怎么清除app内嵌H5的localStorage.md",
        "staticFileName": "clear_app_h5.html",
        "author": "guoqzuo",
        "createDate": "2019/12/27",
        "description": "当你在app内容H5中使用了localStorage又担心可能会超出5M的限制时，就要注意localStorage的清除了。那怎么才能清除app内嵌H5的localStorage呢？我做了一些测试",
        "keywords": "怎么清除app内嵌H5的localStorage",
        "category": "JavaScript",
        "year": "2019",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"站点优化-页面打开较慢处理\">站点优化 页面打开较慢处理</h1>\n<blockquote>\n<p>最近发现打开速度太慢，由于后台是java写的，好久没碰了，基本忘干净了。就一直拖着没处理，现在有时间了，还是硬着头皮优化了下，打开速度提升了很多。</p>\n</blockquote>\n<p><img src=\"../../../images/blog/web/web_optimize_3_1.png\" alt=\"web_optimize_3_1.png\"></p>\n<h2 id=\"背景\">背景</h2>\n<p>博客的代码是2017年初完成的，后面基本没怎么维护了。两年多了，当时的技术栈还是java + jQuery，现在早已放弃了java，主要还是往前端方向发展。后台相关只研究node。这次发现网页太慢了，新的博客版本还没规划好，暂时先优化下这个博客。</p>\n<h2 id=\"代码托管\">代码托管</h2>\n<p>之前的代码都是现在Eclipse里完成，然后导出，再通过ftp传到服务器。再手动更新。版本控制都没用到，这次在本地git init，初始化了一个git仓库。然后在gitlab创建了一个私有库，和本地的仓库关联，把代码放到gitlab就好多了。至少不用怕代码丢失了。</p>\n<h2 id=\"速度慢的原因分析\">速度慢的原因分析</h2>\n<p>准备把代码跑起来看看原因，发现代码跑不起来，提示本地myblog数据库不存在。由于mac重装了mysql，之前是5.6的版本，现在升级为8.0了。之前的数据库貌似丢了。从服务器dump了一份数据，本地创建了myblog数据库，然后通过source导入数据（大概33M，主要是tb_access的数据，记录了蜘蛛抓取及正常访客的所有ua、ip的信息）。数据导入后就可以正常访问了。发现本地都很慢，那就不是服务器配置的问题了。跟代码有关。</p>\n<p><img src=\"../../../images/blog/web/web_optimize_3_2.png\" alt=\"web_optimize_3_2.png\"></p>\n<h3 id=\"代码分析\">代码分析</h3>\n<p>先找到主页的入口页面。index.woe，发现有几个问题</p>\n<ul>\n<li>代码写的很乱，命名不规范</li>\n<li>频繁查询数据库，影响速度</li>\n</ul>\n<h3 id=\"index页面代码问题1\">index页面代码问题1</h3>\n<p>之前不知道怎么想的，把systemInfo也就是网页的title、keywords，description都放到数据库，每次都从数据库读取，每次都会都一次数据库查询，现在改为写死。因为这种基本不怎么更新。分类信息比较少，每次从数据库找也耗时，就写死了。提高速度。</p>\n<pre><code class=\"language-java\">// 1.获取systemInfo信息，之前从数据库获取现在改为写死\nSystemDao sysDao = new SystemDao();\nrequest.setAttribute(&quot;sys_info&quot;, sysDao.findFirstMock());\n// request.setAttribute(&quot;sys_info&quot;, sysDao.findFirst());\n\n// 2.获取分类信息, 之前从数据库获取，现在改为写死\nCategoryDao categoryDao = new CategoryDao();\nrequest.setAttribute(&quot;categorys&quot;, categoryDao.findAllMock());\n// request.setAttribute(&quot;categorys&quot;, categoryDao.findAll());</code></pre>\n<h3 id=\"index页面代码问题2\">index页面代码问题2</h3>\n<p>获取笔记信息之前是分4条sql去取 。现改为用一条sql取，然后根据类型自动分配到4个变量。（由于前端代码不想改动，尽量按原来的数据格式输出），另外发现再将数据库查询的Map数据转为List&lt;Node&gt;时，居然每次都去数据表用分类id来换分类名称，，太恐怖了。不知道之前为啥会这么写，也修改为本地获取。</p>\n<pre><code class=\"language-java\">// 3.获取笔记信息\nNoteDao noteDao = new NoteDao();\nMap&lt;String, Object&gt; noteall = noteDao.findAllNew();\nrequest.setAttribute(&quot;notes_c&quot;, noteall.get(&quot;notes_c&quot;));\nrequest.setAttribute(&quot;notes_web&quot;, noteall.get(&quot;notes_web&quot;));\nrequest.setAttribute(&quot;notes_apue&quot;, noteall.get(&quot;notes_apue&quot;));\nrequest.setAttribute(&quot;notes_ios&quot;, noteall.get(&quot;notes_ios&quot;));\n//        List&lt;Note&gt; notes_c = is3.findC();\n//        request.setAttribute(&quot;notes_c&quot;, notes_c);\n//        List&lt;Note&gt; notes_web = is3.findWeb();\n//        request.setAttribute(&quot;notes_web&quot;, notes_web);\n//        List&lt;Note&gt; notes_apue = is3.findAPUE();\n//        request.setAttribute(&quot;notes_apue&quot;, notes_apue);\n//        List&lt;Note&gt; notes_ios = is3.findIOS();\n//        request.setAttribute(&quot;notes_ios&quot;, notes_ios);\n\n//        if(request.getParameter(&quot;action&quot;) != null) {\n//            request.getRequestDispatcher(&quot;m_index.jsp&quot;).forward(request, response);\n//        } else {\n//            request.getRequestDispatcher(&quot;index.jsp&quot;).forward(request, response);\n//        }</code></pre>\n<p>修改后的部分NoteDao代码</p>\n<pre><code class=\"language-java\">    Map&lt;String, String&gt; cate = new HashMap&lt;String, String&gt;();\n    cate.put(&quot;32&quot;,&quot;C语言&amp;&amp;C&quot;);\n    cate.put(&quot;33&quot;,&quot;UNIX高级编程&amp;&amp;APUE&quot;);\n    cate.put(&quot;34&quot;,&quot;Web&amp;&amp;Web&quot;);\n    cate.put(&quot;36&quot;,&quot;iOS&amp;&amp;iOS&quot;);\n    ...\n\n    note.setCategory(cate.get(map.get(&quot;category_id&quot;)+&quot;&quot;));\n    note.setRelay_count(Integer.parseInt(map.get(&quot;relay_count&quot;)+&quot;&quot;));\n    note.setStatus(Integer.parseInt(map.get(&quot;status&quot;)+&quot;&quot;));\n\n    switch(map.get(&quot;category_id&quot;)+&quot;&quot;) {\n        case &quot;32&quot;:\n            notes_c.add(note);\n            break;\n        case &quot;33&quot;:\n            notes_apue.add(note);\n            break;\n        case &quot;34&quot;: \n            notes_web.add(note);\n            break;\n        case &quot;36&quot;:\n            notes_ios.add(note);\n            break;\n    }\n}\nMap&lt;String, Object&gt; allNote = new HashMap&lt;String, Object&gt;();\nallNote.put(&quot;notes_c&quot;, notes_c);\nallNote.put(&quot;notes_apue&quot;, notes_apue);\nallNote.put(&quot;notes_web&quot;, notes_web);\nallNote.put(&quot;notes_ios&quot;, notes_ios);</code></pre>\n<h3 id=\"index页面代码问题3\">index页面代码问题3</h3>\n<p>访问量这里也是查了4次数据，由于过滤了部分有蜘蛛特征的数据，且数据已经18W了，每次查询都挺耗时的，而且还是分几次查询，本地查询都要1s多.....暂时没想到好的办法，访问数据直接按之前的访问量写死了。待后续优化表结构，来处理这个问题。</p>\n<pre><code class=\"language-sh\">select count(*) from tb_access where (browser not like &#39;%bot%&#39;) and ((browser not like &#39;%spider%&#39;)) and (browser not like &#39;%sitemap%&#39;) and (browser not like &#39;%Alibaba%&#39;) and (browser not like &#39;%Client%&#39;) and (browser not like &#39;Python-urllib&#39;);</code></pre>\n<p><img src=\"../../../images/blog/web/web_optimize_3_3.png\" alt=\"web_optimize_3_3.png\"></p>\n<h3 id=\"总访问量\">总访问量</h3>\n<pre><code class=\"language-java\">//        int access_total = accessDao.findCountAll();\n//        int access_pc = accessDao.findCountWithPC();\n//        int access_mobile = accessDao.findCountWithMobile();\n//        int notes_reply = is3.findRelayCountAll();\n//        request.setAttribute(&quot;access_total&quot;, access_total);\n//        request.setAttribute(&quot;access_pc&quot;, access_pc);\n//        request.setAttribute(&quot;access_mobile&quot;, access_mobile);\n//        request.setAttribute(&quot;notes_reply&quot;, notes_reply);\n    request.setAttribute(&quot;access_total&quot;, 110434);\n    request.setAttribute(&quot;access_pc&quot;, 101159);\n    request.setAttribute(&quot;access_mobile&quot;, 9275);\n    request.setAttribute(&quot;notes_reply&quot;, 5);\n    //System.out.println(access_pc);\n\n    String url = &quot;index.jsp&quot;;\n    if (user.getIsPc() == 0) { // 判断是否为移动端\n        url = &quot;m_index.jsp&quot;;\n    }\n    request.getRequestDispatcher(url).forward(request, response);    \n}</code></pre>\n<h3 id=\"其他页面的问题\">其他页面的问题</h3>\n<p>和index页面类似，改改就好了。</p>\n<h2 id=\"评论的广告问题\">评论的广告问题</h2>\n<p>畅言评论系统居然弹广告了，貌似充钱才能去。果断把评论的代码弄掉了。怀恋 “多说” 的那个时候。后面自己有时间一定要写一个评论系统。</p>\n<h2 id=\"修改完成后，准备发布\">修改完成后，准备发布</h2>\n<p><img src=\"../../../images/blog/web/web_optimize_3_4.png\" alt=\"web_optimize_3_4.png\"></p>\n<p>把相关改动提交到git，然而发布时还是选择了手动更改文件后发布，主要是ueditor编辑器存的图片目录就在工程文件夹内部，不好处理。发布后发现无法运行，看tomcat的log发现，jre的路径找不到，jre自动更新了。导致路径有问题。直接重装了jre。后面发现还有问题。原来copy到服务器的更改文件是绿色的，带加密的，需要修改为不加密。重装jre重启系统后，发现连不上数据库，原来是mysql80服务自动关了，可能和重启有关系。后面手动开启了。</p>\n<h2 id=\"速度测试\">速度测试</h2>\n<p>感觉比之前快多了，用了百度统计的速度测试，还可以，后面还有优化的空间，还是想做成纯静态的，不用JSP服务端渲染。那样就可以秒开了，待写一个类似hexo的静态博客生成系统。</p>\n<p><img src=\"../../../images/blog/web/web_optimize_3_5.png\" alt=\"web_optimize_3_5.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "站点优化 页面打开较慢处理",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "背景"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "代码托管"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "速度慢的原因分析",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "代码分析"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "index页面代码问题1"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "index页面代码问题2"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "index页面代码问题3"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "总访问量"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "其他页面的问题"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "评论的广告问题"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "修改完成后，准备发布"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "速度测试"
            }
          ]
        }
      ],
      "config": {
        "source": "站点优化 页面打开较慢处理.md",
        "staticFileName": "web_optimize_3.html",
        "author": "guoqzuo",
        "createDate": "2019/08/31",
        "description": "最近发现打开速度太慢，由于后台是java写的，好久没碰了，基本忘干净了。就一直拖着没处理，现在有时间了，还是硬着头皮优化了下，打开速度提升了很多。",
        "keywords": "站点优化,页面打开较慢优化",
        "category": "网站建设与SEO",
        "year": "2019",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"vscode中npm-run-dev提示端口被占用的问题\">vscode中npm run dev提示端口被占用的问题</h1>\n<p>vscode 提示端口被占用，vscode编辑器中npm run dev退出后依旧占用端口，vscode的console，有时候可能没关闭就开了新的terminal。</p>\n<h2 id=\"排查问题\">排查问题</h2>\n<ol>\n<li>在vscode编辑器的右下方，看是否开启了多个终端(bash)，可能原来的npm run dev还没有关闭</li>\n</ol>\n<p><img src=\"../../../images/blog/devtools/vscode_bash_1.png\" alt=\"vscode_bash_1.png\"></p>\n<p><img src=\"../../../images/blog/devtools/vscode_bash_2.png\" alt=\"vscode_bash_2.png\"></p>\n<ol start=\"2\">\n<li>把vscode整体退出，再打开看是否OK。</li>\n</ol>\n<p>以后可以不依赖vscode的终端，使用系统自带的terminal</p>\n<h2 id=\"mac-查看端口占用情况\">mac 查看端口占用情况</h2>\n<p>对于端口占用的情况，可以使用系统的命令查看占用端口的进程，然后将该进程关闭，mac下可以使用如下命令来查看端口占用情况：</p>\n<pre><code class=\"language-bash\">lsof -i :7000 # 查看7000端口是否被占用\nsudo kill -9 716 # 如果进程 ID为 716 占用了该端口，关闭该进程。\n# -9后面加一个空格，然后加上占用端口的进程PID，就可以杀掉占用端口的进程。最后重启terminal就ok。</code></pre>\n<p>参考: <a href=\"https://www.jianshu.com/p/9216b6127a82\">Mac 查看端口占用情况及杀死进程</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vscode中npm run dev提示端口被占用的问题",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "排查问题"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "mac 查看端口占用情况"
            }
          ]
        }
      ],
      "config": {
        "source": "vscode中npm run dev提示端口被占用的问题.md",
        "staticFileName": "devtools_vscode_bash.html",
        "author": "guoqzuo",
        "createDate": "2019/09/30",
        "description": "vscode 提示端口被占用，vscode中npm run dev时提示端口被占用的问题, mac查看端口占用情况。vscode编辑器中npm run dev退出后依旧占用端口，vscode的console，有时候可能没关闭就开了新的terminal。",
        "keywords": "vscode中npm run dev时提示端口被占用,mac查看端口占用情况",
        "category": "计算机基础与开发工具",
        "year": "2019",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"element表格ie下由于滚动条原因导致错位问题\">Element表格IE下由于滚动条原因导致错位问题</h1>\n<p>Element 表头固定，表内容可滑动，在IE下滚动条会显示，有一定的宽度占位，导致表头与表内容由点错位，解决方法是：由于表单内容是从接口加载的，从接口加载完数据后，对el-talbe进行从新布局dolayout</p>\n<pre><code class=\"language-js\">// Table Methods: doLayout\n// 对 Table 进行重新布局。当 Table 或其祖先元素由隐藏切换为显示时，可能需要调用此方法\n// &lt;el-table ref=&quot;table&quot;&gt;&lt;/el-table&gt;\n\n// 从接口获取数据成功后\nthis.$nextTick(() =&gt; {\n  this.$refs[&#39;table&#39;].doLayout()\n})</code></pre>\n<p>参考：<a href=\"https://element.eleme.cn/#/zh-CN/component/table\">Table 表格组件 | Element</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Element表格IE下由于滚动条原因导致错位问题"
        }
      ],
      "config": {
        "source": "Element表格IE下由于滚动条原因导致错位问题.md",
        "staticFileName": "element_dolayout.html",
        "author": "guoqzuo",
        "createDate": "2020/01/07",
        "description": "Element 表头固定，表内容可滑动，在IE下滚动条会显示，有一定的宽度占位，导致表头与表内容由点错位，解决方法是：由于表单内容是从接口加载的，从接口加载完数据后，对el-talbe进行从新布局dolayout",
        "keywords": "Element表格IE下由于滚动条原因导致错位问题",
        "category": "Vue",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"ie下dialog弹窗的滚动条滚动到底部时，触发了浏览器滚动条\">IE下dialog弹窗的滚动条滚动到底部时，触发了浏览器滚动条</h1>\n<p>Element dialog弹窗的滚动条滚动到底部时，触发了浏览器滚动条同样都是有遮罩层，chrome都是OK的，但IE下会有问题。经过定位后发现，对于dialog使用了append-to-body属性的，都没问题。发现dialog显示时body上添加了一个 el-popup-parent--hidden的class, 设置了overflow为hidden，关了滚动条。对于没有append-to-body属性的dialog如果想修复有两种办法：</p>\n<ol>\n<li>添加append-to-body，将dialog插入到body上</li>\n<li>不插入到body，根据el-popup-parent--hidden将有滚动条的子div设置overflow:hidden。</li>\n</ol>\n<p>对于不是dialog，普通的弹窗，可以使用另一种思路：</p>\n<p>监听鼠标滚动事件，使用Node.contains函数，判断鼠标是否在dialog范围内滚动，如果是，且到了底部，禁止其默认行为\nappend-to-body属性： Dialog 自身是否插入至 body 元素上。嵌套的 Dialog 必须指定该属性并赋值为 true</p>\n<p>参考：<a href=\"https://element.eleme.cn/#/zh-CN/component/dialog\">element dialog</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "IE下dialog弹窗的滚动条滚动到底部时，触发了浏览器滚动条"
        }
      ],
      "config": {
        "source": "IE下dialog弹窗的滚动条滚动到底部时，触发了浏览器滚动条.md",
        "staticFileName": "ie_dialog_scroll.html",
        "author": "guoqzuo",
        "createDate": "2020/01/07",
        "description": "Element dialog弹窗的滚动条滚动到底部时，触发了浏览器滚动条同样都是有遮罩层，chrome都是OK的，但IE下会有问题。经过定位后发现，对于dialog使用了append-to-body属性的，都没问题。发现dialog显示时body上添加了一个 el-popup-parent--hidden的class, 设置了overflow为hidden，关了滚动条。对于没有append-to-body属性的dialog如果想修复有两种办法",
        "keywords": "IE下dialog弹窗的滚动条滚动到底部时，触发了浏览器滚动条",
        "category": "Vue",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"怎么判断当前鼠标是否在某个div内部\">怎么判断当前鼠标是否在某个div内部</h1>\n<p>当监听到事件，事件的 eveent.target 怎么判断是否在某个div内部呢？可以使用DOM专有扩展的contains方法</p>\n<pre><code class=\"language-js\">let eventType = document.mozHidden ? &#39;DOMMouseScroll&#39; : &#39;mousewheel&#39;\nlet ele = &#39;某个dom&#39;\nele.addEventListener(eventType, (e) =&gt; {\n  if (&#39;容器范围内dom&#39;.contains(e.target)) {\n    // 当前鼠标在容器内\n  }\n})</code></pre>\n<p>参考：<a href=\"https://www.yuque.com/guoqzuo/js_es6/qgh717#2a813746\">DOM专有扩展 contains方法 | JS高程3笔记</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "怎么判断当前鼠标是否在某个div内部"
        }
      ],
      "config": {
        "source": "怎么判断当前鼠标是否在某个div内部.md",
        "staticFileName": "contains.html",
        "author": "guoqzuo",
        "createDate": "2020/01/07",
        "description": "当监听到事件，事件的 eveent.target 怎么判断是否在某个div内部呢？可以使用DOM专有扩展的contains方法",
        "keywords": "怎么判断当前鼠标是否在某个div内部,怎么判断当前event.target在某个div内部",
        "category": "JavaScript",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"当if-else逻辑较多时可以使用策略模式\">当if else逻辑较多时可以使用策略模式</h1>\n<p>当项目中，if else较多时，我们可以考虑使用策略模式，来更优雅的处理，来看看demo</p>\n<pre><code class=\"language-js\">// if else \nif () {\n  a\n} else if () {\n  b\n} else if () {\n  c\n}\n\n// 更优雅的写法，策略模式\n// 更多策略模式，策略模式表单验证可参考：JS设计模式与开发实战 第五章p82\nlet rules = [\n  &#39;a&#39;: () =&gt; { a },\n  &#39;b&#39;: () =&gt; { b },\n  &#39;c&#39;: () =&gt; { c },\n]\nrules[name]()</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "当if else逻辑较多时可以使用策略模式"
        }
      ],
      "config": {
        "source": "当if else逻辑较多时可以使用策略模式.md",
        "staticFileName": "if_else_handle.html",
        "author": "guoqzuo",
        "createDate": "2020/01/08",
        "description": "当项目中，if else较多时，我们可以考虑使用策略模式，来更优雅的处理，来看看demo",
        "keywords": "js策略模式的使用场景",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"ie下dialog弹窗全屏后列表横向滚动卡顿的问题\">IE下dialog弹窗全屏后列表横向滚动卡顿的问题</h1>\n<p>全屏后添加了一个名为 <code>is-fullscreen</code> 的class，发现把对应的overflow:auto去掉后，就不会卡顿。去掉其实就是将overflow设置为默认值visible，如果子组件高度超出范围，将is-fullscreen设置的height 100% 改为 auto。另一种方法是将table的z-index改为3000(相对dialog比较高的一个层级)，这样IE下就不会卡顿了。</p>\n<p>overflow相关值描述</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>visible</td>\n<td>默认值。内容不会被修剪，会呈现在元素框之外。</td>\n</tr>\n<tr>\n<td>hidden</td>\n<td>内容会被修剪，并且其余内容是不可见的。</td>\n</tr>\n<tr>\n<td>scroll</td>\n<td>内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</td>\n</tr>\n<tr>\n<td>auto</td>\n<td>如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>规定应该从父元素继承 overflow 属性的值。</td>\n</tr>\n</tbody></table>\n<p>参考：<a href=\"https://www.w3school.com.cn/cssref/pr_pos_overflow.asp\">CSS overflow 属性</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "IE下dialog弹窗全屏后列表横向滚动卡顿的问题"
        }
      ],
      "config": {
        "source": "IE下dialog弹窗全屏后列表横向滚动卡顿的问题.md",
        "staticFileName": "ie_scorll_slow.html",
        "author": "guoqzuo",
        "createDate": "2020/01/08",
        "description": "全屏后添加了一个名为 is-fullscreen 的class，发现把对应的overflow:auto去掉后，就不会卡顿。去掉其实就是将overflow设置为默认值visible，如果子组件高度超出范围，将is-fullscreen设置的height 100% 改为 auto。另一种方法是将table的z-index改为3000(相对dialog比较高的一个层级)，这样IE下就不会卡顿了。",
        "keywords": "Element表格IE下由于滚动条原因导致错位问题",
        "category": "Vue",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"js遍历数组方法总结，foreach的缺点以及与forof和forin的区别\">JS遍历数组方法总结，forEach的缺点以及与for..of和for...in的区别</h1>\n<p>在ES5中新增了很多方便操作数组的方法，包括新5种数组的迭代方法：forEach, map, filter, some, every；缩小方法：reduce()；检测数组方法Array.isArray()等，这些方法让操作数组更加优雅，趋近于函数式编程. 在ES6中又增加了for..of以及values,entres,keys等，下面来详细看看</p>\n<h2 id=\"es5-array5种迭代方法\">ES5 Array5种迭代方法</h2>\n<p>ES5定义了5个迭代方法，每个方法都接收两个参数，运行函数及作用域对象(this)，IE9+支持</p>\n<ul>\n<li>检测数组里的元素是否满足条件。every()、some() 返回Boolean值<ul>\n<li>every() 对数组的每一项运行给定函数，函数对每一项都返回true，则返回true</li>\n<li>some() 对数组的每一项运行给定函数, 如果函数对数组的任一项返回的true，return true</li>\n</ul>\n</li>\n<li>只做遍历，不返回任何值<ul>\n<li>forEach()  对数组的每一项运行给定函数, 不返回任何值，只做函数操作 类似于 for () { do something }</li>\n</ul>\n</li>\n<li>返回数组<ul>\n<li>filter()  对数组的每一项运行给定函数, 返回该函数会返回true的项组成的数组</li>\n<li>map()  对数组的每一项运行给定函数, 返回每次函数调用结果组成的数组</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">var numbers = [1,2,3,4,5];\n\nvar isGreaterThan2 = function (item, index, array) {\n    return (item &gt; 2)\n};\n\nvar everyResult = numbers.every(isGreaterThan2);\nvar someResult = numbers.some(isGreaterThan2);\nvar filterResult = numbers.filter(isGreaterThan2);\n\nalert(everyResult); // false   是否所有值都大于2\nalert(someResult); // true 是否有一个值大于2\nalert(filterResult); // [3,4,5]  返回所有大于2的项\n\nvar mapResult = numbers.map(function (item, index, array) {\n    return (item * 2);\n});\nalert(mapResult); // [2,3,6,8,10] 返回每个元素执行完*2后的数组\n\nnumbers.foreach(function(item, index, array) {\n  cosnole.log(item)  // 依次打印数组的值\n})</code></pre>\n<h2 id=\"es5-arrayprototypereduce\">ES5 Array.prototype.reduce()</h2>\n<p>ES5新增了两个缩小数组的方法reduce()和reduceRight(), 会迭代数组的所有项，然后构建一个最终返回的值。reduce从数组的第一项开始，逐个遍历到最后。reduceRight则从数组的最后一项开始，向前遍历到第一项。</p>\n<ul>\n<li>该方法接收两个参数：一个在每一项上调用的函数，和（可选的）作为归并基础的初始值。</li>\n<li>第一个参数的函数，接收4个参数：前一个值；当前值；项的索引；数组对象；这个函数返回的任何值，都会作为第一个参数传个下一项。第一次迭代发生在数组的第二项上，第一个参数是第一项，第二个参数为数组的第二项。</li>\n</ul>\n<pre><code class=\"language-js\">// 一参的情况\nvar values = [1,2,3,4,5];\nvar sum = values.reduce(function(prev, cur, index, array) {\n    return prev + cur;\n});\nalert(sum); // 15\n\n// 二参的情况，reduce二参为初识值，然后函数第一个参数为初识值，第二个参数为数组第一个元素，再依次遍历\nvar numbers = [15.5, 2.3, 1.1, 4.7];\n// 四舍五入相加\nnumbers.reduce(function(total, num) {\n  return total + Math.round(num);\n}, 0)\n\n// 计算数组中每个元素出现的次数\n// MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\nvar names = [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Tiff&#39;, &#39;Bruce&#39;, &#39;Alice&#39;];\n\nvar countedNames = names.reduce(function (allNames, name) { \n  if (name in allNames) {\n    allNames[name]++;\n  }\n  else {\n    allNames[name] = 1;\n  }\n  return allNames;\n}, {});\n// countedNames is:\n// { &#39;Alice&#39;: 2, &#39;Bob&#39;: 1, &#39;Tiff&#39;: 1, &#39;Bruce&#39;: 1 }</code></pre>\n<h2 id=\"es5-arrayisarray-检测是否为数组\">ES5 Array.isArray() 检测是否为数组</h2>\n<p>在JS高程3中有讲过安全的类型检测，Object.prototype.toString.call(要检测类型的变量)，如果等于 &quot;[object Array]&quot;就是函数类型，ES5对这个方法进行了封装，我们直接使用Array.isArray(要检测类型的变量)即可</p>\n<pre><code class=\"language-js\">// 判断是否为数组，在进行后续操作\nif (value instanceof Array) {\n    // 对数组执行某些操作\n}\n// ES5之后可以用 Array.isArray(value) 来替代，解决多个框架不同版本的Array构造函数问题\n// 当检测Array实例时, Array.isArray 优于 instanceof,因为Array.isArray能检测iframes.</code></pre>\n<p>在mdn的官方文档里 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\">Array.isArray() Polyfill | MDN</a> 有描述, 假如不存在 Array.isArray()，则在其他代码之前运行下面的代码将创建该方法。</p>\n<pre><code class=\"language-js\">if (!Array.isArray) {\n  Array.isArray = function(arg) {\n    return Object.prototype.toString.call(arg) === &#39;[object Array]&#39;;\n  };\n}</code></pre>\n<h2 id=\"foreach的缺点\">forEach的缺点</h2>\n<p>现在一般再项目中，我经常使用forEach方法，形成了习惯，后来发现当只需要遍历部分元素，达到具体条件后就退出的情况时，这才发现forEach貌似是无法continue或break的，这是它的一个缺陷。这时我们可以使用some或直接使用原始的for循环来代替</p>\n<h3 id=\"实例场景\">实例场景</h3>\n<pre><code class=\"language-js\">// 真实场景: 匹配路由数组里的路径，匹配到就结束遍历，发现无法结束遍历\n// 遍历路由进行匹配，如果匹配到了则执行，停止往下执行下一个中间件，否则向下执行\nstock.forEach((item) =&gt; {\n  if (ctx.url === item.path &amp;&amp; item.methods.includes(ctx.method)) {\n    return\n  }\n  await next()\n})</code></pre>\n<h3 id=\"使用some测试\">使用some测试</h3>\n<pre><code class=\"language-js\">var arr = [1,2,3,4,5] // 为了好在termial执行，改为var\nvar result = arr.some(item =&gt; {\n    console.log(&#39;遍历数组&#39;, item)\n    return item === 2\n}) \nconsole.log(&#39;result&#39;, result)\n// 遍历数组 1\n// 遍历数组 2\n// result true</code></pre>\n<p>some测试结果，可以阻断遍历执行，适用于遇到单一条件就直接结束遍历的情况</p>\n<h3 id=\"使用最原始的for\">使用最原始的for</h3>\n<pre><code class=\"language-js\">var arr = [1,2,3,4,5] \n// for里面的第二个语句每次循环结束后都会去执行比较\n// ;i &lt; arr.length; 每次都计算arr.length，这个值每次会减一，如果把len在一个参数里计算好\n// 复杂度会从O(n) =&gt; O(1)\n// 参考：JS高程3 第24章 最佳实践 - 性能 - 选择正确的方法 - 优化循环\nfor (let i = 0, len = arr.length; i &lt; len; i++) {\n    let item = arr[i]\n    if (item === 2) continue\n    if (item === 4) break\n    console.log(&#39;遍历数组&#39;, item)\n}\n// 遍历数组 1\n// 遍历数组 3</code></pre>\n<p>使用原始的for循环，控制更加精准</p>\n<h3 id=\"使用throw异常的方式结合try-catch终端foreach\">使用throw异常的方式结合try catch终端forEach</h3>\n<pre><code class=\"language-js\">// 参考：https://www.cnblogs.com/Marydon20170307/p/8920775.html\ntry {\n  var array = [&quot;first&quot;,&quot;second&quot;,&quot;third&quot;,&quot;fourth&quot;];\n\n  // 执行到第3次，结束循环\n  array.forEach(function(item,index){\n      if (item == &quot;third&quot;) {\n          throw new Error(&quot;EndIterative&quot;);\n      }\n      alert(item);// first,sencond\n  });\n} catch(e) {\n    if(e.message!=&quot;EndIterative&quot;) throw e;\n};</code></pre>\n<h2 id=\"es6新增的数组迭代方法forofentries，keys和values\">ES6新增的数组迭代方法for...of,entries()，keys()和values()</h2>\n<p>可以用for...of循环进行遍历，它们都返回一个遍历器对象（具体细节参见《ES6入门 Iterator》一章）。<strong>唯一的区别是keys()是对键名(数组下标)的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</strong></p>\n<pre><code class=\"language-js\">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {  \n  console.log(index);}\n// 0\n// 1\nfor (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {\n  console.log(elem);}\n// &#39;a&#39;\n// &#39;b&#39;\nfor (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {\n  console.log(index, elem);}\n// 0 &quot;a&quot;\n// 1 &quot;b&quot;</code></pre>\n<p>相比forEach，for...of是可以使用break，continue中断的，而不需要像最普通的for那样写index，比较长度，自增1等</p>\n<pre><code class=\"language-js\">for (let item of [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) {console.log(item)}\n// a\n// b\n// c</code></pre>\n<h2 id=\"forin遍历数组\">for...in遍历数组</h2>\n<p>for...in一般是用来遍历对象的，他也可以遍历数组</p>\n<pre><code class=\"language-js\">for (let item in [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) {console.log(item)}\n// 0, 1, 2 和for...of的区别是他遍历的是数组下标</code></pre>\n<h2 id=\"遍历数组时对空格的处理\">遍历数组时对空格的处理</h2>\n<pre><code class=\"language-js\">// ES5 对空位的处理\n// forEach(), filter(), reduce(), every() 和some()都会跳过空位\n// map()会跳过空位，但会保留这个值\n// join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串\n\n// forEach方法\n[,&#39;a&#39;].forEach((x,i) =&gt; console.log(i)); // 1\n// filter方法\n[&#39;a&#39;,,&#39;b&#39;].filter(x =&gt; true) // [&#39;a&#39;,&#39;b&#39;]\n// every方法\n[,&#39;a&#39;].every(x =&gt; x===&#39;a&#39;) // true\n// reduce方法\n[1,,2].reduce((x,y) =&gt; x+y) // 3\n// some方法\n[,&#39;a&#39;].some(x =&gt; x !== &#39;a&#39;) // false\n// map方法\n[,&#39;a&#39;].map(x =&gt; 1) // [,1]\n// join方法\n[,&#39;a&#39;,undefined,null].join(&#39;#&#39;) // &quot;#a##&quot;\n// toString方法\n[,&#39;a&#39;,undefined,null].toString() // &quot;,a,,&quot;\n\n// ES6 则是明确将空位转为undefined。\n// entries()\n[...[,&#39;a&#39;].entries()] // [[0,undefined], [1,&quot;a&quot;]]\n// keys()\n[...[,&#39;a&#39;].keys()] // [0,1]\n// values()\n[...[,&#39;a&#39;].values()] // [undefined,&quot;a&quot;]\n// find()\n[,&#39;a&#39;].find(x =&gt; true) // undefined\n// findIndex()\n[,&#39;a&#39;].findIndex(x =&gt; true) // 0</code></pre>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://www.yuque.com/guoqzuo/js_es6/ep07nf#b5608f9d\">ES5 5种Array迭代方法 | JS高程3笔记</a></li>\n<li><a href=\"https://www.yuque.com/guoqzuo/js_es6/xr0m8g#3dc09eb1\">ES6数组的扩展 | ES6入门笔记</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript\">ES2015(ES6)及之前的JS版本更新概要 | MDN</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JS遍历数组方法总结，forEach的缺点以及与for..of和for...in的区别",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "ES5 Array5种迭代方法"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "ES5 Array.prototype.reduce()"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "ES5 Array.isArray() 检测是否为数组"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "forEach的缺点",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "实例场景"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "使用some测试"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "使用最原始的for"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "使用throw异常的方式结合try catch终端forEach"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "ES6新增的数组迭代方法for...of,entries()，keys()和values()"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "for...in遍历数组"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "遍历数组时对空格的处理"
            }
          ]
        }
      ],
      "config": {
        "source": "JS遍历数组方法总结，forEach的缺点以及与for..of和for...in的区别.md",
        "staticFileName": "js_array.html",
        "author": "guoqzuo",
        "createDate": "2020/01/09",
        "description": "在ES5中新增了很多方便操作数组的方法，包括新5种数组的迭代方法：forEach, map, filter, some, every；缩小方法：reduce()；检测数组方法Array.isArray()等，这些方法让操作数组更加优雅，趋近于函数式编程. 在ES6中又增加了for..of以及values,entres,keys等，下面来详细看看",
        "keywords": "js遍历数组方法总结,es5 es6遍历数组方法,forEach的缺点以及与for..of和for...in的区别",
        "category": "JavaScript",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"包含await操作的函数被二次封装成函数，await该函数时执行顺序的问题\">包含await操作的函数被二次封装成函数，await该函数时执行顺序的问题</h1>\n<p>包含await操作的函数被二次封装成函数，await该函数时执行顺序需要注意，当一个包含await的函数A，被另一个函数B包裹，当await函数B执行时，如果包裹函数B里并没有return函数A或await函数A，await函数B执行时并不会等到函数A全部执行完毕才继续执行，来看个例子</p>\n<pre><code class=\"language-js\">(async () =&gt; {\n  await test() // await fn()\n  console.log(&#39;异步执行完成&#39;)\n})()\n\nasync function test() {\n  fn() // return fn() 或 await fn()\n}\n\nasync function fn(next) {\n  console.log(&#39;start fn&#39;)\n  await delay()\n  console.log(&#39;end fn&#39;)\n}\n\nfunction delay() {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      resolve()\n    }, 2000)\n  })\n}\n\n// return fn()  或 await fn() 结果\n// start fn\n// end fn\n// 异步执行完成\n\n// fn() 结果\n// start fn\n// 异步执行完成\n// end fn</code></pre>\n<p>参考：<a href=\"https://blog.csdn.net/guzhao593/article/details/84191401\">async/await函数的执行顺序的理解 - csdn</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "包含await操作的函数被二次封装成函数，await该函数时执行顺序的问题"
        }
      ],
      "config": {
        "source": "包含await操作的函数被二次封装成函数，await该函数时执行顺序的问题.md",
        "staticFileName": "js_await_seq.html",
        "author": "guoqzuo",
        "createDate": "2020/01/09",
        "description": "包含await操作的函数被二次封装成函数，await该函数时执行顺序需要注意，当一个包含await的函数A，被另一个函数B包裹，当await函数B执行时，如果包裹函数B里并没有return函数A或await函数A，await函数B执行时并不会等到函数A全部执行完毕才继续执行，来看个例子",
        "keywords": "async await执行顺序的额问题，如果await的非promise不会等待",
        "category": "JavaScript",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"node-pathresolve\">node path.resolve()</h1>\n<p>koa静态文件服务中间件的实现里，需要将当前路径 __dirname 与用户传入的路径合并为一个绝对路径，就可以使用path.resolve函数</p>\n<blockquote>\n<p>The path.resolve() method resolves a sequence of paths or path segments into an absolute path.</p>\n</blockquote>\n<pre><code class=\"language-js\">const path = require(&#39;path&#39;)\n\npath.resolve(&#39;/foo/bar&#39;, &#39;./baz&#39;);\n// Returns: &#39;/foo/bar/baz&#39;\n\npath.resolve(&#39;/foo/bar&#39;, &#39;/tmp/file/&#39;);\n// Returns: &#39;/tmp/file&#39;\n\nlet dirPath = &#39;./public&#39;\npath.resolve(__dirname, dirPath)</code></pre>\n<p>参考：<a href=\"https://nodejs.org/docs/latest/api/path.html#path_path_resolve_paths\">node path.resolve</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "node path.resolve()"
        }
      ],
      "config": {
        "source": "node path.resolve().md",
        "staticFileName": "node_path.html",
        "author": "guoqzuo",
        "createDate": "2020/01/10",
        "description": "koa静态文件服务中间件的实现里，需要将当前路径 __dirname 与用户传入的路径合并为一个绝对路径，就可以使用path.resolve函数",
        "keywords": "node path.resolve,node路径处理",
        "category": "前端工程化",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"---css变量的使用，var-与变量---\">-- css变量的使用，var() 与变量 --</h1>\n<p>在less或sass中，有直接的变量定义方法，而css原生其实也是可以定义变量的，使用--和var即可</p>\n<pre><code class=\"language-html\">&lt;style&gt;\n  /* 最大高度为三行，将line-height定义为变量lh */\n  .module {\n    --lh: 1.2rem;\n    line-height: var(--lh);\n    max-height: calc(var(--lh) * 3);\n    overflow: hidden;\n  } \n  :root {\n    --main-bg-color: brown;\n  }\n&lt;/style&gt;</code></pre>\n<p><strong>注意：IE不支持</strong></p>\n<p>参考</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties\">CSS变量 | MDN</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "-- css变量的使用，var() 与变量 --"
        }
      ],
      "config": {
        "source": "-- css变量的使用，var() 与变量 --.md",
        "staticFileName": "css_var.html",
        "author": "guoqzuo",
        "createDate": "2020/01/10",
        "description": "在less或sass中，有直接的变量定义方法，而css原生其实也是可以定义变量的，使用--和var即可",
        "keywords": "css变量,-- css变量的使用，var() 与变量 --",
        "category": "CSS",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"markdown里怎么为文字添加颜色，怎么画复杂表格\">markdown里怎么为文字添加颜色，怎么画复杂表格</h1>\n<p>之前看markdown语法时，并没有添加颜色和复杂表格的方法，但最近了解到markdown里面可以直接使用html，那就方便了。复杂表格直接使用table标签画，如果想给文字加颜色，使用如下方法</p>\n<pre><code class=\"language-html\">&lt;span style=&quot;color: red&quot;&gt;这是一段有颜色的字体&lt;/span&gt;\n\n&lt;!-- 下划线 --&gt;\n&lt;u&gt;这是一段有下划线的文字&lt;/u&gt;</code></pre>\n<p><strong>注意：markdown解析器很多。在Typora嵌入html的复杂表格没什么问题，但在github上显示时，table被放到了文档的最下面。语雀里导入时，也会有一点问题。所以为了保证最大程度的兼容，写md时，尽量避免使用内嵌html，对于复杂表格可以使用图片代替</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "markdown里怎么为文字添加颜色，怎么画复杂表格"
        }
      ],
      "config": {
        "source": "markdown里怎么为文字添加颜色，怎么画复杂表格.md",
        "staticFileName": "markdown_html.html",
        "author": "guoqzuo",
        "createDate": "2020/01/11",
        "description": "之前看markdown语法时，并没有添加颜色和复杂表格的方法，但最近了解到markdown里面可以直接使用html，那就方便了。复杂表格直接使用table标签画，如果想给文字加颜色，使用如下方法",
        "keywords": "markdown里怎么为文字添加颜色,markdown里怎么画复杂表格,markdown使用html时注意事项",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"npm-install简写为npm-i安装包时项目文件名与包名冲突不报异常的问题\">npm install简写为npm i安装包时项目文件名与包名冲突不报异常的问题</h1>\n<p>最近在安装 npm install 时喜欢简写 npm i mysql2 -s 但发现执行后，并没有安装成功，在package.json里也没有任何记录。还没有报任何错误。</p>\n<pre><code class=\"language-bash\"># 把简写的命令换成 非简写 再执行\nnpm install mysql --save\n\n# kevindeMacBook-Air:mysql2 kevin$ npm i mysql2 -s    # 简写执行后，没有任何信息\n# kevindeMacBook-Air:mysql2 kevin$ npm install mysql2 -save # 这次就报错了，提示项目名称与包名称相同\n# npm ERR! code ENOSELF\n# npm ERR! Refusing to install package with name &quot;mysql2&quot; under a package\n# npm ERR! also called &quot;mysql2&quot;. Did you name your project the same\n# npm ERR! as the dependency you&#39;re installing?\n# npm ERR! \n# npm ERR! For more information, see:\n# npm ERR!     &lt;https://docs.npmjs.com/cli/install#limitations-of-npms-install-algorithm&gt;\n\n# 由于在初始化生成package.json时为了方便，直接使用了下面的命令\nnpm init -y  # 所有默认yes，生成的package.json里面，项目名称字段为当前文件夹名。\n\n# 由于文件夹名就是 mysql2，与安装的包名重复了。将package.json里的name属性改一个名字即可</code></pre>\n<p><strong>总结: 项目名称不要与依赖的包名相同，当npm安装简写执行异常时，使用非简写方法再试试。</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "npm install简写为npm i安装包时项目文件名与包名冲突不报异常的问题"
        }
      ],
      "config": {
        "source": "npm install简写为npm i安装包时项目文件名与包名冲突不报异常的问题.md",
        "staticFileName": "npm_i.html",
        "author": "guoqzuo",
        "createDate": "2020/01/14",
        "description": "最近在安装 npm install 时喜欢简写 npm i mysql2 -s 但发现执行后，并没有安装成功，在package.json里也没有任何记录。还没有报任何错误。",
        "keywords": "npm install简写为npm i注意事项,npm init -y注意事项",
        "category": "前端工程化",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"node遍历文件夹下的文件再require对应的文件出错，要注意ds_store隐藏文件\">node遍历文件夹下的文件再require对应的文件出错，要注意.DS_Store隐藏文件</h1>\n<p>在使用koa mock接口时，一个模块有很多接口，就写了十几个js，每个js对应一个接口数据。如果每增加一个接口，再添加一个require就很麻烦，于是写了个index.js来遍历文件夹，进行动态引入。以后写好js，就不用再手动require了。之前都运行正常的，最近再运行时发现一直报错，require异常。后来打印遍历的fileName，发现居然有 .DS_Store 文件，require这个文件时错误。这个文件属于mac系统自动生成的文件，之前都没有的。在程序中过滤调这个文件即可。</p>\n<p>mock目录结构如下:</p>\n<pre><code class=\"language-bash\"># 目录结构\nmock\n├── pm\n│   ├── index.js # 入口\n│   ├── 接口1.js\n│   ├── 接口2.js\n│   └── 接口n.js\n├── user \n├── product\n└── sever.js # 入口文件，require(&#39;./pm/index.js&#39;)(router) 将接口添加到路由</code></pre>\n<p>pm/index.js 代码如下：</p>\n<pre><code class=\"language-js\">const fs = require(&#39;fs&#39;)\n\nmodule.exports = router =&gt; {\n  fs.readdirSync(__dirname).forEach(fileName =&gt; {\n    if (fileName === &#39;index.js&#39; || fileName.startsWith(&#39;.&#39;)) return\n    require(&#39;./&#39; + item)(router)\n  })\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "node遍历文件夹下的文件再require对应的文件出错，要注意.DS_Store隐藏文件"
        }
      ],
      "config": {
        "source": "node遍历文件夹下的文件再require对应的文件出错，要注意.DS_Store隐藏文件.md",
        "staticFileName": "node_for_DS_Store.html",
        "author": "guoqzuo",
        "createDate": "2020/01/16",
        "description": "在使用koa mock接口时，一个模块有很多接口，就写了十几个js，每个js对应一个接口数据。如果每增加一个接口，再添加一个require就很麻烦，于是写了个index.js来遍历文件夹，进行动态引入。以后写好js，就不用再手动require了。之前都运行正常的，最近再运行时发现一直报错，require异常。后来打印遍历的fileName，发现居然有 .DS_Store 文件，require这个文件时错误。这个文件属于mac系统自动生成的文件，之前都没有的。在程序中过滤调这个文件即可。",
        "keywords": "node遍历文件夹下的文件时需要过滤.DS_Store隐藏文件",
        "category": "前端工程化",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"js-sleep-测试loading时写的等待函数最简代码\">JS sleep 测试loading时写的等待函数最简代码</h1>\n<p>一般想模拟延时，测试loading效果时，会写一个等待函数，怎么最简单方便呢？下面来研究下</p>\n<pre><code class=\"language-js\">// 一般写法\nconst delay = function (msec){\n  return new Promise(resolve =&gt; {\n    setTimeout(() =&gt; {\n      resolve()\n    }, msec)\n  }) \n}\nawait delay(2000)\nconsole.log(&#39;test&#39;)\n\n// 使用箭头函数简写\nconst delay = (msec) =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(), msec))\nawait delay(2000)\nconsole.log(&#39;test&#39;)\n\n// 舍弃函数封装与自定义时长，最精简写法\n(async () =&gt; {\n  await new Promise(r =&gt; setTimeout(() =&gt; r(), 2000)) // 一行代码\n  console.log(&#39;test&#39;)\n})()\n</code></pre>\n<p>在vue中的实际应用</p>\n<pre><code class=\"language-js\">vue.prototype.$mydelay = (t) =&gt; new Promise(r =&gt; setTimeout(() =&gt; r(), t))\n// 在vue中间中调用\nawait this.$mydelay(2000)</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JS sleep 测试loading时写的等待函数最简代码"
        }
      ],
      "config": {
        "source": "JS sleep测试loading时写的等待函数最简代码.md",
        "staticFileName": "js_sleep.html",
        "author": "guoqzuo",
        "createDate": "2020/01/19",
        "description": "一般想模拟延时，测试loading效果时，会写一个等待函数，怎么最简单方便呢？下面来研究下",
        "keywords": "js sleep测试loading时写的等待函数最简代码",
        "category": "JavaScript",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"零编码或少编码生成通用封装的axios函数\">零编码或少编码生成通用封装的axios函数</h1>\n<p>现在项目中，每个模块都会单独弄一个对应service.js，把所有接口请求放到里面，其实就是将axios请求封装为一个个函数。每个函数的函数名、url、请求方法会有所差别。重复代码比较多。最近在看mongodb教程时，了解到零编码编程的思想，于是想把这里优化下，\b最好以后写新模块时，只要写简单的配置文件就可以自动生成函数，不用再单独手写函数。先来看看原来的方式：</p>\n<pre><code class=\"language-js\">// someService.js\n// 这里的service是对axios的封装，增加了一些请求拦截，用响应拦截等\nimport { service, downloadService } from &#39;../service.js&#39;\nlet someService = {\n  urls: {\n    funcA: &#39;/api/url1&#39;,\n    funcB: &#39;/api/url2&#39;,\n    funcC: &#39;/api/url3&#39;,\n  },\n  funcA() {\n    return service.post(someService.urls.funcA, payload)\n  },\n  funcB() {\n    return service.get(someService.urls.funcB, {params: payload})\n  },\n  funcC() {\n    return downloadService.post(someService.urls.funcC, payload)\n  }\n}\nexport default someService\n\n// 在vue组件里，使用方法\nimport someService from &#39;someService.js&#39;\nsomeService.funcA(payload).then(() =&gt; {\n  // 接收结果\n})</code></pre>\n<p>当接口比较多时，比如20+，那就需要写20个类似的函数，冗余性太高，这里使用零编码编程的思想来优化一下，先来看看优化后的代码</p>\n<pre><code class=\"language-js\">// 优化后的 someService.js 和旧的写法实现的功能一样，且更加强大\nimport generateCommonApi from &#39;./utils/generateCommonApi&#39;\nimport { downloadService } from &#39;../service.js&#39;\n\n// 之前使用对象结构，发现还是有大量重复的属性字段，不是很方便，用数组的方式，写法更精简，更高效\n// 但同时牺牲了扩展性，类似于大的框架总会遇到的问题：各种实现都各有优缺点，关键是要去找一种平衡，做一些取舍。\nconst someApiList = [\n  [&#39;funcA&#39;, &#39;/api/url1&#39;, &#39;post&#39;],\n  [&#39;funcB&#39;, &#39;/api/url2&#39;],\n  [&#39;funcC&#39;, &#39;/api/url3&#39;, &#39;post&#39;, downloadService]\n]\nexport default generateCommonApi(someApiList)</code></pre>\n<p>这里通过写一个generateCommonApi.js来实现自动生成通用api对象，以后就不用再写大量重复的代码了。来看看具体实现:</p>\n<pre><code class=\"language-js\">// generateCommonApi.js\n// 参考文档：https://github.com/axios/axios\nimport { services } from &#39;./service.js&#39;\n\nfunction generateCommonApi(apiList, isAddTimestamp2Url) {\n  let obj = {}\n  let methodsList = [&#39;request&#39;, &#39;get&#39;, &#39;delete&#39;, &#39;head&#39;, &#39;options&#39;, &#39;post&#39;, &#39;put&#39; &#39;patch&#39;]\n\n  // 遍历JSON配置，生成对应的请求函数并挂载到obj对象\n  apiList.forEach(item =&gt; {\n    let [apiName, url, method = &#39;get&#39;, servicesFunc = services] = item\n    let isMethodOk = typeof method === &#39;string&#39; &amp;&amp; methodsList.includes(method.toLowerCase())\n    method = isMethodOk ? method : &#39;get&#39;\n\n    // 如果需要加时间戳\n    url += isAddTimestamp2Url ? &#39;&#39; : `${url.includes(&#39;?&#39;) ? &#39;&amp;&#39; : &#39;?&#39;}t=${+new Date()}`\n\n    obj[apiName] = async (payload = {}, config = {}) =&gt; {\n      let paramsMap = {\n        &#39;1&#39;: [payload],\n        &#39;2&#39;: [url, {params: payload, ...config}],\n        &#39;3&#39;: [url, payload, config]\n      }\n      let is3Args = [&#39;post&#39;, &#39;put&#39;, &#39;patch&#39;].includes(method)\n      let methodType = method === &#39;request&#39; ? &#39;1&#39; : is3Args ? &#39;3&#39; : &#39;2&#39;\n\n      return servicesFunc[method](...paramsMap[methodType])\n    }\n  })\n  return obj\n}\n\nexport default generateCommonApi </code></pre>\n<p>后面我又对其进行了扩展与修改，这里只提供一个思路，并不是完美的实现，</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "零编码或少编码生成通用封装的axios函数"
        }
      ],
      "config": {
        "source": "零编码或少编码根据配置生成通用封装的axios函数.md",
        "staticFileName": "axios_package.html",
        "author": "guoqzuo",
        "createDate": "2020/01/19",
        "description": "现在项目中，每个模块都会单独弄一个对应service.js，把所有接口请求放到里面，其实就是将axios请求封装为一个个函数。每个函数的函数名、url、请求方法会有所差别。重复代码比较多。最近在看mongodb教程时，了解到零编码编程的思想，于是想把这里优化下，最好以后写新模块时，只要写简单的配置文件就可以自动生成函数，不用再单独手写函数",
        "keywords": "axios二次封装,axios服务封装",
        "category": "http与https",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"js-sort对数组进行默认排序时如果有数字为什么会不准确？\">JS sort对数组进行默认排序时如果有数字为什么会不准确？</h1>\n<p>正常情况使用 sort 是好用的，但如果有数字时，会有问题，<strong>因为如果sort不传参，默认情况下会将所有元素转换为字符串后，再根据unicode值来进行排序</strong>，下面我们来看看对应的实例</p>\n<pre><code class=\"language-js\">var arr = [5, -11, -10] \narr.sort() // [-10, -11, 5]\n\nvar arr2 = [5, 0, 6, 11, 7]\narr2].sort() // [0, 11, 5, 6, 7]\n\n// 明显上面的结果是有问题的，默认的排序遇到负数就不正确了\n// 这就需要自定义排序了\narr.sort((a, b) =&gt; a - b) // [-11, -10, 5]\narr2.sort((a, b) =&gt; a - b) //  [0, 5, 6, 7, 11]</code></pre>\n<p>为什么会这样呢？我们来看看MDN官方解释 arr.sort([compareFunction])</p>\n<blockquote>\n<p>compareFunction(Optional)，Specifies a function that defines the sort order. If omitted, the array elements are converted to strings, then sorted according to each character&#39;s Unicode code point value.</p>\n</blockquote>\n<p>sort参数指定一个自定义排序的函数，如果省略了该传值，数组的元素会先转换为string，再根据每个字符在Unicode的值来排序</p>\n<p>综上，我们在使用sort进行排序时要注意两点：</p>\n<ol>\n<li><strong>在对数组做sort操作时，会改变数组，不会像map那样返回一个新的数据，对原数组无影响</strong></li>\n<li><strong>sort对非字符串排序时，一定要使用自定义排序</strong></li>\n</ol>\n<p>参考: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\">Array.prototype.sort() | MDN</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JS sort对数组进行默认排序时如果有数字为什么会不准确？"
        }
      ],
      "config": {
        "source": "JS sort对数组进行默认排序时如果有数字为什么会不准确？.md",
        "staticFileName": "js_sort_num.html",
        "author": "guoqzuo",
        "createDate": "2020/01/21",
        "description": "正常情况使用 sort 是好用的，但如果有数字时，会有问题，因为如果sort不传参，默认情况下会将所有元素转换为字符串后，再根据unicode值来进行排序，下面我们来看看对应的实例",
        "keywords": "js sort数组不准确,js sort负数不准确, js sort对数组排序时的坑",
        "category": "JavaScript",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"js-为什么使用set对数组或对象去重时会无效？\">JS 为什么使用set对数组或对象去重时会无效？</h1>\n<p>我们知道Set是JS的一个种新的数据结构，和数组类似，和数组不同的是它可以去重，比如存入两个1或两个&quot;123&quot;，只有1条数据会存入成功，但有个特殊情况，如果添加到set的值是引用类型，比如数组、对象，他将无法自动去重。因为值相同的两个引用类型地址是不一样的。下面来看一个例子：</p>\n<pre><code class=\"language-js\">var mySet = new Set()\nmySet.add([-1,0,1])\nmySet.add([-1,0,1])\nmySet.add({a: 1})\nmySet.add({a: 1})\nmySet.size // 4\nconsole.log(Array.from(mySet)) // [[-1, 0, 1], [-1, 0, 1], {a: 1}, {a: 1}]</code></pre>\n<p>我们来看看mdn上的文档描述</p>\n<p>Description</p>\n<blockquote>\n<p>Set objects are collections of values. You can iterate through the elements of a set in insertion order. A value in the Set may only occur once; it is unique in the Set&#39;s collection.</p>\n</blockquote>\n<p>Value equality</p>\n<blockquote>\n<p>Because each value in the Set has to be unique, the value equality will be checked. In an earlier version of ECMAScript specification, this was not based on the same algorithm as the one used in the === operator. Specifically, for Sets, +0 (which is strictly equal to -0) and -0 were different values. However, this was changed in the ECMAScript 2015 specification. See &quot;Key equality for -0 and 0&quot; in the browser compatibility table for details. NaN and undefined can also be stored in a Set. All NaN values are equated (i.e. NaN is considered the same as NaN, even though NaN !== NaN).</p>\n</blockquote>\n<p>我们可以简单理解为，像Set实例add数据时，每次都会进行等值判断，类似于将add的元素与每个元素进行 === 比较。因此对引用类型的去重是无效的</p>\n<pre><code class=\"language-js\">var stra = &quot;test&quot;\nvar strb = &quot;test&quot;\nvar a = { a : 1}\nvar b = { a : 1}\nstra === strb // true\na === b // false 尽管他们都是对象 { a: 1 }，但他们存储的地址是不一样的 </code></pre>\n<p>那这种情况怎么去重呢。我们可以自己写方法来处理，以数组为例子，可以将值[-1, 0, 1].join(&#39;|&#39;) 处理下，添加进去，到时统一再split出来</p>\n<p>参考：<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">The Set | MDN</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JS 为什么使用set对数组或对象去重时会无效？"
        }
      ],
      "config": {
        "source": "JS 为什么使用set对数组或对象去重时会无效？.md",
        "staticFileName": "js_set.html",
        "author": "guoqzuo",
        "createDate": "2020/01/21",
        "description": "我们知道Set是JS的一个种新的数据结构，和数组类似，和数组不同的是它可以去重，比如存入两个1或两个'123'，只有1条数据会存入成功，但有个特殊情况，如果添加到set的值是引用类型，比如数组、对象，他将无法自动去重。因为值相同的两个引用类型地址是不一样的。下面来看一个例子：",
        "keywords": "js set去重对数组，对象无效,为什么使用set对数组或对象去重时会无效",
        "category": "JavaScript",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"nginx怎么开启gzip以及怎么判断nginx是否成功开启了gzip？\">nginx怎么开启gzip以及怎么判断nginx是否成功开启了gzip？</h1>\n<p>nginx是比较好的一个运行静态http服务的容器。当我们把静态网站部署到nginx上后，我们怎么设置开启zip，让网页资源体积更小，传输更快呢？下面来看看</p>\n<h2 id=\"nginx开启gzip\">nginx开启gzip</h2>\n<p>首先复习下windows下，nginx怎么使用：</p>\n<ol>\n<li>在<a href=\"https://nginx.org/en/download.html\">nginx官网</a>下载nginx，稳定版，现在是nginx/Windows-1.16.1，下载后是一个zip文件</li>\n<li>解压后放到桌面，进入解压后的目录 nginx-1.16.1，先修改nginx的root文件夹，也就是80端口指向的目录。修改 conf 目录下的 nginx.conf文件，如下图，将静态项目路径设置到root后</li>\n</ol>\n<p><img src=\"../../../images/blog/devtools/nginx_config.png\" alt=\"nginx_config.png\"></p>\n<ol start=\"3\">\n<li>运行nginx</li>\n</ol>\n<pre><code class=\"language-bash\"># 进入到nginx目录，shift + 鼠标右键，在此处打开命令窗口，将nginx.exe拖到窗口，再打一个空格 -c 配置文件，类似下面的命令\nnginx.exe -c conf/nginx.conf\n# 关闭nginx服务，注意 nginx.exe 是将nginx.exe文件拖到terminal时产生的\nnginx.exe -s stop</code></pre>\n<p>在上面的图中，已经有开启gzip的代码了。默认情况下 gzip on 是注释掉的，我们打开这个注释再添加几个属性即可。对于额外增加的几个属性这里说明下:</p>\n<ul>\n<li>gzip_types是指定需要开启gzip压缩的文件类型</li>\n<li>gzip_comp_level 指定压缩等级</li>\n<li>gzip_min_length 当超过多少字节时就压缩，我上面设置的是1K</li>\n<li>gzip_vary 增加响应头”Vary: Accept-Encoding”</li>\n</ul>\n<pre><code class=\"language-js\">gzip on;\ngzip_vary on;\ngzip_min_length 1000;\ngzip_comp_level 2;\ngzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml image/jpeg image/gif image/png application/javascript;</code></pre>\n<h2 id=\"怎么判断nginx是否成功开启gzip\">怎么判断nginx是否成功开启gzip</h2>\n<p>打开chrome访问对应的站点，F12，点击network. 在Name，Priority 那一栏的最右侧空白位置，右键，勾选 Content-Encoding，如下图，设置好后刷新页面就可以看到Content-Encoding那一列了，如果有gzip就说明开启了gzip，需要结合Size这个属性看，如果没有超过设定大小的文件，是不会开启gzip压缩的。</p>\n<p><img src=\"../../../images/blog/devtools/chrome_gzip.png\" alt=\"chrome_gzip.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "nginx怎么开启gzip以及怎么判断nginx是否成功开启了gzip？",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "nginx开启gzip"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "怎么判断nginx是否成功开启gzip"
            }
          ]
        }
      ],
      "config": {
        "source": "nginx怎么开启gzip以及怎么判断nginx是否成功开启了gzip？.md",
        "staticFileName": "nginx_gzip.html",
        "author": "guoqzuo",
        "createDate": "2020/01/29",
        "description": "nginx是比较好的一个运行静态http服务的容器。当我们把静态网站部署到nginx上后，我们怎么设置开启zip，让网页资源体积更小，传输更快呢？下面来看看",
        "keywords": "nginx怎么开启gzip,怎么判断nginx是否成功开启了gzip,怎么判断nginx开启gzip生效",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"静态博客生成系统一：js怎么将markdown文件转html\">静态博客生成系统(一)：JS怎么将markdown文件转html</h1>\n<p>其实早在18年12月，我就已经写好了最简的demo，使用的是marked这个工具。本来准备将博客静态化的，但后来就没继续了，这里来说下方法</p>\n<h2 id=\"用node写demo\">用node写demo</h2>\n<p>一般js处理文件使用的是nodejs，下面来看看具体步骤(假设你已经安装了npm)</p>\n<ol>\n<li>创建一个test.js</li>\n<li>npm init 生成packgage.json</li>\n<li>写一个利用marked包读取md文件生成html字符串后再创建一个文件的demo，下面是示例demo</li>\n<li>node test.js 运行看是否生成正常</li>\n</ol>\n<pre><code class=\"language-js\">// github: https://github.com/markedjs/marked\n// marked.js 是下载好的，不想安装npm包\nlet marked = require(&#39;./lib/marked&#39;) // import marked.js\nlet fs = require(&#39;fs&#39;)\n// 读取md文件\nfs.readFile(&#39;iOS程序启动过程，从main函数开始UIApplication与AppDelegate.md&#39;, (err, data) =&gt; {\n  if (err) {\n    console.log(err);\n    return;\n  }\n\n  // 这里加入了基本的html框架，加入了代码高亮prismjs\n  let htmlStr = `&lt;!DOCTYPE html&gt;\n  &lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n      &lt;meta charset=&quot;UTF-8&quot;&gt;\n      &lt;title&gt;Title&lt;/title&gt;\n      &lt;link href=&quot;../lib/prismjs/prism_default.css&quot; rel=&quot;stylesheet&quot; /&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n      ${marked(data.toString())}\n      &lt;script src=&quot;../lib/prismjs/prism_default.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;\n  `\n  // 生成新的文件\n  fs.writeFile(&#39;./dist/test.html&#39;, htmlStr, (err) =&gt; {\n    console.log(err)\n    console.log(&#39;写入文件成功&#39;);\n  })\n})</code></pre>\n<h2 id=\"在zuo-blog里的实际应用\">在zuo-blog里的实际应用</h2>\n<p>截取至 zuo-blog <a href=\"https://github.com/zuoxiaobai/zuo-blog/blob/master/vendor/ZUOBlog.js\">部分源码 | github</a></p>\n<pre><code class=\"language-js\">// 处理md文件\n_handlerMdFile(article, articlePath, year, month) {\n    // 读取文件内容，通过maked转换为html字符串\n    const fileStr = fs.readFileSync(articlePath).toString() \n    let htmlStr = marked(fileStr)\n}</code></pre>\n<p><strong>注意：marked将md文件转html时，如果在ol或ul后面加了代码块，必须换行，如果不换行就会准换异常</strong></p>\n<pre><code class=\"language-js\">// - 这是一个ul\n// ul后面这里不能直接用```写代码，需要换行，如果不换行在Typora可以正常渲染，但marked转换时会出问题</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "静态博客生成系统(一)：JS怎么将markdown文件转html",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "用node写demo"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "在zuo-blog里的实际应用"
            }
          ]
        }
      ],
      "config": {
        "source": "静态博客生成系统(一)：JS怎么将markdown文件转html.md",
        "staticFileName": "zuoblog_1_md.html",
        "author": "guoqzuo",
        "createDate": "2020/01/29",
        "description": "其实早在18年12月，我就已经写好了最简的demo，使用的是marked这个工具。本来准备将博客静态化的，但后来就没继续了，这里来说下方法",
        "keywords": "怎么用js将markdown转html,markdown转html文件",
        "category": "前端工程化",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"开源许可mit等具体含义\">开源许可MIT等具体含义</h1>\n<p>一般新建一个开源仓库时，需要确定开源协议。之前习惯是MIT，就是别人拿去干什么都可以。对于一些需要控制他人使用的就需要其他协议了。阮一峰博客里有一张图来解释很清晰明了</p>\n<p><img src=\"../../../images/blog/web/opensource_licence.jpg\" alt=\"opensource_licence.jpg\"></p>\n<ul>\n<li>他人修改源码后是否可以闭源?<ul>\n<li>可以闭源，没一个修改过的文件是否都必须放置版权说明?<ul>\n<li>需要放置版权说明 <strong>Apache许可证</strong></li>\n<li>不需要放版权说明，衍生软件的广告是否可以使用你的名字促销?<ul>\n<li>可以用你的名字促销  <strong>MIT许可证</strong></li>\n<li>不可以用你的名字促销 <strong>BSD许可证</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>只能开源，那新增代码后是否采用同样的许可证(不能闭源)?<ul>\n<li>新增代码后也只能开源 <strong>GPL许可证</strong></li>\n<li>新增代码后可以闭源，需要对源码的修改之处提供说明文档吗？<ul>\n<li>需要对源码的修改之处提供说明文档 <strong>LGPL许可证</strong></li>\n<li>不需要提供说明文档 <strong>Mozilla许可证</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>结合实际情况，zuo11.com个人站点blog部分的开源可以使用 Apache许可证，如果是后面开源生成静态页面的程序，可以使用MIT协议</p>\n<p>参考：<a href=\"http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html\">如何选择开源许可证？| 阮一峰</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "开源许可MIT等具体含义"
        }
      ],
      "config": {
        "source": "开源许可MIT等具体含义.md",
        "staticFileName": "os_licence.html",
        "author": "guoqzuo",
        "createDate": "2020/01/30",
        "description": "一般新建一个开源仓库时，需要确定开源协议。之前习惯是MIT，就是别人拿去干什么都可以。对于一些需要控制他人使用的就需要其他协议了。阮一峰博客里有一张图来解释很清晰明了",
        "keywords": "开源许可MIT等具体含义,开源许可licence含义",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"网页seo之将链接提交到搜索引擎进行评定收录\">网页seo之将链接提交到搜索引擎进行评定收录</h1>\n<p>最近对zuo11.com进行了改版，完成了博客的静态化并完成了上线，nginx + 静态文件代替了原来的 tomcat + jsp + mysql的模式。针对百度收录与索引，google收录，做了一些处理。</p>\n<h2 id=\"登录到百度站长平台\">登录到百度站长平台</h2>\n<p>由于url除了zuo11.com其他原来文章的url全部失效，需要让百度重新收录，添加索引。入口：<a href=\"https://ziyuan.baidu.com/\">百度站长平台，现在叫资源搜索平台</a></p>\n<h3 id=\"提交改版规则\">提交改版规则</h3>\n<p>提交网站改版的规则URL对，百度搜索 site:zuo11.com，将收录的网页链接，以及改版后的url以规定的格式提交</p>\n<pre><code class=\"language-bash\"># 旧URL，对应的改版后的url，以空格隔开，一行是一条数据\nhttp://zuo11.com/Notes.woe?action=detail&amp;note_id=24 http://www.zuo11.com/blog/2016/10/c_vim.html\nhttp://zuo11.com/Notes.woe?action=APUE http://www.zuo11.com/blog/category.html</code></pre>\n<h3 id=\"提交死链\">提交死链</h3>\n<p>对于改版后404的页面，可以提交死链，防止搜索引擎认为网站不稳定或服务异常，导致权重评分降级，最好将死链放到一个txt里，定期进行一些更新</p>\n<pre><code class=\"language-bash\"># 死链规则\nhttp://zuo11.com/Notes.woe?</code></pre>\n<h3 id=\"sitemap\">sitemap</h3>\n<p>这里推荐使用sitemap的方式提交链接，怎么生成sitemap呢？使用 <a href=\"https://www.xml-sitemaps.com/\">https://www.xml-sitemaps.com/</a> 输入你的站点，就可以自动生成sitemap.xml信息了，默认只有sitemap.xml，可以找更多文件的下载入口，可以下到一个sitemaps.zip的一个文件，里面还包含了txt、html等非xml格式的数据。<strong>将生成后的sitemap.xml文件放到域名根目录下，提交对应的链接到百度站长平台</strong></p>\n<h3 id=\"向百度站长主动推送站点url\">向百度站长主动推送站点url</h3>\n<p>之前提交链接都是手动将url粘贴到输入框提交。这次试了下curl方式提交还是很方便的</p>\n<pre><code class=\"language-bash\"># 先将要提交的url存放到 urls.txt 里\nvi urls.txt\n\n# 查看\ncat urls.txt \nhttp://www.zuo11.com/blog/2019/11/v-if_filters.html\nhttp://www.zuo11.com/blog/2019/12/web_storage.html\nhttp://www.zuo11.com/blog/2019/12/phantomjs-prebuilt.html\nhttp://www.zuo11.com/blog/2019/12/node_sleep_module.html\nhttp://www.zuo11.com/blog/2019/12/git_clone_timeout.html\nhttp://www.zuo11.com/blog/2019/11/git_push_branch.html\nhttp://www.zuo11.com/blog/2019/12/npm_resource.html\n\n# 确定内容没问题后提交，对应的链接在百度站长提交链接哪里会自动生成\ncurl -H &#39;Content-Type:text/plain&#39; --data-binary @urls.txt &quot;http://data.zz.baidu.com/urls?site=www.zuo11.com&amp;token=xxxxxxx&quot;\n\n# 执行后返回推送接口，实时推送成功\n{&quot;remain&quot;:99993,&quot;success&quot;:7}</code></pre>\n<h2 id=\"登录到google-search-console\">登录到Google search console</h2>\n<p>入口：<a href=\"https://search.google.com/search-console\">Google search console</a>，登录后左侧菜单index - Sitemaps提交sitemap链接</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "网页seo之将链接提交到搜索引擎进行评定收录",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "登录到百度站长平台",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "提交改版规则"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "提交死链"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "sitemap"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "向百度站长主动推送站点url"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "登录到Google search console"
            }
          ]
        }
      ],
      "config": {
        "source": "网页seo之将链接提交到搜索引擎进行评定收录.md",
        "staticFileName": "seo_commit.html",
        "author": "guoqzuo",
        "createDate": "2020/01/30",
        "description": "最近对zuo11.com进行了改版，完成了博客的静态化并完成了上线，nginx + 静态文件代替了原来的 tomcat + jsp + mysql的模式。针对百度收录与索引，google收录，做了一些处理。",
        "keywords": "提交站点链接到百度,提交链接到google",
        "category": "网站建设与SEO",
        "year": "2020",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"element合并单元格，自定义表格border\">element合并单元格，自定义表格border</h1>\n<p>有个较为特殊的表格，需要合并单元格，且改变表格border，下面来看看element el-table怎么实现这种表格</p>\n<p><img src=\"../../../images/blog/vue/special_table.png\" alt=\"element_merge_cells\"></p>\n<p>先来分析下怎么做</p>\n<ol>\n<li>第一列中第二行以后的行是需要合并的，el-table 提供了一个 span-method 属性，用于传入合并单元格方法，在里面可以根据 rowspan、colspan 合并行或列</li>\n<li>第 2、3、4 列需要改变表格 border，需要使用 <code>/deep/</code> 修改 element 默认的颜色，使用 nth-child、first-child 等找到对应的行或列，修改border</li>\n</ol>\n<p>具体实现代码如下</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div class=&quot;table-test&quot;&gt;\n    &lt;el-table\n      :data=&quot;dataList&quot;\n      border\n      size=&quot;mini&quot;\n      :span-method=&quot;arraySpanMethod&quot;\n      :header-cell-style=&quot;{ background: &#39;#f7f7f7&#39; }&quot;\n    &gt;\n      &lt;el-table-column\n        v-for=&quot;item in [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]&quot;\n        :key=&quot;item&quot;\n        :prop=&quot;item&quot;\n        :label=&quot;item&quot;\n      &gt;&lt;/el-table-column&gt;\n    &lt;/el-table&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      dataList: []\n    };\n  },\n  mounted() {\n    this.dataList = [1, 2, 3, 4].map(() =&gt; {\n      return { a: &quot;1&quot;, b: &quot;2&quot;, c: &quot;3&quot;, d: 4 };\n    });\n  },\n  methods: {\n    arraySpanMethod({ row, column, rowIndex, columnIndex }) {\n      console.log(row, column, rowIndex, columnIndex);\n      // 只是遍历表格td内容，不包含th表头\n      // 对第一列，进行合并列\n      if (columnIndex === 0) {\n        if (rowIndex === 0) {\n          // 第一列，第一行，默认\n          return {\n            rowspan: 1,\n            colspan: 1\n          };\n        } else if (rowIndex === 1) {\n          // 第一列，第二行，合并，占this.dataList.length - 1行\n          return {\n            rowspan: this.dataList.length - 1,\n            colspan: 1\n          };\n        } else if (rowIndex &gt;= 2) {\n          // 第一列，剩余行，为空\n          return {\n            rowspan: 0,\n            colspan: 0\n          };\n        }\n      }\n    }\n  }\n};\n&lt;/script&gt;\n\n&lt;style lang=&quot;less&quot; scoped&gt;\n.table-test {\n  width: 500px;\n  margin: 100px;\n  // border处理\n  // 去掉表头单元格th右边框\n  /deep/ .el-table th:not(:first-child) {\n    border-right: 0;\n  }\n  // 去掉表格内容单元格td的右侧边框、底部边框\n  /deep/ .el-table td {\n    border-right: 0;\n    border-bottom: 0;\n  }\n  // 为第一行td增加底部border\n  /deep/ .el-table__row:first-child td {\n    border-bottom: 1px solid #eaeaea;\n  }\n  // 为第一行第一列td增加右侧border\n  /deep/ .el-table__row:first-child td:first-child,\n  // 为第二行（合并后的）第一列td设置右侧border\n  /deep/ .el-table__row:nth-child(2) td:first-child {\n    border-right: 1px solid #eaeaea;\n  }\n}\n&lt;/style&gt;</code></pre>\n<p>完整demo参见：<a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/vuecli-demo/src/views/table/index.vue\">element合并单元格demo | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "element合并单元格，自定义表格border"
        }
      ],
      "config": {
        "source": "element合并单元格，自定义表格border.md",
        "staticFileName": "element_merge_cells.html",
        "author": "guoqzuo",
        "createDate": "2020/10/01",
        "description": "有个较为特殊的表格，需要合并单元格，且改变表格border，下面来看看element el-table怎么实现这种表格。先来分析下怎么做，1. 第一列中第二行以后的行是需要合并的，el-table 提供了一个 span-method 属性，用于传入合并单元格方法，在里面可以根据 rowspan、colspan 合并行或列 2. 第 2、3、4 列需要改变表格 border，需要使用 `/deep/` 修改 element 默认的颜色，使用 nth-child、first-child 等找到对应的行或列，修改border",
        "keywords": "element合并单元格,element表格合并单元格",
        "category": "Vue",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"前端通过documentcookie设置cookie，相关改动会传到后台吗？\">前端通过document.cookie设置cookie，相关改动会传到后台吗？</h1>\n<p>首先我们来捋一捋，什么是cookie？与cookie相关的知识点有两个：</p>\n<ol>\n<li>前端获取/设置cookie，使用 document.cookie</li>\n<li>HTTP请求与响应相关cookie</li>\n</ol>\n<p>我们先下个结论：他们之间是相互关联的，接口响应头设置cookie，会对document.cookie的值产生影响；前端设置docuemnt.cookie也会对请求头cookie值产生影响，<strong>但如果后端写到前端的cookie如果使用了HttpOnly属性，前端是无法通过document.cookie做修改的</strong></p>\n<h2 id=\"根据功能点写测试demo\">根据功能点写测试demo</h2>\n<p>纸上得来终觉浅，这里为了弄懂这里面的关系，我们来写一个demo做测试，将涉及的知识点都串起来，首先要有一个html页面，有两个用处</p>\n<ol>\n<li>在该页面打开F12，在console里通过命令查看或设置document.cookie信息</li>\n<li>在该页面中请求接口，在F12 Network里观察请求头，响应头里cookie的信息</li>\n</ol>\n<p>另外需要写两个接口，用户观察请求响应头里cookie的信息，这里我们用koa来写两个简单的接口。</p>\n<p>下面是demo目录层级，完整demo参见 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/DebugDemo/%E5%89%8D%E7%AB%AF%E6%94%B9%E5%8F%98cookie%E5%90%8E%E4%B9%8B%E5%90%8E%E7%9A%84%E8%AF%B7%E6%B1%82%E4%BC%9A%E6%90%BA%E5%B8%A6%E4%B8%8A%E5%90%97\">前端改变cookie后之后的请求会携带上吗demo | github</a></p>\n<pre><code class=\"language-bash\"># demo 目录层级\n├── public\n│   └── index.html # 静态页面\n├── index.js # 接口\n└── package.json # npm init 创建，用于安装index.js引入的koa等npm包</code></pre>\n<p>index.html代码如下</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n  &lt;h1&gt;test测试&lt;/h1&gt;\n  &lt;button id=&quot;userInfoBtn&quot;&gt;获取user信息&lt;/button&gt;\n  &lt;button id=&quot;editInfoBtn&quot;&gt;修改user信息&lt;/button&gt;\n  &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    let userInfoBtn = document.querySelector(&#39;#userInfoBtn&#39;)\n    let eidtInfoBtn = document.querySelector(&#39;#userInfoBtn&#39;)\n    // 请求获取用户信息接口\n    // 用于测试响应头设置 &#39;Set-Cookie&#39; 对前端docuemnt.cookie的影响\n    userInfoBtn.onclick = () =&gt; {\n      axios.get(&#39;/user&#39;).then((res) =&gt; {\n        console.log(res)\n      }).catch((e) =&gt; {\n        console.error(e.message)\n      })\n    }\n    // 请求修改用户信息接口\n    // 用于测试document.cookie设置后或者第一次请求响应头设置Set-Cookie后，对下次接口请求头的影响\n    editInfoBtn.onclick = () =&gt; {\n      axios.put(&#39;/user&#39;).then((res) =&gt; {\n        console.log(res)\n      }).catch((e) =&gt; {\n        console.error(e.message)\n      })\n    }\n  &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p>index.js接口代码</p>\n<pre><code class=\"language-js\">const Koa = require(&#39;koa&#39;)\nconst Router = require(&#39;koa-router&#39;)\nconst app = new Koa()\nconst router = new Router()\n\n// 静态服务，用于使用 http://127.0.0.1:9000/ 访问 public下的index.html页面\napp.use(new require(&#39;koa-static&#39;)(&#39;./public&#39;))\n\n// GET /user  接口，设置Set-Cookie响应头测试\nrouter.get(&#39;/user&#39;, ctx =&gt; {\n  ctx.set({\n    // &#39;Set-Cookie&#39;: &#39;token=123;path=/;max-age=100;HttpOnly&#39;,\n    &#39;Set-Cookie&#39;: [&#39;token=123;path=/;max-age=100;HttpOnly&#39;,&#39;mark=9;path=/;&#39;]\n  })\n  ctx.body = {\n    name: &#39;张三&#39;,\n    age: 20\n  }\n})\n\n// PUT /user  接口，用于观察接口请求头\nrouter.put(&#39;/user&#39;, ctx =&gt; {\n  ctx.body = {\n    code: 0,\n    data: {},\n    msg: &#39;成功&#39;\n  }\n})\n\napp.use(router.routes())\n\n// 开启本地HTTP服务，9000端口\napp.listen(9000, () =&gt; {\n  console.log(&#39;server listen on 9000 port&#39;)\n})</code></pre>\n<h2 id=\"documentcookie设置对请求头的影响\">document.cookie设置对请求头的影响</h2>\n<p>首先我们可以先看 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie\">Document.cookie - Web API 接口参考 | MDN</a> 这个文档，对document.cookie有一个大概的了解。</p>\n<p>我们先运行demo，nodemon index.js，访问 <code>http://127.0.0.1:9000/</code> 进入页面，查看cookie信息，如下图</p>\n<p><img src=\"../../../images/blog/web/what_cookie_1.png\" alt=\"what_cookie_1.png\"></p>\n<p>这时，我们发送一个put请求，看接口请求头信息。再通过 document.cookie = &quot;a=1&quot; 设置cookie，然后再发送一个put请求，对比请求头之前的区别，如下图，我们初步得出结论：<strong>前端设置cookie后，下次请求，在请求头里会携带这个cookie</strong></p>\n<p><img src=\"../../../images/blog/web/what_cookie_2.png\" alt=\"what_cookie_2.png\"></p>\n<h2 id=\"documentcookie操作方法\">document.cookie操作方法</h2>\n<p>document.cookie API的设计不怎么友好，一般会使用一个库，来操作docuemnt.cookie，需要注意</p>\n<pre><code class=\"language-js\">document.cookie = &quot;a=1&quot; // 如果cookie中没有a这个key，可以添加key为a，值为1的cookie，否则修改对应的值为1\ndocument.cookie = &quot;&quot; // 不会清空cookie，对cookie基本无影响\n// 怎么删除 a=1 的cookie呢？将该cookie的有效时间设置为过去的时间即可\ndocument.cookie = &quot;a=1;expires=&quot; + new Date(&#39;1970-1-1&#39;)</code></pre>\n<p>MDN document.cookie文档里有推荐的一个操作cookie的封装方法，可以参考下</p>\n<pre><code class=\"language-js\">/*\\\n|*|\n|*|  :: cookies.js ::\n|*|\n|*|  A complete cookies reader/writer framework with full unicode support.\n|*|\n|*|  https://developer.mozilla.org/en-US/docs/DOM/document.cookie\n|*|\n|*|  This framework is released under the GNU Public License, version 3 or later.\n|*|  http://www.gnu.org/licenses/gpl-3.0-standalone.html\n|*|\n|*|  Syntaxes:\n|*|\n|*|  * docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])\n|*|  * docCookies.getItem(name)\n|*|  * docCookies.removeItem(name[, path], domain)\n|*|  * docCookies.hasItem(name)\n|*|  * docCookies.keys()\n|*|\n\\*/\n\nvar docCookies = {\n  getItem: function (sKey) {\n    return decodeURIComponent(document.cookie.replace(new RegExp(&quot;(?:(?:^|.*;)\\\\s*&quot; + encodeURIComponent(sKey).replace(/[-.+*]/g, &quot;\\\\$&amp;&quot;) + &quot;\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$&quot;), &quot;$1&quot;)) || null;\n  },\n  setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {\n    if (!sKey || /^(?:expires|max\\-age|path|domain|secure)$/i.test(sKey)) { return false; }\n    var sExpires = &quot;&quot;;\n    if (vEnd) {\n      switch (vEnd.constructor) {\n        case Number:\n          sExpires = vEnd === Infinity ? &quot;; expires=Fri, 31 Dec 9999 23:59:59 GMT&quot; : &quot;; max-age=&quot; + vEnd;\n          break;\n        case String:\n          sExpires = &quot;; expires=&quot; + vEnd;\n          break;\n        case Date:\n          sExpires = &quot;; expires=&quot; + vEnd.toUTCString();\n          break;\n      }\n    }\n    document.cookie = encodeURIComponent(sKey) + &quot;=&quot; + encodeURIComponent(sValue) + sExpires + (sDomain ? &quot;; domain=&quot; + sDomain : &quot;&quot;) + (sPath ? &quot;; path=&quot; + sPath : &quot;&quot;) + (bSecure ? &quot;; secure&quot; : &quot;&quot;);\n    return true;\n  },\n  removeItem: function (sKey, sPath, sDomain) {\n    if (!sKey || !this.hasItem(sKey)) { return false; }\n    document.cookie = encodeURIComponent(sKey) + &quot;=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot; + ( sDomain ? &quot;; domain=&quot; + sDomain : &quot;&quot;) + ( sPath ? &quot;; path=&quot; + sPath : &quot;&quot;);\n    return true;\n  },\n  hasItem: function (sKey) {\n    return (new RegExp(&quot;(?:^|;\\\\s*)&quot; + encodeURIComponent(sKey).replace(/[-.+*]/g, &quot;\\\\$&amp;&quot;) + &quot;\\\\s*\\\\=&quot;)).test(document.cookie);\n  },\n  keys: /* optional method: you can safely remove it! */ function () {\n    var aKeys = document.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, &quot;&quot;).split(/\\s*(?:\\=[^;]*)?;\\s*/);\n    for (var nIdx = 0; nIdx &lt; aKeys.length; nIdx++) { aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]); }\n    return aKeys;\n  }\n};</code></pre>\n<h2 id=\"http-cookies后端接口向前端页面写入cookie\">HTTP cookies后端接口向前端页面写入cookie</h2>\n<p>可以先看下面两个文档，对http cookie有一个基本的了解</p>\n<ol>\n<li>http请求头或响应头参数cookie <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie\">Cookie - HTTP Headers | MDN</a></li>\n<li>http cookies <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies\">HTTP cookies - HTTP | MDN</a></li>\n</ol>\n<blockquote>\n<p>An HTTP cookie (web cookie, browser cookie) is a small piece of data that a server sends to the user&#39;s web browser. The browser may store it and send it back with later requests to the same server. Typically, it&#39;s used to tell if two requests came from the same browser — keeping a user logged-in, for example. It remembers stateful information for the stateless HTTP protocol.（HTTP Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的HTTP协议记录稳定的状态信息成为了可能。）</p>\n</blockquote>\n<p>Cookies are mainly used for three purposes(cookie主要由以下三个应用场景):</p>\n<ul>\n<li>Session management (会话管理) <ul>\n<li>Logins, shopping carts, game scores, or anything else the server should remember(用户登录状态、购物车、游戏分数或其它需要记录的信息)</li>\n</ul>\n</li>\n<li>Personalization (个性化)<ul>\n<li>User preferences, themes, and other settings（用户自定义配置，主题或其他设置）</li>\n</ul>\n</li>\n<li>Tracking (用户行为跟踪)<ul>\n<li>Recording and analyzing user behavior （用于记录和分析用户行为）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"cookie设置属性详解\">cookie设置属性详解</h2>\n<p>服务端通过在接口响应头设置 &#39;Set-Cookie&#39; ，将对应的cookie写到前端，先来看看设置cookie的格式</p>\n<p>Set-Cookie: “name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure;samesite”</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>name</td>\n<td>一个唯一确定的cookie名称。如有特殊字符需要编码(encodeURIComponent)</td>\n<td>/</td>\n</tr>\n<tr>\n<td>value</td>\n<td>存储在cookie中的字符串值。如有特殊字符需要编码</td>\n<td>空字符串</td>\n</tr>\n<tr>\n<td>domain</td>\n<td>cookie对于哪个域是有效，如果指定了一个域，那么子域也包含在内。.xx.com，对于xx.com的所有子域都有效</td>\n<td>当前url所在的域名</td>\n</tr>\n<tr>\n<td>path</td>\n<td>表示这个cookie影响到的路径，浏览器跟会根据这项配置，像指定域中匹配的路径在请求头发送cookie信息</td>\n<td>当前url所在的path</td>\n</tr>\n<tr>\n<td>expires</td>\n<td>失效时间，是一个具体的时间，这个值是GMT时间格式，expires=&quot; + new Date(&#39;1970-1-1&#39;) 这种即可。如果客户端和服务器端时间不一致，使用expires就会存在偏差。注意两点：1.设置一个过去的时间，可用于删除该cookie 2.当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。max-age也是如此</td>\n<td>如果没有定义，cookie会在对话结束时(关闭浏览器)过期</td>\n</tr>\n<tr>\n<td>max-age</td>\n<td>与expires作用相同，用来告诉浏览器此cookie多久过期（单位是秒），而不是一个固定的时间点。正常情况下，max-age的优先级高于expires。</td>\n<td>同上面的expires</td>\n</tr>\n<tr>\n<td>HttpOnly</td>\n<td>告知浏览器不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见。但在http请求张仍然会携带这个cookie。注意这个值虽然在脚本中不可获取，但仍然在浏览器安装目录中以文件形式存在。这项设置通常在服务器端设置。有助于缓解跨站点脚本（XSS）攻击。</td>\n<td>不设置</td>\n</tr>\n<tr>\n<td>secure</td>\n<td>安全标志，指定后，只有在使用SSL链接（https）时候才能发送到服务器，如果是http链接则不会传递该信息。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，因此未加密的重要信息尽量不要放cookie了</td>\n<td>不设置</td>\n</tr>\n<tr>\n<td>samesite</td>\n<td>当跨域请求是浏览器是否发送cookie，可以阻止跨站请求伪造攻击CSRF。1. 值为None: 浏览器会在同站请求、跨站请求下继续发送 cookies，不区分大小写。2.Strict：浏览器将只在访问相同站点时发送 3.Lax：与 Strict 类似，但用户从外部站点导航至URL时（例如通过链接）除外。  Same-site cookies 将会为一些跨站子请求保留，如图片加载或者 frames 的调用，但只有当用户从外部站点导航到URL时才会发送。如 link 链接</td>\n<td>以默认值都是None，现在基本新的浏览器基本都是Lax了</td>\n</tr>\n</tbody></table>\n<h2 id=\"后端设置set-cookie响应头对前端的影响\">后端设置&#39;Set-Cookie&#39;响应头对前端的影响</h2>\n<p>我们在 GET /user 接口做了处理，当访问这个接口时，向前端设置cookie, 一个HttpOnly的，一个非httpOnly，看看效果</p>\n<pre><code class=\"language-js\">ctx.set({\n  // 单个cookie设置\n  // &#39;Set-Cookie&#39;: &#39;token=123;domain=;path=/;max-age=100;HttpOnly&#39;, \n  // 多个cookie设置\n  &#39;Set-Cookie&#39;: [&#39;token=123;path=/;max-age=100;HttpOnly&#39;,&#39;mark=9;path=/;max-age=60;&#39;]\n})</code></pre>\n<p>先删除之前的cookie，保证document.cookie为空</p>\n<p><img src=\"../../../images/blog/web/what_cookie_3.png\" alt=\"what_cookie_3.png\"></p>\n<ol>\n<li>先请求获取user信息接口，在F12里看响应头，Respons e Headers可以看到HttpOnly的cookie</li>\n<li>使用document.cookie看下前端cookie信息。这里获取不到设置了HttpOnly的cookie</li>\n<li>请求修改user信息接口，看请求头。后端设置的cookie，下次请求会携带</li>\n<li>100秒后，发现document.cookie以及application面板都没有cookie值了，因为我们设置了有效时间，再次发送修改user的put请求，请求头不会携带任何cookie信息</li>\n</ol>\n<p><img src=\"../../../images/blog/web/what_cookie_4.png\" alt=\"what_cookie_4.png\"></p>\n<ol start=\"5\">\n<li>再次请求获取user信息接口，然后用document.cookie修改token的值，发现HttpOnly属性的cookie前端无法通过document.cookie来修改，且再次请求put接口，token值还是原先后端设置的值，<strong>所以HttpOnly属性的cookie前端无法修改</strong></li>\n</ol>\n<p><img src=\"../../../images/blog/web/what_cookie_5.png\" alt=\"what_cookie_5.png\"></p>\n<h2 id=\"参考文档\">参考文档</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie\">Document.cookie - Web API 接口参考 | MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie\">Cookie - HTTP Headers | MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies\">HTTP cookies - HTTP | MDN</a></li>\n<li><a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_response_setheader_name_value\">Node.js 设置 Set-Cookie 响应头信息 | Node.js v8.17.0 Documentation</a></li>\n<li><a href=\"https://blog.csdn.net/qq_39207066/article/details/80970668\">HTTP-服务器端CooKie与浏览器端Cookie</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "前端通过document.cookie设置cookie，相关改动会传到后台吗？",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "根据功能点写测试demo"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "document.cookie设置对请求头的影响"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "document.cookie操作方法"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "HTTP cookies后端接口向前端页面写入cookie"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "cookie设置属性详解"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "后端设置'Set-Cookie'响应头对前端的影响"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考文档"
            }
          ]
        }
      ],
      "config": {
        "source": "前端通过document.cookie设置cookie，相关改动会传到后台吗？.md",
        "staticFileName": "document_cookie_edit.html",
        "author": "guoqzuo",
        "createDate": "2020/10/01",
        "description": "首先我们来捋一捋，什么是cookie？与cookie相关的知识点有两个：1. 前端获取/设置cookie，使用 document.cookie 2. HTTP请求与响应相关cookie，我们先下个结论：他们之间是相互关联的，接口响应头设置cookie，会对document.cookie的值产生影响；前端设置docuemnt.cookie也会对请求头cookie值产生影响，但如果后端写到前端的cookie如果使用了HttpOnly属性，前端是无法通过document.cookie做修改的",
        "keywords": "document.cookie设置cookie对接口影响",
        "category": "http与https",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"git将远程仓库a分支合并到b分支\">git将远程仓库A分支合并到B分支</h1>\n<p>假设要将远程分支的 A 分支合并到 B 分支，一般我会先在A分支将B分支merge，再切到B分支，merge A分支。</p>\n<p>以将远程仓库的 dev1.3.4 分支合并到远程的 test1.3.4 分支为例，下面是我一般的合并过程</p>\n<pre><code class=\"language-bash\"># 1. 本地切到 dev1.3.4 分支\n# 2. merge远程的test1.3.4分支，命令如下\ngit merge origin/test1.3.4\n# 3.如果有冲突(conflict)，修改冲突文件\n# 4.修改冲突后提交代码到远程仓库，命令如下\ngit add 修改冲突相关的文件\ngit commit &#39;修改冲突，fix conflict&#39;\ngit push\n# 5.切换到test1.3.4分支\n# 6.merge本地的dev1.3.4，因为本地的dev1.3.4是最新的代码，命令如下\ngit merge dev1.3.4\ngit push</code></pre>\n<p><strong>另外，养成习惯，在git push前，先git pull</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "git将远程仓库A分支合并到B分支"
        }
      ],
      "config": {
        "source": "git将远程仓库A分支合并到B分支.md",
        "staticFileName": "git_merge_branch.html",
        "author": "guoqzuo",
        "createDate": "2020/10/01",
        "description": "假设要将远程分支的 A 分支合并到 B 分支，一般我会先在A分支将B分支merge，再切到B分支，merge A分支。以将远程仓库的 dev1.3.4 分支合并到远程的 test1.3.4 分支为例，下面是我一般的合并过程",
        "keywords": "git远程分支合并,git合并分支",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"objectassgin时是否会忽略nullundefined空字符串\">Object.assgin时是否会忽略null,undefined,空字符串</h1>\n<p>一般我们在需要设置某个对象的多个值时Object.assgin是一种很好的方法，但又怕当某个属性的值为空字符串、null或undefined时，会自动跳过的情况。这里来做一个简单的测试</p>\n<pre><code class=\"language-js\">objA = {a: &#39;a&#39;, b: &#39;b&#39;, c: &#39;c&#39;, d: &#39;d&#39;}\nObject.assign(objA, {a: 1, b: undefined, c: null, d: &#39;&#39;})\nobjA // {a: 1, b: undefined, c: null, d: &quot;&quot;}</code></pre>\n<p><img src=\"../../../images/blog/js/Object_assign.png\" alt=\"Object_assign.png\"></p>\n<p>综上，Object.assgin可以放心用</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Object.assgin时是否会忽略null,undefined,空字符串"
        }
      ],
      "config": {
        "source": "Object.assgin时是否会忽略null,undefined,空字符串.md",
        "staticFileName": "object_assgin.html",
        "author": "guoqzuo",
        "createDate": "2020/10/01",
        "description": "一般我们在需要设置某个对象的多个值时Object.assgin是一种很好的方法，但又怕当某个属性的值为空字符串、null或undefined时，会自动跳过的情况。这里来做一个简单的测试",
        "keywords": "Object.assgin是否会跳过null,undefined,''",
        "category": "JavaScript",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"http请求有哪几种传参方式\">http请求有哪几种传参方式</h1>\n<p>在swagger文档里，有一个传参类型的描述 Parameter Type，一般有四种</p>\n<ul>\n<li>header 通过请求头传参，也就是参数加到首部 headers 里</li>\n<li>path  参数放到url路径里，比如 /user/123 这里 123是用户id</li>\n<li>query 查询参数，也就是url后面 ? 符号之后的传参，一般用于get请求传参，比如 /user/123?a=xx&amp;b=xx</li>\n<li>body 参数放到请求体，一般用于post请求，相对get请求来说，安全性好，可以传的数据更多</li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "http请求有哪几种传参方式"
        }
      ],
      "config": {
        "source": "http请求有哪几种传参方式.md",
        "staticFileName": "http_param_type.html",
        "author": "guoqzuo",
        "createDate": "2020/10/01",
        "description": "在swagger文档里，有一个传参类型的描述 Parameter Type，一般有四种: - header 通过请求头传参，也就是参数加到首部 headers 里 - path  参数放到url路径里，比如 /user/123 这里 123是用户id - query 查询参数，也就是url后面 ? 符号之后的传参，一般用于get请求传参，比如 /user/123?a=xx&b=xx - body 参数放到请求体，一般用于post请求，相对get请求来说，安全性好，可以传的数据更多",
        "keywords": "http请求传参方式,http传参,swagger参数类型",
        "category": "http与https",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"echarts动态改变option里datazoom的值没有实时生效的问题\">echarts动态改变option里dataZoom的值没有实时生效的问题</h1>\n<p>这里我们虽然修改了options的值，但不会实时生效，需要手动调用下echarts实例的resize()方法</p>\n<p>另外在做echarts时，对于自适应缩放的图表，一定要注意在窗口缩放时，重新调用resize()</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "echarts动态改变option里dataZoom的值没有实时生效的问题"
        }
      ],
      "config": {
        "source": "echarts动态改变option里dataZoom的值没有实时生效的问题.md",
        "staticFileName": "echarts_resize.html",
        "author": "guoqzuo",
        "createDate": "2020/10/01",
        "description": "这里我们虽然修改了options的值，但不会实时生效，需要手动调用下echarts实例的resize()方法，另外在做echarts时，对于自适应缩放的图表，一定要注意在窗口缩放时，重新调用resize()",
        "keywords": "echart修改options后没有实时生效的问题",
        "category": "图表可视化",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"git修改上上次的commit信息\">git修改上上次的commit信息</h1>\n<p>由于提交代码时有钩子函数，信息里面没有包含前置的 code 会无法提交。所以如果 commit 信息写的有问题需要修改后才能提交</p>\n<p>对于修改上一次 commit 备注信息，我们可以使用 <code>git commit --amend -m &#39;xxx&#39;</code> 来修改。但它无法修改上上次提交信息，这种情况我们可以使用 rebase 来做处理，下面来做一个测试</p>\n<p>本地做两次提交，第一次提交信息为&quot;测试第一次提交&quot;， 第二次提交信息为 &quot;第二次提交&quot;，先不push，我们需要修改上上次的提交信息，也就是修改&quot;测试第一次提交&quot;的内容</p>\n<pre><code class=\"language-bash\"># 查看git记录\nguoqzuo-mac:fedemo kevin$ git log\ncommit 3814855781da539d21e2072e42a53558587497c6 (HEAD -&gt; master)\nAuthor: guoqzuo &lt;guoqzuo@gmail.com&gt;\nDate:   Mon Aug 10 22:28:15 2020 +0800\n\n    第二次提交\n\ncommit e889c7ecbcb024037701eb48c9bfe3b9c22f9490\nAuthor: guoqzuo &lt;guoqzuo@gmail.com&gt;\nDate:   Mon Aug 10 20:04:27 2020 +0800\n\n    测试第一次提交\n\ncommit d5c2f2f3193cf02d6ac1ae995ca00c4082e36cad (origin/master, origin/HEAD)\nAuthor: guoqzuo &lt;guoqzuo@gmail.com&gt;\nDate:   Mon Aug 10 00:56:34 2020 +0800\n\n    update cookie研究,合并单元格研究demo\n:</code></pre>\n<p>执行 <code>git rebase -i HEAD~2</code>，如下图可以看到最近两次提交，进入一个 vim 编辑页面</p>\n<p><img src=\"../../../images/blog/git/edit_commit_rebase_1.png\" alt=\"edit_commit_rebase_1.png\"></p>\n<p>按ESC, 再按 a 进入INSERT模式, 将上上次提交的信息前的 pick 改为 edit，如下图，按ESC，再按 shift + : 进入命令模式，输入x 或wq保存，不熟悉vim操作的可以搜索下vim教程</p>\n<p><img src=\"../../../images/blog/git/edit_commit_rebase_2.png\" alt=\"edit_commit_rebase_2.png\"></p>\n<p>保存后，终端里会看到下面 log 信息</p>\n<pre><code class=\"language-js\">guoqzuo-mac:fedemo kevin$ git rebase -i HEAD~2\nStopped at e889c7e...  测试第一次提交\nYou can amend the commit now, with\n\n  git commit --amend \n\nOnce you are satisfied with your changes, run\n\n  git rebase --continue\nguoqzuo-mac:fedemo kevin$ </code></pre>\n<p>运行 <code>git commit --amend</code> 会进入下面的修改页面，可以修改上上次的信息</p>\n<p><img src=\"../../../images/blog/git/edit_commit_rebase_3.png\" alt=\"edit_commit_rebase_3.png\"></p>\n<p>这里我们把上上次信息改为 &quot;测试第一次提交,修改第一次提交的内容&quot;，保存后，结果如下</p>\n<pre><code class=\"language-js\">[detached HEAD 45f5911] 测试第一次提交,修改第一次提交的内容\n Date: Mon Aug 10 20:04:27 2020 +0800\n 1 file changed, 2 insertions(+)\nguoqzuo-mac:fedemo kevin$ </code></pre>\n<p>然后运行 <code>git rebase --continue</code>，这样就修改好了</p>\n<pre><code class=\"language-js\">guoqzuo-mac:fedemo kevin$ git rebase --continue\nSuccessfully rebased and updated refs/heads/master.\nguoqzuo-mac:fedemo kevin$ </code></pre>\n<p>再来 git log 看看提交记录，修改上上次的提交信息已ok</p>\n<pre><code class=\"language-js\">guoqzuo-mac:fedemo kevin$ git log\ncommit e498bcabf2d2e4c97f47320e1d72693cb82d9db8 (HEAD -&gt; master)\nAuthor: guoqzuo &lt;guoqzuo@gmail.com&gt;\nDate:   Mon Aug 10 22:28:15 2020 +0800\n\n    第二次提交\n\ncommit 45f591157be44100073de14f5808b816104a8f2b\nAuthor: guoqzuo &lt;guoqzuo@gmail.com&gt;\nDate:   Mon Aug 10 20:04:27 2020 +0800\n\n    测试第一次提交,修改第一次提交的内容\n</code></pre>\n<p>参考：<a href=\"https://www.jianshu.com/p/0f1fbd50b4be\">修改上上次的commit信息</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "git修改上上次的commit信息"
        }
      ],
      "config": {
        "source": "git修改上上次的commit信息.md",
        "staticFileName": "git_edit_commit_info.html",
        "author": "guoqzuo",
        "createDate": "2020/10/01",
        "description": "由于提交代码时有钩子函数，信息里面没有包含前置的 code 会无法提交。所以如果 commit 信息写的有问题需要修改后才能提交。对于修改上一次 commit 备注信息，我们可以使用 `git commit --amend -m 'xxx'` 来修改。但它无法修改上上次提交信息，这种情况我们可以使用 rebase 来做处理，下面来做一个测试，本地做两次提交，第一次提交信息为'测试第一次提交'， 第二次提交信息为 '第二次提交'，先不push，我们需要修改上上次的提交信息，也就是修改'测试第一次提交'的内容",
        "keywords": "git修改commit信息",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"el-input类型为textarea时不能使用v-modeltrim\">el-input类型为textarea时不能使用v-model.trim</h1>\n<p>el-input如果type为textarea，不能使用.trim修饰符，否则输入内容时会无法换行，如果需要去掉收尾空格，可以在提交数据时，手动执行.trim()去空格</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-input\n      type=&quot;textarea&quot;\n      v-model.trim=&quot;text&quot;\n      rows=&quot;5&quot;\n      style=&quot;width:200px;margin:100px;&quot;\n    &gt;&lt;/el-input&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      text: &quot;&quot;\n    };\n  }\n};\n&lt;/script&gt;</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "el-input类型为textarea时不能使用v-model.trim"
        }
      ],
      "config": {
        "source": "el-input类型为textarea时不能使用v-model.trim.md",
        "staticFileName": "textarea_not_trim.html",
        "author": "guoqzuo",
        "createDate": "2020/10/01",
        "description": "el-input如果type为textarea，不能使用.trim修饰符，否则输入内容时会无法换行，如果需要去掉收尾空格，可以在提交数据时，手动执行.trim()去空格",
        "keywords": "textarea不用使用v-model.trim",
        "category": "Vue",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"log对数在前端的应用场景：把文件大小或金额自动添加合适的单位\">log对数在前端的应用场景：把文件大小或金额自动添加合适的单位</h1>\n<p>在写下载/导出文件接口时，由于接口文件数据是流的形式而非buffer，导致total为0，无法获取进度。只能通过loaded知道当前下载了多少字节。前端显示时，怎么给出合适的单位，是KB、MB，还是G？</p>\n<pre><code class=\"language-js\">// Math.pow(2, 0) // B\n// &gt; Math.pow(2, 10) // KB\n// &gt; Math.pow(2, 20) // MB\n// &gt; Math.pow(2, 30) // GB\n// &gt; Math.pow(2, 40) // TB\n// &gt; Math.pow(2, 50) // PB\n// 以此类推...</code></pre>\n<p>可以通过对数来快速确定区间</p>\n<pre><code class=\"language-js\">/**\n * @description 格式化文件size\n * @param { Number } value 文件大小 B 字节\n * @returns 转换后的文件大小及单位数组，保留两位小数\n * @example\n * formatFileSize(100) =&gt;  [100, &quot;B&quot;]\n * formatFileSize(10000) =&gt; [9.77, &quot;KB&quot;]\n * formatFileSize(100000000) =&gt; [95.37, &quot;MB&quot;]\n */\nfunction formatFileSize(value) {\n  let unitArr = [&#39;B&#39;, &#39;KB&#39;, &#39;MB&#39;, &#39;GB&#39;, &#39;TB&#39;, &#39;PB&#39;, &#39;EB&#39;, &#39;ZB&#39;,&#39;YB&#39;]\n  let index = Math.floor(Math.log2(value) / 10) // 计算该value的值为2的多少次方，向下取整\n  // 如果超出范围取最大值\n  if (index &gt; unitArr.length - 1) {\n    index = unitArr.length - 1\n  }\n  let result = value / Math.pow(2, index * 10) // 装换为合适的单位\n  result = (result * 100).toFixed() / 100 \n\n  return [result, unitArr[index]]\n}</code></pre>\n<p>依此类推，假设给定单位为元，将值转换为合适的单位：元/万/亿/兆(万亿)，10的4次方 万，10的8次方 亿，10的12次方 兆</p>\n<pre><code class=\"language-js\">/**\n * @description 格式化人民币\n * @param { Number } value 元\n * @returns 转换后的人民币及单位数组，保留两位小数\n * @example\n * formartMoney(1000) =&gt; [1000, &quot;元&quot;]\n * formartMoney(98000) =&gt; [9.8, &quot;万&quot;]\n * formartMoney(100000000) =&gt; [1, &quot;亿&quot;]\n */\nfunction formartMoney(value) {\n  let unitArr = [&#39;元&#39;, &#39;万&#39;, &#39;亿&#39;, &#39;兆&#39;] \n  let index = Math.floor(Math.log10(value) / 4)\n  // 如果超出范围取最大值\n  if (index &gt; unitArr.length - 1) {\n    index = unitArr.length - 1\n  }\n  let result = value / Math.pow(10, index * 4) // 装换为合适的单位\n\n  result = (result * 100).toFixed() / 100 \n\n  return [result, unitArr[index]]\n}</code></pre>\n<p>扩展：</p>\n<ul>\n<li><a href=\"https://zhidao.baidu.com/question/542103416.html\">KB,MB,GB,TB,在往上是什么单位呢</a></li>\n<li><a href=\"https://zhidao.baidu.com/question/70310844.html\">万亿上面是什么数位</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "log对数在前端的应用场景：把文件大小或金额自动添加合适的单位"
        }
      ],
      "config": {
        "source": "log对数在前端的应用场景：把文件大小或金额自动添加合适的单位.md",
        "staticFileName": "log_web.html",
        "author": "guoqzuo",
        "createDate": "2020/10/08",
        "description": "在写下载/导出文件接口时，由于接口文件数据是流的形式而非buffer，导致total为0，无法获取进度。只能通过loaded知道当前下载了多少字节。前端显示时，怎么给出合适的单位，是KB、MB，还是G？",
        "keywords": "文件大小转换合适单位,单位元数据加合适的单位",
        "category": "JavaScript",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"节流与防抖理解以及element源码中节流与防抖的应用\">节流与防抖理解以及element源码中节流与防抖的应用</h1>\n<blockquote>\n<p>该内容存在理解错误，最新修正笔记参考：<a href=\"/blog/2021/4/easy_throttle_debounce.html\">用游戏中的场景理解节流与防抖，最简单的 js 实现</a></p>\n</blockquote>\n<p>理论上 throttle 节流一般用于监听类似 resize 方法，想要减少执行频率的场景。对于点击按钮提交，防止短时间内多次点击可以用 debounce 防抖</p>\n<p>但实际使用时可根据具体情况来看，本质上都是利用 setTimeout 来处理执行频率或执行间隔。下面是一个简单的 lodash 防抖示例，300ms 内放置重复点击</p>\n<pre><code class=\"language-js\">import { debounce } from &#39;lodash&#39;\nexport default {\n  methods: {\n    submitFormDebounce: debounce(function() {\n      console.log(&#39;submit&#39;, +new Date())\n      this.submitForm()\n    }, 300, {trailing: true}),\n\n    submitForm() {\n\n    }\n  }\n}</code></pre>\n<h2 id=\"element源码中节流与防抖的应用\">element源码中节流与防抖的应用</h2>\n<p>在做input搜索时，由于input change后需要请求接口，这里el-autocomplete有个默认的300豪秒debounce，可以减少请求频率。理论上这里减少频率需要使用节流，但为什么是防抖呢？</p>\n<p>我们把 element 源码中对节流防抖的使用都找一找。可以看到element使用的节流防抖库是 <code>throttle-debounce</code></p>\n<p>发现节流 throttle 用的比较少，只找到了三个地方：</p>\n<pre><code class=\"language-js\">// Backtop 回到顶部\n// packages/backtop/src/main.vue  滚动监听时用到了节流\nimport throttle from &#39;throttle-debounce/throttle&#39;;\nmounted() {\n  this.init();\n  this.throttledScrollHandler = throttle(300, this.onScroll);\n  this.container.addEventListener(&#39;scroll&#39;, this.throttledScrollHandler);\n},\n\n// Carousel 走马灯 \n// packages/carouse/src/main.vue 鼠标hover，箭头点击使用了节流\nimport throttle from &#39;throttle-debounce/throttle&#39;;\ncreated() {\n  this.throttledArrowClick = throttle(300, true, index =&gt; {\n    this.setActiveItem(index);\n  });\n  this.throttledIndicatorHover = throttle(300, index =&gt; {\n    this.handleIndicatorHover(index);\n  });\n},\n\n// Image 图片 滚动到区域懒加载时，使用了节流\nif (_scrollContainer) {\n  this._scrollContainer = _scrollContainer;\n  this._lazyLoadHandler = throttle(200, this.handleLazyLoad);\n  on(_scrollContainer, &#39;scroll&#39;, this._lazyLoadHandler);\n  this.handleLazyLoad();\n}</code></pre>\n<p>再来看看防抖的地方</p>\n<p><img src=\"../../../images/blog/js/el_debounce.png\" alt=\"el_debounce.png\"></p>\n<p><strong>总结：涉及到接口请求次数限制的基本都是防抖，对于滚动类别防止多次执行的情况才用节流，其他请求一律防抖</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "节流与防抖理解以及element源码中节流与防抖的应用",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "element源码中节流与防抖的应用"
            }
          ]
        }
      ],
      "config": {
        "source": "节流与防抖理解以及element源码中节流与防抖的应用.md",
        "staticFileName": "throttle_debounce.html",
        "author": "guoqzuo",
        "createDate": "2020/10/08",
        "description": "理论上 throttle 节流一般用于监听类似 resize 方法，想要减少执行频率的场景。对于点击按钮提交，防止短时间内多次点击可以用 debounce 防抖，但实际使用时可根据具体情况来看，本质上都是利用 setTimeout 来处理执行频率或执行间隔。下面是一个简单的 loadash 防抖示例，300ms 内放置重复点击",
        "keywords": "节流与防抖,element中节流防抖的应用",
        "category": "Vue",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"怎么开发vscode插件\">怎么开发vscode插件</h1>\n<p>在vue-cli项目中，每次修改vue.config.js都需要手动停止在运行，怎么一键就搞定呢？能不能开发个vscode插件</p>\n<p>带着这个问题，来看看vscode插件的开发。直接找vscode官方教程。按照文档先来跑一个hello word</p>\n<pre><code class=\"language-bash\"># Install Yeoman and VS Code Extension Generator with:\nnpm install -g yo generator-code</code></pre>\n<p>运行yo code，生成一个脚手架项目</p>\n<pre><code class=\"language-bash\">guoqzuo-mac:vscodeExtension kevin$ yo code\n\n     _-----_     ╭──────────────────────────╮\n    |       |    │   Welcome to the Visual  │\n    |--(o)--|    │   Studio Code Extension  │\n   `---------´   │        generator!        │\n    ( _´U`_ )    ╰──────────────────────────╯\n    /___A___\\   /\n     |  ~  |     \n   __&#39;.___.&#39;__   \n ´   `  |° ´ Y ` \n\n? What type of extension do you want to create? New Extension (TypeScript)\n? What&#39;s the name of your extension? zuo-restart\n? What&#39;s the identifier of your extension? zuo-restart\n? What&#39;s the description of your extension? A plugin use to auto restart vue.con\nfig.js\n? Initialize a git repository? Yes\n? Which package manager to use? npm\n\nYour extension zuo-restart has been created!\n\nTo start editing with Visual Studio Code, use the following commands:\n\n     cd zuo-restart\n     code .\n\nOpen vsc-extension-quickstart.md inside the new extension for further instructions\non how to modify, test and publish your extension.\n\nFor more information, also visit http://code.visualstudio.com and follow us @code.</code></pre>\n<p>这样会创建一个空的项目，只注册了helloworld命令，我们按照 vsc-extension-quickstart.md 里的说明运行demo</p>\n<p>按F5，进入如下页面，但并没有像官网上的视频那样弹一个新的插件调试窗口，一直在运行中</p>\n<p><img src=\"../../../images/blog/devtools/vscode_plugin_1.png\" alt=\"vscode_plugin_1.png\"></p>\n<p>网上说要装一个 run code的 vscode插件，也装了。后面发现还是不行，点击正在生成，ctrl + c 就弹出一个名为 &quot;扩展开发宿主&quot; 的新窗口了，里面可以调试插件，如下图</p>\n<p><img src=\"../../../images/blog/devtools/vscode_plugin_2.png\" alt=\"vscode_plugin_2.png\"></p>\n<p>生成项目的入口是 extension.ts，他默认注册了一个helloword命令，我们输入命令就会显示一个弹窗消息</p>\n<pre><code class=\"language-js\">// The module &#39;vscode&#39; contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from &#39;vscode&#39;;\n\n// this method is called when your extension is activated\n// your extension is activated the very first time the command is executed\nexport function activate(context: vscode.ExtensionContext) {\n\n    // Use the console to output diagnostic information (console.log) and errors (console.error)\n    // This line of code will only be executed once when your extension is activated\n    console.log(&#39;Congratulations, your extension &quot;zuo-restart&quot; is now active!&#39;);\n\n    // The command has been defined in the package.json file\n    // Now provide the implementation of the command with registerCommand\n    // The commandId parameter must match the command field in package.json\n    let disposable = vscode.commands.registerCommand(&#39;zuo-restart.helloWorld&#39;, () =&gt; {\n        // The code you place here will be executed every time your command is executed\n\n        // Display a message box to the user\n        vscode.window.showInformationMessage(&#39;Hello World from zuo-restart!&#39;);\n    });\n\n    context.subscriptions.push(disposable);\n}\n\n// this method is called when your extension is deactivated\nexport function deactivate() {}\n</code></pre>\n<p>我们在插件调试窗口跑下hello world命令</p>\n<p><img src=\"../../../images/blog/devtools/vscode_plugin_3.png\" alt=\"vscode_plugin_3.png\"></p>\n<p>出现如下弹窗消息，就说明跑的没问题了</p>\n<p><img src=\"../../../images/blog/devtools/vscode_plugin_4.png\" alt=\"vscode_plugin_4.png\"></p>\n<p>这样hellowrod就跑起来了，vsc-extension-quickstart.md 里面有构架、发布插件的文档说明</p>\n<p>官网提供了一些简单的demo，可以练练手，<a href=\"https://github.com/microsoft/vscode-extension-samples\">vscode-extension-samples | github</a>，后续有时间了继续研究</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://code.visualstudio.com/api\">Extension API | Visual Studio Code Extension API</a></li>\n<li><a href=\"https://code.visualstudio.com/api/get-started/your-first-extension\">Get Started - Your First Extension</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/99198980\">VSCode插件开发入门</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "怎么开发vscode插件"
        }
      ],
      "config": {
        "source": "怎么开发vscode插件?.md",
        "staticFileName": "vscode_plugin.html",
        "author": "guoqzuo",
        "createDate": "2020/10/08",
        "description": "在vue-cli项目中，每次修改vue.config.js都需要手动停止在运行，怎么一键就搞定呢？能不能开发个vscode插件，带着这个问题，来看看vscode插件的开发。直接找vscode官方教程。按照文档先来跑一个hello word",
        "keywords": "vscode插件",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"element表单中，人数输入框怎么限制只能输入正整数\">element表单中，人数输入框怎么限制只能输入正整数</h1>\n<p>在人数这一栏，输入时，前端需要确保输入的只能是正整数，且不能是负数，且自动校正，来看看怎么实现</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    只能输入正整数: {{ peopleCount }}\n    &lt;el-input\n      v-model=&quot;peopleCount&quot;\n      @keyup.native=&quot;keyUp&quot;\n      style=&quot;width:200px;margin:50px;&quot;\n    &gt;&lt;/el-input&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      peopleCount: &quot;&quot;\n    };\n  },\n  methods: {\n    keyUp(e) {\n      // 非数字全部转换为&#39;&#39;\n      e.target.value = e.target.value.replace(/[^\\d]/g, &quot;&quot;);\n      // 开始的0处理\n      if ([0, &quot;0&quot;].includes(e.target.value)) {\n        e.target.value = &quot;&quot;;\n      }\n      this.peopleCount = e.target.value;\n      return e.target.value;\n    }\n  }\n};\n&lt;/script&gt;</code></pre>\n<p>有了上面的思路后，对于万元输入框怎么限制只能输入最多保留两位小数点的number类型数据，可以思考下</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "element表单中，人数输入框怎么限制只能输入正整数"
        }
      ],
      "config": {
        "source": "element表单中，人数输入框怎么限制只能输入正整数.md",
        "staticFileName": "people_num.html",
        "author": "guoqzuo",
        "createDate": "2020/10/08",
        "description": "在人数这一栏，输入时，前端需要确保输入的只能是正整数，且不能是负数，且自动校正，来看看怎么实现",
        "keywords": "element只能输入正整数",
        "category": "Vue",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"echarts饼图label两端对齐label距离引导线距离\">echarts饼图label两端对齐label距离引导线距离</h1>\n<p>在对 echarts 饼图label做自定义时，可以通过label选项的 distanceToLabelLine 设置 label 距离引导线距离、alignTo 设置两端对齐。注意echarts版本要是 v4.6 + ，下面来看示例</p>\n<pre><code class=\"language-js\">// 两端对齐 + 引导线距离\n{\nname: &#39;访问来源&#39;,\ntype: &#39;pie&#39;,\nminAngle: 90, // label最小扇区大小\nlabel: {\n    normal: {\n        alignTo: &#39;edge&#39;, // label两端对称布局\n        //  ECharts v4.6.0 版本起，提供了 &#39;labelLine&#39; 与 &#39;edge&#39; 两种新的布局方式\n        margin: 90, // 布局为两端对称时候需要外边距防止图表变形 数值随意不要太大\n        distanceToLabelLine: 0, // label距离引导线距离\n        formatter: function(param) {\n            return &#39;{a|&#39; + param.name + &#39;}\\n{hr|}\\n&#39; + &#39;{d|&#39; + param.value + &#39;}&#39;;\n        },\n        rich: {\n            a: {\n                padding: [4, 10, 0, 10],  // 4边距是文字和hr间距，此处的边距10用于解决label和引导线有间距问题\n                color: &#39;blue&#39;\n            },\n            d: {\n                padding: [0, 10, 4, 10],\n                color: &#39;purple&#39;\n            },\n            hr: {\n                borderWidth: 1,\n                width: &#39;100%&#39;,\n                height: 0,\n                borderColor: &#39; &#39;\n            }\n        }\n    },\n\n}\n\n// 分隔线上线显示内容 \nlabel: {\n    normal: {\n        formatter: &#39;{font|{c}}\\n{hr|}\\n{font|{d}%}&#39;,\n        rich: {\n            font: {\n                fontSize: 20,\n                padding: [5, 0],\n                color: &#39;#fff&#39;\n            },\n            hr: {\n                height: 0,\n                borderWidth: 1,\n                width: &#39;100%&#39;,\n                borderColor: &#39;#fff&#39;\n            }\n        }\n    },\n},\nlabelLine: {\n    lineStyle: {\n        color: &#39;#fff&#39;\n    }\n}</code></pre>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://gallery.echartsjs.com/editor.html?c=x1TVKFGtZ1\">饼图标签两端对称效果</a></li>\n<li><a href=\"https://gallery.echartsjs.com/editor.html?c=xtv96q-x7e\">南丁格尔 + 折线上下内容显示</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "echarts饼图label两端对齐label距离引导线距离"
        }
      ],
      "config": {
        "source": "echarts饼图label两端对齐label距离引导线距离.md",
        "staticFileName": "echarts_label.html",
        "author": "guoqzuo",
        "createDate": "2020/10/08",
        "description": "在对 echarts 饼图label做自定义时，可以通过label选项的 distanceToLabelLine 设置 label 距离引导线距离、alignTo 设置两端对齐。注意echarts版本要是 v4.6 + ，下面来看示例",
        "keywords": "echarts label两端对齐,引导线距离",
        "category": "图表可视化",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"什么是好的代码？\">什么是好的代码？</h1>\n<p>在web前端方面，什么是好的代码？好的代码应该包含以下两个特性</p>\n<ul>\n<li>高性能，低时延（性能优化）<ul>\n<li>熟悉数据结构与算法，减少时间复杂度或空间复杂度</li>\n<li>熟悉浏览器渲染基本原理、熟悉HTTP请求与响应细节、熟悉前端框架源码、减少不必要的渲染开销，提高加载速度</li>\n</ul>\n</li>\n<li>可读性、可维护性、可扩展性<ul>\n<li>熟悉设计模式，封装变化。代码高内聚、低耦合、指责单一、高度复用。写出好维护、好迭代、好扩展的代码</li>\n<li>化繁为简，形成特定代码规范，注意命名、注释。写出人能看懂的代码，不做骚操作。尽量保持简单、易懂，在可扩展性和简单之间寻找平衡</li>\n</ul>\n</li>\n</ul>\n<p>前端只要不是写框架，性能问题会很少遇到。简单来讲，在实现功能的基础上，代码简单、易懂、好维护迭代就很好了。技术始终是为业务需求服务的。基础建设是很重要的一个环节，这样有利于快速迭代开发</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "什么是好的代码？"
        }
      ],
      "config": {
        "source": "什么是好的代码？.md",
        "staticFileName": "good_code.html",
        "author": "guoqzuo",
        "createDate": "2020/10/08",
        "description": "在web前端方面，什么是好的代码？好的代码应该包含以下两个特性：高性能，低时延（性能优化），熟悉数据结构与算法，减少时间复杂度或空间复杂度，悉浏览器渲染基本原理、熟悉HTTP请求与响应细节、熟悉前端框架源码、减少不必要的渲染开销，提高加载速度。可读性、可维护性、可扩展性",
        "keywords": "前端什么是好代码,什么是好的代码",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"用node实现发送包含echarts图表的邮件\">用node实现发送包含echarts图表的邮件</h1>\n<p>在之前我用node研究过怎么收发邮件，但没有研究过邮件里面是否能包含图表，这次来研究下</p>\n<p>首先，我们来看看怎么发邮件</p>\n<h2 id=\"准备工作：配置发件人邮箱\">准备工作：配置发件人邮箱</h2>\n<p>我们发送邮件，首先需要有一个邮箱作为发件人，以QQ邮箱为例，我们发邮件使用 <code>916707888@qq.com</code> 作为发件人，我们需要使用程序自动发邮件，所以需要配置发邮件的服务，开启发邮件的POP3/SMTP服务，得到授权码在操作，下面来看看具体过程</p>\n<p>登录到qq邮箱，进入管理页面，在设置 - POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务位置，开启POP3/SMTP服务</p>\n<p>开启服务后，会得到POP3和IMAP授权码，一个用来收邮件一个用来发邮件，保存好</p>\n<p><img src=\"../../../images/blog/node/node_email_1_qqmail.png\" alt=\"qq邮箱开启服务\"></p>\n<p>gmail邮箱配置</p>\n<p><img src=\"../../../images/blog/node/node_email_2_gmail.png\" alt=\"gmail.png\"></p>\n<h2 id=\"使用nodemailer来发送邮件\">使用nodemailer来发送邮件</h2>\n<p>使用 <a href=\"https://github.com/nodemailer/nodemailer\">nodemailer</a> 来发送邮件，首先开一个koa demo</p>\n<pre><code class=\"language-js\">const Koa = require(&#39;koa&#39;)\nconst Router = require(&#39;koa-router&#39;)\nconst app = new Koa()\nconst router = new Router()\n\n/**\n * @description 使用nodemailer发送邮件\n * @example\n * POST http://127.0.0.1:9000/sendEmail\n */\nrouter.get(&#39;/sendEmail&#39;, async ctx =&gt; {\n  try {\n    let sendEmail = require(&#39;./sendEmail/index.js&#39;)\n    await sendEmail()\n    ctx.body = {\n      msg: &#39;成功&#39;\n    }\n  } catch (e) {\n    ctx.body = {\n      msg: e.message\n    }\n  }\n})\n\napp.use(router.routes())\napp.listen(&#39;9000&#39;, () =&gt; {\n  console.log(&#39;server start on 9000 port&#39;)\n})</code></pre>\n<p>发邮件核心代码 sendEmail/index.js</p>\n<pre><code class=\"language-js\">const nodemailer = require(&#39;nodemailer&#39;);\n\nfunction sendEmail() {\n  return new Promise((resolve, rejected) =&gt; {\n    // create reusable transport method (opens pool of SMTP connections)\n    let smtpTransport = nodemailer.createTransport({\n      host: &quot;smtp.qq.com&quot;, //qq smtp服务器地址, 如果是其他邮箱需要修改为对应的服务器\n      secureConnection: false, //是否使用安全连接，对https协议的\n      port: 465, //qq邮件服务所占用的端口\n      auth: {\n        user: &quot;916707888@qq.com&quot;, //开启SMTP的邮箱，有用发送邮件\n        pass: &quot;rorvinuqemsybccc&quot; // qq POP3/SMTP授权码，如果是gmail，直接填密码\n      }\n    });\n\n    // setup e-mail data with unicode symbols\n    let mailOptions = {\n      from: &quot;guoqzuo &lt;i@zuoguoqing.com&gt;&quot;, // sender address\n      to: &quot;i@zuoguoqing.com, zuoguoqing@aliyun.com&quot;, // list of receivers\n      subject: &quot;邮箱验证码&quot;, // Subject line\n      text: `Hello，您的验证码是 1212323`, // plaintext body\n      // html body\n      html: `\n            Hello，您的验证码是\n            &lt;img src=&quot;https://iknow-pic.cdn.bcebos.com/adaf2edda3cc7cd96b1584973701213fb80e9140?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1&quot;&gt;\n            &lt;img src=&quot;http://www.zuo11.com/images/blog/web/qrcode.jpg&quot;&gt;\n\n            &lt;div&gt;\n              &lt;span style=&quot;color:red;&quot;&gt;1243&lt;/span&gt;\n              &lt;div style=&quot;margin:50px;border:1px solid #ccc;height: 100px;widht:100px;&quot;&gt;1243&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;\n            &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;\n            &lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha384-i+fXrQ+G3+h2478EWpSpIXivtKbbze+0SNOXJGizkAp6DVG/m2fE6hiWeDwskVvp&quot; src=&quot;https://lib.baomitu.com/echarts/4.7.0/echarts.js&quot;&gt;&lt;/script&gt;\n            &lt;script type=&quot;text/javascript&quot;&gt;\n                // 基于准备好的dom，初始化echarts实例\n                var myChart = echarts.init(document.getElementById(&#39;main&#39;));\n\n                // 指定图表的配置项和数据\n                var option = {\n                    title: {\n                        text: &#39;ECharts 入门示例&#39;\n                    },\n                    tooltip: {},\n                    legend: {\n                        data:[&#39;销量&#39;]\n                    },\n                    xAxis: {\n                        data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]\n                    },\n                    yAxis: {},\n                    series: [{\n                        name: &#39;销量&#39;,\n                        type: &#39;bar&#39;,\n                        data: [5, 20, 36, 10, 10, 20]\n                    }]\n                };\n\n                // 使用刚指定的配置项和数据显示图表。\n                myChart.setOption(option);\n            &lt;/script&gt;\n          `\n    }\n\n    // send mail with defined transport object\n    smtpTransport.sendMail(mailOptions, function (error, response) {\n      if (error) {\n        rejected(error);\n      } else {\n        console.log(&quot;Message sent: &quot; + response.message);\n        // 发送成功\n        console.log(&#39;邮件发送成功&#39;);\n        resolve(&#39;发送成功&#39;);\n      }\n      // if you don&#39;t want to use this transport object anymore, uncomment following line\n      smtpTransport.close(); // shut down the connection pool, no more messages\n    });\n  });\n}\n\nmodule.exports = sendEmail</code></pre>\n<p>上面发送的是html富文本，发送后，可以看到，简单的css样式，图片是可以发送的，但js是无法执行，如下图</p>\n<p><img src=\"../../../images/blog/node/node_email_3_send.png\" alt=\"send_mail_png.png\"></p>\n<h2 id=\"使用接口生成echarts图片\">使用接口生成echarts图片</h2>\n<p>在上面的例子中，我们知道无法执行js，也就是无法直接在邮箱使用canvas绘图，那么我们可以换个思路，通过一个src，get请求在后端生成echarts图片</p>\n<p>怎么在后端用node把echart渲染出来并生成图片呢？这里用到了 <code>node-charts</code> 模块，它使用 puppeteer 来进行渲染截图</p>\n<pre><code class=\"language-js\">/**\n * @description 根据接口生成echarts图片\n * @example\n * GET http://127.0.0.1:9000/png?type=a\n * GET http://127.0.0.1:9000/png?type=b\n */\nrouter.get(&#39;/png&#39;, async ctx =&gt; {\n  try {\n    let getEchartsPng = require(&#39;./echartsPng/index.js&#39;)\n    let optionsA = require(&#39;./echartsPng/optionsA.js&#39;)\n    let optionsB = require(&#39;./echartsPng/optionsB.js&#39;)\n    let data = await getEchartsPng(ctx.query.type === &#39;a&#39; ? optionsA : optionsB)\n    ctx.set({\n      &#39;content-type&#39;: &#39;image/png&#39;\n    })\n    ctx.body = data\n  } catch (e) {\n    console.log(e)\n    ctx.body = {\n      msg: e.message\n    }\n  }\n})</code></pre>\n<p>渲染相关逻辑，这样通过接口就可以直接访问一张echart的图片了</p>\n<pre><code class=\"language-js\">const NodeCharts = require(&#39;node-charts&#39;);\n\nfunction getEchartsPng(options) {\n  return new Promise((resolve, reject) =&gt; {\n    let nc = new NodeCharts();\n    //监听全局异常事件\n    nc.on(&#39;error&#39;, (err) =&gt; {\n      reject(err)\n    });\n    nc.render(options, (err, data) =&gt; {\n      if (err) {\n        reject(err)\n      }\n      resolve(data)\n    }, {\n      type: &#39;echarts&#39;\n    })\n  })\n}\n\nmodule.exports = getEchartsPng</code></pre>\n<p>请求截图</p>\n<p><img src=\"../../../images/blog/node/node_email_4_img.png\" alt=\"node_echarts_img.png\"></p>\n<p>完成demo，参见github: <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/DebugDemo/%E7%94%A8%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81echarts%E5%9B%BE%E8%A1%A8\">用邮件发送echarts图表</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "用node实现发送包含echarts图表的邮件",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "准备工作：配置发件人邮箱"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "使用nodemailer来发送邮件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "使用接口生成echarts图片"
            }
          ]
        }
      ],
      "config": {
        "source": "用node实现发送包含echarts图表的邮件.md",
        "staticFileName": "node_email.html",
        "author": "guoqzuo",
        "createDate": "2020/10/08",
        "description": "在之前我用node研究过怎么收发邮件，但没有研究过邮件里面是否能包含图表，这次来研究下。首先，我们来看看怎么发邮件，准备工作：配置发件人邮箱 我们发送邮件，首先需要有一个邮箱作为发件人，以QQ邮箱为例，我们发邮件使用 `916707888@qq.com` 作为发件人，我们需要使用程序自动发邮件，所以需要配置发邮件的服务，开启发邮件的POP3/SMTP服务，得到授权码在操作，下面来看看具体过程",
        "keywords": "node发邮件,node发送图表邮件,node发送echart图表邮件",
        "category": "前端工程化",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"前端代码规范风格指南\">前端代码规范风格指南</h1>\n<p>功能组件、目录结构</p>\n<pre><code class=\"language-js\">// 新建文件夹，命名以小写字母开头，驼峰命名\n- moduleA // 模块A目录\n  - comps // 组件目录\n    - CustomerRefuse.vue // 单文件组件命名规则，参考vue风格指南\n    // 如果组件内容较多，创建一个文件夹\n    // 命名以npm包命名规则一致，全小写、-分隔，建议不超过3个单词\n    - no-permission\n      - src // 其他资源目录，参考Element组件源码\n      - index.vue // 入口或者使用index.js 方便 Vue.use 引入\n  - index.vue // 模块A入口</code></pre>\n<p>Vue、HTML、JS、CSS编码风格</p>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/style-guide/\">Vue风格指南</a></li>\n<li><a href=\"https://codeguide.bootcss.com/\">Bootstrap 编码规范: 编写一致、灵活和可持续的 HTML 和 CSS 代码的规范。</a></li>\n<li><a href=\"http://google.github.io/styleguide/jsguide.html\">Google JavaScript Style Guide</a></li>\n<li><a href=\"https://github.com/airbnb/javascript\">Airbnb JS风格指南</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "前端代码规范风格指南"
        }
      ],
      "config": {
        "source": "前端代码规范风格指南.md",
        "staticFileName": "fe_style.html",
        "author": "guoqzuo",
        "createDate": "2020/10/08",
        "description": "新建文件夹，命名以小写字母开头，驼峰命名，单文件组件命名规则，参考vue风格指南。如果组件内容较多，创建一个文件夹，命名以npm包命名规则一致，全小写、-分隔，建议不超过3个单词。其他资源目录，参考Element组件源码",
        "keywords": "前端代码规范,前端命名规范",
        "category": "Vue",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"filereaderreadasdataurl与urlcreateobjecturl的区别\">FileReader.readAsDataURL与URL.createObjectURL的区别</h1>\n<p>在前端开发中，这两个函数都是可以用于处理文件二进制数据的，一般用于上传文件时预览图片，或者在下载、导出文件时使用。</p>\n<p>下面来以上传图片、前端预览图片的功能为例，比较两个函数的的区别</p>\n<p><img src=\"../../../images/blog/js/img_preview.gif\" alt=\"img_preview.gif\"></p>\n<p>下面的代码中，我们使用一个 radio 来切换使用两种方法。当检测到上传文件的 input 内容 change 后，根据当前 radio 的值，调用不同的方法来预览图片。运行效果如上图</p>\n<pre><code class=\"language-js\">&lt;div&gt;\n  &lt;form id=&quot;form&quot;&gt;\n    &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;type&quot; value=&quot;a&quot; checked&gt;URL.createObjectURL&lt;/label&gt;\n    &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;type&quot; value=&quot;b&quot;&gt;FileReader.readAsDataURL&lt;/label&gt;\n  &lt;/form&gt;\n&lt;/div&gt;\n&lt;input type=&quot;file&quot; id=&quot;file&quot;&gt;\n&lt;div&gt;&lt;img src=&quot;&quot; id=&quot;img&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;imgSrc&quot;&gt;&lt;/div&gt;\n&lt;script&gt;\n  let file = document.getElementById(&#39;file&#39;)\n  file.onchange = function (e) {\n    let funcType = document.getElementById(&#39;form&#39;).type.value\n    if (funcType === &#39;a&#39;) {\n      // 方法1 \n      // blob:http://127.0.0.1:5501/dffc0dee-93e7-4b8f-bee2-8a3b8671aeb2\n      let dataUrl = window.URL.createObjectURL(this.files[0])\n      document.getElementById(&#39;img&#39;).src = dataUrl\n      document.querySelector(&#39;#imgSrc&#39;).innerHTML = dataUrl\n    } else {\n      // 方法2 \n      // data:image/png;base64,iVBORw0KGgoAAA....\n      let reader = new FileReader();\n      reader.readAsDataURL(this.files[0])\n      reader.onload = function (e) {\n        document.getElementById(&#39;img&#39;).src = reader.result\n        document.querySelector(&#39;#imgSrc&#39;).innerHTML = reader.result\n      }\n    }\n  }\n&lt;/script&gt;</code></pre>\n<p>有上面的例子可以得出 </p>\n<ul>\n<li>readAsDataURL 它是将二进制文件数据转成了 URI，base64数据。</li>\n<li>createObjectURL 它是二进制文件数据转成了临时的 URL，是 URL 链接。 </li>\n</ul>\n<p>这里假设我们拿到数据后，进行下载，一般使用 a 标签，再 click。如果是 IE，使用 window.navigator.msSaveBlob。假设我们使用下面的函数来进行下载。如果createObjectURL 生成的 URL，是没问题的，但如果是 readAsDataURL 生成的 base64 就会出现兼容性问题、卡顿问题。</p>\n<p>因此在图片预览时可以使用 FileReader.readAsDataURL，但下载文件时，就需要使用 URL.createObjectURL 了。</p>\n<pre><code class=\"language-js\">    function downloadFile(dataUrl) {\n      // 如果是IE，特殊处理，防止IE下提提示 &quot;拒绝访问&quot;\n      // blob拒绝访问文件 fix\n      if (window.navigator.msSaveBlob) {\n        try {\n          // 根据实际情况加后缀名\n          window.navigator.msSaveBlob(dataUrl, &#39;下载文件.zip&#39;)\n        } catch(e) {\n          console.log(&#39;msSaveBlob异常&#39;, e)\n        }\n        return\n      } \n      const downloadEl = document.createElement(&#39;a&#39;)\n      downloadEl.href = dataUrl\n      downloadEl.download = &#39;下载文件&#39; // download文件名\n      document.body.appendChild(downloadEl)\n      downloadEl.click() \n    }</code></pre>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsDataURL\">FileReader.readAsDataURL() | MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL\">URL.createObjectURL() | MDN</a></li>\n<li><a href=\"https://www.yuque.com/guoqzuo/js_es6/nocthb#97824fad\">File API - 新兴的API | JS高程3笔记</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "FileReader.readAsDataURL与URL.createObjectURL的区别"
        }
      ],
      "config": {
        "source": "FileReader.readAsDataURL与URL.createObjectURL的区别.md",
        "staticFileName": "file_preview_download.html",
        "author": "guoqzuo",
        "createDate": "2020/10/25",
        "description": "在前端开发中，这两个函数都是可以用于处理文件二进制数据的，一般用于上传文件时预览图片，或者在下载、导出文件时使用。下面来以上传图片、前端预览图片的功能为例，比较两个函数的的区别。下面的代码中，我们使用一个 radio 来切换使用两种方法。当检测到上传文件的 input 内容 change 后，根据当前 radio 的值，调用不同的方法来预览图片。运行效果如上图",
        "keywords": "文件预览,文件下载函数,createObjectURL,readAsDataURL",
        "category": "JavaScript",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"el-tabs跳转之前先弹窗确认后再切到tab页\">el-tabs跳转之前先弹窗确认后再切到tab页</h1>\n<p>增加 before-leave 钩子函数，如果返回 false，就不会跳转过去。它的返回值除了支持true，false外，还支持 promise 的 resolve 和 reject。我们可以将调用js弹窗组件函数改为promise，如果非提交表单关闭弹窗就返回 reject。否则 resove 表单数据。调用该函数时使用try catch可以很好的处理筛选组件弹窗确定后再跳转到对应tab的逻辑。</p>\n<p><img src=\"../../../images/blog/vue/before-leave.png\" alt=\"before-leave.png\"></p>\n<p>参考：<a href=\"https://element.eleme.cn/#/zh-CN/component/tabs\">Tabs Attributes | Tab标签页</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "el-tabs跳转之前先弹窗确认后再切到tab页"
        }
      ],
      "config": {
        "source": "el-tabs跳转之前先弹窗确认后再切到tab页.md",
        "staticFileName": "el-tabs-confirm.html",
        "author": "guoqzuo",
        "createDate": "2020/10/25",
        "description": "增加 before-leave 钩子函数，如果返回 false，就不会跳转过去。它的返回值除了支持true，false外，还支持 promise 的 resolve 和 reject。我们可以将调用js弹窗组件函数改为promise，如果非提交表单关闭弹窗就返回 reject。否则 resove 表单数据。调用该函数时使用try catch可以很好的处理筛选组件弹窗确定后再跳转到对应tab的逻辑。",
        "keywords": "el-tabs阻止切换钩子函数,el-tabs跳转前确认",
        "category": "Vue",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"怎么写出类似element官网那样可以看代码运行效果的文档\">怎么写出类似element官网那样可以看代码运行效果的文档</h1>\n<p>对于UI组件、echarts 图表相关文档来说，能够实时看具体显示效果是必须的。它是将文档和 demo 合并在一起，这样更有说服力。那怎么写出类似的文档呢？这里来介绍三种方法：</p>\n<ol>\n<li>dosify </li>\n<li>vuepress </li>\n<li>element官网源码</li>\n</ol>\n<h2 id=\"docsify\">docsify</h2>\n<p>一个神奇的文档网站生成器，支持 markdown 语法，可嵌入 vue 代码。基础用法可以参考文档: <a href=\"https://docsify.js.org/#/quickstart\">docsify </a>，这里介绍下嵌入vue代码需要注意的问题</p>\n<p>由于 docsify 入口是 index.html，本身不支持 ES modules，假设 vue 示例代码中，需要引入 echarts 模块，是无法 import 直接运行的。需要通过在 index.html 引入 js 来引入组件。有一个比较好的示例，可以参考 <a href=\"https://vueblocks.github.io/ve-charts/#/chart-line\">ve-charts</a>, 可以把源码 clone 下来跑一跑。通过 <code>npm run build:lib</code> 打包生成 umd 形式的 js文件，直接引入即可。</p>\n<pre><code class=\"language-html\">&lt;!-- index.html部分代码 --&gt;\n&lt;script src=&quot;//cdn.jsdelivr.net/npm/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;\n&lt;!-- vuep docsify插件，用于实时编辑、显示代码 --&gt;\n&lt;script src=&quot;//cdn.jsdelivr.net/npm/vuep/dist/vuep.min.js&quot;&gt;&lt;/script&gt;\n&lt;!-- vuep默认是CommonJS规范，需要使用 module.exports，加babel后可以使用ES Modules的export default --&gt;\n&lt;script src=&quot;https://unpkg.com/babel-standalone/babel.min.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;//unpkg.com/echarts@latest/dist/echarts.min.js&quot;&gt;&lt;/script&gt;\n&lt;!-- ve-echarts组件库输出的umd形式js文件，只载入这个js即可完整引入ve-echarts组件库 --&gt;\n&lt;script src=&quot;./lib/ve-charts.umd.min.js&quot;&gt;&lt;/script&gt;</code></pre>\n<p>README.md</p>\n<pre><code class=\"language-markdown\">&lt;!-- README.md 里面嵌入vue代码 --&gt;\n&lt;vuep template=&quot;#basicLine&quot; :options=&quot;{ theme: &#39;vue&#39;, lineNumbers: false }&quot;&gt;&lt;/vuep&gt;\n\n&lt;script v-pre type=&quot;text/x-template&quot; id=&quot;basicLine&quot;&gt;\n&lt;template&gt;\n  &lt;ve-line-chart :data=&quot;chartData&quot; /&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  export default {\n    created () {\n      this.chartData = {\n        dimensions: {\n          name: &#39;Week&#39;,\n          data: [&#39;Mon.&#39;, &#39;Tue.&#39;, &#39;Wed.&#39;, &#39;Thu.&#39;, &#39;Fir.&#39;, &#39;Sat.&#39;, &#39;Sun.&#39;]\n        },\n        measures: [{\n          name: &#39;Vue&#39;,\n          data: [30, 40, 35, 50, 49, 70, 90]\n        }]\n      }\n    }\n  }\n&lt;/script&gt;</code></pre>\n<p>效果如下图</p>\n<p><img src=\"../../../images/blog/vue/dosify_vuep_ve_charts.png\" alt=\"dosify_vuep_ve_charts.png\"></p>\n<h2 id=\"vuepress\">vuepress</h2>\n<p><a href=\"https://vuepress.vuejs.org/\">vuepress</a> 是一个静态站点生成器，用于vue官网文档生成。可以内嵌vue代码，<a href=\"https://vuepress.vuejs.org/guide/using-vue.html#browser-api-access-restrictions\">Using Vue in Markdown</a> </p>\n<p>一般vue组件需要在 <code>.vuepress/components/</code> 下实现，在 markdown 语法中才能使用。下面是一个实例</p>\n<pre><code class=\"language-markdown\"># markdown引入vue组件测试\n\n&lt;span v-for=&quot;i in 3&quot;&gt;{{ i }} &lt;/span&gt;\n\n`zchart-test`\n\n&lt;zchart-test&gt;&lt;/zchart-test&gt;</code></pre>\n<p><img src=\"../../../images/blog/vue/vuepress_vue.png\" alt=\"vuepress_vue.png\"></p>\n<h2 id=\"element官网源码\">element官网源码</h2>\n<p>它是自己写的一套构建程序，将 tpl 转 vue，markdown 解析时，内嵌 vue demo 会自动渲染代码，ElementUI官网源码: <a href=\"https://github.com/ElemeFE/element/tree/dev/examples\">ElementUI官网 examples | github</a></p>\n<p>下面以 <a href=\"https://github.com/ElemeFE/element/blob/dev/examples/docs/zh-CN/alert.md\">alert文档源码</a> 为例，来看看具体写法</p>\n<pre><code class=\"language-markdown\">## Alert 警告\n\n用于页面中展示重要的提示信息。\n\n### 基本用法\n\n页面中的非浮层元素，不会自动消失。\n\n:::demo Alert 组件提供四种主题，由`type`属性指定，默认值为`info`。\n&lt;template&gt;\n  &lt;el-alert\n    title=&quot;成功提示的文案&quot;\n    type=&quot;success&quot;&gt;\n  &lt;/el-alert&gt;\n  &lt;el-alert\n    title=&quot;消息提示的文案&quot;\n    type=&quot;info&quot;&gt;\n  &lt;/el-alert&gt;\n  &lt;el-alert\n    title=&quot;警告提示的文案&quot;\n    type=&quot;warning&quot;&gt;\n  &lt;/el-alert&gt;\n  &lt;el-alert\n    title=&quot;错误提示的文案&quot;\n    type=&quot;error&quot;&gt;\n  &lt;/el-alert&gt;\n&lt;/template&gt;\n:::\n\n### 主题</code></pre>\n<p>渲染效果如下</p>\n<p><img src=\"../../../images/blog/vue/elementui_doc_source.png\" alt=\"elementui_doc_source.png\"></p>\n<pre><code class=\"language-js\">// 将 官网.tpl单文件组件转.vue\n// /examples/pages/template/component.tpl 就是element组件文档的入口\n// https://github.com/ElemeFE/element/blob/dev/build/bin/i18n.js\n&#39;use strict&#39;;\n\nvar fs = require(&#39;fs&#39;);\nvar path = require(&#39;path&#39;);\nvar langConfig = require(&#39;../../examples/i18n/page.json&#39;);\n\nlangConfig.forEach(lang =&gt; {\n  try {\n    fs.statSync(path.resolve(__dirname, `../../examples/pages/${ lang.lang }`));\n  } catch (e) {\n    fs.mkdirSync(path.resolve(__dirname, `../../examples/pages/${ lang.lang }`));\n  }\n\n  Object.keys(lang.pages).forEach(page =&gt; {\n    var templatePath = path.resolve(__dirname, `../../examples/pages/template/${ page }.tpl`);\n    var outputPath = path.resolve(__dirname, `../../examples/pages/${ lang.lang }/${ page }.vue`);\n    var content = fs.readFileSync(templatePath, &#39;utf8&#39;);\n    var pairs = lang.pages[page];\n\n    Object.keys(pairs).forEach(key =&gt; {\n      content = content.replace(new RegExp(`&lt;%=\\\\s*${ key }\\\\s*&gt;`, &#39;g&#39;), pairs[key]);\n    });\n\n    fs.writeFileSync(outputPath, content);\n  });\n});</code></pre>\n<p>/examples/pages/template/component.tpl 部分代码</p>\n<pre><code class=\"language-html\">&lt;el-scrollbar class=&quot;page-component__nav&quot;&gt;\n  &lt;side-nav :data=&quot;navsData[lang]&quot; :base=&quot;`/${ lang }/component`&quot;&gt;&lt;/side-nav&gt;\n&lt;/el-scrollbar&gt;\n&lt;div class=&quot;page-component__content&quot;&gt;\n  &lt;!-- 像 alert、button 文档切换，就是切的这里的路由 --&gt;\n  &lt;router-view class=&quot;content&quot;&gt;&lt;/router-view&gt;\n  &lt;footer-nav&gt;&lt;/footer-nav&gt;\n&lt;/div&gt;</code></pre>\n<p>对应的路由代码</p>\n<pre><code class=\"language-js\">// element/examples/route.config.js为alert等文档添加路由部分代码\nfunction addRoute(page, lang, index) {\n  const component = page.path === &#39;/changelog&#39;\n    ? load(lang, &#39;changelog&#39;)\n    : loadDocs(lang, page.path); // 根据path载入对应的docs/zh-CN/xx.md \n  let child = {\n    path: page.path.slice(1),\n    meta: {\n      title: page.title || page.name,\n      description: page.description,\n      lang\n    },\n    name: &#39;component-&#39; + lang + (page.title || page.name),\n    component: component.default || component \n  };\n\n  route[index].children.push(child);\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "怎么写出类似element官网那样可以看代码运行效果的文档",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "docsify"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "vuepress"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "element官网源码"
            }
          ]
        }
      ],
      "config": {
        "source": "怎么写出类似element官网那样可以实时看运行效果的文档.md",
        "staticFileName": "ui_doc.html",
        "author": "guoqzuo",
        "createDate": "2020/10/25",
        "description": "对于UI组件、echarts图表相关文档来说，能够实时看具体显示效果是必须的。它是将文档和demo合并在一起，这样更有说服力。那怎么写出类似的文档呢？这里来介绍三种方法：1.dosify 2.vuepress 3.element官网源码",
        "keywords": "UI组件官网,组件展示官网,dosify实例",
        "category": "Vue",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"怎么用vue写一个组件库，类似element\">怎么用vue写一个组件库，类似element</h1>\n<p>下面通过一个简单的示例来看怎么写一个vue组件库，分为 6 步</p>\n<ol>\n<li>目录规划</li>\n<li>组件库入口文件</li>\n<li>本地测试组件</li>\n<li>打包构建 UMD</li>\n<li>上传 npm 包</li>\n<li>dosify搭建官网</li>\n</ol>\n<h2 id=\"1组件库目录结构\">1.组件库目录结构</h2>\n<p>以 element 为例，下面是一个简单的目录结构</p>\n<pre><code class=\"language-bash\">├── examples # 用于测试组件，demo展示（可以直接是一个完整的vue项目）\n├── packages # 用于存放编写的组件\n│   └── my-button # 封装的组件，具体写法参见element源码\n│       ├── src    \n│       │   └── main.vue  # 单文件组件，组件\n│       └── index.js  # install方法，用于Vue.use()引入单个组件\n└── src\n    └── index.js # 入口文件</code></pre>\n<h2 id=\"2导出组件库\">2.导出组件库</h2>\n<p>我们写好组件后，主要问题是要怎么导出(export)供其他项目使用，一般在 src/index.js 里进行处理</p>\n<pre><code class=\"language-js\">// src/index.js 示例，主要是引入(import)组件再导出(export)，包括Vue.use所需的 install函数处理\nimport MyButton from &quot;../packages/my-button/index.js&quot;;\nconst components = [MyButton];\n\n// Vue.use() 一次性安装所有组件\nconst install = function(Vue) {\n  if (install.installed) return;\n  components.forEach(component =&gt; Vue.use(component));\n  // 如果没有在src/index.js里实现install方法，就需要使用下面的\n  // components.forEach(component =&gt; Vue.component(component.name, component))\n};\n\n// 直接给浏览器或 AMD loader 使用\nif (typeof window !== undefined &amp;&amp; window.Vue) {\n  window.Vue.use(install);\n  if (install.installed) {\n    install.installed = false;\n  }\n}\n\nexport default {\n  install, // 用于ES modules，import Vue 后直接使用 Vue.use()\n  MyButton // 支持解构赋值按需引入单个组件\n};</code></pre>\n<h2 id=\"3本地测试组件\">3.本地测试组件</h2>\n<p>假设我们这个组件命名为vue-chart，那可以在 examples/src/mian.js 直接使用</p>\n<pre><code class=\"language-js\">// examples/src/mian.js\n// 引入所有组件\nimport VueChart from &#39;../../src/index.js&#39;\nVue.use(VueChart)\n\n// 按需引入单个组件\nimport { MyButton } from &#39;../../src/index.js&#39;\nVue.use(MyButton)</code></pre>\n<p>引入后，我们在 App.vue里直接使用该组件</p>\n<pre><code class=\"language-html\">&lt;!-- App.vue --&gt;\n&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;my-button id=&quot;btn&quot;&gt;测试按钮&lt;/my-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre>\n<p>这里可能涉及到 examples 目录 npm run serve 时，提示 eslint 错误</p>\n<p><img src=\"../../../images/blog/vue/eslint-error.png\" alt=\"eslint-error.png\"></p>\n<p>因为 examples 是一个独立的vue项目，引入了外部 packages 目录的文件，如果 packages 下组件不符合eslint规则就需要在项目根目录的package.json里配置eslint规则了，与examples项目的eslint规则保持一致。参考我之前的笔记：&quot;怎么在老项目中加入eslint规则，并可以保存后自动fix&quot;</p>\n<p>这样使用eslint处理 packages 目录下的代码，再运行 examples 目录下的 npm run serve 就可以正常加载组件了</p>\n<h2 id=\"4打包构建umd\">4.打包构建umd</h2>\n<p>上面我们本地测试了，但他不能直接在普通网页中通过引入某个js文件来使用，这就需要使用Vue CLI来打包构建了</p>\n<p>使用 vue-cli 打包成 lib，参考文档 <a href=\"https://cli.vuejs.org/zh/guide/build-targets.html#%E5%BA%94%E7%94%A8\">构建目标 | Vue CLI</a></p>\n<p>由于我们的项目结构不是通过vue-cli生成的，所以就算使用<code>npm install @vue/cli --save</code>，安装 @vue/cli，也无法使用 vue-cli-service 服务，因为 @vue/cli 这个包是一个用于生成脚手架项目的。你没有用它生成项目，如果不安装对应的 npm 包是无法使用 vue-cli-servie 的，我们直接从 vue create 生成的项目中把 devDependencies、dependencies，配置移动到根目录的 package.json 里，再npm install</p>\n<pre><code class=\"language-js\">// dependencies\n&quot;dependencies&quot;: {\n  &quot;core-js&quot;: &quot;^3.6.5&quot;,\n  &quot;vue&quot;: &quot;^2.6.11&quot;\n},\n// devDependencies\n&quot;@vue/cli-plugin-babel&quot;: &quot;~4.5.0&quot;,\n&quot;@vue/cli-plugin-router&quot;: &quot;~4.5.0&quot;,\n&quot;@vue/cli-plugin-vuex&quot;: &quot;~4.5.0&quot;,\n&quot;@vue/cli-service&quot;: &quot;~4.5.0&quot;,\n&quot;less&quot;: &quot;^3.0.4&quot;,\n&quot;less-loader&quot;: &quot;^5.0.0&quot;,\n&quot;vue-template-compiler&quot;: &quot;^2.6.11&quot;\n// browserslist\n&quot;browserslist&quot;: [\n  &quot;&gt; 1%&quot;,\n  &quot;last 2 versions&quot;,\n  &quot;not dead&quot;\n],</code></pre>\n<p>新增一个lib打包命令</p>\n<pre><code class=\"language-js\">// --dest  lib 指定 output 目录文 lib，默认为 dist 目录\n// src/index.js 最后为入口文件，默认为 src/App.vue。\n&quot;scripts&quot;: {\n  &quot;build:lib&quot;: &quot;vue-cli-service build --mode lib --target lib --dest lib src/index.js&quot;\n}   </code></pre>\n<p>理论上 npm run build:lib 会在当前目录下创建lib目录，且包含4个文件</p>\n<ul>\n<li>lib/myLib.common.js：一个给打包器用的 CommonJS 包 (不幸的是，webpack 目前还并没有支持 ES modules 输出格式的包)</li>\n<li>lib/myLib.umd.js：一个直接给浏览器或 AMD loader 使用的 UMD 包</li>\n<li>lib/myLib.umd.min.js：压缩后的 UMD 构建版本</li>\n<li>lib/myLib.css：提取出来的 CSS 文件 (可以通过在 vue.config.js 中设置 css: { extract: false } 强制内联)</li>\n</ul>\n<p>实际我这里打包后没有生成css文件，因为我们多加了一个 --mode lib 参数</p>\n<p><img src=\"../../../images/blog/vue/vue_chart_build_lib.png\" alt=\"vue_chart_build_lib.png\"></p>\n<p>一般将打包后的文件 xx.umd.js 引入到项目中就可以使用了，来看看示例</p>\n<pre><code class=\"language-html\">&lt;!-- docs/index.html --&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &lt;my-button&gt;我的按钮&lt;/my-button&gt;\n    &lt;/div&gt;\n    &lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;../lib/vue-chart.umd.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        const app = new Vue({\n            el: &#39;#app&#39;\n        })\n    &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p><img src=\"../../../images/blog/vue/vue_chat_test1.png\" alt=\"vue_chat_test1.png\"></p>\n<p>vue项目中引用</p>\n<pre><code class=\"language-js\">// examples/src/main.js\nimport VueChart from &quot;../../lib/vue-chart.umd.js&quot;;\nVue.use(VueChart);</code></pre>\n<p>效果如下</p>\n<p><img src=\"../../../images/blog/vue/vue_chat_test2.png\" alt=\"vue_chat_test2.png\"></p>\n<h2 id=\"5上传npm包\">5.上传npm包</h2>\n<p>我们可以把包弄成npm包，在其他vue项目中，可以直接引入，将 package.json 的 main.js 设置为umd模块地址，并加上unpkg参数，用于cdn直接引入</p>\n<pre><code class=\"language-js\">// package.json\n&quot;name&quot;: &quot;@guoqzuo/vue-chart&quot;, // 将项目名称改为加上自己作用域的包\n&quot;version&quot;: &quot;0.0.2&quot;, // 设置项目版本，注意每次修改版本，package-lock.json的版本也要改\n// 指定npm包入口，当我们import某个npm包时，导入的文件就是这个main指定的文件\n&quot;main&quot;: &quot;lib/vue-chart.umd.min.js&quot;\n// cdn相关\n&quot;unpkg&quot;: &quot;lib/vue-chart.umd.min.js&quot;,</code></pre>\n<p>关于unpkg</p>\n<p><img src=\"../../../images/blog/vue/unpkg_info.png\" alt=\"unpkg_info.png\"></p>\n<p>修改好后，我们来发布这个npm包，注意：需要先有对应的npm账号，我的npm账号是 guoqzuo，这里在项目根目录新建一个publish.sh脚本来发布</p>\n<pre><code class=\"language-sh\">#!/usr/bin/env bash\nnpm config get registry # 检查仓库镜像库\nnpm config set registry=http://registry.npmjs.org\necho &#39;请进行登录相关操作：&#39;\nnpm login # 登陆\n# npm login --scope=@guoqzuo # 设置登录作用域\necho &quot;-------publishing-------&quot;\nnpm publish --access public # 发布\nnpm config set registry=https://registry.npm.taobao.org # 设置为淘宝镜像\necho &quot;发布完成&quot;\nexit</code></pre>\n<p>一般新建的publish.sh是没有执行权限的，使用 <code>chmod +x publish.sh</code> 添加可执行权限，再 <code>./publish.sh</code> 执行发布，发布过程中，需要登录npm账号、密码等即可</p>\n<p><img src=\"../../../images/blog/vue/vue_chart_npm_push.png\" alt=\"vue_chart_npm_push.png\"></p>\n<p>我们这里examples目录也跟着发布上传了，可以加参数来限定上传到npm包的文件。细节方面后面在优化。我们可以看到npm官网有我们刚上传的 <a href=\"https://www.npmjs.com/package/@guoqzuo/vue-chart\">@guoqzuo/vue-chart</a> 了</p>\n<p><img src=\"../../../images/blog/vue/guoqzuo_vue_chart.png\" alt=\"guoqzuo_vue_chart.png\"></p>\n<p>测试npm包，在vue项目中先安装</p>\n<pre><code class=\"language-bash\"># 这里建议加@latest，因为有时候发布后有延时\n# 直接npm i @guoqzuo/vue-chart 后可能还是原来的旧版本\nnpm i @guoqzuo/vue-chart@latest</code></pre>\n<p>安装完成后，再在 main.js 里引入，npm run serve 后可正常渲染</p>\n<pre><code class=\"language-js\">// examples/src/main.js\nimport VueChart from &quot;@guoqzuo/vue-chart&quot;;\nVue.use(VueChart);</code></pre>\n<p>另外，我们再测试下 unpkg cdn是否生效</p>\n<pre><code class=\"language-html\">&lt;!-- docs/index.html --&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &lt;my-button&gt;我的按钮&lt;/my-button&gt;\n    &lt;/div&gt;\n    &lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;\n    &lt;!-- &lt;script src=&quot;../lib/vue-chart.umd.js&quot;&gt;&lt;/script&gt; --&gt;\n     &lt;script src=&quot;https://unpkg.com/@guoqzuo/vue-chart@latest/lib/vue-chart.umd.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        const app = new Vue({\n            el: &#39;#app&#39;\n        })\n    &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p>测试可正常运行，以上完成了一个基本vue组件库的开发流程，后面再慢慢优化。</p>\n<h2 id=\"6-dosify官网搭建\">6. dosify官网搭建</h2>\n<p>使用 dosify 写一个组件库官网，参考 <a href=\"http://www.zuo11.com/blog/2020/10/ui_doc.html\">怎么写出类似element官网那样可以实时看运行效果的文档</a></p>\n<p>完整代码已上传github，参见 <a href=\"https://github.com/zuoxiaobai/vue-chart\">zuoxiaobai/vue-chart</a></p>\n<p>使用 dosify 写的对应的官网 <a href=\"https://vuechart.zuo11.com\">@guoqzuo/vue-chart官网</a></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000014924557\">如何用vue写一个组件库</a></li>\n<li><a href=\"http://www.fly63.com/article/detial/2631\">写一个vue组件库_跟着element学习写组件</a></li>\n<li><a href=\"https://vue-loader.vuejs.org/zh/#vue-loader\">Vue Loader</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000016365409\">package.json 非官方字段集合 - 前端小站 - SegmentFault 思否</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "怎么用vue写一个组件库，类似element",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "1.组件库目录结构"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "2.导出组件库"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "3.本地测试组件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "4.打包构建umd"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "5.上传npm包"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "6. dosify官网搭建"
            }
          ]
        }
      ],
      "config": {
        "source": "怎么用vue写一个组件库，类似element.md",
        "staticFileName": "vue_ui_lib.html",
        "author": "guoqzuo",
        "createDate": "2020/10/25",
        "description": "下面通过一个简单的示例来看怎么写一个vue组件库，分为 6 步：1. 目录规划 2. 组件库入口文件 3. 本地测试组件 4. 打包构建 UMD 5. 上传 npm 包 6. dosify搭建官网",
        "keywords": "vue组件库,vue组件库编写流程",
        "category": "Vue",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-cli构建项目时选择不同的eslint规则会有什么区别？\">Vue CLI构建项目时选择不同的eslint规则会有什么区别？</h1>\n<p>当我们使用 vue create xxx 时，会让选择是否需要某个模块，如下图</p>\n<p><img src=\"../../../images/blog/vue/vue_create_perset.png\" alt=\"vue_create_perset.png\"></p>\n<p>如果有使用空格选择 Linter / Formatter，那么后面的流程会让你选择一种eslint规则</p>\n<pre><code class=\"language-bash\">? Pick a linter / formatter config: (Use arrow keys)\n❯ ESLint with error prevention only \n  ESLint + Airbnb config \n  ESLint + Standard config \n  ESLint + Prettier </code></pre>\n<p>加上不使用Linter / Formatter，总共有 5 种情况，我们都逐一试试，看生成的package.json有什么不同</p>\n<blockquote>\n<p>注意除了eslint规则选择不一样外，其他都一样。vue-cli 版本 4.5.0，vue 版本 2.x</p>\n</blockquote>\n<pre><code class=\"language-js\">// 统一选择 lint on save，配置放到package.json，不单独生成elsint配置文件\n? Pick additional lint features: Lint on save\n? Where do you prefer placing config for Babel, ESLint, etc.? In package.json</code></pre>\n<h2 id=\"不使用eslint时\">不使用eslint时</h2>\n<p>package.json里面只有 vue 依赖的一些基础模块</p>\n<pre><code class=\"language-js\">  &quot;scripts&quot;: {\n    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,\n    &quot;build&quot;: &quot;vue-cli-service build&quot;\n  },\n  &quot;devDependencies&quot;: {\n    &quot;@vue/cli-plugin-babel&quot;: &quot;~4.5.0&quot;,\n    &quot;@vue/cli-plugin-router&quot;: &quot;~4.5.0&quot;,\n    &quot;@vue/cli-plugin-vuex&quot;: &quot;~4.5.0&quot;,\n    &quot;@vue/cli-service&quot;: &quot;~4.5.0&quot;,\n    &quot;less&quot;: &quot;^3.0.4&quot;,\n    &quot;less-loader&quot;: &quot;^5.0.0&quot;,\n    &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot;\n  },</code></pre>\n<h2 id=\"eslint-with-error-prevention-only\">ESLint with error prevention only</h2>\n<p>下面是除了 vue 必要模块外，新增的 eslint 相关配置</p>\n<pre><code class=\"language-js\">&quot;scripts&quot;: {\n  &quot;lint&quot;: &quot;vue-cli-service lint&quot;\n},\n&quot;devDependencies&quot;: {\n    &quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;,\n    &quot;babel-eslint&quot;: &quot;^10.1.0&quot;,\n    &quot;eslint&quot;: &quot;^6.7.2&quot;,\n    &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,\n  },\n  &quot;eslintConfig&quot;: {\n    &quot;root&quot;: true,\n    &quot;env&quot;: {\n      &quot;node&quot;: true\n    },\n    &quot;extends&quot;: [\n      &quot;plugin:vue/essential&quot;,\n      &quot;eslint:recommended&quot;\n    ],\n    &quot;parserOptions&quot;: {\n      &quot;parser&quot;: &quot;babel-eslint&quot;\n    },\n    &quot;rules&quot;: {}\n  },</code></pre>\n<h2 id=\"eslint--airbnb-config\">ESLint + Airbnb config</h2>\n<pre><code class=\"language-js\"> &quot;devDependencies&quot;: {\n    &quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;,\n    &quot;@vue/eslint-config-airbnb&quot;: &quot;^5.0.2&quot;,\n    &quot;babel-eslint&quot;: &quot;^10.1.0&quot;,\n    &quot;eslint&quot;: &quot;^6.7.2&quot;,\n    &quot;eslint-plugin-import&quot;: &quot;^2.20.2&quot;,\n    &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,\n  },\n  &quot;eslintConfig&quot;: {\n    &quot;root&quot;: true,\n    &quot;env&quot;: {\n      &quot;node&quot;: true\n    },\n    &quot;extends&quot;: [\n      &quot;plugin:vue/essential&quot;,\n      &quot;@vue/airbnb&quot;\n    ],\n    &quot;parserOptions&quot;: {\n      &quot;parser&quot;: &quot;babel-eslint&quot;\n    },\n    &quot;rules&quot;: {}\n  },</code></pre>\n<p>多了一个.editorconfig</p>\n<pre><code class=\"language-js\">[*.{js,jsx,ts,tsx,vue}]\nindent_style = space\nindent_size = 2\nend_of_line = lf\ntrim_trailing_whitespace = true\ninsert_final_newline = true\nmax_line_length = 100</code></pre>\n<h2 id=\"eslint--standard-config\">ESLint + Standard config</h2>\n<pre><code class=\"language-js\"> &quot;devDependencies&quot;: {\n    &quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;,\n    &quot;@vue/eslint-config-standard&quot;: &quot;^5.1.2&quot;,\n    &quot;babel-eslint&quot;: &quot;^10.1.0&quot;,\n    &quot;eslint&quot;: &quot;^6.7.2&quot;,\n    &quot;eslint-plugin-import&quot;: &quot;^2.20.2&quot;,\n    &quot;eslint-plugin-node&quot;: &quot;^11.1.0&quot;,\n    &quot;eslint-plugin-promise&quot;: &quot;^4.2.1&quot;,\n    &quot;eslint-plugin-standard&quot;: &quot;^4.0.0&quot;,\n    &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,\n  },\n  &quot;eslintConfig&quot;: {\n    &quot;root&quot;: true,\n    &quot;env&quot;: {\n      &quot;node&quot;: true\n    },\n    &quot;extends&quot;: [\n      &quot;plugin:vue/essential&quot;,\n      &quot;@vue/standard&quot;\n    ],\n    &quot;parserOptions&quot;: {\n      &quot;parser&quot;: &quot;babel-eslint&quot;\n    },\n    &quot;rules&quot;: {}\n  },</code></pre>\n<p>多了一个.editorconfig</p>\n<pre><code class=\"language-js\">[*.{js,jsx,ts,tsx,vue}]\nindent_style = space\nindent_size = 2\ntrim_trailing_whitespace = true\ninsert_final_newline = true</code></pre>\n<h2 id=\"eslint--prettier\">ESLint + Prettier</h2>\n<pre><code class=\"language-js\">  &quot;devDependencies&quot;: {\n    &quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;,\n    &quot;@vue/eslint-config-prettier&quot;: &quot;^6.0.0&quot;,\n    &quot;babel-eslint&quot;: &quot;^10.1.0&quot;,\n    &quot;eslint&quot;: &quot;^6.7.2&quot;,\n    &quot;eslint-plugin-prettier&quot;: &quot;^3.1.3&quot;,\n    &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,\n    &quot;prettier&quot;: &quot;^1.19.1&quot;,\n  },\n  &quot;eslintConfig&quot;: {\n    &quot;root&quot;: true,\n    &quot;env&quot;: {\n      &quot;node&quot;: true\n    },\n    &quot;extends&quot;: [\n      &quot;plugin:vue/essential&quot;,\n      &quot;eslint:recommended&quot;,\n      &quot;@vue/prettier&quot;\n    ],\n    &quot;parserOptions&quot;: {\n      &quot;parser&quot;: &quot;babel-eslint&quot;\n    },\n    &quot;rules&quot;: {}\n  },</code></pre>\n<p>我们使用上面相同的配置，只是不选择将eslint配置放到paackage.json，而是选择 In dedicated config files 使用专门的配置文件，他会额外生成一个 .eslintrc.js 存放对应的eslint配置</p>\n<pre><code class=\"language-js\">// .eslintrc.js\nmodule.exports = {\n  root: true,\n  env: {\n    node: true\n  },\n  extends: [&quot;plugin:vue/essential&quot;, &quot;eslint:recommended&quot;, &quot;@vue/prettier&quot;],\n  parserOptions: {\n    parser: &quot;babel-eslint&quot;\n  },\n  rules: {\n    &quot;no-console&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,\n    &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;\n  }\n};</code></pre>\n<h2 id=\"eslint配置配置对比总结\">ESLint配置配置对比总结</h2>\n<pre><code class=\"language-js\">// 1. ESLint with error prevention only \n// - devDependencies\n&quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;,\n&quot;babel-eslint&quot;: &quot;^10.1.0&quot;,\n&quot;eslint&quot;: &quot;^6.7.2&quot;,\n&quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,\n// - eslintConfig\n&quot;extends&quot;: [\n  &quot;plugin:vue/essential&quot;,\n  &quot;eslint:recommended&quot;\n],\n\n// 2. ESLint + Airbnb config \n// - devDependencies\n&quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;,\n&quot;babel-eslint&quot;: &quot;^10.1.0&quot;,\n&quot;eslint&quot;: &quot;^6.7.2&quot;,\n&quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,\n&quot;@vue/eslint-config-airbnb&quot;: &quot;^5.0.2&quot;,\n&quot;eslint-plugin-import&quot;: &quot;^2.20.2&quot;,\n// - eslintConfig\n&quot;extends&quot;: [\n  &quot;plugin:vue/essential&quot;,\n  &quot;@vue/airbnb&quot;\n],\n\n// 3. ESLint + Standard config \n// - devDependencies\n&quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;,\n&quot;babel-eslint&quot;: &quot;^10.1.0&quot;,\n&quot;eslint&quot;: &quot;^6.7.2&quot;,\n&quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,\n&quot;@vue/eslint-config-standard&quot;: &quot;^5.1.2&quot;,\n&quot;eslint-plugin-import&quot;: &quot;^2.20.2&quot;,\n&quot;eslint-plugin-node&quot;: &quot;^11.1.0&quot;,\n&quot;eslint-plugin-promise&quot;: &quot;^4.2.1&quot;,\n&quot;eslint-plugin-standard&quot;: &quot;^4.0.0&quot;,\n\n// - eslintConfig\n&quot;extends&quot;: [\n  &quot;plugin:vue/essential&quot;,\n  &quot;@vue/standard&quot;\n],\n\n// 4. ESLint + Prettier\n// - devDependencies\n&quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;,\n&quot;babel-eslint&quot;: &quot;^10.1.0&quot;,\n&quot;eslint&quot;: &quot;^6.7.2&quot;,\n&quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,\n&quot;@vue/eslint-config-prettier&quot;: &quot;^6.0.0&quot;,\n&quot;eslint-plugin-prettier&quot;: &quot;^3.1.3&quot;,\n&quot;prettier&quot;: &quot;^1.19.1&quot;,\n// - eslintConfig\n&quot;extends&quot;: [\n  &quot;plugin:vue/essential&quot;,\n  &quot;eslint:recommended&quot;,\n  &quot;@vue/prettier&quot;\n],</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue CLI构建项目时选择不同的eslint规则会有什么区别？",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "不使用eslint时"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "ESLint with error prevention only"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "ESLint + Airbnb config"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "ESLint + Standard config"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "ESLint + Prettier"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "ESLint配置配置对比总结"
            }
          ]
        }
      ],
      "config": {
        "source": "Vue CLI构建项目时选择不同的eslint规则会有什么区别？.md",
        "staticFileName": "vue_cli_eslint.html",
        "author": "guoqzuo",
        "createDate": "2020/10/25",
        "description": "当我们使用 vue create xxx 时，会让选择是否需要某个模块，如果有使用空格选择 Linter / Formatter，那么后面的流程会让你选择一种eslint规则。总共有 5 种情况，我们都逐一试试，看生成的package.json有什么不同",
        "keywords": "vue-cli eslint,Vue CLI eslint",
        "category": "Vue",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"怎么在老项目中加入eslint规则，并可以保存后自动fix\">怎么在老项目中加入eslint规则，并可以保存后自动fix</h1>\n<p>在 &quot;Vue CLI 构建项目时选择不同的 eslint 规则会有什么区别？&quot; 中，我们有了解到，不同的 eslint 配置项，会对应不同的 npm 包，eslintConfig 中对应的 extends 也不一样。我们只要找出某个配置特有的 npm 包，以及配置，就可以在旧项目中，引入对应的 eslint 配置，结合 vscode eslint 插件就可以做到保存后自动 fix</p>\n<ol>\n<li>新建一个目录 eslint-fix-test，cd 到该目录，使用 npm init -y 创建一个新的 package.json</li>\n<li>我们把 ESLint + Prettier 的 package.json 配置拷贝到这个 package.json 中</li>\n</ol>\n<pre><code class=\"language-js\">// ESLint + Prettier package.json配置\n &quot;devDependencies&quot;: {\n    &quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;,\n    &quot;@vue/eslint-config-prettier&quot;: &quot;^6.0.0&quot;,\n    &quot;babel-eslint&quot;: &quot;^10.1.0&quot;,\n    &quot;eslint&quot;: &quot;^6.7.2&quot;,\n    &quot;eslint-plugin-prettier&quot;: &quot;^3.1.3&quot;,\n    &quot;eslint-plugin-vue&quot;: &quot;^6.2.2&quot;,\n    &quot;prettier&quot;: &quot;^1.19.1&quot;\n  },\n  &quot;eslintConfig&quot;: {\n    &quot;root&quot;: true,\n    &quot;env&quot;: {\n      &quot;node&quot;: true\n    },\n    &quot;extends&quot;: [\n      &quot;plugin:vue/essential&quot;,\n      &quot;eslint:recommended&quot;,\n      &quot;@vue/prettier&quot;\n    ],\n    &quot;parserOptions&quot;: {\n      &quot;parser&quot;: &quot;babel-eslint&quot;\n    },\n    &quot;rules&quot;: {}\n  }</code></pre>\n<ol start=\"3\">\n<li>npm install 安装依赖</li>\n<li>在该目录下写一个 test.vue 文件，或 test.js 文件，特意写的很随意，看eslint是否报错</li>\n</ol>\n<p>一般情况下，npm install 后，如果vscode eslint插件配置正确，会弹出如下弹窗，提示是否允许 eslint 修复</p>\n<p><img src=\"../../../images/blog/vue/eslint-fix-1.png\" alt=\"eslint-fix-1.png\"></p>\n<p>注意：</p>\n<ol>\n<li>如果没有安装配置好vscode的eslint插件，请先安装，可以参考我之前的笔记: <a href=\"http://www.zuo11.com/blog/2019/10/devtools_autofix.html\">2020 vscode配置eslint保存后自动fix</a></li>\n<li>如果没有生效，可以尝试<strong>新开一个vscode窗口，直接打开eslint-fix-test目录</strong>，有时候目录层级深了，会不起作用</li>\n<li>如果还是没生效，可以尝试彻底关闭 vscode，再重新打开</li>\n<li>有时候刚打开项目，eslint插件可能需要时间加载，等个几秒钟才会工作</li>\n</ol>\n<p>下面是我测试时，eslint插件工作正常的示例</p>\n<p><img src=\"../../../images/blog/vue/eslint-fix-2.png\" alt=\"eslint-fix-2.png\"></p>\n<p>保存后会自动fix，由于两个变量没使用还是会报警告，我用console.log打印了下，就没 warning了</p>\n<p><img src=\"../../../images/blog/vue/eslint-fix-3.png\" alt=\"eslint-fix-3.png\"></p>\n<p>综上，只要你知道某个 eslint 配置所需的npm包及 eslintConfig.extends 配置，那么就可以在项目中任意使用eslint了，完整测试 demo 可以从 github 下载 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/DebugDemo/eslint-fix-test\">eslint-fix-test | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "怎么在老项目中加入eslint规则，并可以保存后自动fix"
        }
      ],
      "config": {
        "source": "怎么在老项目中加入eslint规则，并可以保存后自动fix.md",
        "staticFileName": "old_project_eslint.html",
        "author": "guoqzuo",
        "createDate": "2020/10/25",
        "description": "在 'Vue CLI 构建项目时选择不同的 eslint 规则会有什么区别？' 中，我们有了解到，不同的 eslint 配置项，会对应不同的 npm 包，eslintConfig 中对应的 extends 也不一样。我们只要找出某个配置特有的 npm 包，以及配置，就可以在旧项目中，引入对应的 eslint 配置，结合 vscode eslint 插件就可以做到保存后自动 fix",
        "keywords": "老项目加eslint,旧项目引入eslint,vue eslint",
        "category": "Vue",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"mac设置vscode默认打开的浏览器\">mac设置vscode默认打开的浏览器</h1>\n<p>vscode中，安装 Live Server 插件后，在html文件里，右键 open with Live Server，可以将网页使用http服务在浏览器里面打开。</p>\n<p>我电脑里面默认打开的是 safari，但我一般习惯用Chrome，这个默认浏览器的设置需要在mac系统里设置</p>\n<p>点击屏幕左上角苹果标志 =&gt; 系统偏好设置 =&gt; 通用 =&gt; 默认网页浏览器 选择 Google Chrome 即可</p>\n<p><img src=\"../../../images/blog/vue/default_browser.png\" alt=\"default_browser.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "mac设置vscode默认打开的浏览器"
        }
      ],
      "config": {
        "source": "mac设置vscode默认打开的浏览器.md",
        "staticFileName": "mac_default_browser.html",
        "author": "guoqzuo",
        "createDate": "2020/10/25",
        "description": "vscode中，安装 Live Server 插件后，在html文件里，右键 open with Live Server，可以将网页使用http服务在浏览器里面打开。我电脑里面默认打开的是 safari，但我一般习惯用Chrome，这个默认浏览器的设置需要在mac系统里设置，点击屏幕左上角苹果标志 => 系统偏好设置 => 通用 => 默认网页浏览器 选择 Google Chrome 即可",
        "keywords": "vscode默认浏览器,mac设置默认浏览器",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"npm-run-运行多条命令--不生效的问题\">npm run 运行多条命令 &amp;&amp; 不生效的问题</h1>\n<p>在项目中除了默认的 webpack-dev-server 外，我们还想同时运行 mock 接口的 node 服务，会使用 &amp;&amp; 同时执行两条命令</p>\n<pre><code class=\"language-js\">// npm run 同时执行下面的两条命令\n// webpack-dev-server --config webpack.dev.js\n// nodemon ./mock/index.js</code></pre>\n<p>一般 &amp; 表示并列执行，&amp;&amp; 表示两条命令顺序执行。使用 &amp;&amp; 的形式设置对应的script，如下</p>\n<pre><code class=\"language-js\">&quot;scripts&quot;: {\n  &quot;server&quot;: &quot;nodemon ./mock/index.js &amp;&amp; webpack-dev-server --config webpack.dev.js&quot;\n}</code></pre>\n<p>但实际运行 npm run server 时，只运行了第一条命令，我的是mac，不知道是不是node版本的问题。网上找了下， &amp;&amp; 存在兼容性问题。建议使用 concurrently 来代替，concurrently 跨平台兼容</p>\n<pre><code class=\"language-js\">// 先安装 concurrently\n// npm install concurrently --save\n// 修改 package.json 如下\n&quot;server&quot;: &quot;concurrently \\&quot;nodemon ./mock/index.js\\&quot; \\&quot;webpack-dev-server --config webpack.dev.js\\&quot;&quot;</code></pre>\n<p>这样就可以了，运行效果如下</p>\n<p><img src=\"../../../images/blog/node/npm_run_multi.png\" alt=\"npm_run_multi.png\"></p>\n<p>注意：&amp;&amp; 是按顺序执行多条命令， concurrently 是并列执行多条命令，对于跨平台的顺序执行，可以使用 npm-run-all</p>\n<p>参考：<a href=\"https://blog.csdn.net/ligang2585116/article/details/105909789/\">npm并行&amp;串行执行多个scripts命令</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "npm run 运行多条命令 && 不生效的问题"
        }
      ],
      "config": {
        "source": "npm run 运行多条命令 && 不生效的问题.md",
        "staticFileName": "npm_run_multi.html",
        "author": "guoqzuo",
        "createDate": "2020/10/25",
        "description": "在项目中除了默认的 webpack-dev-server 外，我们还想同时运行 mock 接口的 node 服务，，会使用 && 同时执行两条命令。在有些使用实际运行 npm run server 时，只运行了第一条命令，我的是mac，不知道是不是node版本的问题。网上找了下， && 存在兼容性问题。建议使用 concurrently 来代替，concurrently 跨平台兼容",
        "keywords": "npm run &&多条命令不生效",
        "category": "前端工程化",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"normalizecss浏览器样式差异抹平\">normalize.css浏览器样式差异抹平</h1>\n<p><a href=\"https://github.com/necolas/normalize.css\">normalize.css</a>, A modern alternative to CSS resets 一个用于CSS重置的现代替代方法</p>\n<p>主要用于解决不同浏览器默认样式之间的差异</p>\n<p>What does it do?</p>\n<ul>\n<li>Preserves useful defaults, unlike many CSS resets. 保留有用的默认样式，重置许多不一样的CSS</li>\n<li>Normalizes styles for a wide range of elements. 为许多各种各样的元素标准化样式</li>\n<li>Corrects bugs and common browser inconsistencies. 修正bug和常见的浏览器不一致样式</li>\n<li>Improves usability with subtle modifications. 通细微的修改提高可用性</li>\n<li>Explains what code does using detailed comments. 使用详细的注释来解释代码的作用</li>\n</ul>\n<p>下面来看看 Chrome、Safari、Firefox 三个浏览器之间的差异</p>\n<p><img src=\"../../../images/blog/css/before_normalize.png\" alt=\"before_normalize.png\"></p>\n<p>使用 normalize.css 后的效果 </p>\n<p><img src=\"../../../images/blog/css/after_normalize.png\" alt=\"after_normalize.png\"></p>\n<p>现有的UI框架也抹平了这些差异</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "normalize.css浏览器样式差异抹平"
        }
      ],
      "config": {
        "source": "normalize.css浏览器样式差异抹平.md",
        "staticFileName": "normalize.html",
        "author": "guoqzuo",
        "createDate": "2020/10/31",
        "description": "normalize.css, A modern alternative to CSS resets 一个用于CSS重置的现代替代方法。主要用于解决不同浏览器默认样式之间的差异。What does it do? - Preserves useful defaults, unlike many CSS resets. 保留有用的默认样式，重置许多不一样的CSS - Normalizes styles for a wide range of elements. 为许多各种各样的元素标准化样式",
        "keywords": "浏览器样式差异抹平,normalize.css",
        "category": "CSS",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue实用echarts组件封装\">Vue实用echarts组件封装</h1>\n<p>vue中使用echarts可以自己封装一个简单的组件。实现每次更新数据只需要修改options的值即可，并自带loading、暂无数据slot。先来看看使用demo</p>\n<p><img src=\"../../../images/blog/vue/z-echart.gif\" alt=\"z-echart.gif\"></p>\n<pre><code class=\"language-js\">// main.js 全局引入\nimport VueChart from &quot;@guoqzuo/vue-chart&quot;;\nVue.use(VueChart);</code></pre>\n<p>然后在任意组件里可以直接使用 z-echart</p>\n<pre><code class=\"language-html\">&lt;!-- 固定宽柱状图，不自动resize --&gt;\n&lt;div style=&quot;width:300px; height: 300px&quot;&gt;\n  &lt;z-chart :options=&quot;bar&quot; :loading=&quot;loading&quot; :autoResize=&quot;false&quot;&gt; &lt;/z-chart&gt;\n&lt;/div&gt;\n&lt;!-- 宽高自适应，resize后自动渲染，当hasData为false时显示暂无数据的slot内容--&gt;\n&lt;div style=&quot;width: 50%; height: 50vh&quot;&gt;\n  &lt;z-chart :options=&quot;pie&quot; :hasData=&quot;hasData&quot;&gt;\n    暂无数据\n  &lt;/z-chart&gt;\n&lt;/div&gt;</code></pre>\n<p>来看看z-chart组件的实现细节，这里把echart单独用一个组件处理，在z-echart组件里引入，并加入loading、无数据的slot显示处理</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;!-- z-chart --&gt;\n  &lt;div class=&quot;z-chart-container&quot;&gt;\n    &lt;base-chart\n      v-if=&quot;!loading &amp;&amp; hasData&quot;\n      :options=&quot;options&quot;\n      v-on=&quot;$listeners&quot;\n      v-bind=&quot;$attrs&quot;\n    &gt;&lt;/base-chart&gt;\n    &lt;base-loading v-if=&quot;loading&quot;&gt;&lt;/base-loading&gt;\n\n    &lt;!-- no data slot --&gt;\n    &lt;slot v-if=&quot;!loading &amp;&amp; !hasData&quot;&gt;&lt;/slot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre>\n<p>base-chart代码如下，它主要做了三个操作</p>\n<ul>\n<li>使用options初始化图表</li>\n<li>如果是百分比大小的图，resize时，自动重绘</li>\n<li>使用watch监听options改动，如果有改动为了防止渲染异常，直接dispose销毁echart实例，重新加载</li>\n</ul>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;!-- base chart --&gt;\n  &lt;div class=&quot;z-chart&quot; ref=&quot;z-echart&quot;&gt;&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport echarts from &quot;echarts&quot;;\nimport { addListener, removeListener } from &quot;resize-detector&quot;;\nimport { debounce } from &quot;lodash-es&quot;;\n\nexport default {\n  name: &quot;BaseChart&quot;,\n\n  props: {\n    options: {\n      type: Object,\n      required: false\n    },\n    autoResize: {\n      type: Boolean,\n      required: false,\n      default: true\n    }\n  },\n\n  data() {\n    return {};\n  },\n\n  created() {\n    // 监听 options 改动，改动后重绘数据\n    this.$watch(\n      &quot;options&quot;,\n      () =&gt; {\n        this.refresh();\n      },\n      { deep: true }\n    );\n  },\n\n  mounted() {\n    this.init();\n  },\n\n  beforeDestroy() {\n    this.destroy();\n  },\n\n  methods: {\n    init() {\n      let chart = echarts.init(this.$refs[&quot;z-echart&quot;]);\n      chart.setOption(this.options || {});\n      this.chart = chart;\n\n      // 当元素宽高改变时resize执行重绘\n      if (this.autoResize) {\n        this.__resizeHanlder = debounce(\n          () =&gt; {\n            chart.resize();\n          },\n          100,\n          { leading: true }\n        );\n        addListener(this.$el, this.__resizeHanlder);\n      }\n    },\n\n    destroy() {\n      // 销毁实例，防止 柱状图 动态切换到 饼图 时，柱状图部分属性依旧留存的问题\n      this.chart.dispose();\n      this.chart = null;\n      this.autoResize &amp;&amp; removeListener(this.$el, this.__resizeHanlder);\n    },\n\n    // 销毁后重绘，用于options变更后刷新图表\n    refresh() {\n      this.destroy();\n      this.init();\n    }\n  }\n};\n&lt;/script&gt;\n\n&lt;style lang=&quot;less&quot; scoped&gt;\n.z-chart {\n  width: 100%;\n  height: 100%;\n}\n&lt;/style&gt;</code></pre>\n<ul>\n<li><a href=\"https://github.com/zuoxiaobai/vue-chart/tree/master/examples/src/views/zchart\">完整测试demo地址 | github</a></li>\n<li><a href=\"https://github.com/zuoxiaobai/vue-chart/packages/z-chart/\">z-chart组件源码 | github</a></li>\n<li>更加高级的封装，可以查看 <a href=\"https://github.com/vueblocks/ve-charts\">ve-charts源码</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue实用echarts组件封装"
        }
      ],
      "config": {
        "source": "Vue实用echarts组件封装.md",
        "staticFileName": "vue_echarts.html",
        "author": "guoqzuo",
        "createDate": "2020/10/31",
        "description": "vue中使用echarts可以自己封装一个简单的组件。实现每次更新数据只需要修改options的值即可，并自带loading、暂无数据slot。先来看看使用demo",
        "keywords": "Vue echarts组件封装,echarts组件",
        "category": "Vue",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"mac安装nginx在官网下载与使用brew下载的区别\">mac安装nginx在官网下载与使用brew下载的区别</h1>\n<p>nginx官网直接下载的包，mac下可以直接进入该目录使用，但没有加到环境变量，不能在Terminal的任何目录下直接使用。</p>\n<p><img src=\"../../../images/blog/others/nginx_down.png\" alt=\"nginx_down.png\"></p>\n<p>如果使用 <code>brew install nginx</code> 安装，他会直接都安装好，并修改环境变量。可以使用which nginx来看具体的地址</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "mac安装nginx在官网下载与使用brew下载的区别"
        }
      ],
      "config": {
        "source": "mac安装nginx在官网下载与使用brew下载的区别.md",
        "staticFileName": "nginx_install.html",
        "author": "guoqzuo",
        "createDate": "2020/10/31",
        "description": "nginx官网直接下载的包，mac下可以直接进入该目录使用，但没有加到环境变量，不能在Terminal的任何目录下直接使用。如果使用 `brew install nginx` 安装，他会直接都安装好，并修改环境变量。可以使用which nginx来看具体的地址",
        "keywords": "mac nginx安装方法,mac nginx",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"mac安装svn，svn-error-the-subversion-command-line-tools-are-no-longer-provided-by-xcode\">mac安装svn，svn: error: The subversion command line tools are no longer provided by Xcode.</h1>\n<p>在新的macos系统中，xcode不再集成svn，需要自己安装。可以使用 <code>brew install svn</code> 进行安装</p>\n<p>一般 brew 安装前，需要替换源，会快一点，参考：<a href=\"http://www.zuo11.com/blog/2020/10/brew_slow.html\">mac安装brew下载慢，安装异常，切换成ruby-china源</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "mac安装svn，svn: error: The subversion command line tools are no longer provided by Xcode."
        }
      ],
      "config": {
        "source": "svn: error: The subversion command line tools are no longer provided by Xcode.md",
        "staticFileName": "svn_error.html",
        "author": "guoqzuo",
        "createDate": "2020/10/31",
        "description": "在新的macos系统中，xcode不再集成svn，需要自己安装。可以使用 `brew install svn` 进行安装。一般 brew 安装前，需要替换源，会快一点，参考：[mac安装brew下载慢，安装异常，切换成ruby-china源](http://www.zuo11.com/blog/2020/10/brew_slow.html)",
        "keywords": "svn error,mac svn安装",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"mac安装brew下载慢，安装异常，切换成ruby-china源\">mac安装brew下载慢，安装异常，切换成ruby-china源</h1>\n<p>mac下使用brew可以很方便的安装svn、nginx等常用的工具。</p>\n<p>什么是brew [bruː]，它的全称是 <a href=\"https://brew.sh/\">Homebrew</a>，The Missing Package Manager for macOS (or Linux)。它可以安装macOS或linux下没有的包(Package)。</p>\n<p>一般使用ruby来安装</p>\n<pre><code class=\"language-bash\">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre>\n<p>mac自带ruby，但如果直接安装，他会比较慢，直接卡死，安装不上。</p>\n<p><img src=\"../../../images/blog/others/ruby_brew_1.png\" alt=\"ruby_brew_1.png\"></p>\n<p>这就需要使用国内的 ruby 源了。类似与npm与cnpm的概念，这里使用ruby-china的源，具体参考：<a href=\"https://gems.ruby-china.com/\">RubyGems - Ruby China</a></p>\n<pre><code class=\"language-bash\"># 设置ruby源\ngem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/\n# 查看ruby源\ngem sources -l</code></pre>\n<p><img src=\"../../../images/blog/others/ruby_brew_2.png\" alt=\"ruby_brew_2.png\"></p>\n<p><strong>这样，再重新运行安装brew的命令就可以安装成功了，虽然也慢，但至少可以安装成功。安装包就快了。</strong></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/59805070\">Mac必备神器Homebrew</a></li>\n<li><a href=\"https://ruby-china.org/topics/29250\">taobao Gems 源已停止维护，现由 ruby-china 提供镜像服务</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "mac安装brew下载慢，安装异常，切换成ruby-china源"
        }
      ],
      "config": {
        "source": "mac安装brew下载慢，安装异常，切换成ruby-china源.md",
        "staticFileName": "brew_slow.html",
        "author": "guoqzuo",
        "createDate": "2020/10/31",
        "description": "mac下使用brew可以很方便的安装svn、nginx等常用的工具。什么是brew [bruː]，它的全称是 [Homebrew](https://brew.sh/)，The Missing Package Manager for macOS (or Linux)。它可以安装macOS或linux下没有的包(Package)。一般使用ruby来安装",
        "keywords": "brew下载慢,brew切换ruby源,brew安装异常",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"git-status中文乱码怎么解决\">git status中文乱码怎么解决</h1>\n<p>git status时，如果中文乱码，可以对git进行一个配置即可 <code>git config --global core.quotepath false</code></p>\n<p>具体效果如下图</p>\n<p><img src=\"../../../images/blog/git/git_chinese_show.png\" alt=\"git_chinese_show.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "git status中文乱码怎么解决"
        }
      ],
      "config": {
        "source": "git status中文乱码怎么解决.md",
        "staticFileName": "git_status_chinese.html",
        "author": "guoqzuo",
        "createDate": "2020/10/31",
        "description": "git status时，如果中文乱码，可以对git进行一个配置即可 `git config --global core.quotepath false` 具体效果如下图",
        "keywords": "git中文乱码,git status乱码,git乱码",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"npm-install--g或者npm-link需要sudo的问题\">npm install -g或者npm link需要sudo的问题</h1>\n<p>在mac下，安装node后，会出现两个命令 npm 和 node，再使用 npm install -g 时，默认需要管理员权限，可以再前面加 sudo 以管理源方式运行即可。</p>\n<p>如果在开发 npm 包的时候。如果开发对应的命令程序，测试时需要在当前目录执行 npm link，这里也需要加 sudo。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "npm install -g或者npm link需要sudo的问题"
        }
      ],
      "config": {
        "source": "npm install -g或者npm link需要sudo的问题.md",
        "staticFileName": "npm_sudo.html",
        "author": "guoqzuo",
        "createDate": "2020/10/31",
        "description": "在mac下，安装node后，会出现两个命令 npm 和 node，再使用 npm install -g 时，默认需要管理员权限，可以再前面加 sudo 以管理源方式运行即可。如果在开发 npm 包的时候。如果开发对应的命令程序，测试时需要在当前目录执行 npm link，这里也需要加 sudo。",
        "keywords": "sudo npm install -g,sudo npm link,npm link执行报错,npm install -g执行报错",
        "category": "前端工程化",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue组件的封装性与可操作性：ref拿不到子组件实例以及vuex增加代码复杂度问题\">vue组件的封装性与可操作性：ref拿不到子组件实例以及vuex增加代码复杂度问题</h1>\n<p>一般在封装vue组件时，怎么把组件封装的更好，更容易维护理解是值得思考的问题</p>\n<p>来看一个实际场景：一个组件里有高级查询和列表，他们东西都比较多，需要拆分成两个子组件</p>\n<pre><code class=\"language-html\">&lt;!-- index.vue --&gt;\n&lt;project-search&gt;&lt;/project-search&gt;\n&lt;project-list&gt;&lt;/project-list&gt;</code></pre>\n<p>查询的条件参数比较多，假设表单数据变量为 searchForm。</p>\n<p>按照封装的完整性原则，自己的组件的数据放到自己的组件中，那么 searchForm 就需要放到 project-search 组件里。</p>\n<p>但在index.vue中，我们需要查询列表，依赖searchForm的值，涉及到父组件取子组件的值的问题，一般有四种方法可以选择</p>\n<ul>\n<li>searchForm变量放到父组件，通过props传递到子组件（这样有点违背组件的封装性）</li>\n<li>vuex 个人认为，能不使用vuex的场景，尽量不要使用，除非真的需要使用，他会影响代码的简单性。</li>\n<li>bus 使用 bus 来通信，但和vuex类似，尽量少使用</li>\n<li>使用ref直接取。但由于副组件加载子组件时，在mounted钩子里 ref 拿对应的子组件可能会拿不到，需要加 setTiemout，也是一种比较怪的操作</li>\n</ul>\n<p>对比这几种情况。我一般使用props，把值直接放到index.vue里，再传递给子组件。这样算是比较好理解的一种方法，虽然封装性不强。但涉及到数据需要交互的场景，必须要做一些妥协。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue组件的封装性与可操作性：ref拿不到子组件实例以及vuex增加代码复杂度问题"
        }
      ],
      "config": {
        "source": "vue组件的封装性与可操作性：ref拿不到子组件实例以及vuex增加代码复杂度问题.md",
        "staticFileName": "vue_comps_complex.html",
        "author": "guoqzuo",
        "createDate": "2020/10/31",
        "description": "一般在封装vue组件时，怎么把组件封装的更好，更容易维护理解是值得思考的问题。来看一个实际场景：一个组件里有高级查询和列表，他们东西都比较多，需要拆分成两个子组件",
        "keywords": "vue组件封装,props ref vuex封装组件时对比",
        "category": "Vue",
        "year": "2020",
        "month": "10"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-父组件在什么时候开始加载子组件，父子组件的钩子函数顺序是什么？\">Vue 父组件在什么时候开始加载子组件，父子组件的钩子函数顺序是什么？</h1>\n<p>一般父组件会在自身组件 mounted 后，开始加载子组件，下面来通过一个例子来看完整的父子组件钩子函数。下面的例子中在 index.vue 以及 compA.vue 父子组件中都加了对应的钩子函数 console</p>\n<pre><code class=\"language-html\">&lt;!-- index.vue --&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;comp-a&gt;&lt;/comp-a&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre>\n<p>运行后，对应的 console.log 信息如下</p>\n<ul>\n<li>index beforeCreate</li>\n<li>index.vue index created</li>\n<li>index.vue index beforeMount</li>\n<li>index.vue index mounted</li>\n<li>index.vue index beforeUpdate</li>\n<li>A.vue A beforeCreate</li>\n<li>A.vue A created</li>\n<li>A.vue A beforeMount</li>\n<li>A.vue A mounted</li>\n<li>index.vue index updated</li>\n</ul>\n<p>父组件 beforeCreate =&gt; 父组件 created =&gt; 父组件 beforeMount =&gt; 父组件 mounted =&gt; 父组件 beforeUpdate =&gt; 子组件 beforeCreate =&gt; 子组件 created =&gt; 子组件 beforeMount =&gt; 子组件 mounted =&gt; 父组件 index updated</p>\n<p>如下图，完整demo参见 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/views/vuehooks\">父子组件钩子函数demo ｜ github</a></p>\n<p><img src=\"../../../images/blog/vue/sub_comp_hooks.png\" alt=\"sub_comp_hooks.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue 父组件在什么时候开始加载子组件，父子组件的钩子函数顺序是什么？"
        }
      ],
      "config": {
        "source": "Vue 父组件在什么时候开始加载子组件，父子组件的钩子函数顺序是什么？.md",
        "staticFileName": "vue_son_hooks.html",
        "author": "guoqzuo",
        "createDate": "2020/11/08",
        "description": "一般父组件会在自身组件 mounted 后，开始加载子组件，下面来通过一个例子来看完整的父子组件钩子函数。下面的例子中在 index.vue 以及 compA.vue 父子组件中都加了对应的钩子函数 console。父组件 beforeCreate => 父组件 created => 父组件 beforeMount => 父组件 mounted => 父组件 beforeUpdate => 子组件 beforeCreate => 子组件 created => 子组件 beforeMount => 子组件 mounted => 父组件 index updated",
        "keywords": "vue父组件在什么时候开始加载子组件,vue父子组件钩子函数顺序",
        "category": "Vue",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"eslintignore不生效-vscode-eslint插件不同版本有差异的问题\">.eslintignore不生效, vscode eslint插件不同版本有差异的问题</h1>\n<p>.eslintignore 文件的作用是，当不想对项目的某个目录进行 eslint 检查时，可以在这个文件中声明，类似 .gitignore 文件的效果。</p>\n<pre><code class=\"language-js\">// .eslintignore\nmock</code></pre>\n<p>上面表示忽略 mock 文件夹下的 eslint 代码检查。这样 eslint 插件就不会显示 warning、不会保存后自动 fix 该文件。在这个文件中去掉mock后，mock下的文件就又可以保存后 fix 了。</p>\n<p>但有一个问题，vscode eslint插件不同版本的行为可能有差异，有可能把目录加入到了.eslintignore 后，保存时还是会 fix 这个目录下的 eslint 错误。<strong>这种情况建议升级到最新版本。</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": ".eslintignore不生效, vscode eslint插件不同版本有差异的问题"
        }
      ],
      "config": {
        "source": "eslintignore不生效, vscode eslint插件不同版本有差异的问题.md",
        "staticFileName": "eslintignore_vscode.html",
        "author": "guoqzuo",
        "createDate": "2020/11/08",
        "description": ".eslintignore 文件的作用是，当不想对项目的某个目录进行 eslint 检查时，可以在这个文件中声明，类似 .gitignore 文件的效果。但有一个问题，vscode eslint插件不同版本的行为可能有差异，有可能把目录加入到了.eslintignore 后，保存时还是会 fix 这个目录下的 eslint 错误。这种情况建议升级到最新版本。",
        "keywords": ".eslintignore不生效,vscode eslint插件不同版本差异",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-子组件名称与父组件name相同时死循环的问题\">Vue 子组件名称与父组件name相同时死循环的问题</h1>\n<p>在vue项目中，假设父组件name与子组件名称一致，会造成死循环，出现 <code>Error in nextTick: &quot;RangeError: Maximum call stack size exceeded&quot;</code> 的错误，template在编译时，不会去找 components 引入的组件，而是直接引入自己，形成一个循环引用、递归组件，要特别注意。</p>\n<pre><code class=\"language-js\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;p&gt;我是index组件&lt;/p&gt;\n    &lt;test-a&gt;&lt;/test-a&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  components: {\n    TestA: () =&gt; import(&quot;./TestA&quot;)\n  },\n  // name: &quot;testA&quot;,\n  name: &quot;TestA&quot;,\n  created() {\n    console.log(&quot;index comp created&quot;);\n  }\n};\n&lt;/script&gt;</code></pre>\n<p><img src=\"../../../images/blog/vue/subcomp_samename.png\" alt=\"subcomp_samename.png\"></p>\n<p>完成demo地址，参考 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/views/subcomp_samename\">subcomp_samename demo| github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue 子组件名称与父组件name相同时死循环的问题"
        }
      ],
      "config": {
        "source": "Vue 子组件名称与父组件name相同时死循环的问题.md",
        "staticFileName": "vue_stacksize_exceeded.html",
        "author": "guoqzuo",
        "createDate": "2020/11/08",
        "description": "在vue项目中，假设父组件name与子组件名称一致，会造成死循环，出现 Error in nextTick: 'RangeError: Maximum call stack size exceeded' 的错误，template在编译时，不会去找 components 引入的组件，而是直接引入自己，形成一个循环引用、递归组件，要特别注意。",
        "keywords": "vue组件循环引用,vue递归组件,Maximum call stack size exceeded",
        "category": "Vue",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-keep-alive在路由跳转时按需缓存当前页面数据，route非双向绑定的问题\">Vue keep-alive在路由跳转时按需缓存当前页面数据，$route非双向绑定的问题</h1>\n<p>有这么一个需求，页面 B 跳转到页面 C 时需要保存页面交互数据，跳到其他页面不缓存数据。在 Vue 中这种功能一般会使用 keep-alive 的 include 或 exclude 有条件的缓存来实现。起初我想省事，直接使用 $route.meta 来动态修改 include 值，但后面发现不生效，原来 $router.meta 不是双向绑定的，需要使用其他变量才行，下面来看看具体逻辑。 </p>\n<p>我们可以使用路由 meta 参数里传 keepAlive 为 true 或 false 来对某个路由页面做缓存。示例代码如下：</p>\n<pre><code class=\"language-html\">&lt;keep-alive&gt;\n  &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;\n&lt;/keep-alive&gt;\n&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</code></pre>\n<p>我们假设有A、B、C三个页面组件。B页面只有跳到C页面才缓存数据，跳到其他页面不缓存页面数据</p>\n<p>这里 router-view 组件会切换三个组件的显示类似于 component is 切换组件。我们需要动态的去判断是否缓存 B 页面组件，使用 keep-alive 的 include 参数来指定需要缓存的页面组件数据</p>\n<pre><code class=\"language-html\">&lt;!-- 逗号分隔字符串 --&gt;\n&lt;keep-alive include=&quot;PageB&quot;&gt;\n  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;\n&lt;/keep-alive&gt;</code></pre>\n<p>假设B页面组件的 name 为 &#39;PageB&#39;，那么默认情况下 include 为 &#39;PageB&#39;，就表示缓存该页面，如果设置 include 为 &#39;&#39; 就是不缓存页面数据，核心问题是怎么动态的改变这个 include 的值。</p>\n<p>我们可以在B页面组件路由离开之前的钩子函数里，来修改这个值，<strong>注意，需要单独弄一个变量，使用 <code>$route.meta.include</code> 参数来修改这个值是没有用的，因为 <code>$route.meta</code> 这个值并不像data里面的数据是双向绑定的，他在进入页面时就固定了。中间修改这个值不会触发 template 里面的模板重新渲染</strong></p>\n<h2 id=\"routemeta-是否是双向绑定测试\">$route.meta 是否是双向绑定测试</h2>\n<p>我们来测试 $route.meta 是否是双向绑定，下面的 demo 中 view 视图里面显示 <code>$route.meta.include</code> 的值，然后 3 秒后，再修改对应的值。页面上对应的值并没有刷新，所以 keep-alive 里面的 router-view 不能使用 router meta 里面的值来做实时切换，需要单独使用一个变量。</p>\n<pre><code class=\"language-html\">&lt;!-- index.vue 入口页面 http://localhost:8081/keepAlive/ --&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    我是主页面\n    &lt;ul&gt;\n      &lt;li&gt;&lt;router-link to=&quot;/keepAlive/a&quot;&gt;A组件页面&lt;/router-link&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;router-link to=&quot;/keepAlive/b&quot;&gt;B组件页面&lt;/router-link&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;router-link to=&quot;/keepAlive/c&quot;&gt;C组件页面&lt;/router-link&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n    include{{ include }}\n    &lt;keep-alive :include=&quot;include&quot;&gt;\n      &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;\n    &lt;/keep-alive&gt;\n    &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;\n    &lt;!-- 测试 $route.meta 的值是否是双向绑定的 --&gt;\n    $route.meta.include {{$route.meta.include}}\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      include: &quot;PageB&quot;\n    };\n  },\n  created() {\n    // 这里修改值后数据，页面的$route.meta.include值并没有刷新，因此不能为了节省变量使用$route.meta来做include的控制\n    setTimeout(() =&gt; {\n      this.$route.meta.include = &quot;test&quot;\n      console.log(&#39;this.$route.meta.include&#39;, &#39;test&#39;)\n    }, 3000)\n  }\n};\n&lt;/script&gt;</code></pre>\n<h2 id=\"b组件跳转时逻辑处理\">B组件跳转时逻辑处理</h2>\n<p>/keepAlive/a、/keepAlive/c 只是单独的页面，没有任何逻辑，只是用来测试跳转。主要逻辑是在/keepAlive/b页面，下面的代码中在路由离开之前判断跳转的目标页面</p>\n<ol>\n<li>如果是页面 C，动态修改 keep-avlie 的 include 为 &#39;PageB&#39;，即缓存当前页面数据。</li>\n<li>如果是其他页面，include 设置为 &#39;&#39;，不缓存任何数据</li>\n</ol>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    我是B组件页面\n    &lt;el-input v-model=&quot;input&quot; placeholder=&quot;请输入B组件内容&quot;&gt;&lt;/el-input&gt;\n    &lt;el-radio-group v-model=&quot;radio&quot;&gt;\n      &lt;el-radio :label=&quot;3&quot;&gt;备选项&lt;/el-radio&gt;\n      &lt;el-radio :label=&quot;6&quot;&gt;备选项&lt;/el-radio&gt;\n      &lt;el-radio :label=&quot;9&quot;&gt;备选项&lt;/el-radio&gt;\n    &lt;/el-radio-group&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: &quot;PageB&quot;,\n  data() {\n    return {\n      input: &quot;&quot;,\n      radio: &quot;&quot;\n    };\n  },\n  beforeRouteLeave(to, from, next) {\n    if (to.name === &quot;keepAliveC&quot;) {\n      // 如果跳转的页面C组件，缓存页面数据\n      this.$parent.include = &quot;PageB&quot;;\n    } else {\n      // 如果跳转的页面不是C组件，不缓存数据\n      this.$parent.include = &quot;&quot;;\n    }\n    next();\n  }\n};\n&lt;/script&gt;</code></pre>\n<p>以上就可以实现我们的目的了，完整demo参见 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/views/keepAlive\">keepalive测试demo｜ github</a></p>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/api/#keep-alive\">keep-alive | Vue.js API</a></li>\n<li><a href=\"https://blog.csdn.net/agonie201218/article/details/82151457\">keep-alive的深入理解与使用(配合router-view缓存整个路由页面)</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue keep-alive在路由跳转时按需缓存当前页面数据，$route非双向绑定的问题",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "$route.meta 是否是双向绑定测试"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "B组件跳转时逻辑处理"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "Vue keep-alive在路由跳转时按需缓存当前页面数据，$route非双向绑定的问题.md",
        "staticFileName": "keep-alive-include.html",
        "author": "guoqzuo",
        "createDate": "2020/11/08",
        "description": "有这么一个需求，页面 B 跳转到页面 C 时需要保存页面交互数据，跳到其他页面不缓存数据。在 Vue 中这种功能一般会使用 keep-alive 的 include 或 exclude 有条件的缓存来实现。起初我想省事，直接使用 $route.meta 来动态修改 include 值，但后面发现不生效，原来 $router.meta 不是双向绑定的，需要使用其他变量才行，下面来看看具体逻辑。",
        "keywords": "vue keep-alive按需缓存页面,vue按需缓存,$route是否是双向绑定的",
        "category": "Vue",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"不全局安装npm包，怎么在项目目录下局部执行对应的命令\">不全局安装npm包，怎么在项目目录下局部执行对应的命令</h1>\n<p>一般在 Vue 开发中，vue 命令可以执行，是因为全局安装了 <code>@vue/cli</code> npm包。假设你无法使用 npm install -g 全局安装，那怎么在当前项目所在的目录运行对应的命令呢？这里我们使用 zuo-util 这么 npm 包来介绍 3 种在项目种运行 npm 包命令的方法：</p>\n<ol>\n<li>npm run xxx</li>\n<li>npx 命令 </li>\n<li>./node_modules/.bin/命令</li>\n</ol>\n<p>先准备测试 demo</p>\n<pre><code class=\"language-bash\"># 随便创建一个文件夹，并使用terminal进入到该目录，执行 npm init 创建 package.json\nnpm init\n# 输入项目名，英文，这里用 npm_cmd_test，其他全部默认回车\n# 运行 zuo 这个命令\nzuo\n# 找不到这个命令，说明全局没有安装 zsh: command not found: zuo</code></pre>\n<p>我们再局部安装下</p>\n<pre><code class=\"language-bash\"># 项目里局部安装 zuo-util，非全局安装\nnpm install zuo-util --save\n# 再运行 zuo，还是不行\nzuo</code></pre>\n<p><img src=\"../../../images/blog/node/npm_zuo_1.png\" alt=\"npm_zuo_1.png\"></p>\n<p>我们可以使用下面三种方法来运行局部安装的npm包对应的命令</p>\n<h2 id=\"npm-run-xxx\">npm run xxx</h2>\n<p>在 package.json 里的 scripts 里面，我们可以设置运行的命令</p>\n<pre><code class=\"language-js\">// package.json\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;zuo&quot;: &quot;zuo&quot;\n  },</code></pre>\n<p>按照上面的代码设置后，npm run zuo 即可执行当前目录下的zuo命令</p>\n<p><img src=\"../../../images/blog/node/npm_zuo_3.png\" alt=\"npm_zuo_3.png\"></p>\n<h2 id=\"npx-命令\">npx 命令</h2>\n<p>可以使用npx 命令名，执行项目中的，非全局的命令</p>\n<pre><code class=\"language-bash\">npx zuo</code></pre>\n<h2 id=\"node_modulesbin命令\">./node_modules/.bin/命令</h2>\n<p>一般局部安装的命令都会放到 <code>./node_modules/.bin/</code> 目录下，可以通过 . 语法直接运行</p>\n<pre><code class=\"language-bash\">./node_modules/.bin/zuo</code></pre>\n<p><img src=\"../../../images/blog/node/npm_zuo_2.png\" alt=\"npm_zuo_2.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "不全局安装npm包，怎么在项目目录下局部执行对应的命令",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "npm run xxx"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "npx 命令"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "./node_modules/.bin/命令"
            }
          ]
        }
      ],
      "config": {
        "source": "不全局安装npm包，怎么在项目目录下局部执行对应的命令.md",
        "staticFileName": "npm_cmd_part.html",
        "author": "guoqzuo",
        "createDate": "2020/11/08",
        "description": "一般在 Vue 开发中，vue 命令可以执行，是因为全局安装了 `@vue/cli` npm包。假设你无法使用 npm install -g 全局安装，那怎么在当前项目所在的目录运行对应的命令呢？这里我们使用 zuo-util 这么 npm 包来介绍 3 种在项目种运行 npm 包命令的方法：1. npm run xxx 2. npx 命令 3. ./node_modules/.bin/命令",
        "keywords": "局部执行npm包命令,不全局安装npm包，怎么在项目中运行命令,局部执行命令",
        "category": "前端工程化",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"mac下怎么截取屏幕gif图：gifox\">mac下怎么截取屏幕gif图：Gifox</h1>\n<p>之前在 windows 下用过一款比较好用的免费 gif 工具。后面在 mac 上，就没怎么做 gif 图了。最开始在 mac 上尝试做 gif 图是使用 QuickTime 录制屏幕后，再搜索在线视频转 gif 图的网站进行转换，比较麻烦。</p>\n<p><img src=\"../../../images/blog/devtools/Gifox_logo.png\" alt=\"Gifox_logo.png\"></p>\n<p>最近发现一个比较好的软件 <a href=\"https://gifox.io/\">Gifox</a>，我使用的是免费版的，有水印，最大长度限制为10s。升级付费的版本可以去水印(watermark)，且没有10s限制。它功能强大，录制gif很方便</p>\n<p><img src=\"../../../images/blog/devtools/Gifox_opt.png\" alt=\"Gifox_opt.png\"></p>\n<p>功能如下:</p>\n<ol>\n<li>shift + command + 6 即可录制选中区域进行录制。</li>\n<li>录制完成后，可以像剪辑视频一样剪辑gif图，操作简单</li>\n<li>导出时，可以调整参数，压缩文件大小</li>\n<li>可以直接把QuickTime录制的视频转为gif，并可以剪辑</li>\n</ol>\n<p><img src=\"../../../images/blog/devtools/Gifox_edit.png\" alt=\"Gifox_edit.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "mac下怎么截取屏幕gif图：Gifox"
        }
      ],
      "config": {
        "source": "mac下怎么截取屏幕gif图：Gifox.md",
        "staticFileName": "mac_gif_tools.html",
        "author": "guoqzuo",
        "createDate": "2020/11/08",
        "description": "之前在 windows 下用过一款比较好用的免费 gif 工具。后面在 mac 上，就没怎么做 gif 图了。最开始在 mac 上尝试做 gif 图是使用 QuickTime 录制屏幕后，再搜索在线视频转 gif 图的网站进行转换，比较麻烦。最近发现一个比较好的软件 [Gifox](https://gifox.io/)，我使用的是免费版的，有水印，最大长度限制为10s。升级付费的版本可以去水印(watermark)，且没有10s限制。它功能强大，录制gif很方便",
        "keywords": "mac gif,mac好用的gif工具,mac做gif图",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"涉及到状态code相关判断逻辑，建议使用常量\">涉及到状态code相关判断逻辑，建议使用常量</h1>\n<p>对于一些状态较多的场景，当我们需要进行一些逻辑时，如果我们用状态的code来写判断逻辑。当后端提供的这个状态文案、code变更或调整，改动可能会很麻烦，特别是功能较多时。</p>\n<p><strong>对于状态相关的判断逻辑，尽量把状态定义为容易识别的常量。这样状态名或状态code变更后，就不需要做大量修改了。</strong></p>\n<p>来看一个实例，假设项目的状态有几种：待审核 0 、待跟进 1、已立项 2、落地成功 3、落地失败 4、 关闭 5 ，有些组件只有待审核可以看到，有些功能只有已立项才能看到</p>\n<pre><code class=\"language-js\">const PROJ_STATUS = {\n  PENDING_AUDIT: 0,\n  PENDING_FOLLOW: 1,\n  ALREADY_SET_UP: 2,\n  LAND_SUCCESS: 3,\n  LAND_FAILURE: 4,\n  CLOSE: 5\n}\nconst PROJ_LABEL_MAP = {\n  [PROJ_STATUS.PENDING_AUDIT]: &#39;待审核&#39;,\n  [PROJ_STATUS.PENDING_FOLLOW]: &#39;待跟进&#39;,\n  [PROJ_STATUS.ALREADY_SET_UP]: &#39;已立项&#39;,\n  [PROJ_STATUS.LAND_SUCCESS]: &#39;落地成功&#39;,\n  [PROJ_STATUS.LAND_FAILURE]: &#39;落地失败&#39;,\n  [PROJ_STATUS.CLOSE]: &#39;关闭&#39;\n}\n\nif (status === PROJ_STATUS.PENDING_AUDIT) {\n  // xxx\n} else if ([PROJ_STATUS.LAND_SUCCESS,PROJ_STATUS.LAND_FAILURE].includes(status)) {\n  // xxx\n}</code></pre>\n<p>这样虽然看起来麻烦一点，但不管你状态文案、code怎么变，前端的改动都会很小。项目越大，变动后维护的成本相对会越低</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "涉及到状态code相关判断逻辑，建议使用常量"
        }
      ],
      "config": {
        "source": "涉及到状态code相关判断逻辑，建议使用常量.md",
        "staticFileName": "code_logic.html",
        "author": "guoqzuo",
        "createDate": "2020/11/08",
        "description": "对于一些状态较多的场景，当我们需要进行一些逻辑时，如果我们用状态的code来写判断逻辑。当后端提供的这个状态文案、code变更或调整，改动可能会很麻烦，特别是功能较多时。对于状态相关的判断逻辑，尽量把状态定义为容易识别的常量。这样状态名或状态code变更后，就不需要做大量修改了。",
        "keywords": "code消除魔术字符串,code判断逻辑使用常量",
        "category": "JavaScript",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"js生成二维码怎么实现\">js生成二维码怎么实现</h1>\n<p>QRCode.js 是一个生成二维码的 js 库，使用 HTML5 Canvas 将二维码绘制到 dom 上，不依赖任何库。支持 svg 绘制方式</p>\n<blockquote>\n<p>QRCode.js is javascript library for making QRCode. QRCode.js supports Cross-browser with HTML5 Canvas and table tag in DOM. QRCode.js has no dependencies.</p>\n</blockquote>\n<p>QRCode.js 使用很简单，下面来写一个自动生成二维码的工具，在线示例 <a href=\"https://zuoxiaobai.github.io/fedemo/src/DebugDemo/%E5%89%8D%E7%AB%AF%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/\">在线生成二维码工具</a></p>\n<p><img src=\"../../../images/blog/js/qrcode_js.png\" alt=\"qrcode_js.png\"></p>\n<p>逻辑代码如下：</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n  &lt;div style=&quot;margin-bottom:20px;&quot;&gt;\n    &lt;input id=&quot;input&quot; type=&quot;text&quot;&gt;\n    &lt;button id=&quot;btn&quot;&gt;生成二维码&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;div id=&quot;qrcode&quot;&gt;&lt;/div&gt;\n  &lt;!-- 在 https://github.com/davidshimjs/qrcodejs 下载的文件 ---&gt;\n  &lt;script src=&quot;./qrcode.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script type=&quot;text/javascript&quot;&gt;\n    let inputEl = document.getElementById(&#39;input&#39;)\n    let btnEl = document.getElementById(&#39;btn&#39;)\n    btnEl.onclick = () =&gt; {\n      document.getElementById(&quot;qrcode&quot;).innerHTML = &#39;&#39;\n      // new QRCode(document.getElementById(&quot;qrcode&quot;), inputEl.value);\n      let qrcode = new QRCode(document.getElementById(&quot;qrcode&quot;), {\n        text: inputEl.value,\n        width: 128,\n        height: 128,\n        colorDark: &quot;#000000&quot;,\n        colorLight: &quot;#ffffff&quot;,\n        correctLevel: QRCode.CorrectLevel.H\n      });\n      // 上面使用清空dom，再重绘，也可以使用内置的方法来重绘\n      // qrcode.clear(); // clear the code.\n      // qrcode.makeCode(inputEl.value); // make another code.\n    }\n  &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p>注意：如果输入的是纯文本，那扫描后打开的就是纯文本，如果是 <code>http://</code> 开头的网址，会直接跳转到对应的 URL</p>\n<p>完整 demo，参见: <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/DebugDemo/%E5%89%8D%E7%AB%AF%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81\">前端生成二维码 | github</a></p>\n<p>参考：<a href=\"https://github.com/davidshimjs/qrcodejs\">QRCode.js | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "js生成二维码怎么实现"
        }
      ],
      "config": {
        "source": "JS生成二维码怎么实现.md",
        "staticFileName": "js_qrcode.html",
        "author": "guoqzuo",
        "createDate": "2020/11/08",
        "description": "QRCode.js 是一个生成二维码的 js 库，使用 HTML5 Canvas 将二维码绘制到 dom 上，不依赖任何库。支持 svg 绘制方式。QRCode.js is javascript library for making QRCode. QRCode.js supports Cross-browser with HTML5 Canvas and table tag in DOM. QRCode.js has no dependencies. QRCode.js 使用很简单，下面来写一个自动生成二维码的工具",
        "keywords": "js生成二维码,前端生成二维码,js生成二维码链接",
        "category": "JavaScript",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-单元测试\">Vue 单元测试</h1>\n<p>在 Vue.js 官网，学习 =&gt; CookBook 下有一个 <strong>Vue 组件的单元测试</strong> 文档。</p>\n<p>为什么要测试？组件的单元测试的好处:</p>\n<ul>\n<li>提供描述组件行为的文档</li>\n<li><strong>节省手动测试的时间</strong></li>\n<li><strong>减少研发新特性时产生的 bug</strong></li>\n<li>改进设计</li>\n<li>促进重构</li>\n<li><strong>自动化测试使得大团队中的开发者可以维护复杂的基础代码</strong></li>\n</ul>\n<p>Vue Test Utils 是 Vue 组件单元测试的官方库。他的作者 Edd Yerburgh 写了一本书 《Testing Vue.js Applications》，中文翻译版为《Vue.js应用测试》，如果想系统的学习 Vue 应用测试，建议看这本书。掘金上有一篇该书的笔记，可以参考：<a href=\"https://juejin.im/post/6865477717220851720\">学习Vue应用测试，让你的项目更加健壮和稳定 | 掘金</a></p>\n<p>Vue 官方相关参考文档</p>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/cookbook/unit-testing-vue-components.html\">Vue 组件的单元测试 | Vue.js</a></li>\n<li><a href=\"https://vue-test-utils.vuejs.org/zh/\">Vue Test Utils | 文档</a></li>\n<li><a href=\"https://github.com/vuejs/vue-test-utils\">Vue Test Utils | Github</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue 单元测试"
        }
      ],
      "config": {
        "source": "Vue 单元测试.md",
        "staticFileName": "vue_unit_test.html",
        "author": "guoqzuo",
        "createDate": "2020/11/16",
        "description": "在 Vue.js 官网，学习 => CookBook 下有一个 Vue 组件的单元测试 文档。为什么要测试？组件的单元测试的好处: 节省手动测试的时间，减少研发新特性时产生的 bug，自动化测试使得大团队中的开发者可以维护复杂的基础代码。Vue Test Utils 是 Vue 组件单元测试的官方库。他的作者写了一本书 《Testing Vue.js Applications》，对应的中文版本是《Vue.js应用测试》，如果想系统的学习 Vue 应用测试，建议看这本书。",
        "keywords": "vue单元测试,vue测试,vue应用测试",
        "category": "Vue",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"什么是e2e-test，除了单元测试外还有什么测试？\">什么是e2e test，除了单元测试外还有什么测试？</h1>\n<p>e2e 是 end to end 的缩写，翻译为端到端测试。单元测试只是整个测试金字塔中的一部分。其他类型的测试还包括 e2e(端到端)测试，快照比对测试等。</p>\n<h2 id=\"e2e端到端测试\">e2e(端到端)测试</h2>\n<p>e2e(端到端)测试致力于确保组件的一系列交互是正确的。相比简单快速的单元测试，它是更高级别的测试，例如可能会测试用户是否注册、登录以及更新他们的用户名。这种测试运行起来会比单元测试和快照比对测试慢一些。运行起来会更慢很多。这些测试通常只在部署前运行，来确保系统的每个部分都能够正常的协同工作。下面是一个简单的 e2e 测试示例：检查计算器两数求和的方法</p>\n<pre><code class=\"language-js\">function testCal(browser) {\n  browser\n    .url(&#39;http://localhost:8080&#39;) // 使用浏览器打开 http://localhost:8080\n    .click(&#39;#button-1&#39;) // 点击计算机按钮\n    .click(&#39;#button-plus&#39;)\n    .click(&#39;#button-1&#39;)\n    .click(&#39;#button-equal&#39;)\n    .assert.containsText(&quot;#result&quot;, &quot;2&quot;) // 断言计算器显示结果是否正确\n    .end()\n}</code></pre>\n<h2 id=\"单元测试\">单元测试</h2>\n<p>单元测试是最小巧、最简单、最有用的测试。它们通过隔离单个组件的每一个部分，来在最小工作单元上进行断言。能帮助开发者思考如何设计一个组件或重构一个现有组。通常每次代码发生变化的时候它们都会被运行，来看一个基本的单元测试例子：</p>\n<pre><code class=\"language-js\">// sum.js\n// 待测试函数 sum\nexport default function sum(a, b) {\n  return a + b\n}\n\n// sum.spec.js\n// 将 sum 函数导入测试文件\nimport sum from &#39;../sum.js&#39;\n\nfunction testSum() {\n  // 如果 sum 函数不返回 2，则抛出错误\n  if (sum(1, 1) !== 2) {\n    throw new Error(&#39;sum(1, 1) did not return 2&#39;)\n  }\n}\n\ntestSum() // 运行测试</code></pre>\n<h2 id=\"快照比对测试\">快照比对测试</h2>\n<p>类似于找不同的游戏，快照测试会给运行中的应用拍一张图片，并将它与之前保存的图片进行比较。如果不同就是测试失败。这种方法对于确保代码变更后是否任然可以正确渲染很有帮助。以 Vue 组件为例子，会保存你的 Vue 组件的标记，然后比较每次新生成的测试运行结果。如果有些东西改变了，开发者就会得到通知，并决定这个改变是刻意为之 (组件更新时) 还是意外发生的 (组件行为不正确)。</p>\n<p>更多测试 Vue 测试细节，可以参考 Edd Yerburgh 的书《Testing Vue.js Applications》，中文翻译版为《Vue.js应用测试》</p>\n<p>参考：<a href=\"https://cn.vuejs.org/v2/cookbook/unit-testing-vue-components.html#%E9%A2%9D%E5%A4%96%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87\">额外的上下文 - Vue 组件的单元测试</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "什么是e2e test，除了单元测试外还有什么测试？",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "e2e(端到端)测试"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "单元测试"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "快照比对测试"
            }
          ]
        }
      ],
      "config": {
        "source": "什么是e2e test，除了单元测试外还有什么测试？.md",
        "staticFileName": "e2e_test.html",
        "author": "guoqzuo",
        "createDate": "2020/11/16",
        "description": "e2e 是 end to end 的缩写，翻译为端到端测试。单元测试只是整个测试金字塔中的一部分。其他类型的测试还包括 e2e(端到端)测试，快照比对测试等。e2e(端到端)测试致力于确保组件的一系列交互是正确的。相比简单快速的单元测试，它是更高级别的测试，例如可能会测试用户是否注册、登录以及更新他们的用户名。这种测试运行起来会比单元测试和快照比对测试慢一些。运行起来会更慢很多。这些测试通常只在部署前运行，来确保系统的每个部分都能够正常的协同工作。",
        "keywords": "e2e test,e2e test示例,端到端测试",
        "category": "Vue",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"xxgithubio偶尔访问不了是为什么？\">xx.github.io偶尔访问不了是为什么？</h1>\n<p>在 Github 上开启 Pages 服务后，可以通过 xx.github.io 访问对应的网页。但偶尔会出现打不开的问题，之前都是可以打开的，试了其他人的 github.io，发现也打不开，这就不是自己网络的问题了。</p>\n<p>网上查原因是电信运营商 DNS 污染（域名解析不到正确的 IP 地址）。我们在本地手动设置 host 指定对应域名的解析 IP 即可正常访问，假设我要访问 <code>https://zuoxiaobai.github.io/fedemo/</code> 那手动指定一下这个域名的解析ip即可。下面来看具体怎么操作</p>\n<pre><code class=\"language-bash\"># 修改 /etc/hosts\nsudo vi /etc/hosts\n# 添加如下host记录\n185.199.108.153 zuoxiaobai.github.io\n# 查看host文件\ncat /etc/hosts    \n##\n# Host Database\n#\n# localhost is used to configure the loopback interface\n# when the system is booting.  Do not change this entry.\n##\n127.0.0.1    localhost\n185.199.108.153 zuoxiaobai.github.io\n255.255.255.255    broadcasthost\n::1             localhost</code></pre>\n<p>保存后，就可以打开 <code>https://zuoxiaobai.github.io/fedemo/</code> 了。<strong>这样只能保证自己的电脑上可以正常访问这个网站，但其他人也会出现偶尔访问不了的情况，对于要求较高的网站，建议部署在自己的服务器上。如果想要免费的，可以在 码云 上面弄一个仓库来做自己的网站。国内 IP 解析很快，参考 vant 组件官网。</strong></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_43229056/article/details/108036569\">github.io无法访问问题及解决</a></li>\n<li><a href=\"https://www.cnblogs.com/onelikeone/p/12791969.html\">github无法访问的解决方法 --- 2020</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "xx.github.io偶尔访问不了是为什么？"
        }
      ],
      "config": {
        "source": "xx.github.io偶尔访问不了是为什么？.md",
        "staticFileName": "github_io_failure.html",
        "author": "guoqzuo",
        "createDate": "2020/11/16",
        "description": "在 Github 上开启 Pages 服务后，可以通过 xx.github.io 访问对应的网页。但偶尔会出现打不开的问题，之前都是可以打开的，试了其他人的 github.io，发现也打不开，这就不是自己网络的问题了。网上查原因是电信运营商 DNS 污染（域名解析不到正确的 IP 地址）。我们在本地手动设置 host 指定对应域名的解析 IP 即可正常访问。下面来看具体怎么操作",
        "keywords": "xx.github.io打不开,github.io打不开,githu.io访问不了",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"ssh生成rsa-key时enter-passphrase加和不加有什么区别？\">ssh生成rsa key时Enter passphrase加和不加有什么区别？</h1>\n<p>在使用 ssh 拉取 git 仓库前，需要先生成公共/私有 rsa 密钥对。(Generating public/private rsa key pair.)，一般使用 <code>ssh-keygen -t rsa -C &#39;邮箱@xx.com&#39;</code> 命令，这个时候，会有下面的提示</p>\n<p>Enter passphrase (empty for no passphrase): </p>\n<p>输入通行码(密码、口令短语)，如果不输入，那么就是不使用密码。<strong>如果输入了密码，这个有什么用呢？</strong></p>\n<p>这个主要是安全方面的考虑，如果你私钥泄露了，还有一个保护机制。在你每次使用 ssh 做敏感操作时，就会提示你输入密码</p>\n<p>比如我们使用 ssh 方式拉取 git 仓库代码，远程 origin 源是 ssh 地址，<strong>那么提交代码时，每次 git pull, git push 时都需要输入对应的秘钥</strong>。相对会比较麻烦一点，但安全性更高。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "ssh生成rsa key时Enter passphrase加和不加有什么区别？"
        }
      ],
      "config": {
        "source": "ssh生成rsa key时Enter passphrase加和不加有什么区别.md",
        "staticFileName": "ssh_passphrase.html",
        "author": "guoqzuo",
        "createDate": "2020/11/16",
        "description": "在使用 ssh 拉取 git 仓库前，需要先生成公共/私有 rsa 密钥对。(Generating public/private rsa key pair.)，一般使用 `ssh-keygen -t rsa -C '邮箱@xx.com'` 命令，这个时候，会有下面的提示：Enter passphrase (empty for no passphrase): 输入通行码(密码、口令短语)，如果不输入，那么就是不使用密码。如果输入了密码，这个有什么用呢？",
        "keywords": "ssh passphrase,ssh passphrase有什么用",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"使用git-ssh方式解决rpc-failed-http-413-curl-22-the-requested-url-returned-error-413\">使用git ssh方式解决RPC failed; HTTP 413 curl 22 The requested URL returned error: 413</h1>\n<p>由于改了博客生成系统的生成方式，每个html都改了，导致文件相对较多，也不算大，才 4.57 M, 但 git push 一直push不了，提示如下</p>\n<pre><code class=\"language-js\">error: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413\nfatal: the remote end hung up unexpectedly</code></pre>\n<p><img src=\"../../../images/blog/git/git_push_hang_up.png\" alt=\"git_push_hang_up.png\"></p>\n<p>网上查了下，可以改用 ssh 的方式 push 代码，结合之前的经验，大文件 git clone 不下来，可以换 ssh 方式 git clone。这条路应该可行。找了下之前的笔记 <a href=\"http://www.zuo11.com/blog/2020/8/git_ssh.html\">使用ssh方式拉取代码的步骤</a>，下面来梳理下整个过程。</p>\n<p><strong>1. 使用git平台(这里是github)邮箱账号生成公钥和私钥</strong></p>\n<pre><code class=\"language-bash\"># 先查看 github 对应的邮箱，user.email 就是git邮箱账号\ngit config -l\n# credential.helper=osxkeychain\n# user.name=guoqzuo\n# user.email=guoqzuo@gmail.com\n# core.quotepath=false\n\n# 开始生成秘钥\nssh-keygen -t rsa -C &#39;guoqzuo@gmail.com&#39;\n# 全部默认、回车，也可以输入密码，我这里输入了密码，后面每次pull, push都需要输入密码。\n# Generating public/private rsa key pair.\n# Enter file in which to save the key (/Users/guoqzuo/.ssh/id_rsa): \n# Enter passphrase (empty for no passphrase): \n# Enter same passphrase again: \n# Your identification has been saved in /Users/guoqzuo/.ssh/id_rsa.\n# Your public key has been saved in /Users/guoqzuo/.ssh/id_rsa.pub.\n\n# 查看公钥内容，copy后到github里设置ssh key\ncat ~/.ssh/id_rsa.pub </code></pre>\n<p><strong>2. copy公钥，并配置到对应的git平台里（这里是github）</strong></p>\n<p>登录 github，在个人设置里找到 ssh key，添加 ssh key，内容为 <code>cat ~/.ssh/id_rsa.pub</code> 后显示的内容</p>\n<p><img src=\"../../../images/blog/git/github_ssh_key.png\" alt=\"github_ssh_key.png\"></p>\n<p><strong>3. 测试是否配置成功</strong></p>\n<p>使用下面的命令，测试 github ssh key 是否配置成功，如果之前生成 key 时有输入 passphrase，这里就要输入</p>\n<pre><code class=\"language-bash\">ssh -T git@github.com\n# Enter passphrase for key &#39;/Users/guoqzuo/.ssh/id_rsa&#39;: \n# Hi zuoxiaobai! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre>\n<p><strong>4. 将仓库http的origin地址，替换为ssh的origin地址</strong></p>\n<pre><code class=\"language-bash\"># 查看 remote 地址\ngit remote -v\n# origin  https://github.com.cnpmjs.org/zuoxiaobai/zuo11.com (fetch)\n# origin  https://github.com.cnpmjs.org/zuoxiaobai/zuo11.com (push)\n\n# 设置 remote 地址为对应仓库的 ssh 地址\ngit remote set-url origin git@github.com:zuoxiaobai/zuo11.com.git\n\n# 查看设置是否生效\ngit remote -v                                                    \n# origin  git@github.com:zuoxiaobai/zuo11.com.git (fetch)\n# origin  git@github.com:zuoxiaobai/zuo11.com.git (push)</code></pre>\n<p>配置好后，再进行git pull, git push 就可以 push 成功了，虽然也有点慢，但至少不会报错。可以push成功</p>\n<pre><code class=\"language-bash\">guoqzuo@zuomac zuo11.com % git pull\nEnter passphrase for key &#39;/Users/guoqzuo/.ssh/id_rsa&#39;: \nAlready up to date.\n\nguoqzuo@zuomac zuo11.com % git push\nEnter passphrase for key &#39;/Users/guoqzuo/.ssh/id_rsa&#39;: \nEnumerating objects: 685, done.\nCounting objects: 100% (685/685), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (358/358), done.\nWriting objects: 100% (360/360), 4.57 MiB | 150.00 KiB/s, done.\nTotal 360 (delta 306), reused 0 (delta 0)\nremote: Resolving deltas: 100% (306/306), completed with 296 local objects.\nTo github.com:zuoxiaobai/zuo11.com.git\n   85b3d21..bf8eab3  master -&gt; master\nguoqzuo@zuomac zuo11.com % </code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "使用git ssh方式解决RPC failed; HTTP 413 curl 22 The requested URL returned error: 413"
        }
      ],
      "config": {
        "source": "使用git ssh方式解决RPC failed; HTTP 413 curl 22 The requested URL returned error: 413.md",
        "staticFileName": "git_http_413.html",
        "author": "guoqzuo",
        "createDate": "2020/11/16",
        "description": "由于改了博客生成系统的生成方式，每个html都改了，导致文件相对较多，也不算大，才 4.57 M, 但 git push 一直push不了，提示如下 error: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413 fatal: the remote end hung up unexpectedly，网上查了下，可以改用 ssh 的方式 push 代码，结合之前的经验，大文件 git clone 不下来，可以换 ssh 方式 git clone。",
        "keywords": "RPC failed; HTTP 413 curl 22,The requested URL returned error: 413,fatal: the remote end hung up unexpectedly",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"google-adsense被拒理由网站已下线或无法访问怎么解决？\">Google AdSense被拒理由网站已下线或无法访问怎么解决？</h1>\n<p>在自己网站的 head 部分加入 AdSense 的校验代码后，会有一段审核的时间。在这个过程中，网站可能会有来自福建龙岩的 203.208.60.* IP段蜘蛛来爬取你的网页。蜘蛛会爬取JS渲染后的效果，可以触发百度统计等js代码。不用屏蔽，这属于 Google 蜘蛛正常爬取，Google Analytics 在计算访客时会忽略这一部分访客信息。</p>\n<p>蜘蛛爬完的第二天，就收到了邮件，说审核不通过，看了下原因：&quot;网站已下线或无法访问怎么解决&quot; ，如下图所示。但我的网站是确定可以正常访问的。</p>\n<p><img src=\"../../../images/blog/seo/google_ad_1.png\" alt=\"网站已下线或无法访问怎么解决\"></p>\n<p>网上查了下，这种情况，需要在域名解析里增加两条解析记录，解析路线设置为境外。然后重新提交审核，等待即可。<strong>但我加了解析后，等了一段时间，又是同样的理由被拒绝，于是找到了官方的回复。首页不能重定向，比如 xx.com 不能重定向到 xx.com/home，或者 <code>www.xx.com</code></strong>，再次修改后，重新提交审核，大概5、6天后审核通过。参考 <a href=\"https://support.google.com/adsense/thread/43647550?hl=zh-Hans\">为什么一直提示找不到adsense代码和网站已下线或无法访问？ - AdSense Community</a></p>\n<table>\n<thead>\n<tr>\n<th>主机记录</th>\n<th>记录类型</th>\n<th>解析路线</th>\n<th>记录值</th>\n<th>TTL</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@</td>\n<td>A</td>\n<td>境外</td>\n<td>服务器IP地址</td>\n<td>10分钟(默认)</td>\n</tr>\n<tr>\n<td>www</td>\n<td>A</td>\n<td>境外</td>\n<td>服务器IP地址</td>\n<td>10分钟(默认)</td>\n</tr>\n</tbody></table>\n<p><img src=\"../../../images/blog/seo/google_ad_2.png\" alt=\"域名解析.png\"></p>\n<p>www 和 @ 这样的主机记录是什么意思?</p>\n<ul>\n<li>www：解析后的域名为 <code>www.xx.com</code>。</li>\n<li>@：直接解析主域名 xx.com。</li>\n<li>*：泛解析，匹配其他所有域名 *.xx.com。</li>\n</ul>\n<p>关闭 zuo11.com 到 <code>www.zuo11.com</code> 的重定向，大概是09月27，再次提交后，10月02号收到审核通过邮件。如下图</p>\n<p><img src=\"../../../images/blog/seo/google_ad.jpg\" alt=\"google_ad.jpg\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Google AdSense被拒理由网站已下线或无法访问怎么解决？"
        }
      ],
      "config": {
        "source": "Google AdSense被拒理由网站已下线或无法访问怎么解决.md",
        "staticFileName": "adsense_cannot_found.html",
        "author": "guoqzuo",
        "createDate": "2020/11/16",
        "description": "在自己网站的 head 部分加入 AdSense 的校验代码后，会有一段审核的时间。在这个过程中，网站可能会有来自福建龙岩的 203.208.60.* IP段蜘蛛来爬取你的网页。蜘蛛会爬取JS渲染后的效果，可以触发百度统计等js代码。不用屏蔽，这属于 Google 蜘蛛正常爬取，Google Analytics 在计算访客时会忽略这一部分访客信息。蜘蛛爬完的第二天，就收到了邮件，说审核不通过，看了下原因：'网站已下线或无法访问怎么解决' ，如下图所示。但我的网站是确定可以正常访问的。",
        "keywords": "AdSense网站已下线或无法访问",
        "category": "网站建设与SEO",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"google-analytics、google-adsense、google-search-console分别是干什么的\">Google Analytics、Google AdSense、Google Search Console分别是干什么的?</h1>\n<p>在站点管理这一块，Google的工具有好几个，我现在知道的有三个，他们分别对应不同的功能，下面来看看他们的介绍、区别</p>\n<table>\n<thead>\n<tr>\n<th>平台</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://search.google.com/search-console\">Google Search Console</a>  搜索控制台</td>\n<td>站长工具、sitemap提交，展现量/点击量简单查看，死链提交等</td>\n</tr>\n<tr>\n<td><a href=\"https://analytics.google.com/analytics/\">Google Analytics</a> 分析</td>\n<td>偏数据分析，统计实时用户/累计用户/会话时长/跳出率等，受众群体、流量来源、转化率、页面价值等</td>\n</tr>\n<tr>\n<td><a href=\"https://www.google.com/adsense\">Google AdSense</a> 广告联盟</td>\n<td>用于在自己站点投放 Google 广告，赚取收益</td>\n</tr>\n</tbody></table>\n<p><img src=\"../../../images/blog/seo/google_ad_3.png\" alt=\"google站长工具对比\"></p>\n<p>百度统计类似 Google Search Console 和 Google Analytics 的结合体，但 Google Analytics 的细分功能更加强大</p>\n<p>关于 Google AdSense，有一本书可以参考下：《Google AdSense 实战宝典》</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Google Analytics、Google AdSense、Google Search Console分别是干什么的?"
        }
      ],
      "config": {
        "source": "Google Analytics、Google AdSense、Google Search Console分别是干什么的?.md",
        "staticFileName": "google_web_tools.html",
        "author": "guoqzuo",
        "createDate": "2020/11/16",
        "description": "在站点管理这一块，Google的工具有好几个，我现在知道的有三个，他们分别对应不同的功能，下面来看看他们的介绍、区别：Google Search Console，搜索控制台| 站长工具、sitemap提交，展现量/点击量简单查看，死链提交等；Google Analytics 偏数据分析，统计实时用户/累计用户/会话时长/跳出率等，受众群体、流量来源、转化率、页面价值等；Google AdSense 广告联盟 | 用于在自己站点投放 Google 广告，赚取收益",
        "keywords": "Google Analytics,Google AdSense,Google Search Console",
        "category": "网站建设与SEO",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"js-append-和-appendchild-的区别\">JS append 和 appendChild 的区别</h1>\n<p>在JS高程3中，并没有讲到 append()，基本都是用的 appendChild()，所以有知识盲点，这里对比下 append() 和 apendChiild() 的区别，如下表所示：append 用于在元素内容里追加一个 Node 节点，appendChiled() 用于在元素内容里追加一个或多个 Node 节点或 String 。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>所属对象</th>\n<th>功能</th>\n<th>返回值</th>\n<th>兼容性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild\">appendChild</a></td>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Node\">Node</a></td>\n<td>在元素内容里追加一个 Node 节点</td>\n<td>append的节点</td>\n<td>基本都兼容</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/append\">append</a></td>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ParentNode\">ParentNode</a></td>\n<td>在元素内容里追加一个或多个 Node 节点或 String</td>\n<td>undefined</td>\n<td>实验性功能 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ParentNode#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7\">不支持 IE</a></td>\n</tr>\n</tbody></table>\n<p>注意，如果 append 或 appendChild 的元素是已经存在的，会移动该元素，如果需要保持原来的不移动，需要先 cloneNode, 下面来看一个例子</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n  &lt;div id=&quot;c1&quot;&gt;&lt;/div&gt;\n  &lt;div id=&quot;existDiv&quot;&gt;我是一段已经存在的dom&lt;/div&gt;\n  &lt;div id=&quot;c2&quot;&gt;&lt;/div&gt;\n  &lt;div id=&quot;c3&quot;&gt;&lt;/div&gt;\n  &lt;script&gt;\n    // 1.测试基本功能：创建节点，并 appendChild 到 c1元素\n    let p = document.createElement(&#39;p&#39;)\n    let text = document.createTextNode(&#39;我是一段信息&#39;)\n    p.appendChild(text)\n    console.log(p, p.__proto__) // HTMLParagraphElement\n    document.querySelector(&#39;#c1&#39;).appendChild(p)\n    // document.querySelector(&#39;#c1&#39;).appendChild(&#39;1212&#39;) // Error, Node\n\n    // 2.测试 appendChild 一个已存在的节点，移动节点，而不是copy\n    let existDiv = document.querySelector(&#39;#existDiv&#39;)\n    console.log(existDiv, existDiv.__proto__)  // HTMLDivElement\n    console.log(&#39;测试appendChild 返回&#39;, document.querySelector(&#39;#c2&#39;).appendChild(existDiv))\n    // console.log(&#39;测试append 返回&#39;, document.querySelector(&#39;#c2&#39;).append(existDiv))\n\n    // 4.测试append\n    let span = document.createElement(&#39;span&#39;)\n    // 不要写成链式调用，它返回的是成功appendChild的节点\n    span.appendChild(document.createTextNode(&#39;测试append&#39;))\n    document.querySelector(&#39;#c3&#39;).append(&#39;&lt;span&gt;abc&lt;/span&gt;&#39;)\n    document.querySelector(&#39;#c3&#39;).append(span, &#39;a&#39;, &#39;b&#39;, &#39;&lt;div&gt;c&lt;/div&gt;&#39;)\n  &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p>执行效果如下图</p>\n<p><img src=\"../../../images/blog/js/append_vs_appendChild.png\" alt=\"append_vs_appendChild.png\"></p>\n<p>关于 Node 节点 Element 元素对象的一些值</p>\n<pre><code class=\"language-js\">&lt;div id=&quot;myDiv&quot; class=&quot;bg test&quot; title=&quot;body text&quot; lang=&quot;en&quot; dir=&quot;rtl&quot;&gt;abcdefg&lt;/div&gt;\n// 3.测试节点类型、对象信息 HTMLDivElement =&gt; HTMLElement =&gt; Element =&gt; Node\n// 参考：DOM https://www.yuque.com/guoqzuo/js_es6/hoglme#6bbee863\nvar div = document.getElementById(&quot;myDiv&quot;); // HTMLDivElement\nconsole.log(div.nodeType) // 1 Node.ELEMENT_NODE\nconsole.log(div.nodeName) // DIV\nconsole.log(div.id); // myDiv\nconsole.log(div.className); // bg test\nconsole.log(div.title); // body text\nconsole.log(div.lang); // en\nconsole.log(div.dir); // rtl   </code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JS append 和 appendChild 的区别"
        }
      ],
      "config": {
        "source": "JS append 和 appendChild 的区别.md",
        "staticFileName": "append_append.html",
        "author": "guoqzuo",
        "createDate": "2020/11/16",
        "description": "在 JS 高程 3 中，并没有讲到 append()，基本都是用的 appendChild()，所以有知识盲点，这里对比下 append() 和 apendChiild() 的区别，如下表所示：append 用于在元素内容里追加一个 Node 节点，appendChiled() 用于在元素内容里追加一个或多个 Node 节点或 String，注意，如果 append 或 appendChild 的元素是已经存在的，会移动该元素，如果需要保持原来的不移动，需要先 cloneNode, 下面来看一个例子",
        "keywords": "append appendChild区别,append()和appendchild(),append和appendChild",
        "category": "JavaScript",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"chrome-devtools-network-waterfall-瀑布图各阶段详解\">Chrome DevTools Network Waterfall 瀑布图各阶段详解</h1>\n<p>在 Chrome 调试工具 Network tab 下，每个请求都有一个 Waterfal diagrams(瀑布图)，点击具体接口，Timming(时序)位置会有具体描述。它记录了网络请求各个阶段的耗时，可以用于分析页面加载性能。</p>\n<p><img src=\"../../../images/blog/devtools/waterfall-hover.png\" alt=\"waterfall-hover.png\"></p>\n<p>Timing breakdown phases explained（时序分解阶段明细）</p>\n<p>Here&#39;s more information about each of the phases you may see in the Timing tab:（下面是在Timing标签页中能看到的各个阶段的更多信息）</p>\n<p><strong>1. Resource Scheduling(资源调度)</strong></p>\n<ul>\n<li><strong>Queueing(排队)</strong>. The browser queues requests when:（浏览器在以下情况会排队请求）<ul>\n<li>There are higher priority requests.（有更高优先级的请求）</li>\n<li>There are already six TCP connections open for this origin, which is the limit. Applies to HTTP/1.0 and HTTP/1.1 only. (当前请求的 origin/domain，已经有 6 个 TCP 连接打开，这是限制。仅应用于 HTTP/1.0 and HTTP/1.1)</li>\n<li>The browser is briefly allocating space in the disk cache（浏览器正在磁盘缓存中短暂分配空间）</li>\n</ul>\n</li>\n</ul>\n<p><strong>2. Connecttion Start(连接开始)</strong></p>\n<ul>\n<li><strong>Stalled(停滞/暂缓)</strong>. The request could be stalled for any of the reasons described in Queueing. （处于排队中描述的任何原因，请求都有可能停滞/暂缓）</li>\n<li><strong>DNS Lookup(DNS查询)</strong>. The browser is resolving the request&#39;s IP address. （域名解析成IP。在浏览器和服务器进行通信之前, 必须经过DNS查询, 将域名转换成IP地址. 在这个阶段, 你可以处理的东西很少. 但幸运的是, 并非所有的请求都需要经过这一阶段.）</li>\n<li><strong>Initial connection(初始化连接)</strong>. The browser is establishing a connection, including TCP handshakes/retries and negotiating an SSL.（浏览器正在创建一个连接，包括握手/重试）和 协商SSL。在浏览器发送请求之前, 必须建立TCP连接. 这个过程仅仅发生在瀑布图中的开头几行, 否则这就是性能问题.</li>\n<li><strong>SSL(SSL协商)</strong> SSL/TLS Negotiation  如果你的页面是通过SSL/TLS这类安全协议加载资源, 这段时间就是浏览器建立安全连接的过程. </li>\n<li><strong>Proxy negotiation(代理协商)</strong>. The browser is negotiating the request with a proxy server. （浏览器正在与代理服务器协商请求）</li>\n</ul>\n<p><strong>3. Request/Response(请求/响应)</strong></p>\n<ul>\n<li><p><strong>Request sent(请求发送)</strong>. The request is being sent. 请求开始发送</p>\n</li>\n<li><p><strong>ServiceWorker Preparation(ServiceWorker准备)</strong>. The browser is starting up the service worker. （浏览器正在启动 Service Worker）</p>\n</li>\n<li><p><strong>Request to ServiceWorker(请求到ServiceWorker)</strong>. The request is being sent to the service worker.（请求被发送到 service worker）</p>\n</li>\n<li><p><strong>Waiting (TTFB) 等待</strong>. The browser is waiting for the first byte of a response. TTFB stands for <strong>Time To First Byte</strong>. This timing includes 1 round trip of latency and the time the server took to prepare the response.（浏览器正在等待响应的第一个字节。 TTFB代表到第一个字节的时间。 此时间包括一次往返延迟和服务器准备响应所花费的时间） TTFB 是浏览器请求发送到服务器的时间+服务器处理请求时间+响应报文的第一字节到达浏览器的时间. 我们用这个指标来判断你的web服务器是否性能不够, 或者说你是否需要使用CDN.</p>\n</li>\n<li><p><strong>Content Download</strong>. The browser is receiving the response. （浏览器正在接收响应），这是浏览器用来下载资源所用的时间. 这段时间越长, 说明资源越大. 理想情况下, 你可以通过控制资源的大小来控制这段时间的长度.</p>\n</li>\n<li><p><strong>Receiving Push</strong>. The browser is receiving data for this response via HTTP/2 Server Push.（浏览器正在通过HTTP / 2服务器推送接收此响应的数据）</p>\n</li>\n<li><p><strong>Reading Push</strong>. The browser is reading the local data previously received.（浏览器正在读取先前接收的本地数据。）</p>\n</li>\n</ul>\n<p>参考资料及扩展：</p>\n<ul>\n<li><a href=\"https://developers.google.com/web/tools/chrome-devtools/network/reference?utm_source=devtools#timing-explanation\">Timing breakdown phases explained - Network Analysis Reference  |  Chrome DevTools</a></li>\n<li><a href=\"https://www.html.cn/doc/chrome-devtools/\">Chrome 开发者工具中文文档</a></li>\n<li><a href=\"https://blog.csdn.net/csdn_girl/article/details/54911632\">教你读懂网络请求的瀑布图</a></li>\n<li><a href=\"https://moz.com/blog/the-seo-professional-s-guide-to-waterfall-diagrams\">The SEO Professional&#39;s Guide to Waterfall Diagrams</a></li>\n<li><a href=\"https://github.com/xitu/gold-miner/blob/master/TODO/understanding-service-workers.md\">理解 Service Workers</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Chrome DevTools Network Waterfall 瀑布图各阶段详解"
        }
      ],
      "config": {
        "source": "Chrome DevTools Network Waterfall 瀑布图各阶段详解.md",
        "staticFileName": "chrome_waterfall.html",
        "author": "guoqzuo",
        "createDate": "2020/11/23",
        "description": "在Chrom调试工具Network tab下，每个请求都有一个Waterfal diagrams(瀑布图)，点击具体接口，Timming(时序)位置会有具体描述。它记录了网络请求各个阶段的耗时，可以用于分析页面加载性能。Timing breakdown phases explained（时序分解阶段明细）。Here's more information about each of the phases you may see in the Timing tab:（下面是在Timing标签页中能看到的各个阶段的更多信息）",
        "keywords": "chrome瀑布图,Timming时序图",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"图片占位、懒加载、预览\">图片占位、懒加载、预览</h1>\n<p><strong>使用占位图片有什么好处?</strong></p>\n<ol>\n<li>用户体验更好，标识此处有图片，但正在加载中的这一个状态，避免弱网或图片较大时，完全不显示的问题</li>\n<li>不阻塞其他资源加载，更快的整体文档加载速度，不阻塞其他请求。占位图片一般会和图片懒加载一起使用，当滚动到该区域时再加载图片，减少不必要的并发网络请求</li>\n<li>可以避免回流/重排，让图片加载完成后不改变页面的整体布局，避免回流(重新布局)，只需要重绘，注意: 需要占位图片与实际图片宽高不变</li>\n</ol>\n<p><strong>怎么实现图片懒加载</strong></p>\n<p>这里核心问题是怎么判断图片是否已滚动到当前视口。一般可以通过监听页面滚动事件，实时比较元素的 offsetTop 与页面的 scrollTop。另外还可以通过元素的 getBoundingClientRect() 获取当前元素距离视窗的距离，如果小于 window.innerHeight 就加载，下面来看一个简单的实现</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n  &lt;div&gt;\n    &lt;div style=&quot;height:50px;&quot;&gt;我是占位文本&lt;/div&gt;\n    &lt;img class=&quot;lazy-img&quot; data-src=&quot;http://zuo11.com/images/blog/c/c_vim.png&quot;&gt;\n    &lt;div style=&quot;height:500px;&quot;&gt;我是占位文本&lt;/div&gt;\n    &lt;img class=&quot;lazy-img&quot; data-src=&quot;http://zuo11.com/images/blog/c/c_saolei_3.png&quot;&gt;\n  &lt;/div&gt;\n  &lt;script&gt;\n    let imgEls = document.querySelectorAll(&#39;.lazy-img&#39;)\n    let imgs = []\n    imgEls.forEach(imgEl =&gt; {\n      imgEl.style.height = &#39;300px&#39;\n      imgEl.style.width = &#39;300px&#39;\n      imgEl.src = &quot;placeholder.png&quot;\n      // 存储信息用于监听滚动后比对\n      imgs.push({\n        offsetTop: imgEl.offsetTop,\n        el: imgEl,\n        src: imgEl.dataset.src,\n        isLoad: false\n      })\n    })\n    console.log(imgs)\n    // 判断滚动位置，显示图片\n    function showImg() {\n      console.log(&#39;&gt;&gt;&gt;&gt;&gt;&gt;&#39;)\n      imgs.forEach(item =&gt; {\n        // 如果图片未加载\n        if (!item.isLoad) {\n          console.log(window.innerHeight, item.src, item.el.getBoundingClientRect())\n          let elPos = item.el.getBoundingClientRect()\n          if (elPos.top &lt; window.innerHeight) {\n            // 如果元素相对顶部的距离 &lt; 视窗高度，加载图片\n            item.el.src = item.src\n            item.isLoad = true\n          }\n        }\n      })\n    }\n    showImg()\n    window.onscroll = () =&gt; {\n      showImg()\n    }\n  &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p><strong>图片预览</strong></p>\n<p>可以参考Element UI el-image组件实现，<a href=\"https://element.eleme.cn/#/zh-CN/component/image#da-tu-yu-lan\">Element UI 大图预览 | el-image</a></p>\n<p>参考资料与扩展</p>\n<ul>\n<li><a href=\"https://segmentfault.com/q/1010000007357371?_ea=1320000\">前端为什么要使用占位图 | segmentfault</a></li>\n<li><a href=\"https://www.jianshu.com/p/4876a4fe7731\">图片懒加载和预加载 | 简书</a></li>\n<li><a href=\"https://juejin.im/post/6844903725249609741\">如何判断元素是否进入可视区域viewport？| 掘金</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "图片占位、懒加载、预览"
        }
      ],
      "config": {
        "source": "图片占位、懒加载、预览.md",
        "staticFileName": "img_placeholder_lazyload.html",
        "author": "guoqzuo",
        "createDate": "2020/11/23",
        "description": "使用占位图片有什么好处? 1. 用户体验更好，标识此处有图片，但正在加载中的这一个状态，避免弱网或图片较大时，完全不显示的问题 2. 不阻塞其他资源加载，更快的整体文档加载速度，不阻塞其他请求。占位图片一般会和图片懒加载一起使用，当滚动到该区域时再加载图片，减少不必要的并发网络请求。3. 可以避免回流/重排，让图片加载完成后不改变页面的整体布局，避免回流(重新布局)，只需要重绘，注意: 需要占位图片与实际图片宽高不变",
        "keywords": "怎么实现图片懒加载,图片占位好处,图片预览,image lazyload,图片懒加载",
        "category": "JavaScript",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"什么是回流reflow和重绘repaint？怎么避免？\">什么是回流(Reflow)和重绘(Repaint)？怎么避免？</h1>\n<p><strong>1. 什么是回流和重绘</strong></p>\n<ul>\n<li>浏览器使用流式布局模型 (Flow Based Layout)</li>\n<li>浏览器把 HTML 解析成 DOM，把 CSS 解析为 CSDOM，DOM 和 CSDOM 合并就产生了 Render Tree(渲染树)</li>\n<li>根据Render Tree，计算各个元素在页面中的大小和位置，绘制到页面上。</li>\n</ul>\n<p><strong>回流/重排（Reflow）</strong>：当 Render Tree 中部分或全部元素的尺寸、结构或位置发生改变时，浏览器会重新渲染部分或整个文档的过程就称为Reflow</p>\n<p><strong>重绘（RePaint）</strong>: 当页面中元素样式的改变并不影响它在文档中的位置时，浏览器会重绘该区域，这个过程称为重绘</p>\n<p><strong>2. 回流和重绘的比较</strong></p>\n<p>DOM、CSS style的改变会照成回流或者重绘，回流比重绘更消耗性能</p>\n<ul>\n<li>回流：重新布局，会引起元素位置变化的就会reflow，比如修改 DOM 的宽高、字体大小、窗口大小改变、元素位置改变等</li>\n<li>重绘：重新绘制区域，不改变元素位置，比如修改背景、颜色，visibility等</li>\n</ul>\n<p><strong>3. 如何避免回流或重绘</strong></p>\n<p>CSS：</p>\n<ul>\n<li>尽可能在DOM树的最末端改变class</li>\n<li>避免设置多层内联样式，将动画效果应用到 position 属性为 absolute 或 fixed 的元素上</li>\n<li>避免使用CSS表达式（例如：calc())</li>\n</ul>\n<p>JavaScript</p>\n<ul>\n<li>避免频繁操作样式、DOM</li>\n<li>在 documentFragment 或 display 为 none 的元素上进行 dom 操作不会引起回流或重绘</li>\n<li>对复杂动画，使用绝对定位脱离文档流，避免整体回流</li>\n</ul>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/6844903569087266823\">浏览器的回流与重绘 (Reflow &amp; Repaint) | 掘金</a></li>\n<li><a href=\"https://www.zhoulujun.cn/html/webfront/browser/webkit/2016_0506_7820.html\">使用chrome对页面重绘和回流做优化</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "什么是回流(Reflow)和重绘(Repaint)？怎么避免？"
        }
      ],
      "config": {
        "source": "什么是回流(Reflow)和重绘(Repaint)？怎么避免？.md",
        "staticFileName": "css_reflow_repaint.html",
        "author": "guoqzuo",
        "createDate": "2020/11/23",
        "description": "什么是回流和重绘？ 浏览器使用流式布局模型 (Flow Based Layout)，浏览器把 HTML 解析成 DOM，把 CSS 解析为 CSDOM，DOM 和 CSDOM 合并就产生了 Render Tree(渲染树)，根据Render Tree，计算各个元素在页面中的大小和位置，绘制到页面上。",
        "keywords": "回流和重绘,reflow,repaint,css回流,css重绘",
        "category": "CSS",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"script-error产生原因与解决方法、调试技巧\">Script error产生原因与解决方法、调试技巧</h1>\n<p>一般为了安全起见，如果当前页面引入了跨域的 js 文件，当这个 js 文件出现错误，监听错误会无法获取对应的行号、真实的错误message。这种情况错误信息就是 Script error.</p>\n<p>本地来做一个试验，重现该问题，用 koa 写两个服务，分别监听 5001/5002端口，同时开启服务</p>\n<pre><code class=\"language-js\">/**\n * index_a.js\n * index_b.js 代码和下面的基本一致，只是将 5001 改为 5002\n */\nconst Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\napp.use(require(&#39;koa-static&#39;)(__dirname + &#39;/public&#39;))\n\napp.listen(&#39;5001&#39;, () =&gt; {\n  console.log(&#39;server listen on 5001 port&#39;)\n})</code></pre>\n<p>public/index.html 测试页面中，我们引入 5001端口的 a.js 或 5002 端口的 a.js，看具体 error 信息</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n  &lt;button onclick=&quot;btnClick()&quot;&gt;点击&lt;/button&gt;\n  &lt;script src=&quot;http://127.0.0.1:5001/a.js&quot;&gt;&lt;/script&gt;\n  &lt;!-- &lt;script src=&quot;http://127.0.0.1:5002/a.js&quot;&gt;&lt;/script&gt; --&gt;\n  &lt;script&gt;\n    window.addEventListener(&#39;error&#39;, e =&gt; {\n      console.log(e, e.message)\n    })\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;!-- \n// a.js代码\nfunction btnClick() {\n  console.logaaa(&#39;aaa&#39;) // 故意制造一个错误\n}\n-- &gt;</code></pre>\n<p>访问 <code>http://127.0.0.1:5001/index.html</code>，然后测试不同端口下执行情况，具体如下图</p>\n<p><img src=\"../../../images/blog/js/cross_origin_script_error.png\" alt=\"cross_origin_script_error.png\"></p>\n<p>知道问题后，我们可以通过使用同域的方式引入 js。如果一定要使用跨域的，需要设置下面两点</p>\n<ol>\n<li>script引入时加入 crossorigin=&quot;anonymous&quot;，anonymous 即不发送 Cookie 和 HTTP 认证信息</li>\n<li>服务器对应的js，增加允许跨域</li>\n</ol>\n<pre><code class=\"language-js\">// html里\n// &lt;script src=&quot;http://127.0.0.1:5002/a.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;\n// index_b.js 5002端口增加允许跨域\n\nconst Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n// 允许跨域\napp.use(async (ctx, next) =&gt; {\n  ctx.set({\n    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,\n    &#39;Access-Control-Allow-Headers&#39;: &#39;*&#39;,\n    &#39;Access-Control-Allow-Methods&#39;: &#39;*&#39;,\n    &#39;Access-Control-Allow-Credentials&#39;: &#39;true&#39;, // 允许携带cookie\n    &#39;Access-Control-Max-Age&#39;: 3600 // 对于相同的请求，仅在第一次发送options预检请求，之后1小时内不需要预检请求\n  })\n  await next()\n})\napp.use(require(&#39;koa-static&#39;)(__dirname + &#39;/public&#39;))\napp.listen(&#39;5002&#39;, () =&gt; {\n  console.log(&#39;server listen on 5002 port&#39;)\n})</code></pre>\n<p>设置好后，我们再测试就会发现可以正常显示跨域的信息了。如下图，完整demo参见 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/DebugDemo/%E8%B7%A8%E5%9F%9FScript_error%E6%B5%8B%E8%AF%95\">跨域Script_error测试demo | github</a></p>\n<p><img src=\"../../../images/blog/js/cross_origin_script_error_fix.png\" alt=\"cross_origin_script_error_fix.png\"></p>\n<p>参考：<a href=\"https://blog.fundebug.com/2017/04/05/understand-script-error/\">Script error.全面解析 | Fundebug</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Script error产生原因与解决方法、调试技巧"
        }
      ],
      "config": {
        "source": "Script error产生原因与解决方法、调试技巧.md",
        "staticFileName": "script_error.html",
        "author": "guoqzuo",
        "createDate": "2020/11/23",
        "description": "一般为了安全起见，如果当前页面引入了跨域的 js 文件，当这个 js 文件出现错误，监听错误会无法获取对应的行号、真实的错误message。这种情况错误信息就是 Script error。本地来做一个试验，重现该问题，用 koa 写两个服务，分别监听 5001/5002端口，同时开启服务",
        "keywords": "script error,script error是什么错误",
        "category": "JavaScript",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"amd、umd、commonjs、es-modules的理解\">AMD、UMD、CommonJS、ES Modules的理解</h1>\n<p>在 ES6 之前，JS 本身没有模块功能，社区出现了 CommonJS 和 AMD 等模块方案。从 ES6 开始, JS 开始原生支持模块，一般称之为 ES Modules。</p>\n<ul>\n<li>CommonJS: 主要用于服务端，是 node 中使用的 require、module.exports。从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。但需要采用 .mjs 后缀文件名。如果不希望将后缀名改成.mjs，可以在项目的package.json文件中，指定type字段为module。</li>\n<li>AMD: Asynchronous Module Definition，异步模块定义，主要用于客户端(浏览器)，以 RequireJS 为代表 define、require</li>\n<li>UMD: Universal Module Definition，通用模块定义模式，主要用来解决 CommonJS 模式和 AMD 模式代码不能通用的问题，并同时还支持老式的全局变量规范。</li>\n<li>ES Modules 是 ES 标准模块系统，import、export ，可以和 CommonJS 混合使用</li>\n</ul>\n<pre><code class=\"language-js\">/*\n * bundle.js  UMD webpack打包后的js\n * 判断define为函数，并且是否存在define.amd，来判断是否为AMD规范,\n * 判断module是否为一个对象，并且是否存在module.exports来判断是否为CommonJS规范\n * 如果以上两种都没有，设定为原始的代码规范。\n */\n(function (global, factory) {\n    typeof exports === &#39;object&#39; &amp;&amp; typeof module !== &#39;undefined&#39; ? module.exports = factory() :\n    typeof define === &#39;function&#39; &amp;&amp; define.amd ? define(factory) :\n    (global = global || self, global.myBundle = factory());\n}(this, (function () { &#39;use strict&#39;;\n\n    var main = () =&gt; {\n        return &#39;hello world&#39;;\n    };\n\n    return main;\n\n})));\n// index.html\n&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n  console.log(myBundle());\n&lt;/script&gt;</code></pre>\n<p>区别:</p>\n<ol>\n<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li>\n<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>\n<li>CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。</li>\n</ol>\n<pre><code class=\"language-js\">// CommonJS模块\nlet { stat, exists, readfile } = require(&#39;fs&#39;);\n\n// 等同于\nlet _fs = require(&#39;fs&#39;);\nlet stat = _fs.stat;\nlet exists = _fs.exists;\nlet readfile = _fs.readfile;\n\n// ES6模块\nimport { stat, exists, readFile } from &#39;fs&#39;;</code></pre>\n<p>参考</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/108217164\">《模块化系列》彻底理清 AMD,CommonJS,CMD,UMD,ES6</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/module\">Module 的语法 | ES6入门</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/module-loader\">Module 的加载实现 | ES6入门</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "AMD、UMD、CommonJS、ES Modules的理解"
        }
      ],
      "config": {
        "source": "AMD、UMD、CommonJS、ES Modules的理解.md",
        "staticFileName": "amd_umd_commonjs.html",
        "author": "guoqzuo",
        "createDate": "2020/11/23",
        "description": "在 ES6 之前，JS 本身没有模块功能，社区出现了 CommonJS 和 AMD 等模块方案。从 ES6 开始, JS 开始原生支持模块，一般称之为 ES Modules。- CommonJS: 主要用于服务端，是 node 中使用的 require、module.exports。从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。但需要采用 .mjs 后缀文件名。如果不希望将后缀名改成.mjs，可以在项目的package.json文件中，指定type字段为module。- AMD: Asynchronous Module Definition，异步模块定义，主要用于客户端(浏览器)，以 RequireJS 为代表 define、require -  UMD: Universal Module Definition，通用模块定义模式，主要用来解决 CommonJS 模式和 AMD 模式代码不能通用的问题，并同时还支持老式的全局变量规范。",
        "keywords": "AMD,UMD,CommonJS,ES Modules",
        "category": "前端工程化",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"http2，怎么确定网站是否开启了http2，http3？\">HTTP/2，怎么确定网站是否开启了HTTP/2，HTTP/3？</h1>\n<p>HTTP/2 是新一代的 HTTP 协议，于 2015 正式发布。相对 HTTP/1 来说，大幅提升了网页性能，绝大多数浏览器都支持了 HTTP/2。</p>\n<p>http 怎么开启 http2 呢？HTTP/2 现阶段必须使用 https，80端口就不要想了。参考: <a href=\"https://ziyuan.baidu.com/wiki/786\">拥抱HTTP2.0时代，让网站飞起来 | 百度站长</a></p>\n<p>HTTP/1.1 不足的地方</p>\n<ul>\n<li>连接无法复用，每次请求都经历三次握手和慢启动<ul>\n<li>HTTP/1.0 传输数据时，每次都需要重新建立连接，增加延迟。</li>\n<li>HTTP/1.1 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。</li>\n</ul>\n</li>\n<li>队头阻塞(Head-Of-Line Blocking,HOLB)，并发请求数量限制<ul>\n<li>当页面中需要请求很多资源的时候，HOLB（队头阻塞）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</li>\n<li>HTTP 1.0：下个请求必须在前一个请求返回后才能发出，request-response对按序发生。显然，如果某个请求长时间没有返回，那么接下来的请求就全部阻塞了。</li>\n<li>HTTP 1.1：尝试使用 pipeling 来解决，即浏览器可以一次性发出多个请求（同个域名，同一条 TCP 链接）。但 pipeling 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。所以，pipeling 只部分解决了 HOLB。</li>\n</ul>\n</li>\n<li>协议开销大，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。</li>\n<li>安全因素，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性</li>\n</ul>\n<p>HTTP/2 就是为了解决 HTTP/1 存在的问题而产生的</p>\n<ul>\n<li>二进制传输，HTTP/1.1传输的是文本数据，而HTTP/2传输的是二进制数据，提高了数据传输效率。</li>\n<li>多路复用，多个HTTP请求可以复用同一个TCP连接。解决了浏览器限制同一个域名下的请求数量的问题，减少额外的3次握手开销。</li>\n<li>压缩请求头(Header)，减少重复发送相同的请求头</li>\n<li>支持服务器推送(Server push)，允许在请求之前先响应数据到客户端（之前请求过的数据），可以加快css/js等资源加载速度</li>\n</ul>\n<p>开启 HTTP/2 只需要在 listen 443 ssl 后面加上 http2 即可，可以使用 curl -I 进行测试看HTTP/2是否生效</p>\n<pre><code class=\"language-bash\"># /etc/nginx/conf.d/docker.conf \nserver\n{\n    server_name www.zuoguoqing.com;\n\n    location / {\n      proxy_pass http://127.0.0.1:3000;\n    }\n\n    listen 443 ssl http2; # managed by Certbot\n    ssl_certificate /etc/letsencrypt/live/www.zuoguoqing.com/fullchain.pem; # managed by Certbot\n    ssl_certificate_key /etc/letsencrypt/live/www.zuoguoqing.com/privkey.pem; # managed by Certbot\n    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\n    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot\n}</code></pre>\n<p>来看看 HTTP/1.1 和 HTTP/2 的测试对比</p>\n<pre><code class=\"language-bash\">curl -I www.zuo11.com\n# HTTP/1.1 200 OK\n# Server: nginx/1.16.1\n# Date: Thu, 08 Oct 2020 09:08:55 GMT\n# Content-Type: text/html; charset=utf-8\n# Content-Length: 3666\n# Last-Modified: Thu, 01 Oct 2020 15:02:42 GMT\n# Connection: keep-alive\n# Vary: Accept-Encoding\n# ETag: &quot;5f75ef92-e52&quot;\n# Accept-Ranges: bytes\n\ncurl -I https://www.zuoguoqing.com\n# HTTP/2 200 \n# server: nginx/1.14.0 (Ubuntu)\n# date: Thu, 08 Oct 2020 09:09:07 GMT\n# content-type: text/html\n# content-length: 213\n# last-modified: Wed, 07 Oct 2020 09:03:03 GMT\n# etag: &quot;5f7d8447-d5&quot;\n# accept-ranges: bytes</code></pre>\n<p><strong>HTTP/2够好了，为什么还会有 HTTP/3？</strong></p>\n<p>HTTP/2 的问题在于，其底层支撑协议为 TCP，在丢包的情况下，多个请求复用一个 TCP 连接时，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。这时 HTTP/2 效果可能还不如 HTTP/1</p>\n<p>因此，Google 又弄了一个基于 UDP 协议的 QUIC 协议，是 HTTP/3 中的底层支撑协议，又取了 TCP 中的精华，实现了即快又可靠的协议。</p>\n<ul>\n<li>通过提高链接利用效率减少 RTT（Round Trip Time，通俗地说，就是通信一来一回的时间），提高数据交互速度。</li>\n<li>在第一条的基础上，囊括安全需求。</li>\n<li>解决当前实际网络环境中的适配问题</li>\n</ul>\n<p>参考 </p>\n<ul>\n<li><a href=\"https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/\">一文读懂 HTTP/2 及 HTTP/3 特性</a></li>\n<li><a href=\"https://kiwenlau.com/2019/10/28/speedup-fundebug-by-using-http2/\">Fundebug网站升级HTTP/2，真的变快了！</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/40595473\">HTTP/2之服务器推送(Server Push)最佳实践</a></li>\n<li><a href=\"https://www.zhihu.com/question/302412059\">如何看待 HTTP/3 ？</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "HTTP/2，怎么确定网站是否开启了HTTP/2，HTTP/3？"
        }
      ],
      "config": {
        "source": "HTTP2，怎么确定网站是否开启了HTTP2，HTTP3？.md",
        "staticFileName": "http2_http3.html",
        "author": "guoqzuo",
        "createDate": "2020/11/23",
        "description": "HTTP/2 是新一代的 HTTP 协议，于 2015 正式发布。相对 HTTP/1 来说，大幅提升了网页性能，绝大多数浏览器都支持了 HTTP/2。http 怎么开启 http2 呢？HTTP/2 现阶段必须使用 https，80端口就不要想了。HTTP/1.1 不足的地方 - 连接无法复用，每次请求都经历三次握手和慢启动 - HTTP/1.0 传输数据时，每次都需要重新建立连接，增加延迟。- HTTP/1.1 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。",
        "keywords": "HTTP2,HTTP3,怎么开启HTTP/2",
        "category": "http与https",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"lets-encrypt-免费https证书\">Let’s Encrypt 免费HTTPS证书</h1>\n<p><a href=\"https://letsencrypt.org/\">Let’s Encrypt</a> 是一个非盈利TLS（Transport Layer Security) 证书颁发机构（CA），免费提供 https 证书。 </p>\n<p>由于 Let’s Encrypt 证书的有效期为 3 个月，所以一般使用程序来自动续期更换证书。官方推荐使用 Certbot 来管理，它可以一站式申请、续期证书。</p>\n<p>在 <a href=\"https://certbot.eff.org/\">Certbot 官网</a> 选择部署服务器使用的软件及系统，会自动列出需要操作的步骤，如下图</p>\n<p><img src=\"../../../images/blog/web/https_cert_1.png\" alt=\"https_cert_1.png\"></p>\n<p>注意文档里面分了两种：</p>\n<ol>\n<li>单个域名，仅单个 https 比如 <code>https://xx.com</code> 或 <code>https://www.xx.com</code></li>\n<li>通配符(Wildcard)证书，支持多个二级域名 <code>https://*.xx.com</code>，但不支持 <code>https://xx.com</code></li>\n</ol>\n<p>一般我们写好 nginx.conf 的配置，certbot 会根据 server_name 自动识别域名，并申请安装证书</p>\n<p>这里把两个域名进行 https 处理，分别是 <code>https:/www.zuoguoqing.com</code> 和 <code>https://api.zuoguoqing.com</code></p>\n<p>需要写两个 nginx 配置文件，分别对应下面两个文件，如果还有其他二级域名可以再增加配置文件</p>\n<ul>\n<li>/etc/nginx/conf.d/docker.conf  这里是 www 二级域名</li>\n<li>/etc/nginx/conf.d/api.conf 这里是 api 二级域名的nginx配置</li>\n</ul>\n<pre><code class=\"language-bash\"># /etc/nginx/conf.d/docker.conf \nserver\n{\n    listen 80;\n    server_name www.zuoguoqing.com;\n}\n\n# /etc/nginx/conf.d/api.conf \nserver\n{\n    listen 80;\n    server_name api.zuoguoqing.com;\n}</code></pre>\n<p>开始安装 certbot，并执行</p>\n<pre><code class=\"language-bash\"># 登录到 ubuntu linux 服务器\nsudo apt update\nsudo apt install snapd\nsudo snap install core; sudo snap refresh core\nsudo apt-get remove certbot\nsudo dnf remove certbot\nsudo snap install --classic certbot\nsudo ln -s /snap/bin/certbot /usr/bin/certbot\n# 获取并安装证书\nsudo certbot --nginx</code></pre>\n<p><img src=\"../../../images/blog/web/https_cert_2.png\" alt=\"https_cert_2.png\"></p>\n<pre><code class=\"language-bash\"># 测试续订\nsudo certbot renew --dry-run</code></pre>\n<p>3个月有效期自动续订测试，提示了个 <code>Python 3.8 OSError: [Errno 101] Network is unreachable</code>，但提示又是续订测试成功。只有后面再看是否有问题</p>\n<p>来看看 certbot 自动修改的 nginx 配置，会有 managed by Certbot 注释，后面我又加了一些基本的重定向配置</p>\n<p>/etc/nginx/conf.d/docker.conf</p>\n<pre><code class=\"language-bash\"># /etc/nginx/conf.d/docker.conf \nserver\n{\n    server_name www.zuoguoqing.com;\n\n    location / {\n      # root   html;\n      # index  index.html index.htm;\n      proxy_pass http://127.0.0.1:3000;\n    }\n\n    listen 443 ssl http2; # managed by Certbot\n    ssl_certificate /etc/letsencrypt/live/www.zuoguoqing.com/fullchain.pem; # managed by Certbot\n    ssl_certificate_key /etc/letsencrypt/live/www.zuoguoqing.com/privkey.pem; # managed by Certbot\n    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\n    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot\n\n\n}\n\nserver\n{\n    server_name zuoguoqing.com;\n\n    if ($host = zuoguoqing.com) {\n      return 301 https://www.$host$request_uri;\n    }\n\n    listen 443 ssl; # managed by Certbot\n}\n\nserver\n{ \n    if ($host = zuoguoqing.com) {\n      return 301 https://www.$host$request_uri;\n    }\n    listen 80;\n    server_name zuoguoqing.com;\n    return 404;\n}\n\nserver\n{\n    if ($host = www.zuoguoqing.com) {\n        return 301 https://$host$request_uri;\n    } # managed by Certbot\n\n\n    listen 80;\n    server_name www.zuoguoqing.com;\n    return 404; # managed by Certbot\n\n\n}</code></pre>\n<p>/etc/nginx/conf.d/api.conf </p>\n<pre><code class=\"language-bash\">#  /etc/nginx/conf.d/api.conf \nserver\n{\n    server_name api.zuoguoqing.com;\n\n    location / {\n      # root   html;\n      # index  index.html index.htm;\n      proxy_pass http://127.0.0.1:8700;\n    }\n\n    listen 443 ssl; # managed by Certbot\n    ssl_certificate /etc/letsencrypt/live/www.zuoguoqing.com/fullchain.pem; # managed by Certbot\n    ssl_certificate_key /etc/letsencrypt/live/www.zuoguoqing.com/privkey.pem; # managed by Certbot\n    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\n    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot\n\n}\n\nserver {\n    server_name api.zuoguoqing.com;\n    if ($host = &#39;api.zuoguoqing.com&#39;) {\n        return 301 https://$host$request_uri;\n    }\n    listen 80;\n}</code></pre>\n<p>参考:</p>\n<ul>\n<li><a href=\"https://blog.fundebug.com/2018/07/06/apply-lets-encrypt-certificate/\">教你快速撸一个免费HTTPS证书 | FunDebug</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Let’s Encrypt 免费HTTPS证书"
        }
      ],
      "config": {
        "source": "Let’s Encrypt 免费HTTPS证书.md",
        "staticFileName": "free_https.html",
        "author": "guoqzuo",
        "createDate": "2020/11/23",
        "description": "Let’s Encrypt 是一个非盈利TLS（Transport Layer Security) 证书颁发机构（CA），免费提供 https 证书。 由于 Let’s Encrypt 证书的有效期为 3 个月，所以一般使用程序来自动续期更换证书。官方推荐使用 Certbot 来管理，它可以一站式申请、续期证书。在 Certbot 官网选择部署服务器使用的软件及系统，会自动列出需要操作的步骤，如下图",
        "keywords": "免费https,https",
        "category": "http与https",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"pm2-processyml-you-cannot-define-a-mapping-item-when-in-a-sequence\">pm2 process.yml You cannot define a mapping item when in a sequence</h1>\n<p>使用 pm2 运行 node 项目，<code>pm2 start process.yml</code> 后提示 You cannot define a mapping item when in a sequence，是 process.yml 配置文件的问题，修改下配置文件即可</p>\n<pre><code class=\"language-js\">// cat process.yml\napps:\n  - script: app.js \n  instances: 2\n  watch: true\n  env:\n    NODE_ENV: production</code></pre>\n<p>将 <code>- script: app.js</code> 改为 <code>script: app.js</code> 重新运行就可以了</p>\n<p>参考: <a href=\"https://stackoverflow.com/questions/16482875/you-cannot-define-a-mapping-item-when-in-a-sequence-when-running-phpunit-in-sy\">“You cannot define a mapping item when in a sequence” when running phpunit in symfony\n | Stack overflow</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "pm2 process.yml You cannot define a mapping item when in a sequence"
        }
      ],
      "config": {
        "source": "pm2 process.yml You cannot define a mapping item when in a sequence.md",
        "staticFileName": "pm2_map.html",
        "author": "guoqzuo",
        "createDate": "2020/11/23",
        "description": "使用 pm2 运行 node 项目，`pm2 start process.yml` 后提示 You cannot define a mapping item when in a sequence，是 process.yml 配置文件的问题，修改下配置文件即可。将 `- script: app.js` 改为 `script: app.js` 重新运行就可以了",
        "keywords": "pm2 process.yml",
        "category": "前端工程化",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-功能实现\">Vue @功能实现</h1>\n<p>如果自己写一个 @ 功能会比较麻烦，在 github 上找了一个现成的开源库：<a href=\"https://github.com/zurb/tribute\">Tribute</a> - ES6 Native @mentions，它是ES 原生的实现，社区有各种框架的实现。这里我们使用它的 vue 实现 <a href=\"https://github.com/syropian/vue-tribute\">vue-tribute</a>。下图是实现效果</p>\n<p><img src=\"../../../images/blog/vue/vue_at_mention.gif\" alt=\"vue_at_mention.gif\"></p>\n<p>在线示例：<a href=\"https://www.zuoguoqing.com/at\">Vue @功能在线示例</a> 对应的 vue 代码如下，需要注意的地方</p>\n<ol>\n<li>我们引入 vue-tribute 组件，传入 options 即可</li>\n<li>样式方面，需要写弹出选择框的样式，不然就没有样式</li>\n<li>options 的配置完全是 Tribute 的配置，到对应的 github 上查找即可，options 的可选值支持动态渲染，支持从接口取</li>\n</ol>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;h3&gt;contenteditable @mentions&lt;/h3&gt;\n    &lt;vue-tribute :options=&quot;options&quot;&gt;\n      &lt;div\n        class=&quot;content-editable&quot;\n        contenteditable=&quot;true&quot;\n        @input=&quot;valueChange&quot;\n        placeholder=&quot;@...&quot;\n      &gt;&lt;/div&gt;\n    &lt;/vue-tribute&gt;\n    &lt;br /&gt;\n    &lt;div&gt;\n      &lt;p&gt;纯文本textContent：&lt;/p&gt;\n      &lt;p&gt;{{ textContent }}&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;p&gt;富文本innerHTML：&lt;/p&gt;\n      &lt;p&gt;{{ innerHTML }}&lt;/p&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport VueTribute from &quot;vue-tribute&quot;;\nexport default {\n  components: {\n    VueTribute\n  },\n  computed: {},\n  data() {\n    return {\n      textContent: &quot;&quot;,\n      innerHTML: &quot;&quot;,\n      options: {\n        trigger: &quot;@&quot;,\n        // specify whether a space is required before the trigger string\n        requireLeadingSpace: false,\n        noMatchTemplate: &quot;&lt;li&gt;暂无数据&lt;/li&gt;&quot;,\n        values: [\n          { key: &quot;张三 zhangsan&quot;, value: &quot;张三&quot; },\n          { key: &quot;李四 lisi&quot;, value: &quot;李四&quot; },\n          { key: &quot;王五 wangwu&quot;, value: &quot;王五&quot; },\n          { key: &quot;周杰伦 zhoujielun&quot;, value: &quot;周杰伦&quot; }\n        ],\n        positionMenu: true,\n        selectTemplate: function(item) {\n          return (\n            &#39;&lt;span contenteditable=&quot;false&quot;&gt;&lt;a&gt;&#39; +\n            &quot;@&quot; +\n            item.original.value +\n            &quot;&lt;/a&gt;&lt;/span&gt;&quot;\n          );\n        }\n      }\n    };\n  },\n  methods: {\n    noMatchFound() {\n      console.log(&quot;暂无数据&quot;);\n    },\n    valueChange(e) {\n      console.log(e.target.innerHTML, e.target.textContent);\n      this.textContent = e.target.textContent;\n      this.innerHTML = e.target.innerHTML;\n    }\n  }\n};\n&lt;/script&gt;\n&lt;style lang=&quot;less&quot;&gt;\n// Tribute-specific styles 略\n&lt;/style&gt;</code></pre>\n<p>完整代码参见：<a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/vuecli-demo/src/views/at/index.vue\">vue @功能实现demo | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue @功能实现"
        }
      ],
      "config": {
        "source": "Vue @功能实现.md",
        "staticFileName": "vue_mentions.html",
        "author": "guoqzuo",
        "createDate": "2020/11/30",
        "description": "如果自己写一个 @ 功能会比较麻烦，在 github 上找了一个现成的开源库 Tribute - ES6 Native @mentions，它是 ES 原生的实现，社区有各种框架的实现。这里我们使用它的 Vue 实现 vue-tribute。下图是实现效果",
        "keywords": "@实现,@功能实现,@下拉选择实现,Vue @功能实现",
        "category": "Vue",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"vueconfigjs-plugins-is-not-allowed\">vue.config.js: &quot;plugins&quot; is not allowed</h1>\n<p>在 vue.config.js 中，webpack 相关的配置需要写到 configureWebpack 里，不能直接写到外面，否则会报错：vue.config.js: &#39;plugins&#39; is not allowed。</p>\n<p><img src=\"../../../images/blog/vue/vue_config_js_plugins.png\" alt=\"vue_config_js_plugins.png\"></p>\n<pre><code class=\"language-js\">// vue.config.js\nmodule.exports = {\n  plugins: [], // error，&quot;plugins&quot; is not allowed\n  configureWebpack: {\n    plugins: [], // 正确写法\n    externals: {}\n  }\n};</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue.config.js: \"plugins\" is not allowed"
        }
      ],
      "config": {
        "source": "vue.config.js: 'plugins' is not allowed.md",
        "staticFileName": "vue_cfg_plugins.html",
        "author": "guoqzuo",
        "createDate": "2020/11/30",
        "description": "在 vue.config.js 中，webpack 相关的配置需要写到 configureWebpack 里，不能直接写到外面，否则会报错：vue.config.js: 'plugins' is not allowed。",
        "keywords": "plugins is not allowed",
        "category": "Vue",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-elementui-cannot-read-property-prototype-of-undefined\">Vue ElementUI Cannot read property &#39;prototype&#39; of undefined</h1>\n<p>由于 vue 项目 npm run build 打包时 ElementUI 体积较大，因此把他单独抽离出去。放到 public/index.html 里直接引入。但抽离出去后发现启动后控制台会报这样一个错误：Cannot read property &#39;prototype&#39; of undefined。</p>\n<p><img src=\"../../../images/blog/vue/vue_prototype_undefined.png\" alt=\"vue_prototype_undefined.png\"></p>\n<p>网上查了下，是因为在 public/index.html 中引入 ElementUI 的 js 时，前面没有加 Vue.js 的引入。这里我们在前面加入 Vue.js 的引入即可。</p>\n<pre><code class=\"language-html\">&lt;!-- public/index.html --&gt;\n&lt;!-- 引入element组件js前加入vue的引入 --&gt;\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/element-ui/2.9.2/index.js&quot;&gt;&lt;/script&gt;</code></pre>\n<p>在 vue.config.js 里设置 ElementUI以及JS使用外部引入</p>\n<pre><code class=\"language-js\">module.exports = {\n  configureWebpack: {\n    externals: {\n      // 需要使用外部引入的包名：包名\n      vue: &quot;Vue&quot;,\n      &quot;element-ui&quot;: &quot;ELEMENT&quot;\n    }\n  }\n};</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue ElementUI Cannot read property 'prototype' of undefined"
        }
      ],
      "config": {
        "source": "Vue ElementUI Cannot read property 'prototype' of undefined.md",
        "staticFileName": "vue_element_err.html",
        "author": "guoqzuo",
        "createDate": "2020/11/30",
        "description": "由于 vue 项目 npm run build 打包时 ElementUI 体积较大，因此把他单独抽离出去。放到 public/index.html 里直接引入。但抽离出去后发现启动后控制台会报这样一个错误：Cannot read property 'prototype' of undefined。网上查了下，是因为在 public/index.html 中引入 ElementUI 的 js 时，前面没有加 Vue.js 的引入。这里我们在前面加入 Vue.js 的引入即可。",
        "keywords": "element cannot read property 'prototype' of undefined",
        "category": "Vue",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-cli-项目页面打开时间优化：从16秒到2秒内\">Vue CLI 项目页面打开时间优化：从16秒到2秒内</h1>\n<p>在日常开发中，经常要写一些 demo 来测试一些功能，于是专门新建了一个 github 仓库来管理，方便积累。这次想着把 vue demo 部署到服务器，方便 PC/手机 实时看效果。于是把 vue-cli 项目 npm run build 后，将 dist 部署到服务器 nginx 下，但发现打开很慢，下面来看看怎么优化。</p>\n<p>如下图，DOM 加载完 15 秒，完全加载 16 秒</p>\n<p><img src=\"../../../images/blog/vue/vue_vendor_optimize_1.png\" alt=\"vue_vendor_optimize_1.png\"></p>\n<h2 id=\"nginx-开启-gzip---16s-到-11s\">nginx 开启 gzip - 16s 到 11s</h2>\n<p>主要是 chunk-vendors.js 接近 1.7M，下载时间较长。npm run build 打包后 log 如下图(这是后面补的图，中间把路由懒加载改了下，size 会比上图里的小一点)，超出建议的 244kB</p>\n<p><img src=\"../../../images/blog/vue/vue_vendor_optimize_2.png\" alt=\"vue_vendor_optimize_2.png\"></p>\n<p><strong>理论上，nginx 开启 gzip 成功后，文件大小应该是 600多kb，看最上面的 Chrome Network 图里面，vendors 是 1.7M，且 Content-Encoding 那一栏没有 gzip，说明 js,css文件没有开启 gzip</strong> 咱们配置下 nginx 服务，开启 gzip</p>\n<pre><code class=\"language-bash\">server\n{\n  server_name www.zuoguoqing.com;\n\n  # 开启gzip\n  gzip on;\n  gzip_vary on;\n  gzip_min_length 1000;\n  gzip_comp_level 2;\n  gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml image/jpeg image/gif image/png application/javascript; \n\n  location / {\n    # root   html;\n    # index  index.html index.htm;\n    proxy_pass http://127.0.0.1:3000;\n  }\n}</code></pre>\n<p>咱们再来看看效果，如下图。vendors.js 文件从 1.7M 变为 600多k，且 Content-Type 那一栏也有了 gzip 标识。</p>\n<p><strong>下图可以看出 nginx 开启 gzip 压缩后，加载时间快了 5s。注意网上说的 compresion-webpack-plugin 插件在前端进行 gzip 基本是多此一举。nginx 本身可以配置 gzip 功能，前端不用做 gzip 处理</strong></p>\n<p><img src=\"../../../images/blog/vue/vue_vendor_optimize_3.png\" alt=\"vue_vendor_optimize_3.png\"></p>\n<h2 id=\"使用-vue-cli-report-分析-vendorjs\">使用 Vue CLI report 分析 vendor.js</h2>\n<p>11秒还是有点长，咱们想办法来减少 vendor.js 的体积看看，上面的图里面，gzip压缩后的 venders.js 有 613KB，加载也要 7 秒多。</p>\n<p><strong>这里我们要使用 Vue CLI（@vue/cli）自带的 webpack 包体积优化工具，它可以查看各个模块的 size 大小，方便优化。只需要在 build 后面加上 --report 参数即可。我们把命令配置到 package.json 里，方便 npm run report 打包并生成 report</strong>，注意：网上很多说要先安装 webpack-bundle-analyzer 包，其实不需要安装。</p>\n<pre><code class=\"language-js\">// package.json\n&quot;scripts&quot;: {\n  &quot;serve&quot;: &quot;vue-cli-service serve&quot;,\n  &quot;build&quot;: &quot;vue-cli-service build&quot;,\n  // 加入下面一行\n  &quot;report&quot;: &quot;vue-cli-service build --report&quot;\n},</code></pre>\n<p>根据上面的配置后，运行 npm run report 后，会在 build 的同时，在 dist 目录会生成一个 report.html，打开后如下图，我们可以看到 ElementUI 和 Echarts 占用较大，直接打包了 node_modules 里面框架的内容。</p>\n<p><img src=\"../../../images/blog/vue/vue_vendor_optimize_4.png\" alt=\"vue_vendor_optimize_4.png\"></p>\n<h2 id=\"echarts-改外部引用，elementui-改按需加载---11s-到-36s\">Echarts 改外部引用，ElementUI 改按需加载 - 11s 到 3.6s</h2>\n<p><strong>这里我们可以把 Echarts 改为外部引用 cdn，不打包到主包 vendors.js 里，另外再把 Element 改为懒加载，只加载使用到的部分模块</strong></p>\n<p>如果只把 Echarts 改为外部引入，ElementUI 整体引入，大概还有 1.4M 左右。Element 按需加载后就锐减了，提示大小就变为 596KB 了，如下图</p>\n<p><img src=\"../../../images/blog/vue/vue_vendor_optimize_5.png\" alt=\"vue_vendor_optimize_5.png\"></p>\n<p>对应的 report.html 图如下，可以看到 </p>\n<p><img src=\"../../../images/blog/vue/vue_vendor_optimize_6.png\" alt=\"vue_vendor_optimize_6.png\"></p>\n<h3 id=\"echarts-改外部引用方法\">Echarts 改外部引用方法</h3>\n<p>看完效果后，下面来看方法，怎么把 Echarts 外部引用，以及 Element 怎么按需加载。外部引入需要配置两个地方：</p>\n<ol>\n<li>在 vue.config.js 的 configureWebpack.externals 加入需要外部使用的包 </li>\n<li>在 public/index.html 里引入对应的包</li>\n</ol>\n<p>下面是 Echarts 外部引用需要配置的地方</p>\n<pre><code class=\"language-js\">// vue.config.js \nmodule.exports = {\n  configureWebpack: {\n    externals: {\n      echarts: &quot;echarts&quot;,\n    }\n  }\n};</code></pre>\n<pre><code class=\"language-html\">&lt;!-- public/index.html --&gt;\n&lt;!-- 写在 head 最下面或 body 最下面 --&gt;\n&lt;!-- echarts cdn --&gt;\n&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/echarts/4.8.0/echarts-en.common.min.js&quot;&gt;&lt;/script&gt;</code></pre>\n<h3 id=\"elementui-改按需引用方法\">ElementUI 改按需引用方法</h3>\n<p>再来看看 Element 按需引入。注意 Element 按需引入，也需要两步</p>\n<ol>\n<li>修改 main.js 里的 Element 引入方式，单个模块逐一引入</li>\n<li>按需引入，依赖的是 babel-plugin-component，vue-cli 项目已经带了对应的功能，在 babel.config.js 加入配置即可(官网提示是在 .babelrc ，如果vue-cli 项目,有了 babel.config.js 就在该文件配置)。 参考: <a href=\"https://element.eleme.cn/#/zh-CN/component/quickstart#an-xu-yin-ru\">按需引入 | ElementUI</a></li>\n</ol>\n<pre><code class=\"language-js\">// main.js \n// Element 完整引入\n// import ElementUI from &quot;element-ui&quot;;\n// Vue.use(ElementUI);\n// Element 按需引入\nimport {\n  Input,\n  Button,\n  // ...\n} from &quot;element-ui&quot;;\nimport &quot;element-ui/lib/theme-chalk/index.css&quot;;\nVue.use(Input);\nVue.use(Button);\n// ...</code></pre>\n<pre><code class=\"language-js\">// babel.config.js\nmodule.exports = {\n  presets: [&quot;@vue/cli-plugin-babel/preset&quot;]\n  // element 按需引入\n  plugins: [\n    [\n      &quot;component&quot;,\n      {\n        libraryName: &quot;element-ui&quot;,\n        styleLibraryName: &quot;theme-chalk&quot;\n      }\n    ]\n  ]\n};\n</code></pre>\n<p>这样设置后，从原来的 1.8M 优化到了 596KB，再来看看加载时间，如下图。只需要 3.6s 了，整整快了 7~8s</p>\n<p><img src=\"../../../images/blog/vue/vue_vendor_optimize_7.png\" alt=\"vue_vendor_optimize_7.png\"></p>\n<h2 id=\"cnd-链接优化，elementui-也改外部引入-36s---18s\">CND 链接优化，ElementUI 也改外部引入 3.6s - 1.8s</h2>\n<p>如上图所示，<strong>echarts 外部引入的 js 使用了 cdn，且开启了 gzip，只有 168KB，加载时间仅 65ms，而我的 vendors.js gzip 压缩后只有 122KB，下载时间较长，加载用了 2.23s，我部署的服务器是入门级的较慢，还是 cdn 快</strong>。另外 vendors.css 里面有 Element 的 css 文件，咱们也换成外部引入 cdn 试试</p>\n<p>修改 main.js，不按需引入 Element。把 Element 的 css 也放到外部引入</p>\n<pre><code class=\"language-js\">// main.js\nimport ElementUI from &quot;element-ui&quot;;\nVue.use(ElementUI);\n// import &quot;element-ui/lib/theme-chalk/index.css&quot;;</code></pre>\n<p>修改 vue.config.js，设置 vue、ElementUI 外部引用</p>\n<pre><code class=\"language-js\">module.exports = {\n  configureWebpack: {\n    externals: {\n      // 需要使用外部引入的包名：包名\n      echarts: &quot;echarts&quot;, \n      vue: &quot;Vue&quot;, // 注意 vue需要外部引入。放到 echarts前面，防止 console 报错\n      // element: &quot;ElementUI&quot; 可以打包成功，但chunk-vendors.js里面会打包element\n      &quot;element-ui&quot;: &quot;ELEMENT&quot;\n    }\n  }\n};</code></pre>\n<p>去掉 babel.config.js 里面 Element 按需引入代码，修改 public/index.html，直接head里面引入</p>\n<pre><code class=\"language-html\">&lt;!-- pbulic/index.html --&gt;\n&lt;head&gt;\n  &lt;!-- 引入Element css --&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;\n  &lt;!-- echarts --&gt;\n  &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/echarts/4.8.0/echarts-en.common.min.js&quot;&gt;&lt;/script&gt;\n  &lt;!-- 引入vue --&gt;\n  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;\n  &lt;!-- 引入Element js --&gt;\n  &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;\n&lt;head&gt;</code></pre>\n<p>把 Element 和 vue 都改为外部引入后，再来看看，如下图，完全没警告了，低于 244KB，vendors.js 只有 68 KB</p>\n<p><img src=\"../../../images/blog/vue/vue_vendor_optimize_8.png\" alt=\"vue_vendor_optimize_8.png\"></p>\n<p>对应的 report.html 图如下，其实吧 vue-router、vuex 也使用 cdn 可能 vendor 会更小，但感觉不是很必要了。vendors.js 已经很小了</p>\n<p><img src=\"../../../images/blog/vue/vue_vendor_optimize_9.png\" alt=\"vue_vendor_optimize_9.png\"></p>\n<h3 id=\"unpkg-cdn-负优化（br-压缩比-gzip-还慢）\">unpkg cdn 负优化（br 压缩比 gzip 还慢）</h3>\n<p>再来看看加载时间，还是要 3s 多 ？？？ 可以明显的看到 index.css 是 ElementUI 的 css，这个官方推荐的 unpkg cdn 有点慢，不是 gzip的压缩，是 br 的压缩方式。 32.7k 要 1.33s。（下图里面是 2.5s，其实整体是 3s 多，ElementUI的 JS 我已经换为了 bootcdn。之前的图压缩时不小心被覆盖了。）</p>\n<p><img src=\"../../../images/blog/vue/vue_vendor_optimize_10.png\" alt=\"vue_vendor_optimize_10.png\"></p>\n<p>这里我们再把 Element css 也替换为 bootcdn 连接，连接如下</p>\n<pre><code class=\"language-html\">&lt;link href=&quot;https://cdn.bootcdn.net/ajax/libs/element-ui/2.9.2/theme-chalk/index.css&quot; rel=&quot;stylesheet&quot;&gt;\n&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/element-ui/2.9.2/index.js&quot;&gt;&lt;/script&gt;</code></pre>\n<h3 id=\"使用-bootcdn-优化到-18s\">使用 bootcdn 优化到 1.8s</h3>\n<p>替换后再来看看效果，整体 loaded 只要 1.89s 了。</p>\n<p><img src=\"../../../images/blog/vue/vue_vendor_optimize_11.png\" alt=\"vue_vendor_optimize_11.png\"></p>\n<p>上面的图，是取的均值。再次刷新可能会低于 1s，也可能会高于。我这里在测试时都勾选了 Disable cache。就是不使用缓存，有时候可能 dns 解析，https 验证时间、服务器响应时间会有差别。</p>\n<p><img src=\"../../../images/blog/vue/vue_vendor_optimize_12.png\" alt=\"vue_vendor_optimize_12.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue CLI 项目页面打开时间优化：从16秒到2秒内",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "nginx 开启 gzip - 16s 到 11s"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "使用 Vue CLI report 分析 vendor.js"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Echarts 改外部引用，ElementUI 改按需加载 - 11s 到 3.6s",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "Echarts 改外部引用方法"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "ElementUI 改按需引用方法"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "CND 链接优化，ElementUI 也改外部引入 3.6s - 1.8s",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "unpkg cdn 负优化（br 压缩比 gzip 还慢）"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "使用 bootcdn 优化到 1.8s"
                }
              ]
            }
          ]
        }
      ],
      "config": {
        "source": "Vue CLI 项目页面打开时间优化：从16秒到2秒内.md",
        "staticFileName": "vue_cli_slow.html",
        "author": "guoqzuo",
        "createDate": "2020/11/30",
        "description": "在日常开发中，经常要写一些 demo 来测试一些功能，于是专门新建了一个 github 仓库来管理，方便积累。这次想着把 vue demo 部署到服务器，方便 PC/手机 实时看效果。于是把 vue-cli 项目 npm run build 后，将 dist 部署到服务器 nginx 下，但发现打开很慢，下面来看看怎么优化。如下图，DOM 加载完 15 秒，完全加载 16 秒",
        "keywords": "vue-cli项目页面加载时间太长,npm run build 打包很大,vue vendor.js文件太大,vue项目包体积优化",
        "category": "Vue",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"domcontentloaded-与-load-时间具体指的是什么时间？\">DOMContentLoaded 与 Load 时间具体指的是什么时间？</h1>\n<p>在 <a href=\"https://developers.google.com/web/tools/chrome-devtools/network/reference#load\">Chrome DevTools 官网 Network Reference</a> 里是这样介绍的：</p>\n<p>View load events</p>\n<blockquote>\n<p>DevTools displays the timing of the DOMContentLoaded and load events in multiple places on the Network panel. The DOMContentLoaded event is colored blue, and the load event is red.</p>\n</blockquote>\n<p>这两个时间是从页面开始到 DOMContentLoaded 与 load 事件触发的时间</p>\n<p><img src=\"../../../images/blog/js/chrome_load_event.png\" alt=\"chrome_load_events.png\"></p>\n<p>来看看 <code>DOMContentLoaded</code> 和 <code>load</code> 事件在 MDN 的解释</p>\n<p><strong>DOMContentLoaded事件：window 和 document 上都可以监听，意思一致</strong></p>\n<pre><code class=\"language-js\">window.addEventListener(&#39;DOMContentLoaded&#39;, (event) =&gt; {\n  console.log(&#39;DOM fully loaded and parsed&#39;);\n});\ndocument.addEventListener(&#39;DOMContentLoaded&#39;, (event) =&gt; {\n  console.log(&#39;DOM fully loaded and parsed&#39;);\n});</code></pre>\n<blockquote>\n<p>The DOMContentLoaded event fires when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading.</p>\n</blockquote>\n<p><code>DOMContentLoaded</code> 事件：<strong>当 DOM (HTML document) 完成加载并解析，而不用等 css样式、图片和子 frame 完全加载完成时触发</strong> </p>\n<p>同步 JS 会使 DOM 的解析暂停，如果希望用户在请求页面后尽快解析DOM，你可以把 JS 使用异步加载，并优化 css 样式加载方式。如果按照惯例加载，样式表和 JS 是并行加载的，会减慢 DOM 解析，窃取主 html 文档解析速度。下面是 head 中 script 默认加载以及加上 async, defer 参数的对比，一般把 script 放到 body 末尾，基本等价于 header 中 defer 的效果</p>\n<p><img src=\"../../../images/blog/js/script_load.png\" alt=\"script_load.png\"></p>\n<p><strong>load事件：window</strong></p>\n<pre><code class=\"language-js\">window.addEventListener(&#39;load&#39;, (event) =&gt; {\n  console.log(&#39;page is fully loaded&#39;);\n});\n// 或\nwindow.onload = (event) =&gt; {\n  console.log(&#39;page is fully loaded&#39;);\n};</code></pre>\n<blockquote>\n<p>The load event is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. This is in contrast to DOMContentLoaded, which is fired as soon as the page DOM has been loaded, without waiting for resources to finish loading.</p>\n</blockquote>\n<p><strong>当整个页面加载完成时（包括所有相关资源，例如css样式表和图片），这与 <code>DOMContentLoaded</code> 相反，它在页面DOM被加载后立即触发，而无需等待资源完成加载。</strong></p>\n<p>参考:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/DOMContentLoaded_event\">Window: DOMContentLoaded event | MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event\">Document: DOMContentLoaded event</a></li>\n<li><a href=\"https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery\">优化 css 加载方式 | Google developers</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event\">Window: load event | MDN</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "DOMContentLoaded 与 Load 时间具体指的是什么时间？"
        }
      ],
      "config": {
        "source": "DOMContentLoaded 与 Load 时间具体指的是什么时间？.md",
        "staticFileName": "page_load_time.html",
        "author": "guoqzuo",
        "createDate": "2020/11/30",
        "description": "在 Chrome DevTools 官网 Network Reference 里是这样介绍的：View load events：DevTools displays the timing of the DOMContentLoaded and load events in multiple places on the Network panel. The DOMContentLoaded event is colored blue, and the load event is red. 这两个时间是从页面开始到 DOMContentLoaded 与 load 事件触发的时间",
        "keywords": "DOMContentLoaded,load",
        "category": "JavaScript",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"google广告一个页面怎么显示多个广告，多个广告只显示的一个是什么原因？\">Google广告一个页面怎么显示多个广告，多个广告只显示的一个是什么原因？</h1>\n<p>在 Google Adsense 中，理论上配置好广告形式后，获取代码，把对应的代码放到页面中就可以显示广告了。但发现，如果放多个广告，只有一个可以显示出来，下面来看看是为什么？</p>\n<p>官方提供的代码如下:</p>\n<pre><code class=\"language-html\">&lt;script async src=&#39;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#39;&gt;&lt;/script&gt;\n&lt;ins class=&#39;adsbygoogle&#39;\n     style=&#39;display:block&#39;\n     data-ad-client=&#39;ca-pub-9527676606416000&#39;\n     data-ad-slot=&#39;3653238000&#39;\n     data-ad-format=&#39;auto&#39;\n     data-full-width-responsive=&#39;true&#39;&gt;&lt;/ins&gt;\n&lt;script&gt;\n     (adsbygoogle = window.adsbygoogle || []).push({});\n&lt;/script&gt;</code></pre>\n<p>一般在验证开通 Google Adsense 时，就会引入第一行 script 代码。那么只需要把下面的 ins 元素 和 script 里的代码拷贝进页面里就行。</p>\n<p>当有多个广告时，我只拷贝了 多个 ins 到指定位置。 script 里面 <code>(adsbygoogle = window.adsbygoogle || []).push({});</code> 只放到了 body最后面的 script 里，这时只能显示一个广告。于是我看了下其他可以显示多个 google 广告的页面，打开源码后，发现最下面的 script 里的内容也要多次拷贝。也就是 <strong>如果页面上要放多个 google 广告，每次都需要引入 ins +  script 两部分的代码</strong></p>\n<pre><code class=\"language-html\">&lt;!-- 广告 1 --&gt;\n&lt;ins class=&#39;adsbygoogle&#39; style=&quot;ins内容简写&quot;&gt;&lt;/ins&gt;\n&lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;\n\n&lt;!-- 广告 2 --&gt;\n&lt;ins class=&#39;adsbygoogle&#39; style=&quot;ins内容简写&quot;&gt;&lt;/ins&gt;\n&lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Google广告一个页面怎么显示多个广告，多个广告只显示的一个是什么原因？"
        }
      ],
      "config": {
        "source": "Google广告一个页面怎么显示多个广告，多个广告只显示的一个是什么原因？.md",
        "staticFileName": "google_ad_multiple.html",
        "author": "guoqzuo",
        "createDate": "2020/11/30",
        "description": "在 Google Adsense 中，理论上配置好广告形式后，获取代码，把对应的代码放到页面中就可以显示广告了。但发现，如果放多个广告，只有一个可以显示出来，下面来看看是为什么？一般在验证开通 Google Adsense 时，就会引入第一行 script 代码。那么只需要把下面的 ins 元素 和 script 里的代码拷贝进页面里就行。当有多个广告时，我只拷贝了 多个 ins 到指定位置。",
        "keywords": "Google 广告同页面多个广告不显示,Google 配置了多个广告只显示一个",
        "category": "网站建设与SEO",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-cli-build---target-lib-时如何避免打包成多个umdjs文件\">Vue CLI build --target lib 时如何避免打包成多个umd.js文件</h1>\n<p>Vue CLI 项目中，一般我们使用的是 npm run build 来构建项目，并发布到线上。当我们写组件/工具库的时候，就需要使用 <code>--target lib</code> 参数了。</p>\n<p>打包成库（Library）与普通的构建应用不一样，它会在 dist 目录下生成对应的 umd.js 文件，也就是通用模块定义的 js 文件。一般用于组件/工具库的入口文件，我们可以在静态 html 以及 Vue CLI 等项目中直接引入并使用。<strong>如果不进行构建，只能在 Vue CLI 项目中使用，无法引入一个 js 直接使用。</strong></p>\n<p>在项目中，运行打包命令</p>\n<pre><code class=\"language-bash\"># 打包成库 Library，指定入口为 src/index.js，构建后生成目录为 lib 目录\n# --mode lib 不单独生成css，样式内联\n# --target lib 打包形式为 lib\nvue-cli-service build --mode lib --target lib --dest lib src/index.js</code></pre>\n<p>执行效果如下</p>\n<p><img src=\"../../../images/blog/node/multi_umd_1.png\" alt=\"multi_umd_1.png\"></p>\n<p>一般我们把 *.umd.js 引入到项目中就可以使用。但这里分包了。将 *.umd.js 文件，分了好几个小包。在普通 html 文件里面引入是可以正常运行的。他会根据 umd.js 找到需要加载的其他分包并加载。但在vue项目中只引入 *.umd.js，其他分包不会打包到项目中，导致无法运行。</p>\n<p>其实看上面的图，js 文件超过 77KB 左右就分块了。Gzipped 压缩后不到 12KB，我们完全可以将这些打包成一个 umd.js 文件，而不需要分多个文件。</p>\n<p>这里借助 webpack 的一个插件来配置 Chunk 数量，maxChunks  设置为 1，只打一个包，不分多个 js 文件。在 vue.config.js 里修改webpack 的配置。</p>\n<pre><code class=\"language-js\">// vue.config.js\nconst webpack = require(&quot;webpack&quot;);\nmodule.exports = {\n  configureWebpack: {\n    plugins: [\n      // 限制只打一个包，不分Chunk\n      new webpack.optimize.LimitChunkCountPlugin({\n        maxChunks: 1\n      })\n    ],\n    // 当库里面引入了比较大的文件时，为了不影响主包大小，需要设置下该包使用外部引入\n    externals: {\n      echarts: &quot;echarts&quot;\n    }\n  }\n};</code></pre>\n<p>这样设置后，再重新打包就正常了，只有一个包，各平台就都没问题了。而且 gzip 压缩后也才 14KB 不到。如下图</p>\n<p><img src=\"../../../images/blog/node/multi_umd_2.png\" alt=\"multi_umd_2.png\"></p>\n<p>扩展：</p>\n<p>如果想要了解对于 vue-cli 打包 <code>vue-cli-service --target lib</code> 的具体执行，可以看 Vue CLI 源码</p>\n<pre><code class=\"language-js\">// @vue/cli-service/lib/commands/build/index.js\n// Vue CLI源码，bulid 入口文件，lib时，配置处理\n// resolve raw webpack config\nlet webpackConfig\nif (args.target === &#39;lib&#39;) {\n  webpackConfig = require(&#39;./resolveLibConfig&#39;)(api, args, options)\n} \n// .....\nelse {\n  webpackConfig = require(&#39;./resolveAppConfig&#39;)(api, args, options)\n}\n\n// @vue/cli-service/lib/commands/build/resolveLibConfig.js\n// Vue CLI源码，lib 时 输入、输出文件配置\nrawConfig.output = Object.assign({\n  library: libName,\n  libraryExport: isVueEntry ? &#39;default&#39; : undefined,\n  libraryTarget: format,\n  // preserve UDM header from webpack 3 until webpack provides either\n  // libraryTarget: &#39;esm&#39; or target: &#39;universal&#39;\n  // https://github.com/webpack/webpack/issues/6522\n  // https://github.com/webpack/webpack/issues/6525\n  globalObject: `(typeof self !== &#39;undefined&#39; ? self : this)`\n}, rawConfig.output, {\n  filename: `${entryName}.js`,\n  chunkFilename: `${entryName}.[name].js`,\n  // use dynamic publicPath so this can be deployed anywhere\n  // the actual path will be determined at runtime by checking\n  // document.currentScript.src.\n  publicPath: &#39;&#39;\n})</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue CLI build --target lib 时如何避免打包成多个umd.js文件"
        }
      ],
      "config": {
        "source": "Vue CLI build --target lib 时如何避免打包成多个umd.js文件.md",
        "staticFileName": "vue_umd_multiple.html",
        "author": "guoqzuo",
        "createDate": "2020/11/30",
        "description": "Vue CLI 项目中，一般我们使用的是 npm run build 来构建项目，并发布到线上。当我们写组件/工具库的时候，就需要使用 `--target lib` 参数了。打包成库（Library）与普通的构建应用不一样，它会在 dist 目录下生成对应的 umd.js 文件，也就是通用模块定义的 js 文件。一般用于组件/工具库的入口文件，我们可以在静态 html 以及 Vue CLI 等项目中直接引入并使用。如果不进行构建，只能在 Vue CLI 项目中使用，无法引入一个 js 直接使用。",
        "keywords": "怎么避免生成多个umd.js,如何避免打包成多个umd.js",
        "category": "前端工程化",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"lodashjs-打包后默认是整包，怎么按需打包，减少包体积\">lodash.js 打包后默认是整包，怎么按需打包，减少包体积</h1>\n<p>在 vue-cli 打包 lib 项目时，发现包体积较大有 600多KB，于是使用 <code>-- report</code> 参数看具体是哪个包较大，发现尽管只用到了 lodash 的一个函数，但打包体积却有几百k，如下图，应该是整包打的，没有按需打包。</p>\n<p><img src=\"../../../images/blog/node/lodash_need_1.png\" alt=\"lodash_need_1.png\"></p>\n<pre><code class=\"language-bash\"># 以 src/index.js 为入口，以库的形式打包到lib目录下，并生成 report.html\nvue-cli-service build --mode lib --target lib --dest lib --report src/index.js</code></pre>\n<p>以下是 打开 lib/项目名.umd-report.html 后，显示的各模块大小示意图</p>\n<p><img src=\"../../../images/blog/node/lodash_need_2.png\" alt=\"lodash_need_2.png\"></p>\n<p>这里借助 babel 的 loadsh 插件来进行按需打包。如果没有babel的配置文件，新建 .babelrc 文件，加入如下内容：</p>\n<pre><code class=\"language-js\">// .babelrc  使用 lodash 的babel插件\n{\n  &quot;plugins&quot;: [&quot;lodash&quot;]\n}</code></pre>\n<p>lodash 的 babel 插件就是 babel-plugin-lodash，需要先 npm 安装下</p>\n<pre><code class=\"language-bash\">npm install babel-plugin-lodash -D</code></pre>\n<p>ok后，重新打包，就是按需打包了。如下图，体积只有 100 多 KB 了。</p>\n<p><img src=\"../../../images/blog/node/lodash_need_3.png\" alt=\"lodash_need_3.png\"></p>\n<p>再来看看 report 信息，可以看到，只打包了使用到的函数</p>\n<p><img src=\"../../../images/blog/node/lodash_need_4.png\" alt=\"lodash_need_4.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "lodash.js 打包后默认是整包，怎么按需打包，减少包体积"
        }
      ],
      "config": {
        "source": "lodash.js 打包后默认是整包，怎么按需打包，减少包体积.md",
        "staticFileName": "loadsh_as_demand.html",
        "author": "guoqzuo",
        "createDate": "2020/11/30",
        "description": "在 vue-cli 打包 lib 项目时，发现包体积较大有 600多KB，于是使用 `-- report` 参数看具体是哪个包较大，发现尽管只用到了 lodash 的一个函数，但打包体积却有几百k，如下图，应该是整包打的，没有按需打包。 以下是 打开 lib/项目名.umd-report.html 后，显示的各模块大小示意图。这里借助 babel 的 loadsh 插件来进行按需打包。如果没有babel的配置文件，新建 .babelrc 文件，加入如下内容：",
        "keywords": "loadsh按需打包,loadsh tree shaking,loadsh摇树",
        "category": "前端工程化",
        "year": "2020",
        "month": "11"
      }
    },
    {
      "htmlStr": "<h1 id=\"xxgithubio仓库配置github-pages后对其他仓库github-pages的影响\">xx.github.io仓库配置Github pages后对其他仓库Github pages的影响</h1>\n<p>在 github 中，假设我们创建了 <code>github用户名.github.io</code> 仓库，开启 Github Pages 后，访问该域名，就指向了这个仓库的文件。这时如果你的其他仓库也开启了 Github Pages，那么对于的目录解析可能会有问题。</p>\n<p><img src=\"../../../images/blog/git/github_pages.png\" alt=\"github_pages.png\"></p>\n<p>以我的 github 账号 zuoxiaobai 为例，如果 zuoxiaobai.github.io 这个仓库开启 pages，再把另一个仓库 zuo-blog 也开启 pages，那么访问 <code>https://zuoxiaobai.github.io/zuo-blog/</code> 并不能自动跳转到对应的 index.html，而是提示 404。需要访问 <code>https://zuoxiaobai.github.io/zuo-blog/index.html</code> 才行。这里我直接把 zuoxiaobai.github.io 的仓库关掉了 Github Pages。这样 <code>https://zuoxiaobai.github.io/zuo-blog/</code> 才能自动解析目录下的 index.html。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "xx.github.io仓库配置Github pages后对其他仓库Github pages的影响"
        }
      ],
      "config": {
        "source": "xx.github.io仓库配置Github pages后对其他仓库Github pages的影响.md",
        "staticFileName": "github-io.html",
        "author": "guoqzuo",
        "createDate": "2020/12/07",
        "description": "在 github 中，假设我们创建了 'github用户名.github.io' 仓库，开启 Github Pages 后，访问该域名，就指向了这个仓库的文件。这时如果你的其他仓库也开启了 Github Pages，那么对于的目录解析可能会有问题。以我的 github 账号 zuoxiaobai 为例，如果 zuoxiaobai.github.io 这个仓库开启 pages，再把另一个仓库 zuo-blog 也开启 pages，那么访问 `https://zuoxiaobai.github.io/zuo-blog/` 并不能自动跳转到对应的 index.html，而是提示 404。需要访问 `https://zuoxiaobai.github.io/zuo-blog/index.html` 才行。这里我直接把 zuoxiaobai.github.io 的仓库关掉了 Github Pages。这样 `https://zuoxiaobai.github.io/zuo-blog/` 才能自动解析目录下的 index.html。",
        "keywords": "github.io仓库开启pages后对其他仓库pages的影响",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"github-pages使用自定义域名开启https，配置cname解析\">GitHub Pages使用自定义域名开启HTTPS，配置CNAME解析</h1>\n<p>一般在仓库的 Setting 中，开启 Github Pages 会生成一个 <code>xxx.github.io/xx/</code> 的地址，地址有点长，我们可以使用自定义域名，这里我将 vue-chart 这个仓库设置成了自定义域名 vuechart.zuo11.com。然后，我们需要把自定义的域名解析到 github.com 地址。可以使用 ping github.com 来获取它的服务器 IP。</p>\n<p><img src=\"../../../images/blog/git/github_custom_domain.png\" alt=\"github_custom_domain.png\"></p>\n<p>获取 IP 后，我们到域名管理的位置，设置解析。</p>\n<ul>\n<li>记录类型，就是域名的解析类型，最常见的是 <code>A</code> 类型，就是将域名解析到服务器 IP。<code>CNAME</code> 是将域名指向另一个域名</li>\n<li>主机记录，就是域名前缀，<code>@</code> 表示 xx.com，<code>www</code> 表示 <code>www.xx.com</code>，一般设置这两种。<code>mail</code> 表示 mail.xx.com，代表二级域名。</li>\n</ul>\n<p><img src=\"../../../images/blog/git/github_custom_domain_2.png\" alt=\"github_custom_domain_2.png\"></p>\n<p>解析到 github IP 后，可以正常用域名访问到。但开启 https 后，证书有问题。这时提示需要配置 CNAME 解析。于是就把 &#39;A&#39; 类型的解析改成 了 CNAME。将 zuo11.com 的二级域名 vuechart 解析到 zuoxiaobia.github.io，这样就可以使用 https 访问了，而且证书正常。</p>\n<p><img src=\"../../../images/blog/git/github_custom_domain_3.png\" alt=\"github_custom_domain_3.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "GitHub Pages使用自定义域名开启HTTPS，配置CNAME解析"
        }
      ],
      "config": {
        "source": "GitHub Pages使用自定义域名开启HTTPS，配置CNAME解析.md",
        "staticFileName": "github_pages_https.html",
        "author": "guoqzuo",
        "createDate": "2020/12/07",
        "description": "一般在仓库的 Setting 中，开启 Github Pages 会生成一个 `xxx.github.io/xx/` 的地址，地址有点长，我们可以使用自定义域名，这里我将 vue-chart 这个仓库设置成了自定义域名 vuechart.zuo11.com。然后，我们需要把自定义的域名解析到 github.com 地址。可以使用 ping github.com 来获取它的服务器 IP。",
        "keywords": "github pages https",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"docsify嵌入vue-echarts组件无法显示图表的问题\">docsify嵌入vue echarts组件无法显示图表的问题</h1>\n<p>在使用 docsify 自带的 vue 功能加载 echarts 相关的 vue 组件时，图表都无法正常显示。后来打印 log 发现，<strong>最终渲染到页面的 echarts div并不是 vue 初始化之后，进行绘制的 div，而是一个拷贝后的副本，所以图片显示不出来。</strong> 需要使用 vuep 插件才行。实例参考 <a href=\"https://vuechart.zuo11.com\">https://vuechart.zuo11.com</a> ，效果如下图:</p>\n<p><img src=\"../../../images/blog/vue/z_chart_doc.png\" alt=\"z_chart_doc.png\"></p>\n<p>对应的 markdown 文件内容如下</p>\n<pre><code class=\"language-markdown\">### z-chart\nz-chart组件是基于echarts的组件，只需要设置父容器的宽高，再设置 options 值即可。\n&lt;!-- markdown文档里插入vuep代码 --&gt;\n\n&lt;vuep template=&quot;#basicBar&quot;&gt;&lt;/vuep&gt;\n&lt;script v-pre type=&quot;text/x-template&quot; id=&quot;basicBar&quot;&gt;\n&lt;template&gt;\n  &lt;div style=&quot;width:100%; height:100%;&quot;&gt;\n    &lt;z-chart :options=&quot;chartData&quot; /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n module.exports = {\n    created () {\n      this.chartData = {\n          title: {\n            text: &quot;ECharts 入门示例&quot;\n          },\n          tooltip: {},\n          xAxis: {\n            data: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;]\n          },\n          yAxis: {},\n          series: [\n            {\n              name: &quot;销量&quot;,\n              type: &quot;bar&quot;,\n              data: [5, 20, 36, 10, 10, 20]\n            }\n          ]\n        }\n    }\n  }\n&lt;/script&gt;</code></pre>\n<p>注意在 index.html 里面需要引入 vuep，以及其他你需要的组件</p>\n<pre><code class=\"language-html\">&lt;script src=&quot;//cdn.jsdelivr.net/npm/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;//unpkg.com/vuep/dist/vuep.min.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/echarts/4.8.0/echarts-en.common.min.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;https://unpkg.com/@guoqzuo/vue-chart@latest/lib/vue-chart.umd.min.js&quot;&gt;&lt;/script&gt;</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "docsify嵌入vue echarts组件无法显示图表的问题"
        }
      ],
      "config": {
        "source": "docsify嵌入vue echarts组件无法显示图表的问题.md",
        "staticFileName": "dosify_vue_echarts.html",
        "author": "guoqzuo",
        "createDate": "2020/12/07",
        "description": "在使用 docsify 自带的 vue 功能加载 echarts 相关的 vue 组件时，图表都无法正常显示。后来打印 log 发现，最终渲染到页面的 echarts div并不是 vue 初始化之后，进行绘制的 div，而是一个拷贝后的副本，所以图片显示不出来。 需要使用 vuep 插件才行。实例参考 https://vuechart.zuo11.com，效果如下图:",
        "keywords": "docsify echarts vue组件无法正常显示",
        "category": "Vue",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"vscode配置了自动fix突然失效了，或者一直生效不了，怎么看对应的log\">vscode配置了自动fix突然失效了，或者一直生效不了，怎么看对应的log</h1>\n<p>你是否会遇到下面的问题：在 vscode 里面安装了 eslint 插件后，正确设置了保存后自动 fix 参数，但没有生效。或者之前是生效的，忽然就不生效了。</p>\n<p>只要你的配置是没有问题的，那就是插件依赖的包加载异常了，一般都重启 vscode 一次或多次就 Ok 了。我们可以通过下面两个步骤，查看 eslint 插件对应的 log。</p>\n<ol>\n<li>点击 vscode 右下角的错误信息、警告信息图标，看是信息里是否有 eslint 相关报错</li>\n<li>点击 输出 - 选择 ESLint 就可以看 ESLint 相关 log 了。</li>\n</ol>\n<p>下图是 ESLint 正常加载的 log</p>\n<p><img src=\"../../../images/blog/devtools/vscode_eslint_log.png\" alt=\"vscode_eslint_log.png\"></p>\n<p>下图是 eslint 失效后，查看 输出 - ESLint log 报的错误。提示 eslint-plugin-vue 找不到，一般就是 vscode 内部加载失败了。将 vscode 完全退出，再打开，或者将项目单独用一个新窗口打开就又正常了。</p>\n<p><img src=\"../../../images/blog/devtools/vscode_eslint_log_2.png\" alt=\"vscode_eslint_log_2.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vscode配置了自动fix突然失效了，或者一直生效不了，怎么看对应的log"
        }
      ],
      "config": {
        "source": "vscode配置了自动fix突然失效了，或者一直生效不了，怎么看对应的log.md",
        "staticFileName": "vscode_eslint_log.html",
        "author": "guoqzuo",
        "createDate": "2020/12/07",
        "description": "你是否会遇到下面的问题：在 vscode 里面安装了 eslint 插件后，正确设置了保存后自动 fix 参数，但没有生效。或者之前是生效的。忽然就不生效了。只要你的配置是没有问题的，那就是插件以来的包加载异常了，一般都重启几次就Ok了。那怎么看 eslint 对应的log呢？可以分下面两步 1. 点击 vscode 右下角的错误信息、警告信息图标，看是信息里是否有 eslint 相关报 2. 点击 输出 - 选择 ESLint 就可以看 ESLint 相关 log 了。",
        "keywords": "vscode eslit log",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"两种方法解决error-cannot-find-module-webpack-clibinconfig-yargs\">两种方法解决Error: Cannot find module &#39;webpack-cli/bin/config-yargs&#39;</h1>\n<p>在运行 webpack-dev-server 这个命令时，如果出现了 Error: Cannot find module &#39;webpack-cli/bin/config-yargs&#39; 这个错误，是因为默认情况下 webpack-dev-server 执行依赖 webpack-cli 包目录下的 bin/config-yargs，但 webpack-cli 4.1.0 的版本，做了一些调整，删除了这个文件，导致了这个错误。</p>\n<p><img src=\"../../../images/blog/node/config-yargs_error.png\" alt=\"config-yargs_error.png\"></p>\n<pre><code class=\"language-json\">&quot;webpack&quot;: &quot;^5.1.3&quot;,\n&quot;webpack-cli&quot;: &quot;^4.1.0&quot;,\n&quot;webpack-dev-server&quot;: &quot;^3.11.0&quot;</code></pre>\n<p>有两种解决方法</p>\n<ol>\n<li>将 webpack-cli 降级到 3.x版本, &quot;webpack-cli&quot;: &quot;^ 3.3.12&quot;</li>\n<li>使用 webpack 5.x 中用于替代 webpack-dev-server 命令的 webpack serve 命令。其实它内部还是使用的 webpack-dev-server 这个包</li>\n</ol>\n<pre><code class=\"language-js\">// package.json scripts\n&quot;dev:server&quot;: &quot;webpack serve --config webpack.dev.js&quot;</code></pre>\n<p>参考：<a href=\"https://github.com/webpack/webpack-cli/issues/1948\">Error: Cannot find module &#39;webpack-cli/bin/config-yargs&#39; · Issue #1948 · webpack/webpack-cli</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "两种方法解决Error: Cannot find module 'webpack-cli/bin/config-yargs'"
        }
      ],
      "config": {
        "source": "两种方法解决Error: Cannot find module 'webpack-cli-bin-config-yargs'.md",
        "staticFileName": "webpack_dev_server_err.html",
        "author": "guoqzuo",
        "createDate": "2020/12/07",
        "description": "两种方法解决Error: Cannot find module 'webpack-cli/bin/config-yargs', 在运行 webpack-dev-server 这个命令时，如果出现了 Error: Cannot find module 'webpack-cli/bin/config-yargs' 这个错误，是因为默认情况下 webpack-dev-server 执行依赖 webpack-cli 包目录下的 bin/config-yargs，但 webpack-cli 4.1.0 的版本，做了一些调整，删除了这个文件，导致了这个错误。",
        "keywords": "Error: Cannot find module 'webpack-cli/bin/config-yargs'",
        "category": "前端工程化",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"consolelog-打印带样式的文字、图片\">console.log 打印带样式的文字、图片</h1>\n<p>console.log 的第一个参数中，如果有 &#39;%c&#39;，表示设置样式，会将第二个参数的 css 样式字符串应用到第一个参数的内容中</p>\n<pre><code class=\"language-js\">console.log(&#39;%c文字&#39;, &#39;css样式&#39;)</code></pre>\n<p>这样可以打印绿色的文字</p>\n<pre><code class=\"language-js\">console.log(&#39;%cSuccess!&#39;, &#39;color: green&#39;)</code></pre>\n<p><img src=\"../../../images/blog/js/console_color.png\" alt=\"console_color.png\"></p>\n<p>不仅可以设置文字颜色，还可以通过设置 background-color 在控制台显示图片</p>\n<pre><code class=\"language-js\">if (console) {\n  console.clear();\n  console.log(&quot;%c &quot;, &quot;padding:112px 150px;background:url(&#39;https://images.cnblogs.com/cnblogs_com/enumx/1647344/o_200214113324console.gif&#39;) no-repeat;&quot;);\n  console.log(&#39;%cWelcome&#39;, &#39;color: #0000ff;font-size: 20px;font-weight: bold;&#39;);\n}</code></pre>\n<p>效果如下</p>\n<p><img src=\"../../../images/blog/js/console_img.gif\" alt=\"console_img.gif\"></p>\n<p>参考：<a href=\"https://www.cnblogs.com/enumx/p/12308528.html\">console.log输出字体颜色 - enumx - 博客园</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "console.log 打印带样式的文字、图片"
        }
      ],
      "config": {
        "source": "console.log 打印带样式的文字、图片.md",
        "staticFileName": "console_style_img.html",
        "author": "guoqzuo",
        "createDate": "2020/12/07",
        "description": "console.log 的第一个参数中，如果有 '%c'，表示设置样式，会将第二个参数的 css 样式字符串应用到第一个参数的内容中 console.log('%c文字', 'css样式') 这样可以打印绿色的文字 console.log('%cSuccess!', 'color: green')，不仅可以设置文字颜色，还可以通过设置 background-color 在控制台显示图片",
        "keywords": "console.log打印样式文字,console.log打印图片",
        "category": "JavaScript",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"js-判断两个日期是否是同一周，带单元测试\">JS 判断两个日期是否是同一周，带单元测试</h1>\n<p>给定两个日期，怎么判断他们是同一周呢？核心是 <strong>所有时间都是从 1970年1月1日(周4) 开始，计算出当前时间距离该日期的天数，再用 (天数 + 4)/7 就是周数，如果相同则是同一周</strong>，这里会有一个特殊情况，就是周日的时候，需要特殊处理。判断时只需要日期，不要输入时间，默认都是以 &#39;08:00:00&#39; 为准。</p>\n<pre><code class=\"language-js\">/**\n * @description 判断两个时间是否是同一周\n * 所有时间都是从 1970年1月1日(周4) 开始，(天数 + 4)/7 就是周数，如果相同则是同一周\n * 特殊情况：周日会是整数，如果直接取整，周日会和下周一是同一天\n * (+new Date(&#39;1970-01-01&#39;) / oneDay) + 4 / 7  // 周四 = 0.57\n * (+new Date(&#39;1970-01-04&#39;) / oneDay) + 4 / 7  // 周日 = 1\n * (+new Date(&#39;1970-01-05&#39;) / oneDay) + 4 / 7  // 周一 = 1.14\n * @params { Stirng } timeA &#39;1970-01-03&#39;\n * @params { Stirng } timeB &#39;1970-01-22&#39;\n */\nfunction isSameWeek(timeA, timeB) {\n  let weekIndexA = getWeekIndex(timeA)\n  let weekIndexB = getWeekIndex(timeB)\n  let tempArr = [weekIndexA, weekIndexB].sort((a, b) =&gt; a - b)\n  // 如果有周日，间隔 &lt; 1，则是 [1.9, 2] 或 [1, 1.14]，\n  // 较大的数为整数则是同一周。间隔 &gt;=1 则不是同一周\n  if (tempArr.some(item =&gt; Number.isInteger(item))) {\n    return tempArr[1] - tempArr[0] &lt; 1 ? Number.isInteger(tempArr[1]) : false\n  } else {\n    return parseInt(weekIndexA) === parseInt(weekIndexB)\n  }\n  // 获取周数\n  function getWeekIndex(time) {\n    let oneDayTime = 24 * 3600 * 1000\n    let dayCount = time.getTime() / oneDayTime\n    let weekCount = (dayCount + 4) / 7\n    return weekCount\n  }\n}</code></pre>\n<p>单元测试</p>\n<pre><code class=\"language-js\">// isSameWeek 单元测试\nfunction isSameWeekTest() {\n  let list = [\n    { a: &#39;1970-01-01&#39;, b: &#39;1970-01-04&#39;, result: true },\n    { a: &#39;1970-01-04&#39;, b: &#39;1970-01-05&#39;, result: false },\n    { a: &#39;1970-01-12&#39;, b: &#39;1970-01-11&#39;, result: false },\n    { a: &#39;1970-01-22&#39;, b: &#39;1970-01-23&#39;, result: true },\n  ]\n  list.forEach(item =&gt; {\n    let res = isSameWeek(new Date(item.a), new Date(item.b)) === item.result\n    console.log(\n      `%c${res ? &#39;PASS&#39; : &#39;FAIL&#39;} &#39;${item.a}&#39;,&#39;${item.b}&#39;,${item.result}`,\n      `color: ${res ? &#39;green&#39; : &#39;red&#39;}`\n    )\n  })\n}\n// Run\nisSameWeekTest()</code></pre>\n<p>运行效果:</p>\n<p><img src=\"../../../images/blog/js/is_same_week.png\" alt=\"is_same_week.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JS 判断两个日期是否是同一周，带单元测试"
        }
      ],
      "config": {
        "source": "JS 判断两个日期是否是同一周，带单元测试.md",
        "staticFileName": "js_same_week.html",
        "author": "guoqzuo",
        "createDate": "2020/12/07",
        "description": "给定两个日期，怎么判断他们是同一周呢？核心是 **所有时间都是从 1970年1月1日(周4) 开始，计算出当前时间距离该日期的天数，再用 (天数 + 4)/7 就是周数，如果相同则是同一周**，这里会有一个特殊情况，就是周日的时候，需要特殊处理。判断时只需要日期，不要输入时间，默认都是以 '08:00:00' 为准。",
        "keywords": "判断两个时间是否是同一周,判断两个日期是否是同一周",
        "category": "JavaScript",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"js-使用-localecompare-函数对中文进行首字母排序\">JS 使用 localeCompare 函数对中文进行首字母排序</h1>\n<blockquote>\n<p>tag: js中文按首字母排序, 前端中文按首字母排序,前端中文排序</p>\n</blockquote>\n<p>String.prototype.localeCompare(compareString[, locales[, options]]) 该方法用于对字符串进行排序。第二个参数 locales 可以指定语言，中文排序传 &#39;ch&#39; 即可。它的返回值为 -1, 1, 0 ，与 sort 自定义排序的返回值基本一致。来看一个例子</p>\n<pre><code class=\"language-js\">[&#39;中文zw&#39;, &#39;啊啊啊aaa&#39;, &#39;猜猜猜ccc&#39;].sort((a, b) =&gt; a.localeCompare(b, &#39;ch&#39;))\n//  [&quot;啊啊啊aaa&quot;, &quot;猜猜猜ccc&quot;, &quot;中文zw&quot;]</code></pre>\n<p><img src=\"../../../images/blog/js/sort_ch.png\" alt=\"sort_ch.png\"></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\">String.prototype.localeCompare() | MDN</a></li>\n<li><a href=\"https://blog.csdn.net/stone10086/article/details/83752227\">js中文按首字母排序</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JS 使用 localeCompare 函数对中文进行首字母排序"
        }
      ],
      "config": {
        "source": "JS 使用 localeCompare 函数对中文进行首字母排序.md",
        "staticFileName": "js_chinese_sort.html",
        "author": "guoqzuo",
        "createDate": "2020/12/07",
        "description": "String.prototype.localeCompare(compareString[, locales[, options]]) 该方法用于对字符串进行排序。第二个参数 locales 可以指定语言，中文排序传 'ch' 即可。它的返回值为 -1, 1, 0 ，与 sort 自定义排序的返回值基本一致。来看一个例子",
        "keywords": "js中文按首字母排序,前端中文按首字母排序,前端中文排序",
        "category": "JavaScript",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"使用vuepress生成静态网站并部署到github-pages\">使用VuePress生成静态网站并部署到Github Pages</h1>\n<p><a href=\"https://www.vuepress.cn/guide/#%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84\">VuePress</a> 是一个静态网站生成器，诞生初衷是为了支持 Vue 及其子项目的文档需求。目前 Vue 相关文档都是由 vuepress 搭建。相比其他静态站点生成工具，Docsify 是运行时驱动，通过 JS 加载内容，对 SEO 不够友好。VuePress 类似于 Hexo，主要区别是 VuePress 是由 Vue 驱动的。</p>\n<p>VuePress 的比较好的地方：</p>\n<ol>\n<li>丰富的 Markdown 扩展、主题风格优雅</li>\n<li>可以使用插件支持 PWA</li>\n<li>支持 vue 组件，SEO 友好</li>\n</ol>\n<p>现在以 <code>zuoxiaobai/fenote</code> Github 仓库为例，为该仓库搭建一个官网</p>\n<p>核心目录结构如下，完整目录结构参考 <a href=\"https://www.vuepress.cn/guide/directory-structure.html#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\">VuePress 目录结构</a></p>\n<pre><code class=\"language-bash\">├── docs  # docs 是文档项目名称，也可以自己命名 \n│   ├── .vuepress # .vuepress 配置、构件生成目录\n│   ├── README.md # 默认的首页\n│   ├── 其他markdown目录及文档\n└── package.json</code></pre>\n<p>它的本质就是，先按照指定的目录格式，写好 Markdown 及配置。然后使用 vuepress dev docs 命令生成静态站点，生成目录默认为 docs/.vuepress/dist。另外它还提供了开发服务器，运行 vuepress dev docs 可以实时看页面效果。</p>\n<p>由于需要使用 vuepress 命令，我们为了方便后期维护迭代，一般不推荐全局安装 vuepress。在项目内安装即可。如果项目根目录没有 package.json，那就需要自己创建一个了。</p>\n<pre><code class=\"language-bash\"># 初始化一个 package.json，如果这个文件存在，可跳过\nnpm init   \n# 安装 vuepress 开发依赖\nnpm install vuepress -D # --save-dev</code></pre>\n<p>在 package.json 里面添加下面两条命令的快捷方式，这样就可以使用 npm run docs:dev，以及 npm run docs:build 来运行或构件静态站点了。</p>\n<pre><code class=\"language-js\">&quot;scripts&quot;: {\n  &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,\n  &quot;docs:build&quot;: &quot;vuepress build docs&quot;\n},</code></pre>\n<p>下面按照上面的目录结构，把 docs、.vuepress文件夹，以及 README.md 创建好，REAMEME.md 写一个 hello vuepress。运行 npm run docs:dev 它默认会在本地开启 8080 端口服务，访问效果如下图</p>\n<p><img src=\"../../../images/blog/vue/vuepress_1.png\" alt=\"vuepress_1.png\"></p>\n<p>可以看到标题、右上角导航栏、左侧菜单都没有出来。这就需要在 .vuepress/confing.js 写对应的配置了。你需要关系 4 点：</p>\n<ol>\n<li>title 用于配置左上角标题</li>\n<li>themeConfig.sidebar 用于配置右上角的导航栏</li>\n<li>themeConfig.nav 用于配置左侧菜单</li>\n<li>首页默认是 docs/README.md，<code>/</code> 表示 docs 目录，比如：<code>/a.md</code> 表示 <code>dosc/a.md</code></li>\n</ol>\n<pre><code class=\"language-js\">// .vuepress/config.js\nmodule.exports = {\n  // base: &#39;/fenote/&#39;,\n  title: &#39;左小白的前端笔记&#39;,\n  description: &#39;左小白的前端笔记，用于记录、完善个人前端知识体系结构&#39;,\n  themeConfig: {\n    sidebar: [\n      {\n        title: &#39;指南&#39;,\n        children: [\n          &#39;/&#39;,\n          &#39;/a.md&#39;,\n          &#39;/b.md&#39;\n        ]\n      }\n    ],\n    nav: [\n      { text: &#39;指南&#39;, link: &#39;/&#39; },\n      { text: &#39;配置&#39;, link: &#39;/config.md&#39; },\n      { text: &#39;Github&#39;, link: &#39;https://www.github.com/zuoxiaobai/fenote&#39; }\n    ]\n  }\n}</code></pre>\n<p>我们按照上面的配置文件写好后，在 docs 目录下创建 a.md，b.md，a.md 如下</p>\n<pre><code class=\"language-markdown\"># a文件\n\na.md</code></pre>\n<p>由于 npm run build:dev 后，它支持类似 HMR 热模块加载的功能，修改后，会自动重新构建。根据上面的配置好后，效果如下</p>\n<p><img src=\"../../../images/blog/vue/vuepress_2.png\" alt=\"vuepress_2.png\"></p>\n<p>这样我们就可以根据自己的需要，规划顶部导航以及左侧菜单了。更多配置、markdown扩展语法参见：<a href=\"https://www.vuepress.cn/guide/basic-config.html#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\">基本配置 | VuePress</a></p>\n<p>这样写好后，只能本地运行，怎么部署到 Github Pages 呢？VuePress官网提供一个部署脚本，可以放到项目根目录 deploy.sh</p>\n<pre><code class=\"language-bash\">#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run docs:build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# 如果是发布到自定义域名\n# echo &#39;www.example.com&#39; &gt; CNAME\n\n# 在新生成的目录下初始化 .git，并 add 所有文件，提交到该目录下项目的本地master分支(默认)\ngit init\ngit add -A\ngit commit -m &#39;deploy&#39;\n\n# 如果发布到 https://&lt;USERNAME&gt;.github.io\n# git push -f git@github.com:&lt;USERNAME&gt;/&lt;USERNAME&gt;.github.io.git master\n\n# 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;\n# git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pages\n# zuoxiaobai/fenote 对应的配置如下，将doscs/.vuepress/dist 目录下的 master 分支 push 到 fenote 远程远程仓库的 gh-pages 分支\ngit push -f git@github.com:zuoxiaobai/fenote.git master:gh-pages\n\ncd -</code></pre>\n<p>在 mac 下，新建的 deploy.sh 默认没有可执行权限，需要 <code>chmod +x deploy.sh</code>，这样就可以 ./deploy.sh 直接部署了。</p>\n<p>注意：如果发布到 <code>https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;</code>，且没有使用自定义域名。则需要修改 config.js 的 base 配置为对应的仓库名</p>\n<pre><code class=\"language-js\">module.exports = {\n  base: &#39;/fenote/&#39;, \n  title: &#39;左小白的前端笔记&#39;,\n  // ...\n}</code></pre>\n<p>运行 ./deploy.sh，部署成功后，可以通过 <code>https://zuoxiaobai.github.io/fenote/</code> 来访问了，如下图</p>\n<p><img src=\"../../../images/blog/vue/vuepress_3.png\" alt=\"vuepress_3.png\"></p>\n<p><strong>注意：目前由于部署到了 <code>fe.zuo11.com</code> 二级域名上，<code>github.io</code> 的链接已无法访问</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "使用VuePress生成静态网站并部署到Github Pages"
        }
      ],
      "config": {
        "source": "使用 VuePress 生成静态网站并部署到 Github Pages.md",
        "staticFileName": "vuepress.html",
        "author": "guoqzuo",
        "createDate": "2020/12/15",
        "description": "VuePress 是一个静态网站生成器，诞生初衷是为了支持 Vue 及其子项目的文档需求。目前 Vue 相关文档都是由 vuepress 搭建。相比其他静态站点生成工具，Docsify 是运行时驱动，通过 JS 加载内容，对 SEO 不够友好。VuePress 类似于 Hexo，主要区别是 VuePress 是由 Vue 驱动。",
        "keywords": "VuePress,VuePress 创建网站,vuepress 使用",
        "category": "Vue",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"vuepress-复选框、任务列表不生效怎么处理\">VuePress 复选框、任务列表不生效怎么处理</h1>\n<p>在写 markdown 笔记时，复选框、任务列表（task list）功能在本地 Typora 是生效的，但在 VuePress 中无法正常显示。于是在 Github 对应的 issue 里面搜索 Task lists，找到了解决方法：需要安装一个 markdown 插件 <code>markdown-it-task-lists</code></p>\n<pre><code class=\"language-markdown\">- [x] 已完成的计划\n- [ ] 待完成 1\n- [ ] 待完成 2\n- [x] 已完成的计划\n- [ ] 待完成 1\n- [ ] 待完成 2</code></pre>\n<p>插件安装</p>\n<pre><code class=\"language-bash\">npm install markdown-it-task-lists -D</code></pre>\n<p>修改配置</p>\n<pre><code class=\"language-js\">// config.js\nmodule.exports = {\n  markdown: {\n    plugins: [&#39;task-lists&#39;]\n  }\n}</code></pre>\n<p>完全退出 dev，再重新开启服务后，就正常了，对比图如下：</p>\n<p><img src=\"../../../images/blog/vue/vuepress_tasklist.png\" alt=\"vuepress_tasklist.png\"></p>\n<p>参考: <a href=\"https://github.com/vuejs/vuepress/issues/2364\">怎么实现复选框功能 · Issue #2364 · vuejs/vuepress</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "VuePress 复选框、任务列表不生效怎么处理"
        }
      ],
      "config": {
        "source": "VuePress 复选框、任务列表不生效怎么处理.md",
        "staticFileName": "vuepress_tasklist.html",
        "author": "guoqzuo",
        "createDate": "2020/12/15",
        "description": "在写 markdown 笔记时，复选框、任务列表（task list）功能在本地 Typora 是生效的，但在 VuePress 中无法正常显示。于是在 Github 对应的 issue 里面搜索 Task lists，找到了解决方法：需要安装一个 markdown 插件 `markdown-it-task-lists`",
        "keywords": "VuePress复选框显示不正常,VuePress任务列表,VuePress Task list",
        "category": "Vue",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"外部链接-a-标签为什么要加-noreferrer-与-noopener-？\">外部链接 a 标签为什么要加 noreferrer 与 noopener ？</h1>\n<p>一般页面的外部链接 a 标签都会加上 <code>ref=&quot;noreferrer noopener&quot;</code>，这样可以避免一些安全问题，下面通过几个问题来具体看看</p>\n<ol>\n<li>a 标签加上 noreferrer 和 noopener 后会有什么效果？</li>\n<li>Referer 是什么？有什么应用场景?</li>\n<li>window.opener 可以做什么？</li>\n</ol>\n<p><img src=\"../../../images/blog/js/noreferer_1.png\" alt=\"noreferer_1.png\"></p>\n<h2 id=\"a-标签加上-noreferrer-和-noopener-后会有什么效果？\">a 标签加上 noreferrer 和 noopener 后会有什么效果？</h2>\n<p>以 Github 上 less.js 仓库设置的网站链接为例，如上图。加了这两个参数后点击链接，该页面打开后</p>\n<ul>\n<li>请求头（Request Headers）部分的 Referer 和直接访问的 Referer 一致，都为空，不会携带来源信息。</li>\n<li>window.opener 和直接访问该网站一致，无法获取来源网站信息，无法操作来源网站的跳转等</li>\n</ul>\n<h2 id=\"请求头-referer-的作用是什么？\">请求头 Referer 的作用是什么？</h2>\n<p>一般网页在加载html、js、css、图片等静态资源发送请求时，<strong>请求头部分会有一个 Referer 字段，用于标记请求来源</strong>。referer 单词存在拼写错误，本意是打算使用 referrer，写错了。后来为了兼容，将错就错，还是保留了错误的拼写方式。</p>\n<p>Referer可以标记请求来源，有以下几个应用场景</p>\n<ul>\n<li><strong>用于统计分析中页面来源</strong>，可以知道用户是从哪种方式进入网站的。搜索引擎一般不会开启 noreferrer，比如百度统计可以知道你是通过哪个关键字进入的页面。</li>\n</ul>\n<p><img src=\"../../../images/blog/js/noreferer_2.png\" alt=\"noreferer_2.png\"></p>\n<ul>\n<li><p><strong>用于防盗链</strong>，防止网页静态资源被其他站点直接引用，如淘宝店铺图片、CDN图片链接、文件、视频链接等。一般会设置 referer 白名单，仅允许白名单内的 Referer 访问，否则禁止访问。减少服务器负载或不必要的 CDN 流量花费。</p>\n</li>\n<li><p><strong>用于鉴权</strong>，比如页面在集成评论系统、Google AdSense等第三方功能时，会校验站点与ID是否匹配，如果不匹配会提示 403。防止其他网站引入对应的代码后，导致数据错乱。我们在处理接口请求时，也可以对 Referer 值进行判断，禁止某些来源访问接口。</p>\n</li>\n</ul>\n<h2 id=\"windowopener-可以做什么？\">window.opener 可以做什么？</h2>\n<p>window.opener 可以拿到来源网站的 window 对象，虽然一般访问 dom 等有跨域限制，但 window.opener.location.href 可以直接重定向源网站，使来源站点发生变化。使用 noopener 可以避免一些安全风险。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://cloud.tencent.com/developer/article/1555507\">你了解Referer吗 - 云+社区 - 腾讯云</a></li>\n<li><a href=\"https://help.aliyun.com/document_detail/31869.html?spm=5176.8466010.referer.1.1e611450esasVK\">防盗链_访问控制_数据安全_开发指南_对象存储 OSS-阿里云</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "外部链接 a 标签为什么要加 noreferrer 与 noopener ？",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "a 标签加上 noreferrer 和 noopener 后会有什么效果？"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "请求头 Referer 的作用是什么？"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "window.opener 可以做什么？"
            }
          ]
        }
      ],
      "config": {
        "source": "外部链接 a 标签为什么要加 noreferer 与 noopener ？.md",
        "staticFileName": "a_noreferrer.html",
        "author": "guoqzuo",
        "createDate": "2020/12/15",
        "description": "一般页面的外部链接 a 标签都会加上 ref='noreferrer noopener'，这样可以避免一些安全问题，下面通过几个问题来具体看看 1. a 标签加上 noreferrer 和 noopener 后会有什么效果？2. Referer 是什么？有什么应用场景? 3. window.opener 可以做什么？",
        "keywords": "noreferrer和noopener,noreferrer,noopener",
        "category": "http与https",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"防盗链时需要注意搜索引擎-referer，百度和-google-搜索内容跳转链接之间的区别\">防盗链时需要注意搜索引擎 Referer，百度和 Google 搜索内容跳转链接之间的区别</h1>\n<p>一般搜索引擎为了方便网页做来源分析，不会使用 noreferer，因此从搜索引擎进入页面时，会携带对应的 Referer。当首页 index.html 也放在 CDN 的情况时，做防盗链 Referer 白名单时，要记得放开搜索引擎的相关 Referer。下面分两个部分介绍搜索引擎跳转链接的处理</p>\n<ol>\n<li>百度搜索结果链接的跳转方式</li>\n<li>Google搜索结构链接的跳转方式</li>\n</ol>\n<p><img src=\"../../../images/blog/web/search_1.png\" alt=\"search_1.png\"></p>\n<h2 id=\"百度搜索结果链接的跳转方式\">百度搜索结果链接的跳转方式</h2>\n<p>如上图所示，百度搜索结果列表里的链接，指向的任然是 baidu.com 的域名，访问这个链接它会做一个重定向。我们可以使用 <code>curl -v</code> 的方式来查看具体逻辑</p>\n<pre><code class=\"language-bash\">curl -v &#39;https://www.baidu.com/link?url=MKActaa6Ed8aGU2yOX2y9v3ne5xinD6tt_v-PHOZ9STfd8cgtAY0yi-c5FEqiIt-CW9_8db1PBwqnTE7jEdb3K&amp;wd=&amp;eqid=a4d184060000714d000000065f9d3673&#39;</code></pre>\n<p>下面是得到的网页内容</p>\n<p><img src=\"../../../images/blog/web/search_2.png\" alt=\"search_2.png\"></p>\n<p>可以看到如果支持 <code>script</code>，一般默认使用 window.location.replace 重定向到目标链接。如果不支持 <code>script</code>，使用 meta 的方式进行跳转。</p>\n<p>具体排版后，内容如下</p>\n<pre><code class=\"language-js\">&lt;script&gt;\n  try {\n    if (window.opener &amp;&amp; window.opener.bds &amp;&amp; window.opener.bds.pdc &amp;&amp; window.opener.bds.pdc.sendLinkLog) {\n      window.opener.bds.pdc.sendLinkLog();\n    }\n  } catch (e) {\n  };\n  var timeout = 0;\n  if (/bdlksmp/.test(window.location.href)) {\n    var reg = /bdlksmp=([^=&amp;]+)/, matches = window.location.href.match(reg);\n    timeout = matches[1] ? matches[1] : 0\n  };\n  setTimeout(function () {\n    window.location.replace(&quot;https://blog.csdn.net/aexwx/article/details/86775768&quot;)\n  }, timeout);\n  window.opener = null;\n&lt;/script&gt;\n&lt;noscript&gt;\n  &lt;META http-equiv=&quot;refresh&quot; content=&quot;0;URL=&#39;https://blog.csdn.net/aexwx/article/details/86775768&#39;&quot;&gt;\n&lt;/noscript&gt;</code></pre>\n<p>在进入下面后，我们查看 Network 里面的 Referer 会看到来源的百度链接，如下图</p>\n<p><img src=\"../../../images/blog/web/search_3.png\" alt=\"search_3.png\"></p>\n<h2 id=\"google搜索结构链接的跳转方式\">Google搜索结构链接的跳转方式</h2>\n<p>如下图所示 Google 搜索列表是直接链接到目标地址，和百度先跳自己的链接再重定向是不同的。</p>\n<p><img src=\"../../../images/blog/web/search_4.png\" alt=\"search_4.png\"></p>\n<p>这种情况来看进入页面后，其 Referer，可以看到只有 google 的链接没有参数，可能这就是为什么百度统计里面只能看到百度搜索的来源关键字，而看不到 Google 搜索的来源关键字的原因。</p>\n<p><img src=\"../../../images/blog/web/search_5.png\" alt=\"search_5.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "防盗链时需要注意搜索引擎 Referer，百度和 Google 搜索内容跳转链接之间的区别",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "百度搜索结果链接的跳转方式"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Google搜索结构链接的跳转方式"
            }
          ]
        }
      ],
      "config": {
        "source": "防盗链时需要注意搜索引擎 Referer，百度和 Google 搜索内容跳转链接之间的区别.md",
        "staticFileName": "search_referer.html",
        "author": "guoqzuo",
        "createDate": "2020/12/15",
        "description": "一般搜索引擎为了方便网页做来源分析，不会使用 noreferer，因此从搜索引擎进入页面时，会携带对应的 Referer。当首页 index.html 也放在 CDN 的情况时，做防盗链 Referer 白名单时，要记得放开搜索引擎的相关 Referer。下面分两个部分介绍搜索引擎跳转链接的处理 1. 百度搜索结果链接的跳转方式 2. Google搜索结构链接的跳转方式",
        "keywords": "防盗链需要注意搜索引擎,百度和Google搜索跳转链接区别",
        "category": "http与https",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"js数据类型有多少种，有哪些细节需要注意的？\">JS数据类型有多少种，有哪些细节需要注意的？</h1>\n<p>ES3 有 5 种基本数据类型：null、undefined、boolean、number、string；1 种复杂数据类型 object。ES6+ 后面新增了两种基本数据类型：Symbol, Bigint。如果把函数 function 也算作一种数据类型，就是 9 种。</p>\n<p>需要注意的是：</p>\n<ul>\n<li>typeof 数组值为 <code>object</code>，typeof 函数值为 <code>function</code>, typeof null 值为 <code>object</code>，本质上其实有 9 种数据类型。</li>\n<li>new String(&#39;12&#39;) 是字符串对象，不是 string，new Number(1) 是数字对象，不是 number，new Boolean(false) 是对象，不是 boolean</li>\n<li>新增的 Symbol 以及 bigint 都是不能 new 的，没有 constructor 构造函数方法，参考：<a href=\"http://127.0.0.1:3001/blog/2019/12/new_check.html\">Symbol、BigInt不能new，而String、Number可以new，为什么？ - 左小白的技术日常</a></li>\n</ul>\n<p>测试 demo 如下</p>\n<pre><code class=\"language-js\">var a = null,       // null\n    b = undefined, // undefined \n    c = false, // boolean\n    d = 1, // mumber\n    e = &quot;123&quot;, // string\n    f = {}, // object\n    g = Symbol(&quot;3&quot;), // symbol\n    h = BigInt(4), // 4n bigint\n    i = function() {}; // function\n[a, b, c, d, e, f, g, h, i].forEach(item =&gt; console.log(`typeof `, item, `: ${typeof item}`))\n// typeof  null : object\n// typeof  undefined : undefined\n// typeof  false : boolean\n// typeof  1 : number\n// typeof  123 : string\n// typeof  {} : object\n// typeof  Symbol(3) : symbol\n// typeof  4n : bigint\n// typeof  ƒ () {} : function</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JS数据类型有多少种，有哪些细节需要注意的？"
        }
      ],
      "config": {
        "source": "JS 数据类型有多少种，有哪些细节需要注意的？.md",
        "staticFileName": "js_data_type.html",
        "author": "guoqzuo",
        "createDate": "2020/12/15",
        "description": "ES3 有 5 种基本数据类型：null、undefined、boolean、number、string；1 种复杂数据类型 object。ES6+ 后面新增了两种基本数据类型：Symbol, Bigint。如果把函数 function 也算作一种数据类型，就是 9 种。需要注意的是：- typeof 数组值为 `object`，typeof 函数值为 `function`, typeof null 值为 `object`，本质上其实有 9 种数据类型。- new String('12') 是字符串对象，不是 string，new Number(1) 是数字对象，不是 number，new Boolean(false) 是对象，不是 boolean",
        "keywords": "js数据类型有多少种,js数据类型,js data type",
        "category": "JavaScript",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"getelementsbytagname-的结果为什么不可以-foreach-？和-queryselectorall-有什么区别\">getElementsByTagName 的结果为什么不可以 forEach ？和 querySelectorAll 有什么区别</h1>\n<p>在 JS DOM 编程艺术的例子中，看到 <code>document.getElementsByTagName</code> 后使用了 <code>Array.from(xx)</code> 将其结果转为标准数组后再使用 <code>forEach</code>。下面写个例子来验证为什么？</p>\n<pre><code class=\"language-html\"> &lt;nav&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a href=&quot;index.html&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=&quot;about.html&quot;&gt;About&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/nav&gt;\n&lt;script&gt;\n  let nav = document.getElementsByTagName(&#39;nav&#39;)[0]\n  let linkArr = nav.getElementsByTagName(&#39;a&#39;)\n  console.log(linkArr) // HTMLCollection [] =&gt; Object\n  console.log(linkArr[0].__proto__)  // HTMLAnchorElement\n  // HTMLAnchorElement =&gt; HTMLElement =&gt; Element =&gt; Node =&gt; EventTarget =&gt; Object\n  // &lt;nav&gt; HTMLElement\n  // &lt;li&gt; HTMLLIElement \n  console.log(linkArr[0].nodeType, linkArr[0].nodeName) // 1 &quot;A&quot;\n  console.log(linkArr.__proto__) // HTMLCollection [] \n\n  // Uncaught TypeError: linkArr.forEach is not a function\n  linkArr.forEach(item =&gt; console.log(item))\n&lt;/script&gt;</code></pre>\n<h2 id=\"getelementsbytagname返回结果类型\">getElementsByTagName返回结果类型</h2>\n<p>从上面的例子中，我们可以看到 <code>getElementsByTagName</code> 函数返回的数据类型是 <code>HTMLCollection</code>，类数组对象，并没有实现 forEach 方法，但它内部实现了迭代 for...of（Symbol.iterator）方法，因此可以使用 for、for...of 来遍历</p>\n<p><img src=\"../../../images/blog/js/getElementsByTagName_1.png\" alt=\"getElementsByTagName_1.png\"></p>\n<p>我们换个思路，使用 <code>Array.prototype.forEach.call</code> 来调用试试</p>\n<pre><code class=\"language-js\">// forEach 基本用法\n[1,2,3].forEach((item, index, array) =&gt; console.log(item, index, array))\n\n// 使用 prototype.forEach 直接运行\nlet cb = (item, index, array) =&gt; console.log(item, index, array)\nArray.prototype.forEach.call(linkArr, cb)</code></pre>\n<p>可以正常执行，执行结果如下图。因此 Array 下的一些方法，我们可以使用 prototype 方式使用</p>\n<p><img src=\"../../../images/blog/js/getElementsByTagName_2.png\" alt=\"getElementsByTagName_2.png\"></p>\n<h2 id=\"queryselectorall返回结果类型\">querySelectorAll返回结果类型</h2>\n<p>同样是获取元素列表，<code>querySelectorAll</code> 返回的结果类型是 <code>NodeList</code></p>\n<pre><code class=\"language-js\">// 和 querySelectorAll 对比\nlet linkArr2 = document.querySelectorAll(&#39;li a&#39;)\nconsole.log(linkArr2) // NodeList [] =&gt; Object\nconsole.log(linkArr2[0].__proto__)  //  HTMLAnchorElement\nconsole.log(linkArr2[0].nodeType, linkArr2[0].nodeName) // 1\nconsole.log(linkArr2.__proto__) // NodeList [] \nlinkArr2.forEach(item =&gt; console.log(item))</code></pre>\n<p>如下图，NodeList 类型实现了 forEach, for...of 等方法，所以可以直接使用 forEach 遍历</p>\n<p><img src=\"../../../images/blog/js/NodeList_1.png\" alt=\"NodeList_1.png\"></p>\n<p>他们的区别：</p>\n<ul>\n<li>getElementsByTagName 返回的结果为 <code>HTMLCollection</code> 类型，而 querySelectorAll 返回的结果为 <code>NodeList</code>。HTMLCollection 并没有实现 forEach，无法使用点语法执行forEach，而 NodeList 是可以的。</li>\n<li>getElementsByTagName 返回的 HTMLCollection 是根据 dom 的变动实时更新的，而 querySelectorAll 不是动态的，它只是一个静态副本。</li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "getElementsByTagName 的结果为什么不可以 forEach ？和 querySelectorAll 有什么区别",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "getElementsByTagName返回结果类型"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "querySelectorAll返回结果类型"
            }
          ]
        }
      ],
      "config": {
        "source": "getElementsByTagName 结果为什么不可以 forEach ？和 querySelectorAll 有什么区别.md",
        "staticFileName": "dom_arr_forEach.html",
        "author": "guoqzuo",
        "createDate": "2020/12/15",
        "description": "在 JS DOM 编程艺术的例子中，看到 `document.getElementsByTagName` 后使用了 `Array.from(xx)` 将其结果转为标准数组后再使用 `forEach`。下面写个例子来验证为什么？从上面的例子中，我们可以看到 `getElementsByTagName` 函数返回的数据类型是 `HTMLCollection`，类数组对象，并没有实现 forEach 方法，但它内部实现了迭代 for...of（Symbol.iterator）方法，因此可以使用 for、for...of 来遍历",
        "keywords": "getElementsByTagName,querySelectorAll",
        "category": "JavaScript",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"promiseall、race-实现，函数作为参数时的简写\">Promise.all、race 实现，函数作为参数时的简写</h1>\n<p>一般函数当参数时，有一种情况可以直接简写，例子如下</p>\n<pre><code class=\"language-js\">func(data =&gt; {\n  console.log(data)\n})</code></pre>\n<p>可以简写为</p>\n<pre><code class=\"language-js\">func(console.log)</code></pre>\n<p>下面来看看在 Promise.all 和 Promise.race 实现中的应用</p>\n<pre><code class=\"language-js\">class MyPromise {\n  static all(array) {\n    return new MyPromise((resolve, reject) =&gt; {\n      let successCount = 0\n      let resultArr = []\n      for (let i = 0; i &lt; array.length; i++) {\n        let promise = MyPromise.resolve(array[i])\n        promise._then((data) =&gt; {\n          successCount++\n          resultArr.push(data)\n          successCount === array.length &amp;&amp; resolve(resultArr)\n        }, (err) =&gt; {\n          reject(err)\n        })\n        // 函数参数 (err) =&gt; { reject(err) } 等价于 reject\n      }\n    })\n  }\n\n  static race(array) {\n    return new MyPromise((resolve, reject) =&gt; {\n      for (let i = 0; i &lt; array.length; i++) {\n        let promise = MyPromise.resolve(array[i])\n        promise._then(resolve, reject)\n        // 函数参数 (err) =&gt; { reject(err) } 等价于 reject\n      }\n    })\n  }\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Promise.all、race 实现，函数作为参数时的简写"
        }
      ],
      "config": {
        "source": "Promise.all、race 实现，函数作为参数时的简写.md",
        "staticFileName": "promise_all_abbr.html",
        "author": "guoqzuo",
        "createDate": "2020/12/15",
        "description": "一般函数当参数时，有一种情况可以直接简写，例子如下 func(data => { console.log(data) })，可以简写为 func(console.log) 下面来看看在 Promise.all 和 Promise.race 实现中的应用",
        "keywords": "Promise.all实现,Promise.race实现,函数参数简写",
        "category": "JavaScript",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"js-事件循环-promisethen-与-settimeout-执行顺序问题\">JS 事件循环, Promise.then 与 setTimeout 执行顺序问题</h1>\n<p>来看一个 demo 的执行顺序</p>\n<pre><code class=\"language-js\">setTimeout(function() {\n  console.log(1);\n}, 0);\nnew Promise(function executor(resolve) {\n  console.log(2);\n  for( var i=0 ; i&lt;10000 ; i++ ) {\n    i === 9999 &amp;&amp; resolve();\n  }\n  console.log(3);\n}).then(function() {\n  console.log(4);\n});\nconsole.log(5);</code></pre>\n<p>执行顺序是：2 3 5 4 1，我们知道 setTimeout 与 Promise.then 的回调都是异步的。setTimeout 的执行函数是先 push 到任务队列的，而 Promise.then 的回调是后面 push 的。为什么 Promise.then 的回调先执行呢？这里涉及到 JS 事件循环中 <strong>宏任务</strong> 与 <strong>微任务</strong>。</p>\n<ul>\n<li>宏任务：同步任务、I/O(比如文件读写等)、setTimeout、setInterval、requestAnimationFrame 等</li>\n<li>微任务：Promise.then/catch/finally、generator、async/await、MutationObserver 等</li>\n</ul>\n<p>某个宏任务执行 ok 后，会先看微任务事件队列里是否有任务，有就执行，然后才是宏任务队列。</p>\n<p>参考：<a href=\"https://www.cnblogs.com/xingguozhiming/p/13276725.html\">js 事件循环消息队列和微任务宏任务</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JS 事件循环, Promise.then 与 setTimeout 执行顺序问题"
        }
      ],
      "config": {
        "source": "JS 事件循环, Promise.then 与 setTimeout 执行顺序问题.md",
        "staticFileName": "js_eventloop.html",
        "author": "guoqzuo",
        "createDate": "2020/12/15",
        "description": "来看一个 demo 的执行顺序，执行顺序是：2 3 5 4 1，我们知道 setTimeout 与 Promise.then 的回调都是异步的。setTimeout 的执行函数是先 push 到任务队列的，而 Promise.then 的回调是后面 push 的。为什么 Promise.then 的回调先执行呢？这里涉及到 JS 事件循环中 **宏任务** 与 **微任务**。- 宏任务：同步任务、I/O(比如文件读写等)、setTimeout、setInterval、requestAnimationFrame 等 - 微任务：Promise.then/catch/finally、generator、async/await、MutationObserver 等。某个宏任务执行 ok 后，会先看微任务事件队列里是否有任务，有就执行，然后才是宏任务队列。",
        "keywords": "宏任务与微任务,JS 事件循环",
        "category": "JavaScript",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"domcontentloaded-与白屏-performance-timing\">DOMContentLoaded 与白屏, performance timing</h1>\n<p>白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素</p>\n<p>首屏时间 = 地址栏输入网址后回车 - 浏览器第一屏渲染完成</p>\n<p>一般页面 <strong>白屏结束</strong> 的时间节点在 head 结束，body 开始执行时。可以通过 <code>window.performance.timing</code> 这个对象来看具体时间。</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;utf-8&quot;&gt;\n  &lt;title&gt;白屏&lt;/title&gt;\n  &lt;script&gt;\n    // 不兼容 performance.timing 的浏览器\n    window.pageStartTime = Date.now()\n  &lt;/script&gt;\n  &lt;!-- 页面 CSS 资源 --&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;xx.css&quot;&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;zz.css&quot;&gt;\n  &lt;script&gt;\n    // 白屏结束时间\n    window.firstPaint = Date.now()\n    // 白屏时间\n    console.log(firstPaint - performance.timing.navigationStart)\n  &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Hello World&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>白屏时间 = firstPaint - performance.timing.navigationStart || pageStartTime</p>\n<p>因此：<strong>在 head 元素里面如果放了非 async 或 defer 的 JS，会增加白屏时间。</strong></p>\n<p>DOMContentLoaded 是页面元素(dom)完成加载并解析，而不用等 css样式、图片和子 frame 完全加载完成时触发。对应 jQuery 的 <code>$(document).ready()</code></p>\n<p>Load 事件是当整个页面加载完成时（包括所有相关资源，例如css样式表和图片）触发，对应 jQuery 里面的 <code>$(document).load()</code></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/z9061/article/details/101454438\">Web 性能优化-首屏和白屏时间</a></li>\n<li><a href=\"http://fe.zuo11.com/daily/2020-10.html#domcontentloaded%E4%B8%8Eload%E6%97%B6%E9%97%B4%E5%85%B7%E4%BD%93%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E9%97%B4\">DOMContentLoaded与Load时间具体指的是什么时间？</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "DOMContentLoaded 与白屏, performance timing"
        }
      ],
      "config": {
        "source": "DOMContentLoaded 与白屏, performance timing.md",
        "staticFileName": "white-screen.html",
        "author": "guoqzuo",
        "createDate": "2020/12/30",
        "description": "白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素，首屏时间 = 地址栏输入网址后回车 - 浏览器第一屏渲染完成。一般页面白屏结束的时间节点在 head 结束，body 开始执行时。可以通过 `window.performance.timing` 这个对象来看具体时间。",
        "keywords": "白屏时间计算,DOMContentLoaded与白屏",
        "category": "JavaScript",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"通过-performancetiming-简单理解浏览器输入-url-到页面显示全过程\">通过 performance.timing 简单理解浏览器输入 url 到页面显示全过程</h1>\n<p>performance.timing 记录了在浏览器中输入 url 到页面显示整个过程中各个关键节点的时间。包括：网页重定向的耗时、检查本地缓存的耗时、DNS查询的耗时、TCP连接的耗时、dom 加载完成的时间、页面 load 的总耗时等。performance.timing 是 PerformanceTiming 对象的实例。下面我们通过了解 performance.timing 各个字段的意思来实现下面图片的功能。</p>\n<p><img src=\"../../../images/blog/js/jianshu_timing.png\" alt=\"jianshu_timing.png\"></p>\n<p>首先我们来看一张非常重要的图，下图是页面打开过程中 performance.timing 各字段所在的位置</p>\n<p><img src=\"../../../images/blog/js/performance.png\" alt=\"performance.png\"></p>\n<p>按照顺序对各个字段的解释：</p>\n<ul>\n<li><code>navigationStart: 1607492537332</code> 同一个浏览器上一个页面卸载结束时的时间戳。如果没有上一个页面的话，那么该值会和 fetchStart 的值相同。</li>\n<li><code>redirectStart: 0</code> 第一个 HTTP 重定向开始的时间戳。如果没有重定向，或者重定向到一个不同源的话，那么该值返回为 0。</li>\n<li><code>redirectEnd: 0</code> 最后一个 HTTP 重定向完成时的时间戳。如果没有重定向，或者重定向到一个不同的源，该值也返回为 0。</li>\n<li><code>fetchStart: 1607492537338</code> 浏览器准备好使用 http 请求的时间(发生在检查本地缓存之前)。</li>\n<li><code>domainLookupStart: 1607492537349</code> DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</li>\n<li><code>domainLookupEnd: 1607492537403</code> DNS 域名查询结束的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</li>\n<li><code>connectStart: 1607492537403</code> HTTP（TCP）开始/重新 建立连接的时间，如果是持久连接，则与 fetchStart 值相等。</li>\n<li><code>secureConnectionStart: 1607492537472</code> HTTPS 连接开始的时间，如果不是安全连接，则值为 0。</li>\n<li><code>connectEnd: 1607492537600</code> HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等。</li>\n<li><code>requestStart: 1607492537601</code> HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存。</li>\n<li><code>responseStart: 1607492537841</code>  HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存。</li>\n<li><code>responseEnd: 1607492537996</code> HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存。</li>\n<li><code>unloadEventStart: 0</code> 前一个网页（和当前页面同域）unload的时间戳，如果没有前一个网页或前一个网页是不同的域的话，那么该值为0.</li>\n<li><code>unloadEventEnd: 0</code> 前一个页面 unload 时间绑定的回掉函数执行完毕的时间戳。</li>\n<li><code>domLoading: 1607492537852</code> 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件。</li>\n<li><code>domInteractive: 1607492538002</code>  完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件，注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源。</li>\n<li><code>domContentLoadedEventStart: 1607492538002</code> DOM 解析完成后，网页内资源加载开始的时间，在 DOMContentLoaded 事件抛出前发生。</li>\n<li><code>domContentLoadedEventEnd: 1607492538002</code> DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）。</li>\n<li><code>domComplete: 1607492544648</code> DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件。</li>\n<li><code>loadEventStart: 1607492544648</code> load 事件发送给文档，也即 load 回调函数开始执行的时间。如果没有绑定load事件，该值为0.</li>\n<li><code>loadEventEnd: 1607492544653</code> load 事件的回调函数执行完毕的时间。如果没有绑定load事件，该值为0.</li>\n</ul>\n<p>结合上面的各字段含义以及页面打开过程图，我们可以实现一个简单的计算页面耗时函数</p>\n<pre><code class=\"language-js\">function getPerfermanceTiming() {\n  let t = performance.timing\n\n  // 重定向结束时间 - 重定向开始时间\n  let redirect = t.redirectEnd - t.redirectStart\n  // DNS 查询开始时间 - fetech start 时间\n  let appCache = t.domainLookupStart - t.fetchStart\n  // DNS 查询结束时间 - DNS 查询开始时间\n  let dns = t.domainLookupEnd - t.domainLookupStart\n  // 完成 TCP 连接握手时间 - TCP 连接开始时间 \n  let tcp = t.connectEnd - t.connectStart\n  // 从请求开始到接收到第一个响应字符的时间 \n  let ttfb = t.responseStart - t.requestStart\n  // 资源下载时间，响应结束时间 - 响应开始时间\n  let contentDL = t.responseEnd - t.responseStart\n  // 从请求开始到响应结束的时间\n  let httpTotal = t.responseEnd - t.requestStart\n  // 从页面开始到 domContentLoadedEventEnd\n  let domContentloaded = t.domContentLoadedEventEnd - t.navigationStart\n  // 从页面开始到 loadEventEnd\n  let loaded = t.loadEventEnd - t.navigationStart\n\n  let result = [\n    { key: &quot;Redirect&quot;, desc: &quot;网页重定向的耗时&quot;, value: redirect }, \n    { key: &quot;AppCache&quot;, desc: &quot;检查本地缓存的耗时&quot;, value: appCache },\n    { key: &quot;DNS&quot;, desc: &quot;DNS查询的耗时&quot;, value: dns },\n    { key: &quot;TCP&quot;, desc: &quot;TCP连接的耗时&quot;, value: tcp },\n    { key: &quot;Waiting(TTFB)&quot;, desc: &quot;从客户端发起请求到接收到响应的时间 / Time To First Byte&quot;, value: ttfb },\n    { key: &quot;Content Download&quot;, desc: &quot;下载服务端返回数据的时间&quot;, value: contentDL },\n    { key: &quot;HTTP Total Time&quot;, desc: &quot;http请求总耗时&quot;, value: httpTotal },\n    { key: &quot;DOMContentLoaded&quot;, desc: &quot;dom加载完成的时间&quot;, value: domContentloaded },\n    { key: &quot;Loaded&quot;, desc: &quot;页面load的总耗时&quot;, value: loaded }\n  ]\n  return result\n}\ngetPerfermanceTiming()</code></pre>\n<p>参考: </p>\n<ul>\n<li><a href=\"https://blog.csdn.net/z9061/article/details/101454438\">Web 性能优化-首屏和白屏时间</a></li>\n<li><a href=\"https://www.jianshu.com/p/1355232d525a\">Performance --- 前端性能监控</a></li>\n<li><a href=\"http://fe.zuo11.com/js/ad3/js-ad3-20.html#%E8%AE%A1%E6%97%B6-api-performace%E6%80%A7%E8%83%BD\">计时 API（Performace性能）- 20. JavaScript API - JS高程4笔记</a></li>\n<li><a href=\"https://www.jianshu.com/p/dd07cca0a48e\">该函数实现是对简书 console 内容的模仿实现</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "通过 performance.timing 简单理解浏览器输入 url 到页面显示全过程"
        }
      ],
      "config": {
        "source": "通过 performance.timing 简单理解浏览器输入 url 到页面显示全过程.md",
        "staticFileName": "performance-timing.html",
        "author": "guoqzuo",
        "createDate": "2020/12/30",
        "description": "performance.timing 记录了在浏览器中输入 url 到页面显示整个过程中各个关键节点的时间。包括：网页重定向的耗时、检查本地缓存的耗时、DNS查询的耗时、TCP连接的耗时、dom 加载完成的时间、页面 load 的总耗时等。performance.timing 是 PerformanceTiming 对象的实例。下面我们通过了解 performance.timing 各个字段的意思来实现下面图片的功能。",
        "keywords": "浏览器输入 url 到页面显示全过程,performance.timing各字段详解",
        "category": "JavaScript",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"字符串原始类型不是对象，为什么可以使用点语法运行方法\">字符串原始类型不是对象，为什么可以使用点语法运行方法</h1>\n<p>理论上，原始值本身不是对象，逻辑上是不能有属性、方法的。那为什么字符串可以使用点语法执行 substring 等方法呢？下面的例子中，第 2 行可以正常执行。主要是 JS 内部在后台进行了一些处理</p>\n<pre><code class=\"language-js\">let s1 = &quot;some text&quot;\nlet s2 = s1.substring(2) // &quot;me text&quot;</code></pre>\n<p>在执行到第 2 行时</p>\n<ol>\n<li>临时创建一个 String 类型的实例 <code>let t = new String(&quot;some text&quot;)</code></li>\n<li>调用实例上的特定方法 <code>s2 = t.substring(2)</code></li>\n<li>销毁实例 <code>t = null</code></li>\n</ol>\n<p>这种行为可以让原始值拥有对象的行为。临时创建的 原始值包装类型（String）实例的声明周期只在执行的那一行。执行完后，就销毁了。下面的例子即可说明这个问题。</p>\n<pre><code class=\"language-js\">let s1 = &quot;some text&quot;\ns1.color = &quot;red&quot;\nconsole.log(s1.color) // undefined</code></pre>\n<p>更多详情参考：《JavaScript高级程序设计》第四版 p113 原始值包装类型。在线笔记 <a href=\"http://fe.zuo11.com/js/ad3/js-ad3-5.html#%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B-%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B\">原始值包装类型(基本包装类型) - 5. 基本引用类型 - JS高程4 | 左小白的前端笔记</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "字符串原始类型不是对象，为什么可以使用点语法运行方法"
        }
      ],
      "config": {
        "source": "字符串原始类型不是对象，为什么可以使用点语法运行方法.md",
        "staticFileName": "string-base.html",
        "author": "guoqzuo",
        "createDate": "2020/12/30",
        "description": "理论上，原始值本身不是对象，逻辑上是不能有属性、方法的。那为什么字符串可以使用点语法执行 substring 等方法呢？下面的例子中，第 2 行可以正常执行。主要是 JS 内部在后台进行了一些处理。在执行到第 2 行时 1. 临时创建一个 String 类型的实例 `let t = new String('some text')` 2. 调用实例上的特定方法 `s2 = t.substring(2)` 3. 销毁实例 `t = null`",
        "keywords": "基本包装类型,原始类型不是对象为什么可以执行方法",
        "category": "JavaScript",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"elementchildnodes-和-elementchildren-有什么区别\">element.childNodes 和 element.children 有什么区别</h1>\n<p>元素的 <strong>childNodes</strong> 和 <strong>children</strong> 属性都是用于获取元素子节点，他们返回值都是类数组对象，且都是活动对象（当节点变更后，值也会动态变更）。但有以下区别：</p>\n<ol>\n<li>childNodes 获取的子节点包含所有节点类型，比如注释节点、文本节点、换行空白符文本节点，而 children 仅包含元素类型的子节点。</li>\n<li>childNodes 类型是 NodeList，children 类型是 HTMLCollection</li>\n</ol>\n<p>有了 childNodes 为什么又出了 children 这个 DOM 专有扩展？children 属性是因为 IE9 之前的版本与其他浏览器在处理空白文本节点上有差异才出现的。参见 《JavaScript 高级程序设计（第 4 版）》第 15 章 DOM 扩展 - 专有扩展 - children 属性 p456</p>\n<pre><code class=\"language-js\">(function() {\n  let testDom = document.createElement(&#39;div&#39;)\n  testDom.innerHTML = `\n    123\n    &lt;!-- sdfsdf --&gt;\n    &lt;span&gt;abc&lt;/span&gt;\n    &lt;div&gt;test&lt;/div&gt;\n  `\n  let { childNodes, children } = testDom\n  console.log(childNodes) // NodeList(7) [text, comment, text, span, text, div, text]\n  console.log(children) // HTMLCollection(2) [span, div]\n\n  // 动态性、再次向节点追加内容，再打印之前获取的值\n  testDom.appendChild(document.createElement(&#39;div&#39;))\n  console.log(childNodes) // NodeList(8) [text, comment, text, span, text, div, text, div]\n  console.log(children) // HTMLCollection(3) [span, div, div]\n})()</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "element.childNodes 和 element.children 有什么区别"
        }
      ],
      "config": {
        "source": "element.childNodes 和 element.children 有什么区别.md",
        "staticFileName": "childNodes-children.html",
        "author": "guoqzuo",
        "createDate": "2020/12/30",
        "description": "元素的 childNodes 和 children 属性都是用于获取元素子节点，他们返回值都是类数组对象，且都是活动对象（当节点变更后，值也会动态变更）。但有以下区别：1. childNodes 获取的子节点包含所有节点类型，比如注释节点、文本节点、换行空白符文本节点，而 children 仅包含元素类型的子节点。2. childNodes 类型是 NodeList，HTMLCollection 类型是 HTMLCollection",
        "keywords": "childNodes与children,childNodes children区别",
        "category": "JavaScript",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"htmlcollection-和-nodelist-有什么区别\">HTMLCollection 和 NodeList 有什么区别</h1>\n<p>在获取 dom 节点结集合时，有的 API 返回的是 HTMLCollection 类型，有的是 NodeList 类型。他们有什么区别呢？下来看看具体的 API</p>\n<p>返回 HTMLCollection 类型的 API</p>\n<ul>\n<li>element.children 获取 element 元素的所有子元素节点</li>\n<li>document.getElementsByTagName(&#39;div&#39;)</li>\n<li>document.getElementsByName(&#39;kk&#39;)</li>\n<li>document.getElementsByClassName(&#39;kk&#39;)</li>\n<li>document.anchors 获取文档中所有带 name 特性的 a 元素，必须要有 name 属性</li>\n<li>document.forms 相当于 document.getElementsByTagName(&#39;form&#39;)</li>\n<li>document.images 相当于 document.getElementsByTageName(&#39;img&#39;)</li>\n<li>document.links 获取所有a元素，相当于 documet.getElmentsByTagName(&#39;a&#39;)</li>\n<li>form.elements 表单 form 元素的所有表单字段元素</li>\n</ul>\n<p>返回 NodeList 类型的 API</p>\n<ul>\n<li>element.childNodes 获取元素所有子节点(包含元素节点、文本节点、注释节点等)</li>\n<li>document.querySelectorAll(&#39;div&#39;)</li>\n</ul>\n<p>HTMLCollection 和 NodeList 的相同点：</p>\n<ol>\n<li>它们都是表示节点集合的类数组对象，都可以是活动对象（实时监听 dom 变化并修改值）</li>\n<li>它们都有 length 属性，都可以通过 item() 和数组下标的方式访问内部元素。都实现了 Symbol.iterator 迭代器方法（可以被 for...of 遍历）</li>\n</ol>\n<p>HTMLCollection 和 NodeList 的不同点：</p>\n<ul>\n<li>HTMLCollection 中的值都是 Element 元素节点类型，NodeList 中的值是 Node 节点类型，可以是 Element 元素节点，也可以是 文本节点、注释节点等</li>\n<li>HTMLCollection 支持但 NodeList 不支持的方法：namedItem() - 通过 name 属性查找元素。NodeList 支持但 HTMLCollection 不支持的方法 keys(), values(), entries(), forEach()</li>\n</ul>\n<p>关于 document.querySelectorAll() 函数的特殊情况，理论上该函数获取的是元素集合，可以使用 HTMLCollection，但为什么使用了 NodeList 呢？来看下面的例子</p>\n<pre><code class=\"language-js\">a = document.querySelectorAll(&#39;div&#39;)\nb = document.getElementsByTagName(&#39;div&#39;)\nconsole.log(a.length, b.length) // 75 75\ndocument.body.appendChild(document.createElement(&#39;div&#39;))\nconsole.log(a.length, b.length) // 75 76\nconsole.log(document.querySelectorAll(&#39;div&#39;).length) // 76\nconsole.log(document.getElementsByTagName(&#39;div&#39;).length) // 76</code></pre>\n<p>上面的例子中 getElementsByTagName 获取的 HTMLCollection 类型的集合是实时的，动态的。而 querySelectorAll 获取的 NodeList 是非实时的，是静态的。</p>\n<p>我的理解是，HTMLCollection 可能不支持创建静态副本。而 NodeList 可以是动态的活动对象，比如 element.childNodes，也可以是静态的，比如 querySelectorAll() 返回值。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://fe.zuo11.com/js/ad3/js-ad3-15.html#queryslectorall\">querySelectorAll() - Selectors API - 15. DOM 扩展 - JS高程4</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006782004\">HTMLCollection与NodeList - Segmentfault</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "HTMLCollection 和 NodeList 有什么区别"
        }
      ],
      "config": {
        "source": "HTMLCollection 和 NodeList 有什么区别.md",
        "staticFileName": "HTMLCollection-NodeList.html",
        "author": "guoqzuo",
        "createDate": "2020/12/30",
        "description": "在获取 dom 节点结集合时，有的 API 返回的是 HTMLCollection 类型，有的是 NodeList 类型。他们有什么区别呢？下来看看具体的 API。HTMLCollection 和 NodeList 的相同点：1. 它们都是表示节点集合的类数组对象，都可以是活动对象（实时监听 dom 变化并修改值） 2. 它们都有 length 属性，都可以通过 item() 和数组下标的方式访问内部元素。都实现了 Symbol.iterator 迭代器方法（可以被 for...of 遍历）",
        "keywords": "HTMLCollection,NodeList,HTMLCollection与NodeList区别",
        "category": "JavaScript",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"使用-hash-滚动页面时，被顶部-fixed-区域遮挡怎么解决\">使用 hash 滚动页面时，被顶部 fixed 区域遮挡怎么解决</h1>\n<p>一般页面 URL 的 hash 值变化后，如果当前页面中存在 id 为该 hash 值的元素，页面会滚动到该区域。下面的例子中，点击跳转到h1，页面会滚动到 h1 元素，元素对齐到顶部。<strong>这里有一个问题，如果顶部导航栏是 fixed 固定的，那使用这种方法滚动时，h1 标题会被导航栏遮挡。</strong></p>\n<pre><code class=\"language-js\">&lt;h1 id=&quot;h1&quot;&gt;一级标题&lt;/h1&gt;\n&lt;a href=&quot;#h2&quot;&gt;跳转到h2&lt;/a&gt;\n// 假设这里有很长的内容，超过一页\n&lt;h2 id=&quot;h2&quot;&gt;二级标题&lt;/h2&gt;\n&lt;a href=&quot;#h1&quot;&gt;跳转到h1&lt;/a&gt;</code></pre>\n<p>之前在写 zuo-blog 时，我的解决方案是：滚动到顶部后，再往下滚动 70 px，这种方法有一个缺点，就是只能是 JS 跳转，如果直接通过 a 标签访问，还是会被遮挡</p>\n<pre><code class=\"language-js\">document.getElementById(id).scrollIntoView(true)\ndocument.documentElement.scrollBy(0, -70)</code></pre>\n<p>后来使用 VuePress 时，发现跳转的时候没有遮挡，于是审查元素，看了下样式。发现使用一个 css 就可以解决这个问题。 <strong>给需要定位到该 id 的元素加一个超过导航栏高度的 padding-top，再加一个保持元素位置的 margin-top，这样使用 hash 滚动到该 id 元素时，就不会有遮挡，会与顶部保持 padding 的距离</strong></p>\n<pre><code class=\"language-css\">h1,h2,h3,h4,h5,h6 {\n  margin-top: -3.1rem;\n  padding-top: 4.6rem;\n  margin-bottom: 0;\n}</code></pre>\n<p>我写了一个测试 demo，可以看对应的效果，完整 demo 参见 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/DebugDemo/%E9%A1%B6%E9%83%A8fix%E9%81%AE%E6%8C%A1hash/index.html\">顶部 fix 遮挡 hash demo | Github</a></p>\n<pre><code class=\"language-html\">&lt;style&gt;\n  body {\n    margin: 0;\n  }\n  .top {\n    position: fixed;\n    height: 60px;\n    width: 100%;;\n    border-bottom: 1px solid #ccc;\n    background-color: #fff;\n  }\n  .main {\n    padding-top: 80px;\n  }\n  /* fix 顶部遮挡的问题 */\n  /* h1,h2 {\n    padding-top: 100px;\n    margin-top: -90px;\n  } */\n&lt;/style&gt;\n&lt;body&gt;\n  &lt;div class=&quot;top&quot;&gt;顶部区域&lt;/div&gt;\n  &lt;div class=&quot;main&quot;&gt;\n    我是主内容区域\n   &lt;h1 id=&quot;h1&quot;&gt;一级标题&lt;/h1&gt;\n   &lt;a href=&quot;#h2&quot;&gt;跳转到h2&lt;/a&gt;\n    &lt;div&gt;\n      &lt;ul&gt;\n        &lt;li&gt;列表a&lt;/li&gt;\n        &lt;!-- 省略多行... --&gt;\n        &lt;li&gt;列表a&lt;/li&gt;\n      &lt;/ul&gt;\n      &lt;h2 id=&quot;h2&quot;&gt;二级标题&lt;/h2&gt;\n      &lt;a href=&quot;#h1&quot;&gt;跳转到h1&lt;/a&gt;\n      &lt;ul&gt;\n        &lt;li&gt;列表a&lt;/li&gt;\n        &lt;!-- 省略多行... --&gt;\n        &lt;li&gt;列表a&lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "使用 hash 滚动页面时，被顶部 fixed 区域遮挡怎么解决"
        }
      ],
      "config": {
        "source": "使用 hash 滚动页面时，被顶部 fixed 区域遮挡怎么解决.md",
        "staticFileName": "hash_scroll_fixed.html",
        "author": "guoqzuo",
        "createDate": "2020/12/30",
        "description": "一般页面 URL 的 hash 值变化后，如果当前页面中存在 id 为该 hash 值的元素，页面会滚动到该区域。下面的例子中，点击跳转到h1，页面会滚动到 h1 元素，元素对齐到顶部。**这里有一个问题，如果顶部导航栏是 fixed 固定的，那使用这种方法滚动时，h1 标题会被导航栏遮挡。**后来使用 VuePress 时，发现跳转的时候没有遮挡，于是审查元素，看了下样式。发现使用一个 css 就可以解决这个问题。 **给需要定位到该 id 的元素加一个超过导航栏高度的 padding-top，再加一个保持元素位置的 margin-top，这样使用 hash 滚动到该 id 元素时，就不会有遮挡，会与顶部保持 padding 的距离**",
        "keywords": "hash滚动被fixed区域遮挡,fixed遮挡a标签滚动怎么解决",
        "category": "CSS",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"前端低代码框架-amis，通过-json-配置生成页面\">前端低代码框架 amis，通过 JSON 配置生成页面</h1>\n<p>什么是低代码开发平台？ (LCDP，Low-Code Development Platform)，是无需编码（0代码）或通过少量代码就可以快速生成应用程序的开发平台。</p>\n<p>对于比较简单的、通用的页面可以自动生成代码。amis 就是这样的一个框架。可以根据 JSON 配置，自动生成页面，而且还支持在线可视化编辑。对于简单、通用、不需要定制化开发的情况，可以直接使用。</p>\n<p><strong>我们主要是学习这种思路，可以参考这种方法做一些类似的封装</strong></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/baidu/amis\">baidu/amis | Github</a></li>\n<li><a href=\"https://github.com/fex-team/amis-editor-demo\">amis 可视化编辑器 | Github</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "前端低代码框架 amis，通过 JSON 配置生成页面"
        }
      ],
      "config": {
        "source": "前端低代码框架 amis，通过 JSON 配置生成页面.md",
        "staticFileName": "low-code-amis.html",
        "author": "guoqzuo",
        "createDate": "2020/12/30",
        "description": "什么是低代码开发平台？ (LCDP，Low-Code Development Platform)，是无需编码（0代码）或通过少量代码就可以快速生成应用程序的开发平台。对于比较简单的、通用的页面可以自动生成代码。amis 就是这样的一个框架。可以根据 JSON 配置，自动生成页面，而且还支持在线可视化编辑。对于简单、通用、不需要定制化开发的情况，可以直接使用。",
        "keywords": "低代码开发平台,amis,根据json生成页面",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"git-修改文件内容后误删了该文件，再使用-git-还原该文件，修改的文件内容丢失怎么办？\">git 修改文件内容后误删了该文件，再使用 git 还原该文件，修改的文件内容丢失怎么办？</h1>\n<p>最近修改某个文件后，还没将改动提交到 git，中途不小心删了该文件。然后想着恢复文件，就使用 git 恢复该文件。这个时候发现未提交的修改内容都丢失了，文件内容是 git 上最近的内容。</p>\n<p>这种情况，理论上 git 是无法还原的。因为没有提交，git 不会记录对应的内容。我们不能总是想着使用 git 怎么恢复，需要换一下思路。<strong>修改的文件删除后，默认会存在废纸篓(回收站)，去里面找即可。</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "git 修改文件内容后误删了该文件，再使用 git 还原该文件，修改的文件内容丢失怎么办？"
        }
      ],
      "config": {
        "source": "git 修改文件内容后误删了该文件，再使用 git 还原该文件，修改的文件内容丢失怎么办？.md",
        "staticFileName": "git_edit_loss.html",
        "author": "guoqzuo",
        "createDate": "2020/12/30",
        "description": "最近修改某个文件后，还没将改动提交到 git，中途不小心删了该文件。然后想着恢复文件，就使用 git 恢复该文件。这个时候发现未提交的修改内容都丢失了，文件内容是 git 上最近的内容。这种情况，理论上 git 是无法还原的。因为没有提交，git 不会记录对应的内容。我们不能总是想着使用 git 怎么恢复，需要换一下思路。**修改的文件删除后，默认会存在废纸篓(回收站)，去里面找即可。**",
        "keywords": "git修改内容丢失怎么恢复,git修改内容未提交误删后怎么恢复",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "12"
      }
    },
    {
      "htmlStr": "<h1 id=\"description在seo中的重要性\">description在seo中的重要性</h1>\n<p>网站页面描述(description)可能会直接显示在百度搜索的结果里，所以尽量不要写太少，不然看起来内容就比较少，description 最好能对当前页面的内容有一个大概的描述，下面我们来看看为什么会有这个结论。</p>\n<h2 id=\"网站页面描述description\">网站页面描述(description)</h2>\n<p>2020年02月15号，我像往常一样在百度搜索 <strong>site:zuo11.com</strong> 来看网站的收录情况。发现之前在半个月前提交的页面，百度已经收录了部分。但仔细看发现有点怪，百度搜索出来的页面，内容显示的信息比较少，如下图：</p>\n<p><img src=\"../../../images/blog/seo/mata_description_baidu.png\" alt=\"mata_description_baidu.png\"></p>\n<p>而且这些信息正好是我通过 <strong>meta</strong> 元素指定的 <strong>description</strong> 属性的内容</p>\n<pre><code class=\"language-html\">&lt;meta name=&quot;application name&quot; content=&quot;apue_first.html&quot;&gt;\n&lt;meta name=&quot;author&quot; content=&quot;guoqzuo&quot;&gt;\n&lt;meta name=&quot;description&quot; content=&quot;UNIX环境高级编程简介，概览&quot;&gt;\n&lt;meta name=&quot;keywords&quot; content=&quot;APUE,apue 笔记, APUE笔记,UNIX基础知识,UNIX环境高级编程,apue&quot;&gt;</code></pre>\n<p>所以得出结论，在百度的搜索中，description的内容是很重要的，还是不能谁便填写。</p>\n<h2 id=\"google对description的处理\">Google对description的处理</h2>\n<p>后面我看了下google的收录情况，发现同样的页面，google并不像百度那样直接显示description内容，而是直接截取了文章内容的开头部分，如下图:</p>\n<p><img src=\"../../../images/blog/seo/mata_description_google.png\" alt=\"mata_description_google.png\"></p>\n<h2 id=\"seo中google和百度的一些区别\">seo中Google和百度的一些区别</h2>\n<p>上面提到了Google在显示descrption时与百度的差异，其实还有有些地方有区别，比如收录页面规则，处理死链规则。</p>\n<h3 id=\"收录页面方面\">收录页面方面</h3>\n<ul>\n<li>百度: 先进行一段时间判定，页面评定OK后，会进行收录，提交一个页面，可能要半个月才会收录</li>\n<li>Google: 先进行收录，然后再一段时间内对页面进行判定，完成评估内容不好久会撤掉，提交一个页面，1天后就会收录</li>\n</ul>\n<h3 id=\"死链处理方面\">死链处理方面</h3>\n<ul>\n<li>百度: 当页面被收录，网站如果出现了改版，且收录的页面成了死链，提交死链给百度，3天后收录里面居然还有，处理的比较很慢</li>\n<li>Google: 提交死链后，最多一天你就在收录里看不到对应的死链页面了</li>\n</ul>\n<p>注意：提交链接，提交死链需要在百度站长平台或Google Search console里提交</p>\n<h3 id=\"总结\">总结</h3>\n<p>相对于百度来讲google确实更智能一点</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "description在seo中的重要性",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "网站页面描述(description)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Google对description的处理"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "seo中Google和百度的一些区别",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "收录页面方面"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "死链处理方面"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "总结"
                }
              ]
            }
          ]
        }
      ],
      "config": {
        "source": "description在seo中的重要性.md",
        "staticFileName": "seo_description.html",
        "author": "guoqzuo",
        "createDate": "2020/02/16",
        "description": "网站页面描述(description)可能会直接显示在百度搜索的结果里，所以尽量不要写太少，不然看起来内容就比较少，description 最好能对当前页面的内容有一个大概的描述，下面我们来看看为什么会有这个结论。",
        "keywords": "description seo,网站页面描述(description),description在seo中的重要性,seo中Google和百度的一些区别",
        "category": "网站建设与SEO",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"静态博客生成系统二：markdown大纲提取以及页面滚动到对应区域时高亮处理\">静态博客生成系统(二)：markdown大纲提取以及页面滚动到对应区域时高亮处理</h1>\n<p>在考虑把个人博客站点静态化时，其中一个原因是markdown的大纲显示比较好，文章结构层次分明，可以更好的阅读。那怎么提取markdown文件的大纲数据，并呈现在网页上呢？下面来看看zuo-blog是怎么处理的。</p>\n<h2 id=\"提取markdown文件的大纲结构数据\">提取markdown文件的大纲结构数据</h2>\n<p>知道将md转换为html文件的方法后，需要生成对应的大纲数据。其实在marked这个npm包里有对应的方法。来看看具体实现</p>\n<pre><code class=\"language-js\">// 截取至 zuo-blog 源码\n// 读取文件内容，通过maked转换为html字符串\nconst fileStr = fs.readFileSync(articlePath).toString() \n// let htmlStr = marked(fileStr)\nlet headers = marked.lexer(fileStr).filter(item =&gt; item.type === &#39;heading&#39;)\nlet outline = _generateOutline(headers) // 根据文件内容生成大纲数据\n\n/**\n * @description 将md文件heading列表，转换为层级结构，用于生成大纲\n * @param {*} headers 原数据格式\n * [ { type: &#39;heading&#39;, depth: 1, text: &#39;站点优化 页面打开较慢处理&#39; },\n *  { type: &#39;heading&#39;, depth: 2, text: &#39;代码托管&#39; },\n *  { type: &#39;heading&#39;, depth: 2, text: &#39;速度慢的原因分析&#39; },\n *  { type: &#39;heading&#39;, depth: 3, text: &#39;代码分析&#39; },\n *  { type: &#39;heading&#39;, depth: 2, text: &#39;速度测试&#39; } ]\n * @returns  [ { text: &#39;xx&#39;, children: [ { text:&#39;xxx&#39;, children:[...] } ] } ]\n */\nfunction _generateOutline(headers) {\n  let tree = []\n  // 加try catch是为了如果中间出现跨越的层级问题，直接返回错误\n  try {\n    for (let i = 0, len = headers.length; i &lt; len; i++) {\n      let item = headers[i]\n      // 如果是一级目录，直接挂载到tree下\n      if (item.depth === 1) {\n        tree.push(item)\n      } else {\n        let target\n        // 如果是二级目录，挂载到当前tree最后一个元素的children上\n        if (item.depth === 2) {\n          target = tree.slice(-1)[0]\n        } else {\n          // 如果是3级+，遍历到最近一个层级的list\n          let count = item.depth - 2\n          target = tree.slice(-1)[0]\n          while(count--) {\n            target = target.children.slice(-1)[0]\n          }\n        }\n        !target.children &amp;&amp; (target.children = [])\n        target.children.push(item)\n      }\n    }\n  } catch(e) {\n    console.log(e)\n    let text = &#39;目录生成异常，请确保目录层级从H1到H6是正常顺序，对于没有H1或目录中间断层的情况需要修正&#39;\n    return [ { text } ]\n  }\n  return tree\n}\n\n// 最开始比较low的写法\n//  let tree = []\n//   for (let i = 0, len = headers.length; i &lt; len; i++) {\n//     let item = headers[i]\n//     if (item.depth === 1) {\n//       tree.push(item)\n//     } else if (item.depth === 2) {\n//       // 找最近的一个1级目录，加入到其list里面\n//       let level1 = tree[tree.length - 1]\n//       !level1.list &amp;&amp; (level1.list = [])\n//       level1.list.push(item)\n//     } else if (item.depth === 3) {\n//       // 找最近的一个二级目录\n//       let level1 =  tree[tree.length - 1]\n//       let level2 = level1.list[level1.list.length - 1]\n//       !level2.list &amp;&amp; (level2.list = [])\n//       level2.list.push(item)\n//     } else if (item.depth === 4) {\n//        // 找最近的一个三级目录\n//        let level1 =  tree[tree.length - 1]\n//        let level2 = level1.list[level1.list.length - 1]\n//        let level3 = level2.list[level2.list.length - 1]\n//        !level3.list &amp;&amp; (level3.list = [])\n//        level3.list.push(item)\n//     } else if (item.depth === 5) {\n//        // 找最近的一个4级目录\n//        let level1 =  tree[tree.length - 1]\n//        let level2 = level1.list[level1.list.length - 1]\n//        let level3 = level2.list[level2.list.length - 1]\n//        let level4 = level3.list[level3.list.length - 1]\n//        !level4.list &amp;&amp; (level4.list = [])\n//        level4.list.push(item)\n//     } else if (item.depth === 6) {\n//       // 找最近的一个5级目录\n//       let level1 =  tree[tree.length - 1]\n//       let level2 = level1.list[level1.list.length - 1]\n//       let level3 = level2.list[level2.list.length - 1]\n//       let level4 = level3.list[level3.list.length - 1]\n//       let level5 = level4.list[level4.list.length - 1]\n//       !level5.list &amp;&amp; (level5.list = [])\n//       level5.list.push(item)\n//     } else if (item.depth === 7) {\n//       // 找最近的一个6级目录\n//       let level1 =  tree[tree.length - 1]\n//       let level2 = level1.list[level1.list.length - 1]\n//       let level3 = level2.list[level2.list.length - 1]\n//       let level4 = level3.list[level3.list.length - 1]\n//       let level5 = level4.list[level4.list.length - 1]\n//       let level6 = level5.list[level5.list.length - 1]\n//       !level6.list &amp;&amp; (level6.list = [])\n//       level6.list.push(item)\n//     } \n//   }</code></pre>\n<h2 id=\"根据大纲数据生成html\">根据大纲数据生成html</h2>\n<p>在md文件显示的右侧，显示大纲html，将大纲JSON数据，生成html。注意：</p>\n<ol>\n<li><p>ul 的padding-left要修改为0，而不是1em，因为发现语雀、gaylab对应的大纲实现里，focus时都有左侧border，菜单的padding-left根据其depth来生成，padding-left: (depth * 1)em</p>\n</li>\n<li><p>这里大纲的每一个标题都没有使用a标签，不是走hash，而是直接通过点击js来滚动到对应id的位置。</p>\n<pre><code class=\"language-js\">/**\n* @description 根据大纲数据(JSON)生成侧边栏html\n* @param {*} outline \n*/\n_getAsideHtml(outline) {\nfunction handlerId(id) {\n let newId = id.toLowerCase().replace(/\\s/g, &#39;-&#39;)\n newId = newId.replace(/[\\(\\)\\/\\,\\=\\&gt;\\.\\:\\+]/g, &#39;&#39;)\n return newId\n}\nlet asideHtml = &#39;&#39;\nlet backupOutline = JSON.parse(JSON.stringify(outline))\nfor (let i = 0, len = outline.length; i &lt; len; i++) {\n asideHtml += &#39;&lt;ul&gt;&#39;\n asideHtml += `&lt;li&gt;&lt;span class=&quot;ul-span&quot; data-id=&quot;${handlerId(outline[i].text)}&quot; style=&quot;padding-left:${outline[i].depth + &#39;em&#39;}&quot;&gt;${outline[i].text}&lt;span&gt;&lt;/li&gt;`\n if (outline[i].children) {\n   asideHtml += getChildrenAsideHtml(outline[i].children)\n } \n asideHtml += &#39;&lt;/ul&gt;&#39;\n}\n\nfunction getChildrenAsideHtml(outline) {\n if (!outline || outline.length === 0) {\n   return &#39;&#39;\n }\n let asideHtml = &#39;&#39;\n for (let i = 0, len = outline.length; i &lt; len; i++) {\n   asideHtml += &#39;&lt;ul&gt;&#39;\n   asideHtml += `&lt;li&gt;&lt;span class=&quot;ul-span&quot; data-id=&quot;${handlerId(outline[i].text)}&quot; style=&quot;padding-left:${outline[i].depth + &#39;em&#39;}&quot;&gt;${outline[i].text}&lt;span&gt;&lt;/li&gt;`\n   if (outline[i].children) {\n     asideHtml += getChildrenAsideHtml(outline[i].children)\n   } \n   asideHtml += &#39;&lt;/ul&gt;&#39;\n }\n return asideHtml\n}\nreturn asideHtml\n}</code></pre>\n</li>\n</ol>\n<h2 id=\"页面滚动到对应的大纲区域时怎么设置高亮\">页面滚动到对应的大纲区域时怎么设置高亮</h2>\n<p>这里需要注意有两点：</p>\n<ol>\n<li>点击大纲里某个标题，页面滚动到对应区域</li>\n<li>滚动页面后自动改变大纲focus</li>\n</ol>\n<p>这里的核心问题是: 怎么获取页面滚动到了哪个标题区域？</p>\n<p><strong>每次一进入页面，将每个标题(h1,h2,..)的id，offsetTop(距离页面顶部距离)按顺序存到数组，监听页面滚动事件，根据document.documentElement.scrollTop的高度，来匹配之前的数组，就可以找到滚动到哪个标题了</strong></p>\n<p>来看具体代码</p>\n<pre><code class=\"language-js\">// 监听大纲的点击事件\nlet asideDiv = document.getElementsByTagName(&#39;aside&#39;)[0]\nasideDiv.onclick = (e) =&gt; {\n  let id = e.target.dataset.id\n  if (!id) return\n  // 移除所有的active\n  let nodes = document.getElementsByClassName(&#39;ul-span&#39;)\n  for (let i = 0, len = nodes.length; i &lt; len; i++) {\n    nodes[i].classList.remove(&#39;active&#39;)\n  }\n  e.target.classList.add(&#39;active&#39;)\n  document.getElementById(id).scrollIntoView(true)\n  document.documentElement.scrollBy(0, -70)\n}\n\nlet headersArr = []\n\nwindow.onload = () =&gt; {\n  // 如果是category，且有hash值，向上滚动 -70\n  // 通过category.html#web进入页面时, 由于顶部fixed会有遮挡，fix方案\n  let { pathname, hash } = location\n  pathname.includes(&#39;category.html&#39;) &amp;&amp; hash &amp;&amp; document.documentElement.scrollBy(0, -70)\n\n  // 将每个标题的高度，存到数组里，当滚动时，自动focus右侧大纲\n  let nodes = document.getElementsByClassName(&#39;ul-span&#39;)\n  for (let i = 0, len = nodes.length; i &lt; len; i++) {\n    // console.log(nodes.dataset)\n    let id = nodes[i].dataset.id\n    headersArr.push({id: id, offsetTop: document.getElementById(id).offsetTop})\n  }\n  // console.log(headersArr)\n\n  window.onscroll = () =&gt; {\n    focusAsideSpan()\n    // debounce(focusAsideSpan)\n  }\n}\n\n// 效果不好，没有实时滚动的感觉，关闭防抖\n// function debounce(method, context) {\n//   clearTimeout(method.tId)\n//   method.tId = setTimeout(function() {\n//     method.call(context)\n//   }, 100)\n// }\n\nfunction focusAsideSpan() {\n  let scrollTop = document.documentElement.scrollTop\n  let curNode\n  for (let i = 0, len = headersArr.length; i &lt; len; i++) {\n    if (headersArr[i].offsetTop - scrollTop &gt;= 0) {\n      // 移除所有的active\n      let nodes = document.getElementsByClassName(&#39;ul-span&#39;)\n      for (let j = 0, len = nodes.length; j &lt; len; j++) {\n        if (headersArr[i].id === nodes[j].dataset.id) {\n          nodes[j].classList.remove(&#39;active&#39;)\n          nodes[j].classList.add(&#39;active&#39;)\n        } else {\n          nodes[j].classList.remove(&#39;active&#39;)\n        }\n      }\n      return\n    }\n  }\n  // 如果走到这里，说明滚到底部了\n  // 移除所有的active\n  let nodes = document.getElementsByClassName(&#39;ul-span&#39;)\n  for (let i = 0, len = nodes.length; i &lt; len; i++) {\n    nodes[i].classList.remove(&#39;active&#39;)\n  }\n  nodes[nodes.length - 1].classList.add(&#39;active&#39;)\n}</code></pre>\n<h2 id=\"大纲更好的实现方式\">大纲更好的实现方式</h2>\n<p>这里实现很复杂，对于非标准层级结构来说会有bug，<strong>其实这里没必要做的这么麻烦，没必要将对象数组，转换为树形结构，只需要渲染时根据不同的depth设置不同的margin-left或padding-left，其值为 (depth - 1) * baseWidth基础间距，这样就可以很好的显示了，待0.3.0版本优化</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "静态博客生成系统(二)：markdown大纲提取以及页面滚动到对应区域时高亮处理",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "提取markdown文件的大纲结构数据"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "根据大纲数据生成html"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "页面滚动到对应的大纲区域时怎么设置高亮"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "大纲更好的实现方式"
            }
          ]
        }
      ],
      "config": {
        "source": "静态博客生成系统(二)：markdown大纲提取以及页面滚动到对应区域时高亮处理.md",
        "staticFileName": "zuoblog_2_outline.html",
        "author": "guoqzuo",
        "createDate": "2020/02/02",
        "description": "在考虑把个人博客站点静态化时，其中一个原因是markdown的大纲显示比较好，文章结构层次分明，可以更好的阅读。那怎么提取markdown文件的大纲数据，并呈现在网页上呢？下面来看看zuo-blog是怎么处理的。",
        "keywords": "提取markdown文件的大纲结构数据,markdown大纲提取,mardown目录提取,根据大纲数据生成html,页面滚动时，自动切换大纲focus,怎么监听页面滚动到了某个标题区域",
        "category": "前端工程化",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"静态博客生成系统三：node复制或删除文件夹以及npm包命令执行时所在路径获取\">静态博客生成系统(三)：node复制或删除文件夹以及npm包命令执行时所在路径获取</h1>\n<p>静态博客生成系统，需要把src目录下的源文件生成dist目录下的可部署的文件，对于资源文件需要从src下直接拷贝过去。这就涉及怎么用node复制或删除文件夹了，另外我们在使用zuoblog init执行构建生成时，需要知道命令执行时所在的路径，下面来看看</p>\n<h2 id=\"node复制或删除文件夹\">node复制或删除文件夹</h2>\n<p>node只提供了复制文件、删除空文件夹的方法，如果需要复制文件夹或删除文件夹，就需要自己写方法了，在网上找了个不错的实现，稍微再次封装了下，来看<a href=\"https://github.com/zuoxiaobai/zuo-blog/blob/master/vendor/utils/FSExtend.js\">源码 | github</a></p>\n<pre><code class=\"language-js\">const path = require(&#39;path&#39;)\nconst fs = require(&#39;fs&#39;)\n\n/**\n * node 在操作文件夹时会比较麻烦，需要自己封装方法，将网上的方法修改了下路径方面的问题\n * https://segmentfault.com/a/1190000020040889\n */\nclass FSExtend {\n  /**\n   * 删除文件夹\n   */\n  static deleteFolder(delPath) {\n    // console.log(&#39;pre delPath&#39;, delPath)\n    // delPath = path.join(__dirname, delPath) // 这个是当前文件的路径\n    // process.cwd()  当前命令执行时所在的目录\n    delPath = path.join(process.cwd(), delPath)\n    // console.log(&#39;delPath&#39;, delPath)\n\n    try {\n        if (fs.existsSync(delPath)) {\n            const delFn = function (address) {\n                const files = fs.readdirSync(address)\n                for (let i = 0; i &lt; files.length; i++) {\n                    const dirPath = path.join(address, files[i])\n                    if (fs.statSync(dirPath).isDirectory()) {\n                        delFn(dirPath)\n                    } else {\n                        FSExtend.deleteFile(dirPath)\n                    }\n                }\n                /**\n                * @des 只能删空文件夹\n                */\n                fs.rmdirSync(address);\n            }\n            delFn(delPath);\n        } else {\n            // console.log(&#39;需要删除的文件不存在，不用删除&#39;, delPath);\n        }\n    } catch (error) {\n        console.log(&#39;del folder error&#39;, error);\n    }\n  }\n\n  /**\n   * @description 删除文件\n   * @param { delPath：String } （需要删除文件的地址）\n   */\n  static deleteFile(delPath) {\n    try {\n        /**\n         * @des 判断文件或文件夹是否存在\n         */\n        if (fs.existsSync(delPath)) {\n            fs.unlinkSync(delPath);\n        } else {\n            console.log(&#39;inexistence path：&#39;, delPath);\n        }\n    } catch (error) {\n        console.log(&#39;del error&#39;, error);\n    }\n  }\n\n  /**\n   * @description 负责文件夹\n   */\n  static copyFolder(copiedPath, resultPath) {\n    // copiedPath = path.join(process.cwd(), copiedPath)\n    // resultPath = path.join(process.cwd(), resultPath)\n\n    function createDir (dirPath) {\n        fs.mkdirSync(dirPath)        \n    }\n\n    if (fs.existsSync(copiedPath)) {\n        createDir(resultPath)\n        /**\n         * @des 方式一：利用子进程操作命令行方式\n         */\n        // child_process.spawn(&#39;cp&#39;, [&#39;-r&#39;, copiedPath, resultPath])\n\n        /**\n         * @des 方式二：\n         */\n        const files = fs.readdirSync(copiedPath, { withFileTypes: true });\n        for (let i = 0; i &lt; files.length; i++) {\n            const cf = files[i]\n            const ccp = path.join(copiedPath, cf.name)\n            const crp = path.join(resultPath, cf.name)  \n            if (cf.isFile()) {\n                /**\n                 * @des 创建文件,使用流的形式可以读写大文件\n                 */\n                const readStream = fs.createReadStream(ccp)\n                const writeStream = fs.createWriteStream(crp)\n                readStream.pipe(writeStream)\n            } else {\n                try {\n                    /**\n                     * @des 判断读(R_OK | W_OK)写权限\n                     */\n                    fs.accessSync(path.join(crp, &#39;..&#39;), fs.constants.W_OK)\n                    FSExtend.copyFolder(ccp, crp)\n                } catch (error) {\n                    console.log(&#39;folder write error:&#39;, error);\n                }\n\n            }\n        }\n    } else {\n        console.log(&#39;do not exist path: &#39;, copiedPath);\n    }\n  }\n}\n\nmodule.exports = FSExtend</code></pre>\n<h2 id=\"zuoblog-init命令执行时所在的路径获取\">zuoblog init命令执行时所在的路径获取</h2>\n<p>在写 zuoblog init 命令执行的操作时，需要操作当前命令执行时所在的目录，而__dirname是程序文件的路径。这就需要用到 process.cwd()了，可以获取到当前命令执行时所在的目录</p>\n<pre><code class=\"language-js\">const path = require(&#39;path&#39;)\n// delPath = path.join(__dirname, delPath) // 这个是当前文件的路径\n// process.cwd()  当前命令执行时所在的目录\n// 在每次构建前，先删除当前路径下的dist目录，下面是获取对应路径的方法\ndelPath = path.join(process.cwd(), delPath)</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "静态博客生成系统(三)：node复制或删除文件夹以及npm包命令执行时所在路径获取",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "node复制或删除文件夹"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "zuoblog init命令执行时所在的路径获取"
            }
          ]
        }
      ],
      "config": {
        "source": "静态博客生成系统(三)：node复制或删除文件夹以及npm包命令执行时所在路径获取.md",
        "staticFileName": "zuoblog_3_file.html",
        "author": "guoqzuo",
        "createDate": "2020/02/02",
        "description": "静态博客生成系统，需要把src目录下的源文件生成dist目录下的可部署的文件，对于资源文件需要从src下直接拷贝过去。这就涉及怎么用node复制或删除文件夹了，另外我们在使用zuoblog init执行构建生成时，需要知道命令执行时所在的路径，下面来看看",
        "keywords": "node复制或删除文件夹,npm包命令执行时所在路径获取",
        "category": "前端工程化",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"深入js遍历对象，从4个维度比较遍历对象的8种方法\">深入JS遍历对象，从4个维度比较遍历对象的8种方法</h1>\n<p>一般遍历对象时，大部分人可能想到的方法是for..in或Object.keys.forEach()，但你知道吗？截止ES2020，在JS中总共有8种方法来遍历对象，不同的遍历方法在一些细节方面会有区别，下面我们将从以下几个方面来深入理解JS遍历对象</p>\n<ol>\n<li>看似可以遍历对象但又不能遍历对象的for与for...of</li>\n<li>可能会对遍历对象产生影响的4种因素：属性是否可枚举、Symbol属性、继承属性、遍历次序</li>\n<li>从ES5到ES2020所有可以遍历对象的方法总结</li>\n<li>通过实例demo，从4个维度比较8种遍历对象方法</li>\n<li>属性遍历次序总结</li>\n</ol>\n<p><strong>注意, 本文所指的对象是普通的键值对Object对象，而不是Array、Set等对象</strong></p>\n<h2 id=\"for和forof不能直接遍历object对象\">for和for...of不能直接遍历Object对象</h2>\n<p>首先我们要知道for和for...of不能直接遍历Object对象，除非先将对象转换为数组或Set、Map等</p>\n<p>下面对for...of的知识点做一些回顾，for...of可迭代的对象包括 Array，Map，Set，String，TypedArray，arguments 对象等等</p>\n<p>JS有4种表示集合的数据结构</p>\n<ul>\n<li>ES5及之前: Array, Object</li>\n<li>ES6: Map, Set</li>\n</ul>\n<p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环。当使用for...of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</p>\n<p>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。</p>\n<h3 id=\"forof遍历数组\">for...of遍历数组</h3>\n<pre><code class=\"language-js\">// 遍历数组 for...of\nconst arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];\nfor(let v of arr) {\n  console.log(v); // red green blue\n}</code></pre>\n<h3 id=\"forof遍历set和map结构\">for...of遍历Set和Map结构</h3>\n<pre><code class=\"language-js\">var engines = new Set([&quot;Gecko&quot;, &quot;Trident&quot;, &quot;Webkit&quot;, &quot;Webkit&quot;]);\nfor (var e of engines) {\n  console.log(e);\n}\n// Gecko\n// Trident\n// Webkit\n\nvar es6 = new Map();\nes6.set(&quot;edition&quot;, 6);\nes6.set(&quot;committee&quot;, &quot;TC39&quot;);\nes6.set(&quot;standard&quot;, &quot;ECMA-262&quot;);\nfor (var [name, value] of es6) {\n  console.log(name + &quot;: &quot; + value);\n}\n// edition: 6\n// committee: TC39\n// standard: ECMA-262\n\n// example2\nlet map = new Map().set(&#39;a&#39;, 1).set(&#39;b&#39;, 2);\nfor (let pair of map) {\n  console.log(pair);\n}\n// [&#39;a&#39;, 1]\n// [&#39;b&#39;, 2]\nfor (let [key, value] of map) {\n  console.log(key + &#39; : &#39; + value);\n}\n// a : 1\n// b : 2</code></pre>\n<h2 id=\"对象属性的可枚举属性\">对象属性的可枚举属性</h2>\n<p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</p>\n<pre><code class=\"language-js\">let obj = { foo: 123 };\nObject.getOwnPropertyDescriptor(obj, &#39;foo&#39;)\n//  {\n//    value: 123,\n//    writable: true,\n//    enumerable: true,\n//    configurable: true\n//  }</code></pre>\n<p>目前，有六个操作会忽略enumerable为false的属性。</p>\n<ul>\n<li>for...in循环：只遍历对象自身的和继承的可枚举的属性。</li>\n<li>Object.keys()：返回对象自身的所有可枚举的属性的键名。</li>\n<li>Object.values()：返回对象自身的所有可枚举的属性的值。</li>\n<li>Object.entires()：返回对象自身的所有可枚举的属性的键值对。</li>\n<li>JSON.stringify()：只串行化对象自身的可枚举的属性。</li>\n<li>Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</li>\n</ul>\n<p>另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替。</p>\n<h2 id=\"对象symbol属性名的遍历问题\">对象Symbol属性名的遍历问题</h2>\n<p>Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</p>\n<pre><code class=\"language-js\">let sym = Symbol(&#39;foo&#39;)\nlet obj = {a: 1, b:2, [sym]: 3}\n\nObject.getOwnPropertyNames() // [&quot;a&quot;, &quot;b&quot;]\nObject.getOwnPropertySymbols(obj) // [Symbol(foo)]\n\n// Reflect.ownKeys() 返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。\nReflect.ownKeys(obj) // [&#39;a&#39;, &#39;b&#39;, Symbol(aaa)]</code></pre>\n<h2 id=\"es6遍历对象的5种方法\">ES6遍历对象的5种方法</h2>\n<p>ES6 一共有 5 种方法可以遍历对象的属性。</p>\n<h3 id=\"forin\">for...in</h3>\n<p>for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>\n<h3 id=\"objectkeysobj\">Object.keys(obj)</h3>\n<p>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>\n<h3 id=\"objectgetownpropertynamesobj\">Object.getOwnPropertyNames(obj)</h3>\n<p>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>\n<h3 id=\"objectgetownpropertysymbolsobj\">Object.getOwnPropertySymbols(obj)</h3>\n<p>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。包括不可枚举属性</p>\n<h3 id=\"reflectownkeysobj\">Reflect.ownKeys(obj)</h3>\n<p>Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。</p>\n<pre><code class=\"language-js\">var myObject = {\n  foo: 1,\n  bar: 2,\n  [Symbol.for(&#39;baz&#39;)]: 3,\n  [Symbol.for(&#39;bing&#39;)]: 4\n}\n// 旧写法\nObject.getOwnPropertyNames(myObject)\n// [&#39;foo&#39;, &#39;bar&#39;]\nObject.getOwnPropertySymbols(myObject)\n//[Symbol(baz), Symbol(bing)]\n// 新写法\nReflect.ownKeys(myObject)\n// [&#39;foo&#39;, &#39;bar&#39;, Symbol(baz), Symbol(bing)]</code></pre>\n<h2 id=\"es2017-新增3种遍历对象的方法\">ES2017 新增3种遍历对象的方法</h2>\n<p>由于for...in可以遍历出继承自父元素的原型属性，导致一般可能不会用这个方法来遍历。所以在遍历对象时，一般比较优雅的方式是下面的方法</p>\n<pre><code class=\"language-js\">Object.keys(myObj).forEach(function (key) {\n  let obj = myObj[key];\n  // do something with obj\n});</code></pre>\n<p>但这种方法的缺陷是，我如果想操作对象里面的所有值，我需要先转数组再forEach，再通过key从对象里取值，会很麻烦。于是就有人提议是否可以把数组的Array.prototype.values()和entries()引入到Object来，这样操作对象就灵活了，于是就有了Object.values与Object.entries</p>\n<p>以下是TC39关于Object.values/Object.entries 相关描述</p>\n<blockquote>\n<p>It is a very common use case to need the own values of an object - for example, when using an object as a hash filter. Many libraries have a “values” function: lodash/underscore, jQuery, Backbone, etc.</p>\n</blockquote>\n<blockquote>\n<p>It is also useful to obtain an array of key/value pairs (what the spec calls “entries”) from an object, for the purposes of iteration or serialization. With the advent of the Map constructor accepting an iterable of entries, and its associated entries iterator (WeakMap also accepts iterable entries in its constructor), it becomes very compelling to want to quickly convert a plain object to a Map, via passing an array of entries into new Map.</p>\n</blockquote>\n<blockquote>\n<p>We already have the precedent of Object.keys returning an array of own keys, and matched triplets of keys/values/entries iterators on Map/Set/Array. As such, per discussions on es-discuss and in at least one previous TC39 meeting, this proposal seeks to add Object.values and Object.entries to ECMAScript. Like Object.keys, they would return arrays. Their ordering would match Object.keys ordering precisely, such that the indices of all three resulting arrays would reflect the same key, value, or entry on the object.</p>\n</blockquote>\n<h3 id=\"objectvalues与objectentries\">Object.values与Object.entries</h3>\n<p>他们和Object.keys返回的都一样是<strong>数组</strong>，除了下面的for...of遍历外，我们也可以使用forEach</p>\n<pre><code class=\"language-js\">// import { keys, values, entries } from &#39;@dict&#39;;\nlet { keys, values, entries } = Object;\n\nlet obj = { a: 1, b: 2, c: 3 };\n\nfor (let key of keys(obj)) {\n// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n}\n\nfor (let value of values(obj)) {\n// [1, 2, 3]\n}\n\nfor (let [key, value] of entries(obj)) {\n// [[&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]]\n}</code></pre>\n<h3 id=\"地表最强objectgetownpropertydescriptors\">地表最强Object.getOwnPropertyDescriptors()</h3>\n<p>ES5 的Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>\n<pre><code class=\"language-js\">// 1.获取属性的描述对象 Object.getOwnPropertyDescriptor()\nObject.getOwnPropertyDescriptor(book, &quot;_year&quot;); \n// {&quot;value&quot;:2004,&quot;writable&quot;:false,&quot;enumerable&quot;:false,&quot;configurable&quot;:false}\n\n// 2.获取对象的所有自身属性表述对象\nconst obj = {\n  foo: 123,\n  get bar() { return &#39;abc&#39; }\n};\n\nObject.getOwnPropertyDescriptors(obj)\n// { foo:\n//    { value: 123,\n//      writable: true,\n//      enumerable: true,\n//      configurable: true },\n//   bar:\n//    { get: [Function: get bar],\n//      set: undefined,\n//      enumerable: true,\n//      configurable: true } }</code></pre>\n<p><strong>该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。这是因为Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。这时，Object.getOwnPropertyDescriptors()方法配合Object.defineProperties()方法，就可以实现正确拷贝。</strong></p>\n<pre><code class=\"language-js\">// 1.Object.assign()无法拷贝set,get方法\nconst source = {\n  set foo(value) {\n    console.log(value);\n  }\n};\n\nconst target1 = {};\nObject.assign(target1, source);\n\nObject.getOwnPropertyDescriptor(target1, &#39;foo&#39;)\n// { value: undefined,\n//   writable: true,\n//   enumerable: true,\n//   configurable: true }\n\n// 2.Object.getOwnPropertyDescriptors()方法配合Object.defineProperties()方法\nconst source = {\n  set foo(value) {\n    console.log(value);\n  }\n};\n\nconst target2 = {};\nObject.defineProperties(target2, Object.getOwnPropertyDescriptors(source));\nObject.getOwnPropertyDescriptor(target2, &#39;foo&#39;)\n// { get: undefined,\n//   set: [Function: set foo],\n//   enumerable: true,\n//   configurable: true }</code></pre>\n<p>Object.getOwnPropertyDescriptors()方法可以实现一个对象继承另一个对象。</p>\n<pre><code class=\"language-js\">// 写法1\nconst obj = {\n  __proto__: prot,\n  foo: 123,\n};\n\n// 写法2\nconst obj = Object.create(prot);\nobj.foo = 123;\n\n// 写法3\nconst obj = Object.assign(\n  Object.create(prot),\n  {\n    foo: 123,\n  }\n);\n\n// 写法4\nconst obj = Object.create(\n  prot,\n  Object.getOwnPropertyDescriptors({\n    foo: 123,\n  })\n);\n// Object.create(proto[, propertiesObject])  NDN\n// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create</code></pre>\n<h2 id=\"从4个维度比较遍历对象8种方法\">从4个维度比较遍历对象8种方法</h2>\n<p>我们通过一个demo从4个维度来比较8种遍历对象方法的异同点​</p>\n<ol>\n<li>是否可以遍历不可枚举属性</li>\n<li>是否可以遍历Symbol属性</li>\n<li>是否可以遍历继承的原型属性</li>\n<li>遍历次序</li>\n</ol>\n<pre><code class=\"language-js\">console.log(&#39;object 遍历测试&#39;)\n\n// 1. 安排 继承属性\nfunction A() {\n  this[&#39;99&#39;] =  2,\n  this.parentA = &#39;1&#39;\n}\nlet a = new A()\n// 原型继承，只是将a的原型属性挂载到了myObject上\nlet myObject = Object.create(a)\n// 测试继承来的原型属性 \nconsole.log(&#39;myObject.parentA&#39;, myObject.parentA)\n\n// 2. 安排各种常规属性、symbol属性，数值属性\nObject.assign(myObject, {\n  foo: 1,\n  baz: 2,\n  &quot;2&quot;: &quot;798&quot;,\n  &quot;1&quot;: &quot;123&quot;,\n  [Symbol.for(&#39;baz&#39;)]: 3,\n  [Symbol.for(&#39;bing&#39;)]: 4\n})\n\n// 3. 安排两个不可枚举属性\nObject.defineProperties(myObject, {\n  notEnumProp1: { \n    configurable: false,\n    enumerable: false,\n    writable: false,\n    value: 27\n  },\n  &#39;9999&#39;: {\n    enumerable: false,\n    value: &quot;test9999&quot;\n  }\n})\n\n// 4. 测试\nlet forInArr = []\nfor (let item in myObject) {\n  forInArr.push(item)\n}\nconsole.log(&#39;for...in&#39;, forInArr)\nconsole.log(&#39;Object.keys&#39;, Object.keys(myObject))\nconsole.log(&#39;Object.getOwnPropertyNames&#39;, Object.getOwnPropertyNames(myObject))\nconsole.log(&#39;Object.getOwnPropertySymbols&#39;, Object.getOwnPropertySymbols(myObject))\nconsole.log(&#39;Reflect.ownKeys&#39;, Reflect.ownKeys(myObject))\nconsole.log(&#39;Object.values&#39;, Object.values(myObject))\nconsole.log(&#39;Object.entries&#39;, Object.entries(myObject))\nconsole.log(&#39;Object.getOwnPropertyDescriptors&#39;, Object.getOwnPropertyDescriptors(myObject))\n// 未实现的\n// console.log(&#39;Reflect.ownValues&#39;, Reflect.ownValues(myObject)) // 仅在tc39文档里讨论过\n// console.log(&#39;Reflect.ownEntries&#39;, Reflect.ownEntries(myObject)) // 仅在tc39文档里讨论过</code></pre>\n<p>运行结果如下图，完整demo可以从 <a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/JS%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E7%9A%848%E4%B8%AD%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94/test.js\">github</a> 下载</p>\n<p><img src=\"../../../images/blog/js/object_iterator.png\" alt=\"object_iterator.png\"></p>\n<p>综上，他们遍历次序基本一致，我们只需要比较三个维度即可，如下表</p>\n<table>\n<thead>\n<tr>\n<th>遍历方法</th>\n<th>可以遍历不可枚举属性</th>\n<th>可以遍历Symbol属性</th>\n<th>可以遍历继承的原型属性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>for...in</td>\n<td>否</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>Object.keys()</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n</tr>\n<tr>\n<td>Object.values()</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n</tr>\n<tr>\n<td>Object.entries()</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n</tr>\n<tr>\n<td>Object.getOwnPropertyNames()</td>\n<td>是</td>\n<td>否</td>\n<td>否</td>\n</tr>\n<tr>\n<td>Object.getOwnPropertySymbols()</td>\n<td>是</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>Reflect.ownKeys()</td>\n<td>是</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>Object.getOwnPropertyDescriptors()</td>\n<td>是</td>\n<td>是</td>\n<td>否</td>\n</tr>\n</tbody></table>\n<h2 id=\"8种遍历方法遵循同一次序规则\">8种遍历方法遵循同一次序规则</h2>\n<p>以上的 8 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>\n<ul>\n<li><strong>首先遍历所有数值键，按照数值升序排列。</strong></li>\n<li>其次遍历所有字符串键，<strong>按照加入时间升序排列</strong>。</li>\n<li>最后遍历所有 Symbol 键，<strong>按照加入时间升序排列</strong>。</li>\n<li>如果是for...in，最后遍历继承自父元素的原型属性，按照先数值、再字符串的顺序</li>\n</ul>\n<p>总结：当如果同时存在数值属性、字符串属性等时，for...in遍历属性是无序的。如需确定顺序，建议使用数组。</p>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://github.com/tc39/proposals/blob/master/finished-proposals.md\">tc39/proposals finished-proposals</a></li>\n<li><a href=\"https://github.com/tc39/proposal-object-values-entries\">tc39/proposal-object-values-entries</a></li>\n<li><a href=\"https://www.yuque.com/guoqzuo/js_es6/wnn0h0#8c8efbbe\">Iterator和for...of循环 | es6入门笔记</a></li>\n<li><a href=\"https://www.yuque.com/guoqzuo/js_es6/csk2et#85b97dce\">Reflect.ownKeys() | es6入门笔记</a></li>\n<li><a href=\"https://www.yuque.com/guoqzuo/js_es6/rxu7ms#358d8be2\">对象的扩展 | es6入门笔记</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in\">for...in - JavaScript | MDN</a></li>\n<li><a href=\"https://blog.csdn.net/SailingLee/article/details/84598921\">for...in遍历的顺序</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "深入JS遍历对象，从4个维度比较遍历对象的8种方法",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "for和for...of不能直接遍历Object对象",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "for...of遍历数组"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "for...of遍历Set和Map结构"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "对象属性的可枚举属性"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "对象Symbol属性名的遍历问题"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "ES6遍历对象的5种方法",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "for...in"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "Object.keys(obj)"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "Object.getOwnPropertyNames(obj)"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "Object.getOwnPropertySymbols(obj)"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "Reflect.ownKeys(obj)"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "ES2017 新增3种遍历对象的方法",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "Object.values与Object.entries"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "地表最强Object.getOwnPropertyDescriptors()"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "从4个维度比较遍历对象8种方法"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "8种遍历方法遵循同一次序规则"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "深入JS遍历对象，从4个维度比较遍历对象的8种方法.md",
        "staticFileName": "js_obj_iterator.html",
        "author": "guoqzuo",
        "createDate": "2020/02/02",
        "description": "一般遍历对象时，大部分人可能想到的方法是for..in或Object.keys.forEach()，但你知道吗？截止ES2020，在JS中总共有8种方法来遍历对象，而且不同的遍历方法在一些细节方面会有区别，下面我们将从以下几个方面来深入理解JS遍历对象 1. 看似可以遍历对象但又不能遍历对象的for与for...of 2. 可能会对遍历对象产生影响的4种因素：属性是否可枚举、Symbol、是否有继承属性、遍历次序 3. 从ES5到ES2020发展过程中所有的可以遍历对象的方法 4. 通过实例demo来从4个维度比较8种遍历对象的方法 5. 属性遍历次序总结",
        "keywords": "js遍历对象,js遍历对象方法总结,js遍历对象的8种方法",
        "category": "JavaScript",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"node中的4种模块类型\">node中的4种模块类型</h1>\n<p>Node.js的模块化使用CommonJS规范：module.exports导出，require引入。在node中你会发现在使用某个模块时，有时候需要require，有时候不需要；有时候需要npm install，有时候不需要，这是为什么呢？下面来看看</p>\n<h2 id=\"核心模块\">核心模块</h2>\n<p>require都不需要直接使用，比如global、buffer、module、process等</p>\n<h2 id=\"内置模块\">内置模块</h2>\n<p>需要require才能使用，不需要npm install，比如：os、fs、path、http、util等</p>\n<h2 id=\"第三方模块\">第三方模块</h2>\n<p>不仅需要require，还需要npm install才能使用，比如: download-git-repo、ora、commander等</p>\n<h2 id=\"本地自己写的模块\">本地自己写的模块</h2>\n<p>自己写的模块一般require就行，但如果里面包含了需要npm install的包，也需要安装</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "node中的4种模块类型",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "核心模块"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "内置模块"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "第三方模块"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "本地自己写的模块"
            }
          ]
        }
      ],
      "config": {
        "source": "node中的4种模块类型.md",
        "staticFileName": "node_module_type.html",
        "author": "guoqzuo",
        "createDate": "2020/02/04",
        "description": "Node.js的模块化使用CommonJS规范：module.exports导出，require引入。在node中你会发现使用某个模块时，有时候需要require，有时候不需要；有时候需要npm install，有时候不需要，这是为什么呢？下面来看看",
        "keywords": "node中的4种模块类型,node中使用某个模块时为什么有的模块需要require，有的模块又不需要，有的需要npm install，有的又不需要",
        "category": "前端工程化",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"nodejs、js、v8三者之间的关系\">Node.js、js、v8三者之间的关系</h1>\n<ol>\n<li><p>Node.js 提供了JS运行时（运行js的环境，类似的概念有JRE提供了运行java的环境）。Node.js通过内部集成Chrome V8引擎来解析执行js</p>\n</li>\n<li><p>Node.js除了解析执行js外，还包含其他功能，比如浏览器里js无法操作文件、无法开启http服务器、而Node.js里可以，主要是因为Node.js里面扩展加入了很多功能。比如使用libuv，提供了文件系统、网络、子进程、管道、信号处理、轮询、流等功能；使用llhttp提供了HTTP解析功能；使用OpenSSL提供tls、crypto加密相关功能等等。</p>\n</li>\n</ol>\n<p>参考之前的笔记：<a href=\"https://www.yuque.com/guoqzuo/rdrqd5/ms0w14#Libraries\">Node.js基础</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Node.js、js、v8三者之间的关系"
        }
      ],
      "config": {
        "source": "Node.js、js、v8三者之间的关系.md",
        "staticFileName": "node_js_v8.html",
        "author": "guoqzuo",
        "createDate": "2020/02/04",
        "description": "Node.js 提供了JS运行时（运行js的环境，类似的概念有JRE提供了运行java的环境）。Node.js通过内部集成Chrome V8引擎来解析执行js，Node.js除了解析执行js外，还包含其他功能，比如浏览器里js无法操作文件、无法开启http服务器、而Node.js里可以，主要是因为Node.js里面扩展加入了很多功能。比如使用libuv，提供了文件系统、网络、子进程、管道、信号处理、轮询、流等功能；使用llhttp提供了HTTP解析功能；使用OpenSSL提供tls、crypto加密相关功能等等",
        "keywords": "node.js和js的区别,node.js v8 js之间的关系",
        "category": "前端工程化",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"nginx访问不带www的域名，自动切到www\">nginx访问不带www的域名，自动切到www</h1>\n<p>在seo时，搜索引擎可能会将 <code>xx.com</code> 和 <code>www.xx.com</code> 一起收录。这里需要进行处理，当使用一级域名直接访问时(<code>xx.com</code>)，自动切到 <code>www.xx.com</code> ，下面来看看怎么配置nginx</p>\n<pre><code class=\"language-bash\"># 修改nginx配置，加入如下转换\nif ($host = &#39;zuo11.com&#39;) {\n  rewrite ^/(.*)$ http://www.zuo11.com/$1 permanent;\n}</code></pre>\n<p>如下图</p>\n<p><img src=\"../../../images/blog/web/nginx_config.png\" alt=\"nginx_config.png\"></p>\n<p>测试是否生效</p>\n<pre><code class=\"language-bash\"># 打开浏览器的console，测试是否有转换成功\nlocation.host # zuo11.com 或 www.zuo11.com</code></pre>\n<p>参考：</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/yiwd/p/3230371.html\">nginx 域名跳转 Nginx跳转自动到带www域名规则配置、nginx多域名向主域名跳转</a></p>\n</li>\n<li><p><a href=\"http://nginx.org/en/docs/http/converting_rewrite_rules.html\">Converting rewrite rules - nginx</a></p>\n</li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "nginx访问不带www的域名，自动切到www"
        }
      ],
      "config": {
        "source": "nginx访问不带www的域名，自动切到www.md",
        "staticFileName": "www_redirect.html",
        "author": "guoqzuo",
        "createDate": "2020/02/08",
        "description": "在seo时，搜索引擎可能会将xx.com和www.xx.com一起收录。这里需要进行处理，当使用一级域名直接访问时(xx.com)，自动切到www.xx.com，下面来看看怎么配置nginx",
        "keywords": "不带www跳转到www二域名,xx.com重定向到www.xx.com",
        "category": "网站建设与SEO",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"mysql中char与varchar的区别\">mysql中char与varchar的区别</h1>\n<p>在创建表，指定字段数据类型时，如果是字符串数据类型可以是varchar(50)，也可以是char(50)。这两种有什么区别呢？</p>\n<ol>\n<li>它们都是用来储存字符数值小于255的字符, mysql5.0之前是varchar支持最大255。</li>\n<li>varchar(40)存入&quot;Bill Gates&quot;，取出数据时字符串长度为10；char(40)存入&quot;Bill Gates&quot;，取出数据时字符串长度为40, 后面会被加多余的空格。</li>\n<li>varchar使用可能会更方便、所占用内存空间更小，特别是当数据库比较大时，内存和磁盘空间的节省会非常重要。</li>\n<li>从系统性能讲，char处理速度更快，有时可以超出varchar处理速度的50%。</li>\n<li>在设计数据库时应综合考虑各方面因素，来达到一个平衡。</li>\n</ol>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "mysql中char与varchar的区别"
        }
      ],
      "config": {
        "source": "mysql中char与varchar的区别.md",
        "staticFileName": "char_varchar.html",
        "author": "guoqzuo",
        "createDate": "2020/02/12",
        "description": "在创建表，指定字段数据类型时，如果是字符串数据类型可以是varchar(50)，也可以是char(50)。这两种有什么区别呢？",
        "keywords": "char和varchar的区别,char varchar区别",
        "category": "后端数据库等",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"为什么书上sql语句一般都是大写\">为什么书上SQL语句一般都是大写</h1>\n<p>一般我比较喜欢小写的sql语句，比如：</p>\n<pre><code class=\"language-bash\">select * from tb_user; # 一般习惯用法\nSELECT * FROM tb_user; # 教材或书上的写法</code></pre>\n<p>为什么小写更直观，而不使用小写呢？今天在看语法时，有了一个答案，来看一个例子</p>\n<pre><code class=\"language-bash\"># select ... from 内连接语法\n# 先来看全小写的写法\nselect some_colums from tb1 inner join tb2 on some_conditions;\n# 教科书上的写法\nSELECT some_colums FROM tb1 INNER JOIN tb2 ON some_confitions;</code></pre>\n<p><strong>你会发现可变动的内容一般是小写（比如：列名，表名，一些条件），而SQL语法相关的单词都是大写，这样更好理解</strong>。全小写描述语法时，对于初学者来看分不清哪些是SQL语句中必须的，哪些是可变动的。以后还是要习惯大写，更规范。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "为什么书上SQL语句一般都是大写"
        }
      ],
      "config": {
        "source": "为什么书上SQL语句一般都是大写.md",
        "staticFileName": "sql_uppercase.html",
        "author": "guoqzuo",
        "createDate": "2020/02/12",
        "description": "为什么小写更直观，而不使用小写呢？今天在看语法时，有了一个答案，你会发现可变动的内容一般是小写（比如：列名，表名，一些条件），而SQL语法相关的单词都是大写，这样更好理解。全小写描述语法时，对于初学者来看分不清哪些是SQL语句中必须的，哪些是可变动的。以后还是要习惯大写，更规范。",
        "keywords": "为什么书上SQL语句一般都是大写",
        "category": "后端数据库等",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"error-1396-hy000-operation-drop-user-failed-for-zhangsanlocalhost\">ERROR 1396 (HY000): Operation DROP USER failed for &#39;zhangsan&#39;@&#39;localhost&#39;</h1>\n<p>在看mysql账号相关内容时，发现在root用户下，更新、删除用户均报错。后面发现居然是localhost的字母拼错了，但新建user时居然没报错。下面来复盘整个记录：</p>\n<pre><code class=\"language-bash\"># 1. 先创建一个账号，用来测试修改用户名\nCREATE USER zhangsan@localost IDENTIFIED BY &#39;123&#39;;\n\n# 2. 在使用 RENAME USER ... TO ... 时，发现更改不了名字，一直报错\n# mysql&gt; RENAME USER &#39;zhangsan&#39;@&#39;localhost&#39; TO &#39;wangwu&#39;@&#39;localhost&#39;;\nERROR 1396 (HY000): Operation RENAME USER failed for &#39;zhangsan&#39;@&#39;localhost&#39;\n\n# 3. 于是我试了下删除，发现还是错误\n# mysql&gt; DROP USER zhangsan@localhost;\nERROR 1396 (HY000): Operation DROP USER failed for &#39;zhangsan&#39;@&#39;localhost&#39;\n\n# 4. 于是搜索了下，偶然看到一个测试的命令，仔细看发现host拼写错误，而我之前修改删除时host的localhost都是拼写正确的，所以没匹配到\nselect user,host from mysql.user where user = &#39;zhangsan&#39;;\n+----------+----------+\n| user     | host     |\n+----------+----------+\n| zhangsan | localost |\n+----------+----------+\n1 row in set (0.00 sec)\n\n# 5. 于是我将host改了下，再删除，就成功了。\nmysql&gt; DROP USER zhangsan@localost;\nQuery OK, 0 rows affected (0.01 sec)</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "ERROR 1396 (HY000): Operation DROP USER failed for 'zhangsan'@'localhost'"
        }
      ],
      "config": {
        "source": "ERROR 1396 (HY000): Operation DROP USER failed for 'zhangsan'@'localhost'.md",
        "staticFileName": "sql_localhost.html",
        "author": "guoqzuo",
        "createDate": "2020/02/18",
        "description": "在看mysql账号相关内容时，发现在root用户下，更新、删除用户均报错。后面发现居然是localhost的字母拼错了，但新建user时居然没报错。下面来复盘整个记录:",
        "keywords": "Operation DROP USER failed for,ERROR 1396 (HY000): Operation DROP USER failed for",
        "category": "后端数据库等",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"使用js调用vue单文件组件\">使用js调用vue单文件组件</h1>\n<p>在封装组件时，如果是dialog组件，一般封装好后，通过component引入，然后把标签放到html里，通过true或false来隐藏和显示，每次都要写一些重复代码。</p>\n<p>怎么能够像ElementUI的message函数一样直接调用呢，首先需要搞懂怎么用js来调用vue单文件组件，下面来看方法</p>\n<pre><code class=\"language-js\">// 假设写好了 showInfo.vue 组件，执行clickShow函数直接显示dialog\n// 组件中 dialog :visible.sync=&quot;dialogTableVisible&quot;初始值设置为true\n\n// demo.vue 在需要调用的vue文件中引入该组件\nimport ShowInfo from &#39;showInfo.vue&#39;\n// ...\nclickShow() {\n  const Component = Vue.extend(ShowInfo)\n\n  // 挂载后返回对应组件的vm\n  let showInfoVue = new Component().$mount() \n\n  // 将组件vm的dom，append到当前页面\n  this.$el.appendChild(showInfoVue.$el) \n}\n// ...</code></pre>\n<p>参考: </p>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/api/#vm-mount\">vm.$mount()</a></li>\n<li><a href=\"https://blog.csdn.net/u014445339/article/details/79596201\">JS 操作vue单文件组件</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "使用js调用vue单文件组件"
        }
      ],
      "config": {
        "source": "使用js调用vue单文件组件.md",
        "staticFileName": "js_vue_comp.html",
        "author": "guoqzuo",
        "createDate": "2020/02/20",
        "description": "在封装组件时，如果是dialog组件，一般封装好后，通过component引入，然后把标签放到html里，通过true或false来隐藏和显示，每次都要写一些重复代码。怎么能够像ElementUI的message函数一样直接调用呢，首先需要搞懂怎么用js来调用vue单文件组件，下面来看方法",
        "keywords": "使用js调用vue单文件组件",
        "category": "Vue",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"element-表单校验函数没生效的问题\">element 表单校验函数没生效的问题</h1>\n<p>根据element官网的dmeo，加入表单校验，发现校验的rules根本没执行。</p>\n<p>注意：<strong>el-form-item 标签也需要设置 prop 属性，并且名称需要和对应model的名称一致</strong></p>\n<p>我这次漏写了，所以一直没生效</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://element.eleme.cn/#/zh-CN/component/form#zi-ding-yi-xiao-yan-gui-ze\">表单 自定义校验规则 - element</a></li>\n<li><a href=\"https://blog.csdn.net/qq_36070288/article/details/88683747\">关于el-form中的rules未生效问题的解决方法</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "element 表单校验函数没生效的问题"
        }
      ],
      "config": {
        "source": "element表单校验函数没生效的问题.md",
        "staticFileName": "el_form_validate.html",
        "author": "guoqzuo",
        "createDate": "2020/02/24",
        "description": "根据element官网的dmeo，加入表单校验，发现校验的rules根本没执行。注意：el-form-item 标签也需要设置 prop 属性，并且名称需要和对应model的名称一致，我这次漏写了，所以一直没生效",
        "keywords": "element表单校验没生效",
        "category": "Vue",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"element-cascader显示异常问题\">element cascader显示异常问题</h1>\n<p>当cascader里选项比较多时，组件高度会异常，主要是 <code>.el-cascader-menu__wrap</code> 这个样式高度为100%，将cascader里其任意一父元素手动指定高度即可，但el-cascader-menu__wrap设置的效果最好</p>\n<pre><code class=\"language-css\">.el-cascader-menu__wrap {\n  max-height: 300px;\n  overflow: scroll;\n}</code></pre>\n<p>但这样设置后，可能会影响全局，这个是直接挂载在body元素下的，对其他模块会有影响，怎么解决这个影响呢？</p>\n<p>发现组件提供了一个 popper-class 属性，可以自定义浮层类名</p>\n<pre><code class=\"language-less\">// 用 popper-class指定一个class，比如my-container，防止污染全局样式\n.my-container {\n  .el-cascader-menu__wrap {\n    max-height: 300px;\n    overflow: scroll;\n  }\n}</code></pre>\n<p>总结：当写类似的组件时，如果需要在body里插入，需要有入口可以指定对应的自定义class，这样当多个页面需要时，不会产生样式干扰</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://element.eleme.cn/#/zh-CN/component/cascader#cascader-attributes\">cascader 组件popper-class属性</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000021033440\">vue element Cascader 高度过长问题？</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "element cascader显示异常问题"
        }
      ],
      "config": {
        "source": "element cascader显示异常问题.md",
        "staticFileName": "el_cascader.html",
        "author": "guoqzuo",
        "createDate": "2020/02/24",
        "description": "当cascader里选项比较多时，组件高度会异常，主要是 .el-cascader-menu__wrap 这个样式高度为100%，将cascader里其任意一父元素手动指定高度即可，但el-cascader-menu__wrap设置的效果最好",
        "keywords": "element cascader显示异常问题,element cascader高度问题",
        "category": "Vue",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"koa-ctxbody写在异步里接口会返回404的问题\">koa ctx.body写在异步里接口会返回404的问题</h1>\n<p>在前端mock上传的接口时，发现总是404，刚开始以为是代理的问题，后来单独写了个demo，发现如果ctx.body放在异步的回调，后端接收到请求了，但还是会返回404，下面来具体研究下</p>\n<p><img src=\"../../../images/blog/node/koa_body_async_404.png\" alt=\"koa_body_async_404.png\"></p>\n<pre><code class=\"language-js\">// 最简单的验证方法\nsetTimeout(() =&gt; {\n  ctx.body = {} // 只要是异步，前端就会返回404\n}, 0)</code></pre>\n<h2 id=\"用koa写个简单的测试demo\">用koa写个简单的测试demo</h2>\n<p>demo如下，nodemon index.js后，我们用postman请求 <code>http://127.0.0.1:9000</code> 时，如果用setTimeout包裹，会返回404 Not Found，去掉setTimeout就可以正常返回 <code>{ msg: &#39;成功&#39;}</code></p>\n<pre><code class=\"language-js\">// index.js\nconst Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\napp.use(ctx =&gt; {\n  setTimeout(() =&gt; {\n    ctx.body = {\n      msg: &#39;成功&#39;\n    }\n  }, 0)\n})\n\napp.listen(9000, () =&gt; {\n  console.log(&#39;server is start on 9000 port&#39;)\n})</code></pre>\n<h2 id=\"解决方法\">解决方法</h2>\n<p>在处理文件上传时，我们需要接收完所有文件数据后才响应结果给前端，接收上传肯定是一个异步操作，怎么解决这个问题呢？</p>\n<p><strong>注意：不要把 ctx.body 写在异步操作里，异步操作封装成函数，调用时用await来等待，完成后再设置ctx.body</strong>, 来看一个demo</p>\n<pre><code class=\"language-js\">const Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\napp.use(async ctx =&gt; {\n    await asyncOpt()\n    ctx.body = {\n      msg: &#39;成功&#39;\n    }\n})\n\nfunction asyncOpt() {\n  return new Promise(r =&gt; setTimeout(()=&gt; r(), 2000))\n}\n\napp.listen(9000, () =&gt; {\n  console.log(&#39;server is start on 9000 port&#39;)\n})</code></pre>\n<h2 id=\"实际应用\">实际应用</h2>\n<p>上面的例子中，两秒后会返回结果。如果可以把异步操作像demo中那样封装，就没问题。所以对于接收上传文件，我们可以这样处理</p>\n<pre><code class=\"language-js\">// 将文件数据接收，放到Promise里然后await，这样前端就不会404了\nlet data = await getUploadData(req)\nctx.body = {}\n\n// 用 promise 封装一层\nfunction getUploadData(req) {\n  return new Promise((resolve, reject) =&gt; {\n    let chunk = []\n    let size = 0\n    req.on(&#39;data&#39;, (data) =&gt; {\n      console.log(&#39;data&#39;, data)\n      chunk.push(data)\n      size += data.length\n    })\n\n    req.on(&#39;end&#39;, () =&gt; {\n      console.log(&#39;end&#39;)\n      const data = Buffer.concat(chunk, size)\n      resolve(data)\n    })\n  })\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "koa ctx.body写在异步里接口会返回404的问题",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "用koa写个简单的测试demo"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "解决方法"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "实际应用"
            }
          ]
        }
      ],
      "config": {
        "source": "koa ctx.body写在异步里接口会返回404的问题.md",
        "staticFileName": "koa_async_404.html",
        "author": "guoqzuo",
        "createDate": "2020/02/26",
        "description": "在前端mock上传的接口时，发现总是404，刚开始以为是代理的问题，后来单独写了个demo，发现如果ctx.body放在异步的回调，后端接收到请求了，但还是会返回404，下面来具体研究下",
        "keywords": "koa接口404,ctx.body写在异步操作里404",
        "category": "前端工程化",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"前端怎么获取文件上传进度以及使用node-mock上传文件接口demo\">前端怎么获取文件上传进度以及使用node mock上传文件接口demo</h1>\n<p>现在接口请求一般用的是axios，对于上传文件的进度监听，我们需要了解在axios的config参数里，可以传入onUploadProgress参数来接收upload进度事件，里面会有上传进度信息。我们前端怎么mock上传文件的接口呢？在koa处理时使用 <code>post-bodyparser</code> 可以很好的解析 <code>multipart/form-data</code> 数据，下面来具体看看</p>\n<p><img src=\"../../../images/blog/node/node_upload.png\" alt=\"node文件上传进度.png\"></p>\n<h2 id=\"前端demo\">前端demo</h2>\n<p>来看代码:</p>\n<pre><code class=\"language-html\">&lt;!-- 前端HTML --&gt;\n&lt;body&gt;\n  &lt;div&gt;\n    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;test&quot;&gt;\n    &lt;div id=&quot;progressDiv&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    let fileInput = document.getElementById(&#39;test&#39;)\n    let progressDiv = document.getElementById(&#39;progressDiv&#39;)\n\n    // 当input文件输入框值改变时\n    fileInput.onchange = () =&gt; {\n      let file = fileInput.files[0]\n      this.uploadFile(file)\n    } \n\n    // 上传文件到后台\n    async function uploadFile(file) {\n      let fd = new FormData()\n      fd.append(&#39;file&#39;, file)\n      fd.append(&#39;type&#39;, &#39;mask&#39;)\n      try {\n        let payload = fd\n        let res = await axios.post(&#39;/upload&#39;, payload, {\n          // axios 接收进度事件文档\n          // https://github.com/axios/axios#request-config\n          onUploadProgress: function (progressEvent) {\n            // {loaded: 1687552, total: 35353356, ...}\n            console.log(&#39;接收到进度事件&#39;, progressEvent)\n            progressDiv.innerHTML = `\n              &lt;div&gt;上传中，当前进度：${((progressEvent.loaded / progressEvent.total) * 100).toFixed(2) }% &lt;/div&gt; \n              &lt;div&gt;文件大小: ${progressEvent.loaded}/${progressEvent.total}\n            `\n          },\n        })\n        console.log(res)\n      } catch(e) {\n        cosnoel.error(e)\n      }\n    }\n  &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<h2 id=\"koa-mock上传接口\">koa mock上传接口</h2>\n<p>koa后端接收处理 upload.js</p>\n<pre><code class=\"language-js\">const Koa = require(&#39;koa&#39;)\nconst Router = require(&#39;koa-router&#39;)\nconst static = require(&#39;koa-static&#39;)\nconst BodyParser = require(&#39;post-bodyparser&#39;)\n\nconst router = new Router()\nconst app = new Koa()\n\napp.use(static(__dirname + &#39;/&#39;))\n\nrouter.post(&#39;/upload&#39;, async (ctx, next) =&gt; {\n  console.log(&#39;upload&#39;, ctx.url)\n  let { req } = ctx.request\n  const parser =  new BodyParser(req);\n  let body = await parser.formData()\n  console.log(body)\n  ctx.body = body\n})\n\napp.use(router.routes())\n\napp.listen(3000)\n\n// 打印内容\n// upload\n// /upload\n// { file:\n//    { value:\n//       &#39;/var/folders/mw/hbp6ytc9753gcm3zhqbmfkp40000gn/T/RAzvcR/9cd892b3-3243-4469-8cfa-ecbe2190a6ee.mongodb-macos-x86_64-4.2.2.tar&#39;,\n//      name: &#39;file&#39;,\n//      filename: &#39;mongodb-macos-x86_64-4.2.2.tar&#39;,\n//      contentType: &#39;application/x-tar&#39; },\n//   type: &#39;mask&#39; }</code></pre>\n<h2 id=\"完整demo-github地址\">完整demo github地址</h2>\n<p>完整demo，参见: <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/DebugDemo/upload%E4%B8%8A%E4%BC%A0%E8%BF%9B%E5%BA%A6\">upload文件上传demo - github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "前端怎么获取文件上传进度以及使用node mock上传文件接口demo",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "前端demo"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "koa mock上传接口"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "完整demo github地址"
            }
          ]
        }
      ],
      "config": {
        "source": "前端怎么获取文件上传进度以及使用node mock上传文件接口demo.md",
        "staticFileName": "upload_progress_monitor.html",
        "author": "guoqzuo",
        "createDate": "2020/02/26",
        "description": "现在接口请求一般用的是axios，对于上传文件的进度监听，我们需要了解在axios的config参数里，可以传入onUploadProgress参数来接收upload进度事件，里面会有上传进度信息。我们前端怎么mock上传文件的接口呢？在koa处理时使用 `post-bodyparser` 可以很好的解析 `multipart/form-data` 数据，下面来具体看看",
        "keywords": "前端获取文件上传进度,文件上传进度demo,怎么获取文件上传进度,axios文件上传进度监听,前端怎么mock上传文件接口",
        "category": "http与https",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"怎么使用一条命令安装多个npm包\">怎么使用一条命令安装多个npm包</h1>\n<p>在安装npm包时，我们一般使用 npm install xx --save，但对于一次需要安装多个包的情况，怎么用一条命令来安装呢？下面来看看</p>\n<pre><code class=\"language-bash\"># 安装多个包koa、koa-router、koa-static \nnpm install koa koa-router koa-static --save\n# npm notice created a lockfile as package-lock.json. You should commit this file.\n# npm WARN upload@1.0.0 No description\n# npm WARN upload@1.0.0 No repository field.\n\n# + koa-router@8.0.8\n# + koa@2.11.0\n# + koa-static@5.0.0\n# added 61 packages from 29 contributors in 22.996s\n# kevindeMacBook-Air:upload上传进度 kevin$</code></pre>\n<p>如果需要卸载已经写入package.json里的npm包</p>\n<pre><code class=\"language-bash\">npm uninstall 对应的包 --save</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "怎么使用一条命令安装多个npm包"
        }
      ],
      "config": {
        "source": "怎么使用一条命令安装多个npm包.md",
        "staticFileName": "npm_install_multiple.html",
        "author": "guoqzuo",
        "createDate": "2020/02/26",
        "description": "在安装npm包时，我们一般使用 npm install xx --save，但对于一次需要安装多个包的情况，怎么用一条命令来安装呢？下面来看看",
        "keywords": "怎么使用一条命令安装多个npm包,一条命令安装多个npm包",
        "category": "前端工程化",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"element怎么动态改变校验rules且实时生效\">element怎么动态改变校验rules且实时生效</h1>\n<p>在需要动态设置rules，并需要其实时生效的场景，一般需要将rules完成改变才行，这是为什么呢，下面来看看</p>\n<h2 id=\"实际应用场景\">实际应用场景</h2>\n<p>在做项目的过程中，需要需要动态变更rules的场景，有两个功能点：</p>\n<ol>\n<li>某个checkbox的值改变，有部分字段需要在必须和可选间切换</li>\n<li>某个cascader组件值改变时，需要动态切换部分字段（有删有减）</li>\n</ol>\n<p>需要注意的地方</p>\n<ol>\n<li>可选和必选切换，只需要改变rules里的require属性，true和false之间切换（我之前直接暴力删rule里的fields，这种方法不能关闭原来必选时触发的错误提示）</li>\n<li>对于动态修改rules后，必选的小红星以及之前的错误信息还在的问题，需要完全改变rules的值，才能重新触发校验，使前端页面更新</li>\n</ol>\n<pre><code class=\"language-js\">// 强制触发表单校验更新\nthis.rules = JSON.parse(JSON.stringify(this.rules))</code></pre>\n<h2 id=\"element对rules的监听逻辑\">element对rules的监听逻辑</h2>\n<pre><code class=\"language-js\">// 截取自element源码: https://github.com/ElemeFE/element/blob/dev/packages/form/src/form.vue\nwatch: {\n  rules() {\n    // remove then add event listeners on form-item after form rules change\n    this.fields.forEach(field =&gt; {\n        field.removeValidateEvents();\n        field.addValidateEvents();\n    });\n\n    if (this.validateOnRuleChange) {\n        this.validate(() =&gt; {});\n    }\n  }\n},</code></pre>\n<p>我们来看看element form 相关源码，可以看到使用watch监听rules的改变，没有使用deep，所以直接改变某个嵌套的属性时，是无法监听到的。这里可能是为了提高性能，就没加deep</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "element怎么动态改变校验rules且实时生效",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "实际应用场景"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "element对rules的监听逻辑"
            }
          ]
        }
      ],
      "config": {
        "source": "element怎么动态改变校验rules且实时生效.md",
        "staticFileName": "element_form_rules.html",
        "author": "guoqzuo",
        "createDate": "2020/02/27",
        "description": "在需要动态设置rules，并需要其实时生效的场景，一般需要将rules完成改变才行，这是为什么呢，下面来看看",
        "keywords": "element怎么动态改变校验rules且实时生,element el-form rules动态改变",
        "category": "Vue",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"el-form-item里非elment输入组件时，校验回调函数不触发的问题\">el-form-item里非elment输入组件时，校验回调函数不触发的问题</h1>\n<p>今天写表单校验规则，有个 el-form-item 里使用了富文本编辑器，发现校验规则校验这个值会有异常：</p>\n<ol>\n<li>当 change 或 blur 时，根本没有触发校验(提示错误)</li>\n<li>提交表单时，当该字段校验失败会提示错误，但该字段符合要求时，validate的回调一直没触发，导致无法进行校验成功之后的下一步操作</li>\n</ol>\n<p>将富文本编辑器换成 el-input 正常，换成普通的 input 也会异常，感觉一头雾水。</p>\n<p>使用 this.$refs.ruleForm.validateField(&#39;xxx&#39;) 单读校验也不行，这个应该是element表单输入组件特有的</p>\n<p>于是粗略看了下源码，发现错误信息在form-item(也就是el-form-item)组件里处理，当el-select或el-input值改变时会将事件传递给form-item</p>\n<p>两个不同的组件，一个组件里怎么捕获到另一个组件的事件呢，在element内部使用了发布订阅设计模式来处理：</p>\n<ol>\n<li>在form-item里订阅事件</li>\n<li>当el-input或el-select等elemnt表单输入组件的值改变时，发布事件</li>\n</ol>\n<p>来看源码</p>\n<pre><code class=\"language-js\">// 在 form-item 里订阅事件\n// https://github.com/ElemeFE/element/blob/1.x/packages/form/src/form-item.vue\nif (rules.length || this._props.hasOwnProperty(&#39;required&#39;)) {\n  this.$on(&#39;el.form.blur&#39;, this.onFieldBlur);\n  // 订阅了el.form.change事件\n  this.$on(&#39;el.form.change&#39;, this.onFieldChange);\n}\n\n// 当 el-input 值改变时，发布事件\n// https://github.com/ElemeFE/element/blob/1.x/packages/input/src/input.vue\n// el-input\nsetCurrentValue(value) {\n  if (value === this.currentValue) return;\n  this.$nextTick(_ =&gt; {\n    this.resizeTextarea();\n  });\n  this.currentValue = value;\n  if (this.validateEvent) {\n    // 发布el.form.change事件\n    this.dispatch(&#39;ElFormItem&#39;, &#39;el.form.change&#39;, [value]);\n  }\n}\n\n// el-select\n// https://github.com/ElemeFE/element/blob/1.x/packages/select/src/select.vue\nvalue(val) {\n  if (this.multiple) {\n    this.resetInputHeight();\n    if (val.length &gt; 0 || (this.$refs.input &amp;&amp; this.query !== &#39;&#39;)) {\n      this.currentPlaceholder = &#39;&#39;;\n    } else {\n      this.currentPlaceholder = this.cachedPlaceHolder;\n    }\n  }\n  this.setSelected();\n  if (this.filterable &amp;&amp; !this.multiple) {\n    this.inputLength = 20;\n  }\n  this.$emit(&#39;change&#39;, val);\n  this.dispatch(&#39;ElFormItem&#39;, &#39;el.form.change&#39;, val);\n}</code></pre>\n<p>所以，如果表单里使用了非element输入组件，比如普通的input，当值改变或输入框失去焦点时，没有发布对应的事件，那么form-item组件就不会触发校验</p>\n<p>怎么来处理呢？这里暂时采用自定义方法来处理：</p>\n<ol>\n<li>从rules移除对应的字段 required，至于label前面的红星，直接在el-form-item__label类上加一个before属性来设置</li>\n<li>对于行内显示错误信息，可以在el-form-item__label的after里显示错误信息，通过一个父类的error-class来控制隐藏显示</li>\n<li>单独写校验逻辑，如果校验失败加上一个error-class，如果想做的更逼真一点，在错误时给输入组件加一个红色的border</li>\n</ol>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "el-form-item里非elment输入组件时，校验回调函数不触发的问题"
        }
      ],
      "config": {
        "source": "el-form-item里非elment输入组件时，校验回调函数不触发的问题.md",
        "staticFileName": "not_element_input_validate.html",
        "author": "guoqzuo",
        "createDate": "2020/02/27",
        "description": "今天写表单校验规则，有个 el-form-item 里使用了富文本编辑器，发现校验规则校验这个值会有异常: 1. 当 change 或 blur 时，根本没有触发校验(提示错误) 2. 提交表单时，当该字段校验失败会提示错误，但该字段符合要求时，validate的回调一直没触发，导致无法进行校验成功之后的下一步操作，将富文本编辑器换成 el-input 正常，换成普通的 input 也会异常，感觉一头雾水。",
        "keywords": "element表单校验时如果非element组件会触发布料校验,富文本编辑器在element form中校验回调函数不触发的问题",
        "category": "Vue",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"怎么给三角形加border，添加到我的小程序ui实现以及需要注意的问题\">怎么给三角形加border，添加到我的小程序UI实现以及需要注意的问题</h1>\n<p>在给小程序添加 &quot;添加到我的小程序&quot; 引导时，里面有个带边框的三角形，如下图</p>\n<p><img src=\"../../../images/blog/mp/border_border.png\" alt=\"border_border.png.png\"></p>\n<p>一般用css画三角形使用的是border，但三角形边的边框怎么画呢？一般用两个三角形叠加来实现</p>\n<pre><code class=\"language-html\">&lt;view class=&quot;add-to-mymptips&quot;&gt;\n  &lt;view class=&quot;atm-angle-a&quot;&gt;&lt;/view&gt;\n  &lt;view class=&quot;atm-angle-b&quot;&gt;&lt;/view&gt;\n  &lt;view class=&quot;atm-main&quot;&gt;\n    点击 &lt;image src=&quot;/images/three_point.png&quot;&gt;&lt;/image&gt; 添加到我的小程序，微信首页下拉即可快速访问小程序\n  &lt;/view&gt;\n&lt;/view&gt;</code></pre>\n<p>来看css样式</p>\n<pre><code class=\"language-css\">.add-to-mymptips {\n  position: absolute;\n  right: 15px;\n  width: 270px;\n  margin-top:15px;\n  box-sizing: border-box;\n}\n\n/* 主内容区域 */\n.atm-main {\n  padding: 15px;\n  border: 1px solid #ddd;\n  border-radius: 5px;\n  box-shadow: 0 0 10px #ccc;\n  color:rgb(53, 53, 53);\n}\n\n/* 三个点图片样式 */\n.atm-main image {\n  width: 33px;\n  height: 15px;\n}\n\n/* 三角形+边框 区域 */\n.atm-angle-a, .atm-angle-b {\n  position: absolute;\n  margin-left:200px;\n  width: 0;\n  height: 0;\n  border: 10px solid;\n}\n.atm-angle-a {\n  top: -20px;\n  border-color: transparent transparent #ccc;\n}\n.atm-angle-b {\n  top:-19px;\n  border-color: transparent transparent #fff;\n}</code></pre>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/blosaa/p/3823695.html\">纯CSS写三角形-border法</a></li>\n</ul>\n<h2 id=\"添加到我的小程序引导tips被原生组件遮挡的问题\">添加到我的小程序引导tips被原生组件遮挡的问题</h2>\n<p>在小程序里，为了增加用户留存，会做一个引导用户添加到我的小程序的提示面板</p>\n<p>今天自己实现了下，发现原生组件遮挡了这个提示，貌似暂时没有很好的解决方法</p>\n<p>所以，当设计小程序UI时，尽量不要在顶部使用原生组件。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html#%E5%8E%9F%E7%94%9F%E7%BB%84%E4%BB%B6%E7%9B%B8%E5%AF%B9%E5%B1%82%E7%BA%A7\">原生组件相对层级 - 小程序</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "怎么给三角形加border，添加到我的小程序UI实现以及需要注意的问题",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "添加到我的小程序引导tips被原生组件遮挡的问题"
            }
          ]
        }
      ],
      "config": {
        "source": "怎么给三角形加border，添加到我的小程序UI实现以及需要注意的问题.md",
        "staticFileName": "border_border.html",
        "author": "guoqzuo",
        "createDate": "2020/02/29",
        "description": "在给小程序添加 '添加到我的小程序' 引导时，里面有个带边框的三角形，一般用css画三角形使用的是border，但三角形边的边框怎么画呢？一般用两个三角形叠加来实现",
        "keywords": "css 三角形加border,css 用border画的三角形怎么加border,小程序添加到我的小程序引导UI实现",
        "category": "CSS",
        "year": "2020",
        "month": "2"
      }
    },
    {
      "htmlStr": "<h1 id=\"网页深色模式样式适配web-dark-mode-support\">网页深色模式样式适配(web dark mode support)</h1>\n<p>目前iOS，macos都有了深色模式，而最近微信最新版也做了深色模式(dark mode)适配，我试了下，手机切换时页面效果样式是实时刷新的。于是就想着web怎么能够监听深色模式，并设置样式。查了资料后，在Stack Overflow上找到了答案，下面来看看</p>\n<p>一般通过css里的媒体查询就能适配深色模式: (prefers-color-scheme: dark)，先来看看怎么用js获取当前是否是深色模式</p>\n<h2 id=\"怎么用js判断当前是否是深色模式\">怎么用js判断当前是否是深色模式</h2>\n<pre><code class=\"language-js\">// 获取当前是否是深色模式\n// window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;).matches\nwindow.matchMedia &amp;&amp; console.log(&#39;Is dark mode: &#39;, window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;).matches)</code></pre>\n<h2 id=\"js实时监听深色模式的切换\">js实时监听深色模式的切换</h2>\n<pre><code class=\"language-js\">// 用js监听深色模式的切换事件\nwindow.matchMedia &amp;&amp; window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;).addEventListener(&#39;change&#39;, (event) =&gt; {\n  console.log(&#39;dark mode change，已&#39; + (event.matches ? &#39;进入&#39;: &#39;退出&#39;) + &#39;dark mode&#39;)\n})</code></pre>\n<p>window.matchMedia到底是用来做什么的？我查了下mdn，发现了这样一个示例</p>\n<pre><code class=\"language-js\">let mql = window.matchMedia(&#39;(max-width: 600px)&#39;);\n\ndocument.querySelector(&quot;.mq-value&quot;).innerText = mql.matches;</code></pre>\n<h2 id=\"怎么用css媒体查询处理深色模式样式\">怎么用css媒体查询处理深色模式样式</h2>\n<p>从这个例子看，大概就知道怎么用css来支持dark模式了吧，就是加一个类似小屏适配的一个媒体查询样式，来看个例子</p>\n<pre><code class=\"language-css\">/* dark mode support */\n@media (prefers-color-scheme: dark) {\n  body {\n    background-color: black;\n    color: #aaa;\n  }\n\n  body .content article, header, aside &gt; div, footer  {\n    border-color: #333;\n    color: #aaa;\n    background-color: black;\n    box-shadow: 0 0 10px #333;\n  }\n}</code></pre>\n<p>深色模式下，一般将背景调暗，字体设置为偏白色即可。zuo11.com 已用上面的方法适配了深色模式，可以体验下。网站是开源的，<a href=\"https://github.com/zuoxiaobai/zuo11.com/blob/master/src/global.css\">zuo11.com深色模式支持代码 - github</a></p>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/56393880/how-do-i-detect-dark-mode-using-javascript\">How do I detect dark mode using JavaScript? - Stack Overflow</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia\">window.matchMedia | MDN</a></li>\n<li><a href=\"https://developer.apple.com/documentation/xcode/supporting_dark_mode_in_your_interface\">Supporting Dark Mode in Your Interface | Apple Developer Documentation</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "网页深色模式样式适配(web dark mode support)",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "怎么用js判断当前是否是深色模式"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "js实时监听深色模式的切换"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "怎么用css媒体查询处理深色模式样式"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "网页深色模式样式适配(web dark mode support).md",
        "staticFileName": "drak_mode.html",
        "author": "guoqzuo",
        "createDate": "2020/03/28",
        "description": "web dark mode，网页js怎么监听深色模式改变事件，window.matchMedia, (prefers-color-scheme: dark)，目前iOS，macos都有了深色模式，而最近微信最新版也做了深色模式(dark mode)适配，我试了下，手机切换时页面效果样式是实时刷新的。于是就想着web怎么能够监听深色模式，并设置样式。查了资料后，在Stack Overflow上找到了答案，下面来看看",
        "keywords": "window.matchMedia, web drak mode event,web dark mode,web深色模式,网页深色模式,网页怎么监听深色模式,(prefers-color-scheme: dark)",
        "category": "CSS",
        "year": "2020",
        "month": "3"
      }
    },
    {
      "htmlStr": "<h1 id=\"js操作复制copy的内容，向复制内容中追加内容\">JS操作复制copy的内容，向复制内容中追加内容</h1>\n<p>在csdn等网站上，我们cttrl+c，ctrl+v时，会发现粘贴后的内容加了当前的作者信息、链接、版权问题等说明。那这个功能是怎么实现的呢？</p>\n<p><img src=\"../../../images/blog/js/js_opt_copy.png\" alt=\"js_opt_copy.png\"></p>\n<p>在JS高程中，有讲这一块的内容，下面来看看</p>\n<p><strong>监听body里的copy事件，然后用 document.getSelection()获取内容，追加内容后，再使用event.clipboardData.setData像粘贴板里写入内容</strong></p>\n<pre><code class=\"language-js\">// 操作粘贴板\n// JS高程3 表单脚本 操作粘贴板\n// https://www.yuque.com/guoqzuo/js_es6/ubpn7k#8482e7c5\ndocument.body.oncopy = function(event) {\n  console.log(&#39;copy&#39;, event);\n  // 获取copy的内容\n  // console.log(document.getSelection().toString());\n  // 在copy内容里加入信息\n  var msg = `\n-----------------------------\n标题：${document.title}\n链接：${location.href}\n作者：guoqzuo (http://github/zuoxiaobai)\n  `\n  event.clipboardData.setData(&#39;text/plain&#39;, `${document.getSelection().toString()} ${msg}`);\n  event.preventDefault();\n};</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JS操作复制copy的内容，向复制内容中追加内容"
        }
      ],
      "config": {
        "source": "JS操作复制copy的内容，向复制内容中追加内容.md",
        "staticFileName": "js_copy_opt.html",
        "author": "guoqzuo",
        "createDate": "2020/03/02",
        "description": "在csdn等网站上，我们cttrl+c，ctrl+v时，会发现粘贴后的内容加了当前的作者信息、链接、版权问题等说明。那这个功能是怎么实现的呢？在JS高程中，有讲这一块的内容，下面来看看",
        "keywords": "js操作粘贴板内容,js向copy的内容中追加信息,js向复制信息里追加内容",
        "category": "JavaScript",
        "year": "2020",
        "month": "3"
      }
    },
    {
      "htmlStr": "<h1 id=\"js怎么监听当前页面滚动比例，完整ui实现demo\">JS怎么监听当前页面滚动比例，完整UI实现demo</h1>\n<p>在阮一峰的es6入门教程里，顶部有一个计算页面百分比的UI，于是就想尝试实现这个功能，恰好在js高程3里有对应的描述，来看看</p>\n<p><img src=\"../../../images/blog/js/page_scroll_percent.png\" alt=\"page_scroll_percent.png\"></p>\n<p>监听页面的scroll事件，整个滚动距离为 document.documentElement.scrollHeight - window.innerHeight，当前scrollTop除以整个滚动距离，就是页面的百分比，向body挂载两个div来显示进度信息</p>\n<p>完整demo</p>\n<pre><code class=\"language-js\">// 页面滚动比例监听\n// posTop 顶部类似阮一峰ES6网页的滚动进度条\n// pos 右下角滚动百分比\n// JS高程3 - UI事件 scroll事件\n// https://www.yuque.com/guoqzuo/js_es6/elgng1#e38771e5\nlet htmlStr = `\n  &lt;div id=&quot;posTop&quot; style=&quot;position: fixed;top:0;height:2px;background: #25b864;z-index:999999;&quot;&gt;&lt;/div&gt;\n  &lt;div id=&quot;pos&quot; style=&quot;display:none;position:fixed;bottom: 100px;right:20px;padding:10px;background: #25b864;color:white;width:40px;text-align: center;border-radius:5px;&quot;&gt;&lt;/div&gt;\n`\nlet eleNode = document.createElement(&#39;div&#39;)\neleNode.innerHTML = htmlStr\ndocument.body.appendChild(eleNode)\n\nwindow.addEventListener(&#39;scroll&#39;, function(e) {\n  let scrollTop = document.documentElement.scrollTop;\n  let total = document.documentElement.scrollHeight - window.innerHeight;\n  let persentage = parseInt(scrollTop/total*100);\n  // console.log(scrollTop);  \n\n  document.getElementById(&#39;pos&#39;).style.display = scrollTop === 0 ? &#39;none&#39; : &#39;block&#39;;\n  document.getElementById(&#39;pos&#39;).innerHTML = `${persentage}%`;\n  document.getElementById(&#39;posTop&#39;).style.width = `${persentage}%`;\n}, false)</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JS怎么监听当前页面滚动比例，完整UI实现demo"
        }
      ],
      "config": {
        "source": "JS怎么监听当前页面滚动比例，完整UI实现demo.md",
        "staticFileName": "js_scorll_percent.html",
        "author": "guoqzuo",
        "createDate": "2020/03/02",
        "description": "在阮一峰的es6入门教程里，顶部有一个计算页面百分比的UI，于是就想尝试实现这个功能，恰好在js高程3里有对应的描述，来看看",
        "keywords": "页面滚动比例监听",
        "category": "JavaScript",
        "year": "2020",
        "month": "3"
      }
    },
    {
      "htmlStr": "<h1 id=\"网页中怎么实时监听网络变动并给出提示\">网页中怎么实时监听网络变动并给出提示</h1>\n<p>在js高程3中有讲过一个内容，叫做离线检测，就是监听页面的online和offline事件，这样在断网或再次连接到网络时，就会有对应的提示，下面是zuo11.com使用的网络检测功能，可以参考下</p>\n<p><img src=\"../../../images/blog/js/offline_check.png\" alt=\"offline_check.png\"></p>\n<pre><code class=\"language-js\">// 当网络状态发生改变时（有网 =&gt; 无网，无网 =&gt; 有网）,提示信息\n// JS高程3 离线检测\n// 参考: https://www.yuque.com/guoqzuo/js_es6/sp2k81#244d3090\nlet errorMsgNode // 用来移除错误信息节点\nwindow.ononline = function(event) {\n  errorMsgNode &amp;&amp; document.body.removeChild(errorMsgNode)\n  message(&#39;success&#39;, &#39;网络已连接&#39;, 3000)\n}\nwindow.onoffline = function(event) {\n  message(&#39;error&#39;, &#39;网络已断开&#39;)\n}\n/**\n * 为了显示网络信息，专门写了个小tips提示函数，在顶部显示信息\n * @param {}} type 文字颜色 error 为红色，其他为绿色\n * @param {*} msg 显示信息\n * @param {*} sec 如果有传入时间，sec秒后关闭提示\n */\nfunction message(type, msg, sec) {\n  let color = type === &#39;error&#39; ? &#39;red&#39; : &#39;green&#39;\n  let cssArr = [\n    &#39;position:fixed;top:8px;left:50%;z-index:9999999;&#39;,\n    &#39;transform:translateX(-50%);padding:5px 10px;background:#fff;&#39;\n  ]\n  let htmlStr = `\n    &lt;div style=&quot;${cssArr.join(&#39;&#39;)}color:${color}&quot;&gt;${msg}&lt;/di&gt;\n  `\n  let node = document.createElement(&#39;div&#39;)\n  node.innerHTML = htmlStr\n  document.body.appendChild(node)\n  if (Number.isInteger(sec) &amp;&amp; sec &gt; 0) {\n    setTimeout(() =&gt; {\n      document.body.removeChild(node)\n    }, sec)\n  } else {\n    // 错误信息，一直提示，需要设置到变量里，等网络连接上时移除\n    errorMsgNode = node\n  }\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "网页中怎么实时监听网络变动并给出提示"
        }
      ],
      "config": {
        "source": "网页中怎么实时监听网络变动并给出提示.md",
        "staticFileName": "1.html",
        "author": "guoqzuo",
        "createDate": "2020/03/02",
        "description": "在js高程3中有讲过一个内容，叫做离线检测，就是监听页面的online和offline事件，这样在断网或再次连接到网络时，就会有对应的提示，下面是zuo11.com使用的网络检测功能，可以参考下",
        "keywords": "js离线检测,js断网检测,js怎么实时监听网络变动",
        "category": "JavaScript",
        "year": "2020",
        "month": "3"
      }
    },
    {
      "htmlStr": "<h1 id=\"js怎么监听浏览器tab页切换？浏览器tab页切换时更改标题\">JS怎么监听浏览器tab页切换？浏览器tab页切换时更改标题</h1>\n<p>当用户点击了浏览器其他tab页离开页面，或者从其他tab页进入当前页，都会触发visibilitychange事件，根据docuemnt.hidden可以判断是否离开或回来，我们可以修改标题达到可视化的一个效果</p>\n<p><img src=\"../../../images/blog/js/tab_change_title.png\" alt=\"tab_change_title.png\"></p>\n<pre><code class=\"language-js\">// 实现tab间切换时，隐藏页面title改变功能\n// JS高程3 Page Visibility API(页面可见性API)\n// 参考：https://www.yuque.com/guoqzuo/js_es6/nocthb#0cf7a8b7\nvar title = document.title;\ndocument.addEventListener(&#39;visibilitychange&#39;, function (event) {\n  document.title =  document.hidden ? &#39;快回来 ~ &#39; : title\n  if (document.hidden) {\n    // 做一些暂停操作\n  } else {\n    // 开始操作\n  }\n}, false)</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JS怎么监听浏览器tab页切换？浏览器tab页切换时更改标题"
        }
      ],
      "config": {
        "source": "JS怎么监听浏览器tab页切换？浏览器tab页切换时更改标题.md",
        "staticFileName": "tab_change_title.html",
        "author": "guoqzuo",
        "createDate": "2020/03/02",
        "description": "当用户点击了浏览器其他tab页离开页面，或者从其他tab页进入当前页，都会触发visibilitychange事件，根据docuemnt.hidden可以判断是否离开或回来，我们可以修改标题达到可视化的一个效果",
        "keywords": "浏览器tab切换事件监听,visibilitychange,js 页面可见性API",
        "category": "JavaScript",
        "year": "2020",
        "month": "3"
      }
    },
    {
      "htmlStr": "<h1 id=\"使用new-date在前端获取当期时间是不准确的\">使用new Date()在前端获取当期时间是不准确的</h1>\n<p>一般我们在前端开发中，经常会用到new Date()来获取当前时间，但我们要知道：new Date()是获取的当前操作系统的时间，它是不准确的？</p>\n<h2 id=\"为什么不准确呢？\">为什么不准确呢？</h2>\n<p>因为我们知道电脑的时间是可以自己修改的。当我们修改了电脑上的时间，再用new Date()获取时间就是修改后的时间，而不是当前时间。</p>\n<h2 id=\"测试\">测试</h2>\n<p>下面我们来进行具体的测试</p>\n<h3 id=\"1打开百度，搜索-时间\">1.打开百度，搜索 &quot;时间&quot;</h3>\n<p>这样我们就可以看到当前的时间了，如下图</p>\n<p><img src=\"../../../images/blog/web/baidu_time.png\" alt=\"baidu_time.png\"></p>\n<h3 id=\"2打开console，打印new-date的值\">2.打开console，打印new Date()的值</h3>\n<p>在当前网页中，按下F12或者右键 - 查看，进入浏览器的 console，使用 new Date().toLocaleString() 来显示当前时间，如下图，我们可以看到，正常情况下，用new Date()获取当前时间，是准确的。</p>\n<p><img src=\"../../../images/blog/web/baidu_time_2.png\" alt=\"baidu_time_2.png\"></p>\n<h3 id=\"3修改系统时间\">3.修改系统时间</h3>\n<p>我们修改当前的时间为2019年，如下图</p>\n<p><img src=\"../../../images/blog/web/baidu_time_3.png\" alt=\"baidu_time_3.png\"></p>\n<h3 id=\"4再次打印new-date的值\">4.再次打印new Date()的值</h3>\n<p>修改时间后，我们再在console里打印 new Date().toLocaleString() 试试，我们发现这时候用new Date()获取的时间就不准确了，如下图</p>\n<p><img src=\"../../../images/blog/web/baidu_time_4.png\" alt=\"baidu_time_4.png\"></p>\n<h2 id=\"总结\">总结</h2>\n<p>通过上面的例子，我们可以发现前端获取时间是不准确的。<strong>因此，一般获取当前时间是后端来处理的，比如在发送信息时，记录当前信息的发送时间，一般是后端来记录</strong></p>\n<p>思考：后端来记录就没问题了吗？其实如果服务器系统的系统变更后，获取的时间也是不准确的。但一般不会有这个问题。就算有问题，这也不是前端的问题了，后端应该有一套机制来处理时间的问题。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "使用new Date()在前端获取当期时间是不准确的",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "为什么不准确呢？"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "测试",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "1.打开百度，搜索 \"时间\""
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "2.打开console，打印new Date()的值"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "3.修改系统时间"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "4.再次打印new Date()的值"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "总结"
            }
          ]
        }
      ],
      "config": {
        "source": "使用new Date()在前端获取当期时间是不准确的.md",
        "staticFileName": "new_date_fe.html",
        "author": "guoqzuo",
        "createDate": "2020/06/21",
        "description": "一般我们在前端开发中，经常会用到new Date()来获取当前时间，但我们要知道：new Date()是获取的当前操作系统的时间，它是不准确的？",
        "keywords": "前端获取当前时间是不准确的,new Date()获取当前时间不准确,new Date()获取当前时间是当前操作系统的时间",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "6"
      }
    },
    {
      "htmlStr": "<h1 id=\"开发个人微信小程序前必看，个人主体可以做什么内容\">开发个人微信小程序前必看，个人主体可以做什么内容</h1>\n<p>微信小程序很早就已经开放个人主体了，也就是说个人开发者也可以上传、发布自己的小程序。但现在个人主体的小程序可以做的内容越来越少了，相信很多开发者都遇到过这种情况：好不容易做好的小程序，在准备上线时，由于类目问题，提交审核被拒，导致小程序无法上线的情况。</p>\n<h2 id=\"微信小程序现状\">微信小程序现状</h2>\n<p>在19年我做小程序的时候，日记类的小程序个人还是可以做的，审核不会被拒，而且小程序名称也没有太多限制，现在这些都变了。</p>\n<h3 id=\"小程序名称的设置变的更加严格\">小程序名称的设置变的更加严格</h3>\n<p>现在稍微通用一点的关键字，比如包含 &quot;管理&quot; 两个字，可能会要求你提供上传手持身份证的照片，而且还要有对应的商标证书。如下图：</p>\n<p><img src=\"../../../images/blog/mp/mp_personal_cando.png\" alt=\"mp_personal_cando.png\"></p>\n<p>我搜索了下商标的问题，商标申请需要1000，且审批时间需要1年多... 对个人开发者来说，太难了</p>\n<h3 id=\"个人小程序容易被拒\">个人小程序容易被拒</h3>\n<p>只要名称中带有日记、记事方面的都会被拒绝，如下图</p>\n<p><img src=\"../../../images/blog/mp/mp_personal_cando_2.png\" alt=\"mp_personal_cando_2.png\"></p>\n<h2 id=\"为什么会有这种情况呢？\">为什么会有这种情况呢？</h2>\n<p>之所以会变严格，我的理解是</p>\n<ol>\n<li>小程序名称问题：由于每个小程序名称是唯一的，早期存在乱取名，抢注小程序名称的情况。可以想象，之前应该发生了很多次涉及小程序名称侵权被用户投诉的案列，所以，微信官方才会加强小程序名称的审核</li>\n</ol>\n<p><img src=\"../../../images/blog/mp/mp_personal_cando_3.png\" alt=\"mp_personal_cando_3.png\"></p>\n<ol start=\"2\">\n<li>个人小程序不能提供备忘录、日记、记事服务：这一块应该是涉及隐私问题，如果不限制，那么个人开发者可以轻易的获取的他人的隐私，对微信平台来讲会有风险。</li>\n</ol>\n<h2 id=\"那个人小程序可以做什么内容呢？\">那个人小程序可以做什么内容呢？</h2>\n<p>我们可以在小程序官方文档，运营 =&gt; 开放的服务类目 =&gt; <a href=\"https://developers.weixin.qq.com/miniprogram/product/material/#%E4%B8%AA%E4%BA%BA%E4%B8%BB%E4%BD%93%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E6%94%BE%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%B1%BB%E7%9B%AE\">个人主体小程序</a> 查看个人主体的小程序可以做什么内容</p>\n<p><img src=\"../../../images/blog/mp/mp_personal_cando_4.png\" alt=\"mp_personal_cando_4.png\"></p>\n<p>如上图所示，官方已经列出了个人小程序可以开发的内容，<strong>有些小程序个人主体是有资质要求的，需要提供一些许可证才行。因此，我们在开发个人主体的小程序时，一定要先看这个文档，查询下自己想要做的内容能不能做，是否有这个资质，不然做了也白做，审核会被拒绝，无法上线</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "开发个人微信小程序前必看，个人主体可以做什么内容",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "微信小程序现状",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "小程序名称的设置变的更加严格"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "个人小程序容易被拒"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "为什么会有这种情况呢？"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "那个人小程序可以做什么内容呢？"
            }
          ]
        }
      ],
      "config": {
        "source": "开发个人微信小程序前必看，个人主体可以做什么内容.md",
        "staticFileName": "mp_personal_cando.html",
        "author": "guoqzuo",
        "createDate": "2020/06/21",
        "description": "微信小程序很早就已经开放个人主体了，也就是个人也可以上传发布小程序。但现在个人主体小程序可以做的内容越来越少了，相信很多微信小程序的开发者都遇到过这种情况：好不容易做好了小程序，结果准备提交审核上线时，由于类目问题，审核被拒，无法上线的情况。",
        "keywords": "开发个人微信小程序前必看,小程序个人主体可以做什么内容,个人小程序审核被拒",
        "category": "微信开发",
        "year": "2020",
        "month": "6"
      }
    },
    {
      "htmlStr": "<h1 id=\"github-tag标签图片以及npm-badge图片生成\">github tag标签图片以及npm badge图片生成</h1>\n<p>在github写readme时，最开始一般会贴一些tab标签(徽章图片)，比如 build passing，license MIT 等，注意这些都是引入的图片，npm badge也是类似的情况下面来看看</p>\n<p><img src=\"../../../images/blog/web/github_tab_img.png\" alt=\"github_tab_img.png\"></p>\n<h2 id=\"github-tab标签图片\">github tab标签图片</h2>\n<pre><code class=\"language-js\">// 上图对应的三个徽章图片\n![version-v0.2.0](https://img.shields.io/badge/version-v0.2.0-yellow.svg) \n![build-passing](https://img.shields.io/badge/build-passing-green.svg) \n![license-MIT](https://img.shields.io/badge/license-MIT-green.svg) \n// 发现规律没，更改后面的参数，就可以生成不同的图片\n\n// 比如\nhttps://img.shields.io/badge/JAVA-1.8+-green.svg</code></pre>\n<h2 id=\"npm-徽章图片\">npm 徽章图片</h2>\n<p>主要适用于npm包，显示npm包的一些信息，只要把你npm包名替换掉对应的包名就可以了</p>\n<pre><code class=\"language-js\">// 文档 https://www.npmjs.com/package/npm-badge\n// zuo-blog npm包使用示例，只需要把对应的npm 包名称修改即可\n\n// ![NPM](https://nodei.co/npm/zuo-blog.png)  \n[![NPM](https://nodei.co/npm/zuo-blog.png)](https://npmjs.org/package/zuo-blog)</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "github tag标签图片以及npm badge图片生成",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "github tab标签图片"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "npm 徽章图片"
            }
          ]
        }
      ],
      "config": {
        "source": "github tag标签图片以及npm badge图片生成.md",
        "staticFileName": "github_badge_img.html",
        "author": "guoqzuo",
        "createDate": "2020/06/21",
        "description": "在github写readme时，最开始一般会贴一些tab标签(徽章图片)，比如 build passing，license MIT 等，注意这些都是引入的图片，npm badge也是类似的情况下面来看看",
        "keywords": "github tag标签图片,readme badge,npm badge",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "6"
      }
    },
    {
      "htmlStr": "<h1 id=\"利用koa来彻底理解web前端跨域问题\">利用koa来彻底理解web前端跨域问题</h1>\n<p>JS高程3中在Ajax那一章里有详细的讲解跨域的问题，由于是纯理论，之前看时只是了解个大概。之后学会了koa后，用koa来写测试接口模拟跨域的场景，对跨域问题有了更深层次的理解，下面来对跨域的相关知识点进行整理、回顾，并写demo做一些测试</p>\n<p><img src=\"../../../images/blog/node/koa_cros_1.png\" alt=\"koa_cros_1.png\"></p>\n<h2 id=\"什么是跨域？会产生跨域的三种情况\">什么是跨域？会产生跨域的三种情况</h2>\n<p>跨域是浏览器同源策略引起的接口调用问题，<strong>只针对XMLHttpRequest发出的请求</strong>。</p>\n<p><strong>协议、端口、host 三者有一个不同就会跨域</strong>，导致ajax请求接口失败</p>\n<p>以 <a href=\"http://127.0.0.1:9000\">http://127.0.0.1:9000</a> 为例</p>\n<ul>\n<li><code>http</code> 为协议，还可以是 <code>https</code></li>\n<li><code>127.0.0.1</code> 为 host，还可以是 baidu.com、api.xx.com等</li>\n<li><code>9000</code> 为端口，在不指定端口的情况下，默认http为80端口，https为443端口</li>\n</ul>\n<h2 id=\"本地模拟跨域场景\">本地模拟跨域场景</h2>\n<p>我们本地一般最简单的方式就是通过不同的端口来模拟出跨域的场景，现在我们用koa在本地创建两个服务，一个是在8000端口的静态文件服务，一个是在9000端口的接口服务</p>\n<p>静态文件服务</p>\n<pre><code class=\"language-js\">// 8000_static_server.js\nconst Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\napp.use(require(&#39;koa-static&#39;)(__dirname + &#39;/public&#39;)) // 静态服务\n\napp.listen(8000, () =&gt; console.log(&#39;服务已开启，端口 8000&#39;))</code></pre>\n<p>我们访问 <a href=\"http://127.0.0.1:8000\">http://127.0.0.1:8000</a> 就可以访问public/index.html到这个页面，这个页面再请求 9000端口的接口，就算跨域了。</p>\n<pre><code class=\"language-html\">&lt;button id=&quot;send-get-request&quot;&gt;发送get请求&lt;/button&gt;\n&lt;button id=&quot;send-post-request&quot;&gt;发送post请求&lt;/button&gt;\n&lt;script src=&quot;axios.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n  let sendGetRequest = document.getElementById(&#39;send-get-request&#39;)\n  let sendPostRequest = document.getElementById(&#39;send-post-request&#39;)\n  sendGetRequest.onclick = async () =&gt; {\n    try {\n      let res = await axios.get(&#39;http://127.0.0.1:9000/users&#39;)\n      console.log(res)\n    } catch(e) {\n      console.error(e)\n    }\n  }\n  sendPostRequest.onclick = async () =&gt; {\n    try {\n      let payload = { x: 1, y: 1}\n      let res = await axios.post(&#39;http://127.0.0.1:9000/info&#39;, payload)\n      console.log(res)\n    } catch(e) {\n      console.error(e)\n    }\n  }\n&lt;/script&gt;</code></pre>\n<p>接口服务</p>\n<pre><code class=\"language-js\">// 9000_api_server.js\nconst Koa = require(&#39;koa&#39;)\nconst Router = require(&#39;koa-router&#39;)\nconst app = new Koa()\nconst router = new Router()\n\n// 路由\nrouter.get(&#39;/users&#39;, ctx =&gt; ctx.body = &#39;users&#39;)\nrouter.post(&#39;/info&#39;, ctx =&gt; ctx.body = { b: 1 })\n\napp.use(router.routes()).use(router.allowedMethods())\n\napp.listen(9000, () =&gt; console.log(&#39;服务已开启，端口 9000&#39;))</code></pre>\n<p>点击发送get请求，chrome会报跨域限制的错误，请求失败</p>\n<p><img src=\"../../../images/blog/node/koa_cros_2.png\" alt=\"koa_cros_2.png\"></p>\n<pre><code class=\"language-js\">Access to XMLHttpRequest at &#39;http://127.0.0.1:9000/users&#39; from origin &#39;http://127.0.0.1:8000&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code></pre>\n<h2 id=\"跨域问题的解决方式\">跨域问题的解决方式</h2>\n<h3 id=\"img、link-元素\">img、link 元素</h3>\n<p>img和link元素都会给服务器发送get请求，因为这个并不属于ajax请求，所以浏览器不会阻止请求发送到服务端。我们可以利用这个特性来发送跨域请求，下面来看例子</p>\n<pre><code class=\"language-html\">&lt;button id=&quot;send-get-img&quot;&gt;使用img发送get请求&lt;/button&gt;\n&lt;button id=&quot;send-get-link&quot;&gt;利用link发送get请求&lt;/button&gt;\n&lt;script src=&quot;axios.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n  let sendGetRequestByImg = document.getElementById(&#39;send-get-img&#39;)\n  let sendGetRequestByLink = document.getElementById(&#39;send-get-link&#39;)\n  sendGetRequestByImg.onclick = async () =&gt; {\n    let img = document.createElement(&#39;img&#39;)\n    img.src = &#39;http://127.0.0.1:9000/users&#39;\n    img.style.display = &#39;none&#39;\n    document.body.appendChild(img)\n    setTimeout(() =&gt; {\n      document.body.removeChild(img)\n    }, 2000)\n  }\n  sendGetRequestByLink.onclick = async () =&gt; {\n    let link = document.createElement(&#39;link&#39;)\n    link.href = &#39;http://127.0.0.1:9000/users&#39;\n    link.rel = &#39;stylesheet&#39;\n    document.head.appendChild(link)\n    setTimeout(() =&gt; {\n      document.head.removeChild(link)\n    }, 2000)\n  }\n&lt;/script&gt;</code></pre>\n<p>img和link标签虽然都可以发送跨域的get请求，img常用于跟踪用户点击页面或动态广告曝光的次数。这种跨域方式都无法接收服务器响应的数据，请求是单向的。</p>\n<h3 id=\"script元素与jsonp\">script元素与JSONP</h3>\n<p>上面利用link元素与img元素，做get请求，那script理论上也是可以发送跨域get请求的，而且script元素还可以利用JSONP，接收后台的响应</p>\n<p>JSONP是JSON with padding(填充式JSON或参数式JSON)的简写，他由两部分组成:</p>\n<ol>\n<li>回调函数</li>\n<li>数据</li>\n</ol>\n<pre><code class=\"language-js\">callback({&quot;user&quot;: &quot;zhangsan&quot;})</code></pre>\n<p>当script元素接收到后端响应的JSONP数据时，会调用页面中对应的callback函数，而callback函数名字一般是通过前端请求url的查询参数来决定的，来看看看下面的例子</p>\n<pre><code class=\"language-html\">&lt;button id=&quot;send-get-script&quot;&gt;使用script发送get请求&lt;/button&gt;\n&lt;script&gt;\n  let sendGetRequestByScript = document.getElementById(&#39;send-get-script&#39;)\n  sendGetRequestByScript.onclick = async () =&gt; {\n    let script = document.createElement(&#39;script&#39;);\n    script.type=&quot;text/javascript&quot; \n    // script.src = &quot;http://127.0.0.1:9000/users&quot;\n    script.src = &quot;http://127.0.0.1:9000/jsonpTest?callback=handleRes&quot;\n    document.body.appendChild(script)\n    setTimeout(() =&gt; {\n      document.body.removeChild(script)\n    }, 2000)\n  }\n  // 这里可以接收到对应的数据\n  function handleRes(response) {\n    console.log(&#39;利用jsonp接收到的响应数据&#39;, response)\n  }\n&lt;/script&gt;</code></pre>\n<p>JSONP需要后端返回JSONP格式的数据，前端才能接收到响应，来看看node是怎么处理的</p>\n<pre><code class=\"language-js\">router.get(&#39;/jsonpTest&#39;, ctx =&gt; {\n  console.log(`接收到get请求${ctx.url}`)\n  let resdata = {\n    user: &#39;zhangsan&#39;\n  }\n  let jsonpData = `${ctx.query.callback}(${JSON.stringify(resdata)})`\n  console.log(&#39;ctx.query.callback&#39;, ctx.query.callback)\n  console.log(&#39;jsonpData&#39;, jsonpData) // handleRes({&quot;user&quot;:&quot;zhangsan&quot;})\n  ctx.body = jsonpData\n})</code></pre>\n<p>JSONP的缺点：</p>\n<ol>\n<li>不安全，后端返回的数据可以决定前端要执行的函数</li>\n<li>不容易确定JSONP请求是否失败</li>\n</ol>\n<h3 id=\"cors跨域资源共享\">CORS跨域资源共享</h3>\n<p>一般限制跨域请求这种安全策略可以预防某些恶意行为，但实现合理的跨域请求对开发web应用也是至关重要的，因此W3C提出了 CORS（Cross-Origin Resource Sharing, 跨域资源共享）的解决方案，<strong>CORS 定义了浏览器与服务器应该如何沟通，背后的基本思想是，使用自定义的HTTP头部让浏览器与服务器沟通，从而决定请求或响应是否成功</strong></p>\n<p>比如，前端在发送请求时，浏览器会自动附加一个额外的请求头 Origin，包含请求页面的源信息(协议、域名、端口)，下面是Origin头部的一个示例</p>\n<pre><code class=\"language-js\">Origin: http://127.0.0.1:8000</code></pre>\n<p>如果服务器认为可以接受该请求，可以在响应头 Access-Control-Allow-Origin 中发相同的源信息（或者 *），例如</p>\n<pre><code>Access-Control-Allow-Origin：http://127.0.0.1:8000</code></pre><p><strong>如果没有这个头部浏览器会驳回请求。也就是说，浏览器其实发送了请求，后端也接收到了请求，只是浏览器阻止了响应，并报错了，这一点很关键。</strong></p>\n<p>后端只要加一个响应头就可以解决跨域的问题，我们来试试，通过写一个中间件来允许跨域请求</p>\n<pre><code class=\"language-js\">// allowCors.js\nasync function allowCORS(ctx, next) {\n  console.log(ctx.headers[&#39;origin&#39;])\n  ctx.set({\n    &#39;Access-Control-Allow-Origin&#39;: &#39;http://127.0.0.1:8000&#39;\n    // &#39;Access-Control-Allow-Origin&#39;: ctx.headers[&#39;origin&#39;]\n    // &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;\n  })\n  next()\n}\n\nmodule.exports = allowCORS</code></pre>\n<p>在路由前面加一行，引入该中间件即可</p>\n<pre><code class=\"language-js\">app.use(require(&#39;./allowCors&#39;))</code></pre>\n<p>我们再来测试下发送请求，get请求可以了，没有提示跨域了，但post请求却还是提示跨域，这是为什么呢？这就涉及preflight，预检请求的概念了</p>\n<p><img src=\"../../../images/blog/node/cors_error.png\" alt=\"cors_error.png\"></p>\n<pre><code class=\"language-js\">Access to XMLHttpRequest at &#39;http://127.0.0.1:9000/info&#39; from origin &#39;http://127.0.0.1:8000&#39; has been blocked by CORS policy: Request header field content-type is not allowed by Access-Control-Allow-Headers in preflight response.</code></pre>\n<h4 id=\"为什么会有preflight预检请求\">为什么会有preflight预检请求</h4>\n<p>浏览器限制跨域有两种方式：</p>\n<ol>\n<li>浏览器限制发起跨域请求</li>\n<li>跨域请求可以正常发起，但返回的结果被浏览器拦截了</li>\n</ol>\n<p>一般浏览器都是使用第二种方式限制跨域请求，<strong>跨域请求已经到达服务器，并可能对数据库里的数据进行了操作，但返回的结果被浏览器拦截了，对前端来讲这是一次失败的请求，但可能对数据库里的数据产生了影响</strong></p>\n<p>为了防止这种情况发生，<strong>对于可能对服务器数据产生副作用的HTTP请求方法，浏览器会先使用OPTIONS方法发起一个预检请求</strong>，从而获知服务器是否允许跨域请求：如果允许，就发送带真实的数据请求，如果不允许，则阻止带数据的真实请求。</p>\n<h4 id=\"什么情况会发触发cors预检请求\">什么情况会发触发CORS预检请求?</h4>\n<ul>\n<li>使用了PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH请求方法</li>\n<li>人为设置了CORS安全的请求头之外的其他请求头，下面是安全的请求头列表<ul>\n<li>Accept </li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n<li>Content-Type</li>\n<li>DPR</li>\n<li>Downlink</li>\n<li>Save-Data</li>\n<li>Viewport-Width</li>\n<li>Width</li>\n<li>Content-Type值为 application/x-www-form-urlencoded、multipart/form-data、text/plain</li>\n</ul>\n</li>\n</ul>\n<p>现在知道刚才的POST请求为什么出错了吧，请求头里面Content-type为application/json，不是安全的请求头，需要加上一个请求头设置即可</p>\n<pre><code class=\"language-js\">&#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39; // 或 *</code></pre>\n<p>同理，当我们使用 put请求时，需要加上</p>\n<pre><code class=\"language-js\">&#39;Access-Control-Allow-Methods&#39;: &#39;PUT&#39; // 或 *，注意PUT要大写</code></pre>\n<p><img src=\"../../../images/blog/node/cors_preflight.png\" alt=\"cors_preflight.png\"></p>\n<h4 id=\"跨域请求默认不会携带cookie怎么处理\">跨域请求默认不会携带cookie怎么处理</h4>\n<p>axios 跨域请求 默认不发送cookie，如果想发送的请求携带cookie需要将withCredentials设置为true</p>\n<pre><code class=\"language-js\">// `withCredentials` indicates whether or not cross-site Access-Control requests\n// should be made using credentials\n// withCredentials: false, // default\naxios.defaults.withCredentials = true // 允许跨域请求发送cookie\n\n// OPTIONS需要加一个设置\n&#39;Access-Control-Allow-Credentials&#39;: &#39;true&#39;</code></pre>\n<h4 id=\"终极后端允许跨域请求头设置\">终极后端允许跨域请求头设置</h4>\n<p>因此终极的后端允许跨域的请求头设置为</p>\n<pre><code class=\"language-js\">ctx.set({\n  &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,\n  &#39;Access-Control-Allow-Headers&#39;: &#39;*&#39;,\n  &#39;Access-Control-Allow-Methods&#39;: &#39;*&#39;,\n  &#39;Access-Control-Allow-Credentials&#39;: &#39;true&#39;, // 允许携带cookie\n  &#39;Access-Control-Max-Age&#39;: 3600 // 对于相同的请求，仅在第一次发送options预检请求，之后1小时内不需要预检请求\n})</code></pre>\n<h3 id=\"服务器代理-devserverproxy\">服务器代理 devServer.proxy</h3>\n<p>还有一种跨域方式就是通过服务器代理的方式来进行跨域请求。就是请求同源服务器，通过该服务器转发请求到目标服务器，得到结果再转发给前端。</p>\n<pre><code class=\"language-js\">// http-proxy-middleware\nconst express = require(&#39;express&#39;);\nconst { createProxyMiddleware } = require(&#39;http-proxy-middleware&#39;);\n\nconst app = express();\napp.use(express.static(__dirname + &#39;/public&#39;))\n\napp.use(&#39;/users&#39;, createProxyMiddleware({ \n    target: &#39;http://127.0.0.1:9000&#39;, changeOrigin: true \n  })\n);\napp.use(&#39;/info&#39;, createProxyMiddleware({ \n    target: &#39;http://127.0.0.1:9000&#39;, changeOrigin: true \n  })\n);\napp.listen(7000);</code></pre>\n<p>有没有很熟悉？其实我们在vue.config.js里面配置devServer的proxy属性就是调用类似的方法</p>\n<h2 id=\"参考\">参考</h2>\n<p>更多细节可以参考下面的文档</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX\">Ajax - Web 开发者指南 | MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\">XMLHttpRequest - Web APIs | MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\">跨來源資源共用（CORS） - HTTP | MDN</a></li>\n<li><a href=\"https://www.jianshu.com/p/b55086cbd9af\">前端 | 浅谈preflight request - 简书</a></li>\n<li><a href=\"https://www.yuque.com/guoqzuo/rdrqd5/pwlw7i#f5457f4a\">前端跨域问题 - 网络编程 | Node笔记</a></li>\n<li><a href=\"https://www.yuque.com/guoqzuo/js_es6/fcw53h#ac35dda4\">跨域资源共享 | JS高程3笔记</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "利用koa来彻底理解web前端跨域问题",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "什么是跨域？会产生跨域的三种情况"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "本地模拟跨域场景"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "跨域问题的解决方式",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "img、link 元素"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "script元素与JSONP"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "CORS跨域资源共享",
                  "children": [
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "为什么会有preflight预检请求"
                    },
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "什么情况会发触发CORS预检请求?"
                    },
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "跨域请求默认不会携带cookie怎么处理"
                    },
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "终极后端允许跨域请求头设置"
                    }
                  ]
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "服务器代理 devServer.proxy"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "利用koa来彻底理解web前端跨域问题.md",
        "staticFileName": "koa_web_cros.html",
        "author": "guoqzuo",
        "createDate": "2020/06/21",
        "description": "JS高程3中在Ajax那一章里有详细的讲解跨域的问题，由于是纯理论，之前看时只是了解个大概。之后学会了koa后，用koa来写测试接口模拟跨域的场景，对跨域问题有了更深层次的理解，下面来对跨域的相关知识点进行整理、回顾，并写demo做一些测试",
        "keywords": "web前端跨域问题,web跨域,前端跨域,请求预检,cros,跨域资源共享",
        "category": "http与https",
        "year": "2020",
        "month": "6"
      }
    },
    {
      "htmlStr": "<h1 id=\"invalid-character-in-header-content-content-disposition\">Invalid character in header content [&quot;Content-Disposition&quot;]</h1>\n<p>在koa中，如果Content-Disposition里设置文件名有中文会提示错误，需要用类似 encodeURIComponent 转码的函数转码后才行</p>\n<pre><code class=\"language-js\">const fileName = encodeURIComponent(&#39;这是一个文件&#39;) // 需要先转码才行\nctx.set({\n  &#39;Content-Type&#39;: &#39;application/x-tar&#39;,\n  &#39;Content-Disposition&#39;: `attachment; filename=&quot;${fileName}.tar&quot;`\n})</code></pre>\n<h2 id=\"encodeuricomponent与encodeuri的区别\">encodeURIComponent与encodeURI的区别</h2>\n<p>在JS高程3的第5章：引用类型 - 单体内置对象 - Global对象里有将对应的内容</p>\n<h3 id=\"什么是uri\">什么是URI</h3>\n<ul>\n<li>URI (Uniform Resource Identifiers，统一资源标识符) 在某个规则下把资源独一无二的标识出来</li>\n<li>URL (Uniform Resource Locator，同一资源定位符) URL是用定位的方式实现的URI。</li>\n</ul>\n<h3 id=\"uri与url的区别\">URI与URL的区别</h3>\n<blockquote>\n<p>统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是URI的一个实例，通过名字这个字符串就可以标识出唯一的一个人。现实当中名字当然是会重复的，所以身份证号才是URI，通过身份证号能让我们能且仅能确定一个人。那统一资源定位符URL是什么呢。也拿人做例子然后跟HTTP的URL做类比，就可以有：动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。URL是以描述人的位置来唯一确定一个人的。在上文我们用身份证号也可以唯一确定一个人。对于这个在杭州的张三，我们也可以用：身份证号：123456789来标识他。所以不论是用定位的方式还是用编号的方式，我们都可以唯一确定一个人，都是URl的一种实现，而URL就是用定位的方式实现的URI。</p>\n</blockquote>\n<p>参考: <a href=\"https://www.zhihu.com/question/21950864/answer/154309494\">HTTP 协议中 URI 和 URL 有什么区别？</a></p>\n<h3 id=\"encodeuricomponent与encodeuri的作用\">encodeURIComponent与encodeURI的作用</h3>\n<p>由于有效的<strong>URI不能包含某些字符，如空格以及其他特殊字符</strong>。这两个函数可以对URI进行编码，以便发送给浏览器</p>\n<p>他们的区别是：<strong>encodeURI只转义空格，encodeURIComponent会转义所有的非字母数字字符</strong></p>\n<pre><code class=\"language-js\">var uri = &quot;http://www.zuo11.com/test value.html#start&quot;;\nencodeURI(url); // &quot;http://www.zuo11.com/test%20value.html#start&quot;  只转义空格\nencodeURIComponent(url); // &quot;http%3A%2F%2Fwww.zuo11.com%2Ftest%20value.html%23start&quot; \n// encodeURI只转义空格, encodeURIComponent()会转义所有的非字母数字字符\n\n// 解码&quot;http://www.zuo11.com/test value.html#start&quot;\n// 只解码空格\ndecodeURI(&quot;http://www.zuo11.com/test%20value.html#start&quot;);\n// 解码非数字字母字符\ndecodeURIComponent(&quot;http%3A%2F%2Fwww.zuo11.com%2Ftest%20value.html%23start&quot;);</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Invalid character in header content [\"Content-Disposition\"]",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "encodeURIComponent与encodeURI的区别",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "什么是URI"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "URI与URL的区别"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "encodeURIComponent与encodeURI的作用"
                }
              ]
            }
          ]
        }
      ],
      "config": {
        "source": "Invalid character in header content ['Content-Disposition'].md",
        "staticFileName": "content-dispositon.html",
        "author": "guoqzuo",
        "createDate": "2020/06/21",
        "description": "在koa中，如果Content-Disposition里设置文件名有中文会提示错误，需要用类似 encodeURIComponent 转码的函数转码后才行，这里顺便介绍下encodeURIComponent和encodeURI的区别",
        "keywords": "Invalid character in header content ['Content-Disposition'],URI和URL的区别,encodeURIComponent和encodeURI的区别,encodeURI和encodeURIComponent区别",
        "category": "http与https",
        "year": "2020",
        "month": "6"
      }
    },
    {
      "htmlStr": "<h1 id=\"windows下nginx部署https服务实战\">windows下nginx部署https服务实战</h1>\n<p>这里复盘下将koa写的接口服务部署到<code>https://api.zuo11.com</code>上，配置nginx的全流程</p>\n<ol>\n<li>在阿里云将域名免费的ssl证书分配给api.zuo11.com</li>\n<li>在域名解析里，增加 api.zuo11.com 的解析，解析到服务器</li>\n<li>初始化一个koa项目，监听某个端口，比如 9000端口，写一些测试的接口</li>\n<li>部署到服务器</li>\n<li>nginx 添加对https的支持：①. 在ssl证书位置下载证书，会有两个文件 xxx.pem, xxx.key，在服务器nignx目录下的conf目录新建cert目录，将两个文件拷贝进去，修改conf下nginx.conf的配置</li>\n</ol>\n<pre><code class=\"language-bash\"># HTTPS server\nserver {\n    listen       443 ssl;\n    server_name  api.zuo11.com;\n\n    ssl_certificate     cert\\3391782_api.zuo11.com.pem;\n    ssl_certificate_key cert\\3391782_api.zuo11.com.key;\n\n    ssl_session_cache    shared:SSL:1m;\n    ssl_session_timeout  5m;\n\n    # 注释掉默认的加密方式\n    # ssl_ciphers  HIGH:!aNULL:!MD5;\n    # ssl_prefer_server_ciphers  on;\n\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  #使用此加密套件。\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;   #使用该协议进行配置。\n    ssl_prefer_server_ciphers on;\n\n    location / {\n        # root   html;\n        # index  index.html index.htm;\n        proxy_pass http://127.0.0.1:9000;\n    }\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "windows下nginx部署https服务实战"
        }
      ],
      "config": {
        "source": "windows下nginx部署https服务实战.md",
        "staticFileName": "nginx_https.html",
        "author": "guoqzuo",
        "createDate": "2020/06/21",
        "description": "这里复盘下将koa写的接口服务部署到`https://api.zuo11.com`上，相关nginx配置的全流程",
        "keywords": "nginx部署https服务,nginx https",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "6"
      }
    },
    {
      "htmlStr": "<h1 id=\"css-hover后改变其他元素样式\">css hover后改变其他元素样式</h1>\n<p>css中某个元素hover后，可以对其他元素设置样式，但注意：只限定于改变他的子元素, 以及其后面的元素，下面我们写demo来看看</p>\n<p><img src=\"../../../images/blog/css/css_hover.png\" alt=\"css_hover.png\"></p>\n<pre><code class=\"language-html\">&lt;style&gt;\n  /* hover后单独改变某一个子元素的样式 */\n  .cur-element:hover .child-1 {\n    color: red;\n  }\n  /* 设置相邻的后一个兄弟节点样式 */\n  .cur-element:hover + div {\n    background: blue;\n  }\n  /* 设置后面的所有对应的兄弟节点样式，不必相邻，但需要再其后面 */\n  .cur-element:hover ~ div {\n    background: red;\n  }\n&lt;/style&gt;\n&lt;div class=&quot;parent&quot;&gt;\n  &lt;div&gt;再前一个兄弟元素&lt;/div&gt;\n  &lt;div&gt;前一个兄弟元素&lt;/div&gt;\n  &lt;div class=&quot;cur-element&quot;&gt;\n    测试hover\n    &lt;span class=&quot;child-1&quot;&gt;child-1&lt;/span&gt;\n    &lt;span class=&quot;child-2&quot;&gt;child-2&lt;/span&gt;\n  &lt;/div&gt;\n  &lt;div&gt;后一个兄弟元素&lt;/div&gt;\n  &lt;div&gt;再后一个兄弟元素&lt;/div&gt;\n  &lt;div&gt;再再后一个兄弟元素&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<p>完整demo参见: <a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/hover%E6%94%B9%E5%8F%98%E5%85%B6%E4%BB%96%E5%85%83%E7%B4%A0%E6%A0%B7%E5%BC%8F/index.html\">css hover后改变其他样式demo | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "css hover后改变其他元素样式"
        }
      ],
      "config": {
        "source": "css hover后改变其他元素样式.md",
        "staticFileName": "css_hover.html",
        "author": "guoqzuo",
        "createDate": "2020/06/29",
        "description": "css中某个元素hover后，可以对其他元素设置样式，但注意：只限定于改变他的子元素, 以及其后面的元素，下面我们写demo来看看",
        "keywords": "css hover后改变其他元素样式,css 元素hover后设置其他元素样式",
        "category": "CSS",
        "year": "2020",
        "month": "6"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue封装组件时预留install函数便于vueuse全局引入\">vue封装组件时预留install函数便于Vue.use全局引入</h1>\n<p>在element组件中，我们使用el-input等element元素时，不需要在components里引入。为什么呢？在引入element时，我们有在mian.js里我们使用了Vue.use(elemnt组件)，这样进行了全局注入组件，相当于组件做成了一个vue插件，如果我们自己封装组件如何能够在Vue.use后直接可以全局调用呢？</p>\n<p>于是我特意去看了下element组件源码，这里我们暂时不要求封装为npm包，只需要在平常自定义组件的基础上做一个增强，可以使用Vue.use全局引入。\nelement-ui源码中，以alert组件为例，来看目录结构</p>\n<pre><code class=\"language-bash\">alert\n├── src\n│   └── main.vue  # 组件实现\n└── index.js # install方法，供全局引入</code></pre>\n<pre><code class=\"language-js\">import Alert from &#39;./src/main&#39;;\n\n/* istanbul ignore next */\nAlert.install = function(Vue) {\n  Vue.component(Alert.name, Alert);\n};\n\nexport default Alert;</code></pre>\n<p>综上：我们在开发组件时，可以增加全局引入的接口，层级也可以仿照element的来，多研究源码这样代码才会写的更健壮。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue封装组件时预留install函数便于Vue.use全局引入"
        }
      ],
      "config": {
        "source": "vue封装组件时预留install函数便于Vue.use全局引入.md",
        "staticFileName": "vue_use_install.html",
        "author": "guoqzuo",
        "createDate": "2020/06/29",
        "description": "在element组件中，我们使用el-input等element元素时，不需要在components里引入。为什么呢？在引入element时，我们有在mian.js里我们使用了Vue.use(elemnt组件)，这样进行了全局注入组件，相当于组件做成了一个vue插件，如果我们自己封装组件如何能够在Vue.use后直接可以全局调用呢？",
        "keywords": "vue封装组件时预留install函数,element组件为什么use后可以直接使用",
        "category": "Vue",
        "year": "2020",
        "month": "6"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue自定义组件使用v-model指令实现dialog组件的二次封装\">vue自定义组件使用v-model指令实现dialog组件的二次封装</h1>\n<p>当某个组件是对element的dialog组件进行二次封装时，我们需要对dialog进行隐藏显示，当子组件里的dialog关闭时，需要修改父组件传入的值，尽管不是表单组件也可以使用v-model来解决，先来看看怎么调用</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;user-selection v-model=&quot;showUserSelection&quot; @confirm=&quot;confirm&quot;/&gt;\n    &lt;el-button type=&quot;primary&quot; @click=&quot;showUserSelection = true&quot;&gt;打开弹窗&lt;/el-button&gt;\n  &lt;div&gt;\n&lt;template&gt;\n&lt;script&gt;\nexport default {\n  components: {\n    UserSelection: () =&gt; import(&quot;../src/components/user-selection/src/main&quot;)\n  },\n  data() {\n    return {\n      showUserSelection: false\n    }\n  },\n  methods: {\n    confirm(value) {\n      console.log(value)\n    }\n  }\n}\n&lt;/script&gt;</code></pre>\n<p>再来看组件实现</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-dialog title=&quot;提示&quot; :visible.sync=&quot;dialogVisible&quot;&gt;\n      内容\n      &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;\n        &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt;\n        &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确 定&lt;/el-button&gt;\n      &lt;/span&gt;\n    &lt;/el-dialog&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  model: {\n    prop: &#39;show&#39;, // 设置对应v-model的属性字段\n    event: &#39;close&#39; // 如果不指定默认为input，当$emit该事件，可以自动执行 修改父组件v-model参数的值\n  },\n  props: [&#39;show&#39;], // 接收v-model的传值\n  computed: {\n    dialogVisible: {\n      get() {\n        return this.show\n      },\n      set(newVal) {\n        console.log(newVal)\n        this.$emit(&#39;close&#39;, newVal)\n      }\n    }\n  },\n  data() {\n    return {}\n  }\n}\n&lt;/script&gt;</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue自定义组件使用v-model指令实现dialog组件的二次封装"
        }
      ],
      "config": {
        "source": "vue自定义组件使用v-model指令实现dialog组件的二次封装.md",
        "staticFileName": "v_model_dialog.html",
        "author": "guoqzuo",
        "createDate": "2020/06/29",
        "description": "当某个组件是对element的dialog组件进行二次封装时，我们需要对dialog进行隐藏显示，当子组件里的dialog关闭时，需要修改父组件传入的值，尽管不是表单组件也可以使用v-model来解决，先来看看怎么调用",
        "keywords": "v-model属性实现dialog组件的二次封装,element dialog组件的二次封装",
        "category": "Vue",
        "year": "2020",
        "month": "6"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue封装组件方式的思考\">vue封装组件方式的思考</h1>\n<p>在封装组件时，一般我们使用的方法是<strong>把组件单独放到一个xx.vue，然后需要引入时在components使用懒加载引入再使用</strong></p>\n<p>我就在想，每次引入组件都需要三步</p>\n<ol>\n<li>把组件通过 components 引入</li>\n<li>在template中写对应的代码</li>\n<li>在data中写对应的数据，methods里写绑定的事件</li>\n</ol>\n<p>会不会太麻烦了，我希望像element的组件那样，通过 this.$message.error(e.message) 这样直接调用一个组件</p>\n<p>于是我尝试使用js的方式来调用单文件组件(.vue)，在之前02/20号写过方法，除了直接挂载到body外，也可以挂载到任何地方，只要你能拿到对应的dom，可以使用ref属性，再通过this.$refs[&#39;xx&#39;]来获取其DOM 元素和组件实例。</p>\n<pre><code class=\"language-js\">// 引入该组件\nimport ShowInfo from &#39;showInfo.vue&#39;\n\n// 通过js调用\nclickShow() {\n  // 创建一个vue组件\n  const Component = Vue.extend(ShowInfo)\n\n  // 在文档之外渲染并且随后挂载，返回对应的Vue实例(vm)\n  let showInfoVue = new Component().$mount() \n\n  // 将组件实例的dom，append到当前页面body下\n  this.$el.appendChild(showInfoVue.$el) \n}</code></pre>\n<p>其实你发现没，用js直接调用vue组件可以是可以，但也要比正常情况下写更多代码，比如</p>\n<ol>\n<li>js调用vue的方法需要封装为一个class</li>\n<li>以上面的示例为例子，通过js调用组件，我们需要一个成功的回调，以及传参到组件，在获取到ShowInfo时，我们需要知道我们引入的只是一个&#39;js对象&#39;。我们可以在对象的methods里面注入方法，用来获取传入的值，或挂载成功后的回调。这样相当于mixin，但.vue组件实现里使用这些注入的事件时会不好理解，有种默认其妙多出来全局函数的疑惑</li>\n<li>以js方法写的组件，不能兼容默认的引用方法，如果要支持那就要写一些额外的代码</li>\n<li>你会发现逻辑会变的不好理解，不够简单，对新手不友好，如果需要其他人维护时，可能不好理解为什么这么做</li>\n</ol>\n<p>综上所述：默认的封装调用组件的方式就很好，简单、明了，你想在调用的时候轻松，那么在封装组件时，就会增加对应的工作量，整体工作量差不多。</p>\n<p>我们再来看element组件，对于内容比较少的，比如通知类，element都提供的是js调用方法，而没有普通的组件调用方法。且一般挂载到body上。为什么dialog组件没有封装成js呢？我的理解是dialog里面的内容可扩展性很强，如果改为js调用，可能会出现把大量代码写在js的情况，或者需要写VNode的render方法。就显得不够优雅了。</p>\n<p>总结：在封装组件时，什么时候用封装为js调用方式、什么时候采用普通的封装呢？我的理解是可以通过下面几个方面来进行评估</p>\n<ol>\n<li>被封装的组件需求是否稳定，有没有可能会在后面经常变更或者进行渐进式增强，如果不稳定，不建议封装为js调用方式，对于可扩展性强的，还是建议使用普通组件封装方式，更利于维护</li>\n<li>是否是挂载到body下，还是需要放到任意的div内? 一般普通组件更好放置。如果挂载到body下，可以考虑封装为js调用方式</li>\n<li>是否功能相对单一简单，如果组件功能单一简单建议封装为js调用方式</li>\n<li>该组件是否在页面里大量被调用 大量的被调用，意味着大量重复的代码，可以考虑封装为js调用方式，增加组件实现时的复杂度，来降低调用时的复杂度</li>\n</ol>\n<p>总之，不管怎么样封装，当有人问你为什么这么封装时，你要能够说出你自己的理由。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue封装组件方式的思考"
        }
      ],
      "config": {
        "source": "vue封装组件方式的思考.md",
        "staticFileName": "vue_component_think.html",
        "author": "guoqzuo",
        "createDate": "2020/06/29",
        "description": "在封装组件时，一般我们使用的方法是：把组件单独放到一个xx.vue，然后需要引入时在components使用懒加载引入再使用，我就在想，每次引入组件都需要三步：1. 把组件通过 components 引入 2. 在template中写对应的代码 3. 在data中写对应的数据，methods里写绑定的事件。会不会太麻烦了，我希望像element的组件那样，通过 this.$message.error(e.message) 这样直接调用一个组件",
        "keywords": "vue封装组件思考,vue封装组件总结",
        "category": "Vue",
        "year": "2020",
        "month": "6"
      }
    },
    {
      "htmlStr": "<h1 id=\"他人提交了package-lockjson的更新导致拉取时和本地冲突的问题\">他人提交了package-lock.json的更新导致拉取时和本地冲突的问题</h1>\n<p>一般在npm install 时会修改package-lock.json文件，我一般不会提交这个更新，但今天发现有人提交。我拉取时，提示这个文件冲突，导致拉取不下来，我又不想提交更新，所以尝试用下面的命令，将工作区该文件的修改丢弃，再拉取</p>\n<pre><code class=\"language-bash\">git checkout -- package-lock.json</code></pre>\n<p>拉取成功后，npm run serve 基本没什么影响</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "他人提交了package-lock.json的更新导致拉取时和本地冲突的问题"
        }
      ],
      "config": {
        "source": "他人提交了package-lock.json的更新导致拉取时和本地冲突的问题.md",
        "staticFileName": "git_package_lock.html",
        "author": "guoqzuo",
        "createDate": "2020/06/29",
        "description": "一般在npm install 时会修改package-lock.json文件，我一般不会提交这个更新，但今天发现有人提交。我拉取时，提示这个文件冲突，导致拉取不下来，我又不想提交更新，所以尝试用下面的命令，将工作区该文件的修改丢弃，再拉取",
        "keywords": "是否要提交package-lock.json",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "6"
      }
    },
    {
      "htmlStr": "<h1 id=\"git-commit提交信息有误怎么修改\">git commit提交信息有误怎么修改</h1>\n<p>如果不小心提交了，但没有push，可以使用--amend参数来修改上一次的commit信息，命令如下</p>\n<pre><code class=\"language-js\">git commit --amend -m &#39;xxx&#39;</code></pre>\n<p>注意，一般是修改没有push前的提交信息</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "git commit提交信息有误怎么修改"
        }
      ],
      "config": {
        "source": "git commit提交信息有误怎么修改.md",
        "staticFileName": "git_comit_amend.html",
        "author": "guoqzuo",
        "createDate": "2020/06/29",
        "description": "如果不小心提交了，但没有push，可以使用--amend参数来修改上一次的commit信息，命令如下：git commit --amend -m 'xxx', 注意，一般是修改没有push前的提交信息",
        "keywords": "git commit提交信息修改,commit备注信息有误怎么修改",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "6"
      }
    },
    {
      "htmlStr": "<h1 id=\"webpack与parcel区别\">webpack与parcel区别</h1>\n<p>webpack与parcel都是打包工具，webpack\b功能强大，但比较重，配置项比较多，有点繁琐。而parcel就是为了解决配置项太多这个问题的，它默认集成了通用的常规功能，<strong>零配置</strong>，如果自定义较多，还是推荐webpack</p>\n<blockquote>\n<p>If you don&#39;t want to worry about configuring everything and your needs are common needs, you should go directly with parcel. Parcel provides defaults (for babel-preset-env, post-css, html, etc) that fits most scenarios and works for everybody. You don&#39;t have to worry about configuring anything.</p>\n</blockquote>\n<blockquote>\n<p>From the other hand, if you need a more customization, you should go with webpack. Keep in mind that you will have to setup everything that you need, explicitly set those things.</p>\n</blockquote>\n<p>参考：<a href=\"https://stackoverflow.com/questions/51453462/webpack-vs-parcel\">Webpack vs Parcel - Stack Overflow</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "webpack与parcel区别"
        }
      ],
      "config": {
        "source": "webpack与parcel区别.md",
        "staticFileName": "webpack_parcel_difference.html",
        "author": "guoqzuo",
        "createDate": "2020/06/29",
        "description": "webpack与parcel都是打包工具, webpack功能强大，但比较重，配置项比较多, 有点繁琐。而parcel就是为了解决配置项太多这个问题的，它默认集成了通用的常规功能，零配置，如果自定义较多，还是推荐webpack",
        "keywords": "webpack与parcel区别,parcel与webpack区别,webpack parcel difference",
        "category": "前端工程化",
        "year": "2020",
        "month": "6"
      }
    },
    {
      "htmlStr": "<h1 id=\"nodejs的核心用处及应用场景\">Node.js的核心用处及应用场景</h1>\n<p>Node.js是一个基于chrome v8引擎的js运行时，那他一般有什么用处呢，下面来看看</p>\n<h2 id=\"node三个核心应用场景\">node三个核心应用场景</h2>\n<ol>\n<li><p><strong>打包构建、工程化</strong>，主要依赖基础的fs模块，文件读写，如xxx-cli(脚手架)、webpack、parcel、hexo，node在打包构建、前端工程化这块基本影响了整个前端的开发过程，各框架基本都有基于node的cli，快速生成脚手架，使开发更加高效、规范。</p>\n</li>\n<li><p><strong>写后台接口</strong>，主要依赖基础的http模块，处理请求和响应，如 express.js、koa.js，一般主要用于模拟假数据接口, 调UI、交互效果以及做一些请求响应方面的自测</p>\n</li>\n<li><p><strong>综合应用：获取数据+渲染页面(高并发、高性能)</strong>，koa.js对于开发商业化应用来说还是比较单薄，egg.js基于koa做了一些增强，让node也可以做企业级应用。阿里的使用场景就是一个很好的例子，基础设施大部分采用 Java 实现，变化较少，有事务要求的 Business Services 通常使用 Java。而Node主要用于<strong>替代过去php、jsp使用场景</strong>, 用在需要快速迭代，需求变化非常快的用户侧。node已经经受了阿里双11的考验，技术上是可行的。</p>\n</li>\n</ol>\n<blockquote>\n<p>题外话：个人认为综合应用这块，自己玩玩还可以，小团队或node不是非常强的技术团队尽量不要尝试，阿里能做好这块是因为国内顶尖的node方面人才基本都在阿里，经过多年实践踩坑，拥有相对完善的node基建和生态。目前市面上前端里node强的比较少，饿了么为了招node服务端开发，还专门写了个node相关的面试教程。可想而知这方面人才有多少。</p>\n</blockquote>\n<h2 id=\"node支持高并发的原因\">node支持高并发的原因</h2>\n<ul>\n<li><strong>node.js基于异步I/O</strong>，接收到请求后，直接开一个I/O线程去执行，然后就不管了，立即继续执行主线程。等I/O线程执行完成后，直接执行对应的回调函数即可。省去了许多等待请求的时间</li>\n<li><strong>事务驱动</strong>，主线程通过event loop事件循环触发的方式来运行程序，这一条暂时还不是很理解，先写上~</li>\n</ul>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/50526101/answer/144952130\">如何评价阿里开源的企业级 Node.js 框架 EggJS？</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015841624\">Node.js：浅析高并发与分布式集群</a></li>\n<li><a href=\"https://github.com/tmallfe/tmallfe.github.io/issues/28?utm_source=ourjs.com\">天猫双11前端分享系列（四）：大规模 Node.js 应用</a></li>\n<li><a href=\"https://eggjs.org/zh-cn/intro/index.html\">egg.js</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview\">node-interview | ElemeFE</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Node.js的核心用处及应用场景",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "node三个核心应用场景"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "node支持高并发的原因"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "Node.js的核心用处及应用场景.md",
        "staticFileName": "nodejs_uses.html",
        "author": "guoqzuo",
        "createDate": "2020/06/29",
        "description": "Node.js是一个基于chrome v8引擎的js运行时，那他一般有什么用处呢，下面来看看。node三个核心应用场景：1.打包构建、工程化 2.写后台接口 3.综合应用：获取数据+渲染页面(高并发、高性能)",
        "keywords": "Node.js的核心用处及应用场景,node使用场景,node应用场景,node应用",
        "category": "前端工程化",
        "year": "2020",
        "month": "6"
      }
    },
    {
      "htmlStr": "<h1 id=\"npm包前面加是什么意思vue-cli与vuecli的区别\">npm包前面加@是什么意思(vue-cli与@vue/cli的区别)</h1>\n<p>今天看vue-cli文档，发现了下面的这段话 vue-cli 改为了 @vue/cli，这两个npm有什么区别呢？npm包前面加@是什么意思呢？</p>\n<blockquote>\n<p>Vue CLI 的包名称由 vue-cli 改成了 @vue/cli。 如果你已经全局安装了旧版本的 vue-cli (1.x 或 2.x)，你需要先通过 npm uninstall vue-cli -g 或 yarn global remove vue-cli 卸载它。</p>\n</blockquote>\n<p>查了下官网，npm包前面加@，代表scopes相关的包，可以理解为作用域(范围)包，作用域使我们可以创建与其他用户或组织创建的包同名，而不会发生冲突。</p>\n<p>A scope allows you to create a package with the same name as a package created by another user or Org without conflict.</p>\n<p>作用域名称是介于@和斜线之间的所有内容：</p>\n<p>The scope name is everything between the @ and the slash:</p>\n<pre><code class=\"language-js\">// “npm” scope:\n@npm/package-name\n// “npmcorp” scope:\n@npmcorp/package-name</code></pre>\n<h2 id=\"为什么需要有作用域包\">为什么需要有作用域包</h2>\n<p><strong>npm包一个诟病就是包名很容易被占用的问题，占用后用其他人就不能用了。而作用域包类似于创建了一个命名空间，不同的命名空间，可以使用相同的包名</strong></p>\n<p>作用域的命名不是谁便就能用的，只有两种可以使用：自己的用户名、自己创建的组织名</p>\n<p>注意：必须先注册一个npm用户帐户，然后才能发布用户作用域的npm软件包。此外，要发布组织作用域的软件包，您必须创建一个npm用户帐户，然后创建一个npm Org(组织)。</p>\n<p><strong>在 vue-cli 中可以用@vue/cli说明使用了vue这个npm账号或者组织发布了该包。</strong></p>\n<p>参考:</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/kunmomo/p/11222063.html\">npm学习（十）之如何使用创建、发布、使用作用域包</a></li>\n<li><a href=\"https://docs.npmjs.com/about-scopes\">About scopes - Packages and modules | npm</a></li>\n<li><a href=\"https://docs.npmjs.com/creating-and-publishing-scoped-public-packages\">Creating and publishing scoped public packages | npm</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "npm包前面加@是什么意思(vue-cli与@vue/cli的区别)",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "为什么需要有作用域包"
            }
          ]
        }
      ],
      "config": {
        "source": "npm包前面加@是什么意思(vue-cli与@vue-cli的区别).md",
        "staticFileName": "npm_scope.html",
        "author": "guoqzuo",
        "createDate": "2020/07/06",
        "description": "今天看vue-cli文档，发现了下面的这段话 vue-cli 改为了 @vue/cli，这两个npm有什么区别呢？npm包前面加@是什么意思呢？查了下官网，npm包前面加@，代表scopes相关的包，可以理解为作用域(范围)包，作用域使我们可以创建与其他用户或组织创建的包同名，而不会发生冲突。A scope allows you to create a package with the same name as a package created by another user or Org without conflict.",
        "keywords": "npm包前面加@是什么意思,vue-cli与@vue/cli的区别",
        "category": "前端工程化",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"koa-multer与koamulter逻辑差异\">koa-multer与@koa/multer逻辑差异</h1>\n<p>之前有了解过以@开头的作用域包，这次在使用koa-multer这个模块时，发现@koa/multer与koa-multer的逻辑居然不一样。源码有些差异，下面来具体看看</p>\n<pre><code class=\"language-js\">// 在使用 koa-multer 时\nconst multer = require(&#39;koa-multer&#39;)\nrouter.post(&#39;/test&#39;, multer().none(), ctx =&gt; { \n  let isFormData = ctx.headers[&#39;content-type&#39;].startsWith(&#39;multipart/form-data&#39;)\n  // ctx.req node的request对象, ctx.request koa的request对象\n  ctx.body = isFormData ? ctx.req.body : ctx.request.body\n})</code></pre>\n<p>koa-multer这个包是从express的multer包上面加了一层封装，而koa-multer并没有把fileds字段挂载到ctx.request.body上，只维持原来express那样挂载到node的request对象上，也就是ctx.req.body，来看看koa-multer的源码部分</p>\n<pre><code class=\"language-js\">// https://github.com/koa-modules/multer/blob/master/index.js\nmulter[name] = function () {\n    const middleware = fn.apply(this, arguments)\n\n    return (ctx, next) =&gt; {\n      return new Promise((resolve, reject) =&gt; {\n        middleware(ctx.req, ctx.res, (err) =&gt; {\n          err ? reject(err) : resolve(ctx)\n        })\n      }).then(next)\n    }\n  }</code></pre>\n<p>而@koa/multer则做了处理，可以与上面的例子对比下</p>\n<pre><code class=\"language-js\">// https://github.com/koajs/multer/blob/master/index.js\nmulter[name] = function() {\n    const middleware = Reflect.apply(fn, this, arguments);\n\n    return (ctx, next) =&gt; {\n      return new Promise((resolve, reject) =&gt; {\n        middleware(ctx.req, ctx.res, err =&gt; {\n          if (err) return reject(err);\n          if (&#39;request&#39; in ctx) {\n            if (ctx.req.body) {\n              ctx.request.body = ctx.req.body;\n              delete ctx.req.body;\n            }\n\n            if (ctx.req.file) {\n              ctx.request.file = ctx.req.file;\n              ctx.file = ctx.req.file;\n              delete ctx.req.file;\n            }\n\n            if (ctx.req.files) {\n              ctx.request.files = ctx.req.files;\n              ctx.files = ctx.req.files;\n              delete ctx.req.files;\n            }\n          }\n\n          resolve(ctx);\n        });\n      }).then(next);\n    };\n  };</code></pre>\n<p>我们再来看看使用@koa/multer的情况，就比较方便了，和其他数据一样挂载到 ctx.request.body</p>\n<pre><code class=\"language-js\">const multer = require(&#39;@koa/multer&#39;)\nrouter.post(&#39;/test&#39;, multer().none(), ctx =&gt; { \n  ctx.body = ctx.request.body\n}) </code></pre>\n<p><strong>综上，如果某个模块有两种包名，建议先考虑@开头的作用域包，通常这种功能会新点。后面迭代维护应该都是以这个为准</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "koa-multer与@koa/multer逻辑差异"
        }
      ],
      "config": {
        "source": "koa-multer与@koa-multer逻辑差异.md",
        "staticFileName": "koa-multer.html",
        "author": "guoqzuo",
        "createDate": "2020/07/06",
        "description": "之前有了解过以@开头的作用域包，这次在使用koa-multer这个模块时，发现@koa/multer与koa-multer的逻辑居然不一样。源码有些差异，下面来具体看看。koa-multer这个包是从express的multer包上面加了一层封装，而koa-multer并没有把fileds字段挂载到ctx.request.body上，只维持原来express那样挂载到node的request对象上，也就是ctx.req.body，来看看koa-multer的源码部分",
        "keywords": "koa-multer与@koa/multer逻辑差异",
        "category": "前端工程化",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"markdown里怎么加引用注释或脚注\">markdown里怎么加引用注释或脚注</h1>\n<p>一般我们只是在markdown添加链接，但怎么在markdown里加脚注呢？下面来看看</p>\n<pre><code class=\"language-markdown\">这里有一个注脚[^1]，这段话的还有其他意思[^2]在里面\n[^1]:这里是注脚内容\n[^2]:这里是其他意思的注脚</code></pre>\n<p>注脚放到中间也可以，下面是具体效果</p>\n<p><img src=\"../../../images/blog/web/md_footnote.png\" alt=\"md_footnote.png\"></p>\n<h2 id=\"md中链接的另一种写法\">md中链接的另一种写法</h2>\n<pre><code class=\"language-markdown\">我是一段文字，[baidu][1]、[qq][2]里面有链接\n[1]: http://baidu.com &quot;baidu&quot;\n[2]: http://qq.com &quot;qq&quot;</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "markdown里怎么加引用注释或脚注",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "md中链接的另一种写法"
            }
          ]
        }
      ],
      "config": {
        "source": "markdown里怎么加引用注释或脚注.md",
        "staticFileName": "md_ref.html",
        "author": "guoqzuo",
        "createDate": "2020/07/06",
        "description": "一般我们只是在markdown添加链接，但怎么在markdown里加脚注呢？下面来看看",
        "keywords": "md添加脚注,markdown里怎么加引用注释或脚注,markdown脚注,md脚注",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"md5加密是可逆的吗？\">md5加密是可逆的吗？</h1>\n<p>理论上md5加密后，在不知道原始消息的前提下，是无法凭借16个字节的消息摘要（Message Digest），还原出原始的消息的.</p>\n<p>但为什么有些网站可以破解md5加密后的密码呢？主要是使用的碰撞检测。它会提前算出一些常用弱密码的md5值，一个个比较。才会让人产生md5可逆的错觉。一般除了md5加密外，我们可以再多进行一些处理(加盐)，来进行干扰，提高破解难度</p>\n<p>参考：<a href=\"https://www.zhihu.com/question/22651987\">为什么说 MD5 是不可逆的？</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "md5加密是可逆的吗？"
        }
      ],
      "config": {
        "source": "md5加密是可逆的吗.md",
        "staticFileName": "md5_reverse.html",
        "author": "guoqzuo",
        "createDate": "2020/07/06",
        "description": "理论上md5加密后，在不知道原始消息的前提下，是无法凭借16个字节的消息摘要（Message Digest），还原出原始的消息的.但为什么有些网站可以破解md5加密后的密码呢？主要是使用的碰撞检测。它会提前算出一些常用弱密码的md5值，一个个比较。才会让人产生md5可逆的错觉。一般除了md5加密外，我们可以再多进行一些处理(加盐)，来进行干扰，提高破解难度",
        "keywords": "md5是否可逆,md5逆向,md5解密",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"两个不同文件md5可能一样吗\">两个不同文件md5可能一样吗?</h1>\n<p>我们先来看看什么是md5？md5 是 messge digest [daɪˈdʒest] 5 的缩写，意思是信息摘要算法</p>\n<p>linux下，在terminal中执行man md5，可以查看对应的文档</p>\n<p>md5 -- calculate a message-digest fingerprint (checksum) for a file </p>\n<p>md5 -- 为一个文件计算信息摘要指纹(&#39;校验和&#39;或&#39;校验码&#39;)</p>\n<pre><code class=\"language-bash\">md5 -s &#39;123456&#39;\n# MD5 (&quot;123456&quot;) = e10adc3949ba59abbe56e057f20f883e\n\nmd5 1.txt\n# MD5 (1.txt) = 6f74626e0749e5353cc7e11767418d43</code></pre>\n<p>从上面的例子中我们可以看到，将文件或字符串进行 md5校验 会生成一个 32位 的校验码。问题来了，网上看到 md5加密后一般是128位，而这里只有32位为什么呢？我们要分清16进制与2进制，<strong>标准说法是，md5加密后的字符为 128bit(16字节)，而一个我们看到的32位是16进制，每一位都可以转为4bit，也就是4个二进制位。1 - f 分别对应 0000 - 1111，所以128bit</strong></p>\n<p>一个二进制位(bit)只能表示0或1两种情况，128bit可以表示 Math.pow(2, 128) 2的128次方种情况，定死了，最多只能表示这么多种情况，不同内容的文件实在是太多了，理论上绝对是会超过2的128次方的。</p>\n<p>综上：<strong>两个不同文件md5是有可能相同的，因为md5最多只能表示2的128次方种情况，而不同的文件绝对大于这个数</strong></p>\n<p><strong>虽然两个文件的md5可能一致，但给定一个文件的md5值，想伪造另一个文件的md5值与该值一样，相对还是比较困难的，因此可用于判断文件完整性</strong></p>\n<p>参考: <a href=\"https://www.zhihu.com/question/29406619\">有没有两个完全不一样的文件，但是他们的md5值是一样的？</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "两个不同文件md5可能一样吗?"
        }
      ],
      "config": {
        "source": "两个不同文件md5可能一样吗.md",
        "staticFileName": "file_md5.html",
        "author": "guoqzuo",
        "createDate": "2020/07/06",
        "description": "我们先来看看什么是md5？md5 是 messge digest [daɪˈdʒest] 5 的缩写，意思是信息摘要算法，两个不同文件md5是有可能相同的，因为md5最多只能表示2的128次方种情况，而不同的文件绝对大于这个数。虽然两个文件的md5可能一致，但给定一个文件的md5值，想伪造另一个文件的md5值与该值一样，相对还是比较困难的，因此可用于判断文件完整性",
        "keywords": "两个不同文件md5可能一样吗,md5一样的文件存在吗,md5一样的文件",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"根据文件名后缀判断文件类型不准确，那怎么判断两个文件一模一样呢\">根据文件名后缀判断文件类型不准确，那怎么判断两个文件一模一样呢</h1>\n<p>一般根据文件名后缀判断文件类型不准确，比如我有个1.png文件，我修改下后缀名 1.txt，那前端如果仅凭文件名的后缀来显然是不行的，我们需要根据文件类型的二进制数据标记来判断对应的文件类型，这样才会更加准确，安全性更高</p>\n<p><img src=\"../../../images/blog/web/file_type.png\" alt=\"判断文件类型.png\"></p>\n<h2 id=\"怎么判断两个文件一模一样呢\">怎么判断两个文件一模一样呢</h2>\n<p>一般文件的md5可能会有重复的，怎么减少这种概率呢？校验分三个部分</p>\n<ol>\n<li>比较整个文件的md5</li>\n<li>选择文件固定位置的几个片段分别计算md5进行比对</li>\n<li>比较文件名是否一样</li>\n</ol>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "根据文件名后缀判断文件类型不准确，那怎么判断两个文件一模一样呢",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "怎么判断两个文件一模一样呢"
            }
          ]
        }
      ],
      "config": {
        "source": "根据文件名后缀判断文件类型不准确，那怎么判断两个文件一模一样呢.md",
        "staticFileName": "file_same.html",
        "author": "guoqzuo",
        "createDate": "2020/07/06",
        "description": "一般根据文件名后缀判断文件类型不准确，比如我有个1.png文件，我修改下后缀名 1.txt，那前端如果仅凭文件名的后缀来显然是不行的，我们需要根据文件类型的二进制数据标记来判断对应的文件类型，这样才会更加准确，安全性更高",
        "keywords": "怎么判断两个文件一样,文件一致性检验,根据文件名后缀判断文件类型是不准确的",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"json数据转blob后，怎么还原？怎么将blob数据转json\">JSON数据转Blob后，怎么还原？怎么将Blob数据转JSON</h1>\n<p>在axios请求下载文件接口时，一般设置responseType: &#39;blob&#39;，文件返回正常就没问题，但后台如果处理文件或鉴权有问题，接口返回了包含错误信息的json格式数据，那样json数据也会被转为Blob对象，而前端有必要将错误信息展示，那怎么将Blob数据转JSON呢？下面来看看</p>\n<pre><code class=\"language-js\">let fileType = blobData.type\nif (fileType.startsWith(&#39;application/json&#39;)) {\n  let reader = new FileReader();\n  reader.addEventListener(&quot;loadend&quot;, function() {\n    let data = JSON.parse(reader.result)\n    console.log(data);\n  });\n  reader.readAsText(res.data, &quot;UTF-8&quot;) // 加UTF-8防止中文乱码\n  return\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JSON数据转Blob后，怎么还原？怎么将Blob数据转JSON"
        }
      ],
      "config": {
        "source": "JSON数据转Blob后，怎么还原？怎么将Blob数据转JSON.md",
        "staticFileName": "blob_json.html",
        "author": "guoqzuo",
        "createDate": "2020/07/06",
        "description": "在axios请求下载文件接口时，一般设置responseType: 'blob'，文件返回正常就没问题，但后台如果处理文件或鉴权有问题，接口返回了包含错误信息的json格式数据，那样json数据也会被转为Blob对象，而前端有必要将错误信息展示，那怎么将Blob数据转JSON呢？下面来看看",
        "keywords": "blob转json,json转blob后怎么还原",
        "category": "JavaScript",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"canvas-多次fill会覆盖前面的fill的问题\">canvas 多次fill会覆盖前面的fill的问题</h1>\n<p>在使用canvas进行绘图时，封装了一个绘制函数，每次都会填充颜色 ctx.fill()，如果多次执行，只会在最后一次时，整体fill一次？</p>\n<p>刚开始以为是后面的fill覆盖了前面的fill，后来网上查了下，第一次fill后，<strong>再次fill需要再次调用ctx.beginPath()</strong>，不然只会在最后一次fill。</p>\n<p>参考: <a href=\"https://bbs.csdn.net/topics/392293890?page=1\">HTML5的canvas标签为什么会覆盖之前画的东西的颜色 </a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "canvas 多次fill会覆盖前面的fill的问题"
        }
      ],
      "config": {
        "source": "canvas多次fill会覆盖前面的fill的问题.md",
        "staticFileName": "canvas_file_more.html",
        "author": "guoqzuo",
        "createDate": "2020/07/06",
        "description": "在使用canvas进行绘图时，封装了一个绘制函数，每次都会填充颜色 ctx.fill()，如果多次执行，只会在最后一次时，整体fill一次？刚开始以为是后面的fill覆盖了前面的fill，后来网上查了下，第一次fill后，再次fill需要再次调用ctx.beginPath()，不然只会在最后一次fill。",
        "keywords": "canvas多次fill会覆盖前面的fill的问题,ctx.fill覆盖了前一次的fill",
        "category": "JavaScript",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"canvas不支持文本换行怎么处理\">canvas不支持文本换行怎么处理</h1>\n<p>今天在stackoveflow里面搜索ctx.fill的问题时，查到了很多关于canvas ctx.fillText()绘制文本时不支持换行的问题，找到了一个比较好的答案</p>\n<blockquote>\n<p>I&#39;m afraid it is a limitation of Canvas&#39; fillText. There is no multi-line support. Whats worse, there&#39;s no built-in way to measure line height, only width, making doing it yourself even harder!</p>\n</blockquote>\n<p>一般解决思路是，根据 ctx.measureText(&#39;Hello&#39;).width 来看需要显示的文字是否需要换行，写一个for循环来处理</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000017869922\">canvas绘制文本内容自动换行</a></li>\n<li><a href=\"https://stackoverflow.com/questions/5026961/html5-canvas-ctx-filltext-wont-do-line-breaks\">javascript - HTML5 canvas ctx.fillText won&#39;t do line breaks? - Stack Overflow</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "canvas不支持文本换行怎么处理"
        }
      ],
      "config": {
        "source": "canvas不支持文本换行怎么处理.md",
        "staticFileName": "canvas_text_wrap.html",
        "author": "guoqzuo",
        "createDate": "2020/07/06",
        "description": "今天在stackoveflow里面搜索ctx.fill的问题时，查到了很多关于canvas ctx.fillText()绘制文本时不支持换行的问题，找到了一个比较好的答案。I'm afraid it is a limitation of Canvas' fillText. There is no multi-line support. Whats worse, there's no built-in way to measure line height, only width, making doing it yourself even harder! 一般解决思路是，根据 ctx.measureText('Hello').width 来看需要显示的文字是否需要换行，写一个for循环来处理",
        "keywords": "canvas不支持文本换行怎么处理,canvas文本换行,canvas文本怎么换行",
        "category": "JavaScript",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"canvas绘制模糊的问题\">canvas绘制模糊的问题</h1>\n<p>今天发现同样的代码在两台电脑上绘制的一个清晰，一个模糊，后来查资料发现确实有这个问题</p>\n<p>因为canvas不是矢量图，高dpi屏幕每平方英寸有更多的像素，也就是两倍屏，浏览器会以两个像素点的宽度来渲染一个像素，所以在Retina屏上会导致图片、文字都会模糊，怎么解决呢？</p>\n<p>获取设备像素比：<code>window.devicePixelRatio || 1</code></p>\n<p><strong>如果绘制的实际区域大小为 750 * 40，假设设备像素比为2，那么，canvas的width、height需要设置为 1500 * 80，然后用内联样式设置width为750，height为40，相当于canvas绘制2倍的大小，然后再缩放，这样就清晰了。</strong></p>\n<p>综上，在canvas绘制时，各种长度一定要考虑乘以devicePixelRatio，不然可能显示的不清晰</p>\n<p>参考：<a href=\"https://www.html.cn/archives/9297\">解决 canvas 在高清屏中绘制模糊的问题</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "canvas绘制模糊的问题"
        }
      ],
      "config": {
        "source": "canvas绘制模糊的问题.md",
        "staticFileName": "canvas_dim.html",
        "author": "guoqzuo",
        "createDate": "2020/07/06",
        "description": "今天发现同样的代码在两台电脑上绘制的一个清晰，一个模糊，后来查资料发现确实有这个问题: 因为canvas不是矢量图，高dpi屏幕每平方英寸有更多的像素，也就是两倍屏，浏览器会以两个像素点的宽度来渲染一个像素，所以在Retina屏上会导致图片、文字都会模糊，怎么解决呢？",
        "keywords": "canvas绘制模糊的问题,retina屏canvas绘制模糊的问题",
        "category": "JavaScript",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"实战canvas绘制不规则形状填充渐变色\">实战canvas绘制不规则形状填充渐变色</h1>\n<p>在JS高程3中，有一章专门将使用canvas绘图，今天终于用上了，效果还不错，来看效果，原生js，70行不到，用canvas画不规则形状，且添加渐变色</p>\n<p><img src=\"../../../images/blog/js/cavas_unnormal_shape.png\" alt=\"cavas_unnormal_shape.png\"></p>\n<pre><code class=\"language-js\">&lt;canvas id=&quot;drawing1&quot; width=&quot;720&quot; height=&quot;45&quot; &gt;A draw of something.&lt;/canvas&gt;\n&lt;script&gt;\n  drawStatus(&#39;drawing1&#39;, 2)\n  function drawStatus(domId, position) {\n    let str = [&#39;① 状态一&#39;, &#39;② 状态二&#39;, &#39;③ 状态三&#39;, &#39;④ 状态四&#39;, &#39;⑤ 状态五&#39;, &#39;⑥ 状态六&#39;]\n    let config = {\n      width: 100,\n      height: 40,\n      extendLength: 20,\n      radius: 4\n    }\n    let config2 = { ...config, width: 110 }\n    let cur = str.length - position\n\n    str.reverse().forEach((item, index) =&gt; {\n      let pos = str.length - index - 1\n      let x = 0 + (str.length - 1) * config.radius\n      if (pos !== 0) {\n        x = (pos * 100) + (pos -1) * 10 + (str.length - 1 - pos) * config.radius\n      }\n      console.log(pos,x)\n      let curConfig = pos === 0 ? config : config2 \n      if (pos &lt; (str.length - cur)) {\n        curConfig.isFocus = true\n      }\n      drawUnnormalShape(domId, x , 0, str[index], curConfig)\n    })\n  }\n\n  function drawUnnormalShape(domId, x, y, text, config) {\n    let drawing = document.getElementById(domId);\n    let ctx = drawing.getContext(&#39;2d&#39;);\n    let { width, height, extendLength, radius, isFocus } = config \n    ctx.beginPath(); // 如果都需要重新beginPath 不然，后面的fill会覆盖前面的fill\n\n    // 不规则矩形\n    ctx.moveTo(x + radius, y) // 从左上角 (x + radius, y) 位置开始\n    ctx.arcTo(x, y, x, y + radius, radius) // 左上圆角\n    ctx.lineTo(x, y + height - 2 * radius) // 画左边\n    ctx.arcTo(x, y + height, x + radius, y + height, radius) // 左下圆角\n    ctx.lineTo(x + width - radius, y + height) // 下边\n    // ctx.arcTo(x + width - radius, y + height, x + width - radius, y + height - 1, 1) // 圆角\n\n    let extendEndX = x + width + extendLength\n    let middleHeight = y + height / 2\n    ctx.arcTo(extendEndX, middleHeight, extendEndX - radius, middleHeight - radius, radius) // 线 + 圆角\n    ctx.lineTo(x + width - radius, y)\n    ctx.lineTo(x + radius, y)\n\n    var gradient = ctx.createLinearGradient(x, y + height / 2, x + width + extendLength, y + height / 2); // 从(130,130)到(160,160)渐变\n    gradient.addColorStop(0, isFocus ? &#39;#62ccff&#39; : &#39;#fff&#39;); // 渐变的起点色\n    gradient.addColorStop(1, isFocus ? &#39;#0486fe&#39; : &#39;#fff&#39;); // 渐变的结束色\n\n    ctx.shadowOffsetX = 6;\n    ctx.shadowOffsetY = 2;\n    ctx.shadowBlur = 16; // 模糊像素\n    ctx.shadowColor = &quot;rgba(58, 86, 111, 0.15)&quot;;\n\n    ctx.fillStyle = gradient\n    ctx.fill() // ctx.stroke()\n\n    let textArr = text.split(&#39; &#39;)\n    ctx.font = &quot;15px arial&quot;\n    ctx.fillStyle = isFocus ? &#39;#fff&#39; : &#39;#ccc&#39;\n    ctx.fillText(textArr[0], x + width / 2 - 20, y + height / 2 + 5)\n    ctx.font = &quot;11px arial&quot;\n    ctx.fillText(textArr[1], x + width / 2, y + height / 2 + 4)\n  }\n&lt;/script&gt;</code></pre>\n<p>参考之前的笔记：<a href=\"https://www.yuque.com/guoqzuo/js_es6/sbx6vi#a59e2f96\">使用canvas绘图 - JS高程3笔记</a></p>\n<p>完整demo: <a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/canvas%E7%94%BB%E4%B8%8D%E8%A7%84%E5%88%99%E5%BD%A2%E7%8A%B6%E5%A1%AB%E5%85%85%E6%B8%90%E5%8F%98%E8%83%8C%E6%99%AF/index.html\">canvas画不规则形状填充渐变背景 - github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "实战canvas绘制不规则形状填充渐变色"
        }
      ],
      "config": {
        "source": "实战canvas绘制不规则形状填充渐变色.md",
        "staticFileName": "cavas_unnormal_shape.html",
        "author": "guoqzuo",
        "createDate": "2020/07/06",
        "description": "在JS高程3中，有一章专门将使用canvas绘图，今天终于用上了，效果还不错，来看效果，原生js，70行不到，用canvas画不规则形状，且添加渐变色",
        "keywords": "实战canvas绘制不规则形状填充渐变色,canvas画不规则形状,canvas渐变",
        "category": "JavaScript",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"canvas怎么绘制环形进度条\">canvas怎么绘制环形进度条</h1>\n<p>使用canvas绘制渐变的环形进度条，主要是使用arc函数，下面来看看</p>\n<h2 id=\"4个重点\">4个重点</h2>\n<ol>\n<li><p>怎么画圆弧, ctx.arc函数里开始角度、结束角度以PI为基准，取值范围时：0 ~ 2PI，PI就是π值约等于3.14，圆心正上方位置为1.5PI，圆心右侧为 0 或 2*PI，圆心正下方为0.5PI，选定义额开始位置和结束位置就可以绘制任意一个弧形，详情参见: <a href=\"https://www.yuque.com/guoqzuo/js_es6/sbx6vi#eda54f70\">之前的canvas笔记 - 绘制路径</a></p>\n</li>\n<li><p>画圆环使用的是ctx.stroke，一般默认画圆大概是1px的宽度，线的宽度可以使用 <strong>ctx.lineWidth</strong> 调整，这样就成圆环了</p>\n</li>\n<li><p>用ctx.arc画一个完整的圆，再画一个进度圆弧，重叠在一起，颜色设置不一样，就是一个标准的圆环进度条了。</p>\n</li>\n<li><p>进度圆环怎么设置圆角，可以使用 ctx.lineCap = &quot;round&quot;;</p>\n</li>\n<li><p>关于retina两倍屏，需要注意乘以设备像素比，参见：<a href=\"http://www.zuo11.com/blog/2020/7/canvas_dim.html\">canvas绘制模糊的问题</a></p>\n</li>\n</ol>\n<p><img src=\"../../../images/blog/js/canvas_progress.png\" alt=\"canvas_progress.png\"></p>\n<h2 id=\"简单代码实现\">简单代码实现</h2>\n<p>完整demo可以参见github：<a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/%E6%B8%90%E5%8F%98%E7%8E%AF%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1/index.html\">渐变环形进度条 | github</a></p>\n<pre><code class=\"language-html\">&lt;canvas id=&quot;drawing&quot; width=&quot;180&quot; height=&quot;180&quot; &gt;A draw of something.&lt;/canvas&gt;\n&lt;script&gt;\n  let drawing = document.getElementById(&#39;drawing&#39;);\n  let ctx = drawing.getContext(&#39;2d&#39;);\n  let percent = 80 // 进度百分比\n  let circleRadios = 80 // 圆环半径\n  let lineWidth = 10\n  let PI = 3.1415926\n  let long  = (percent / 100) * PI * 2 // 百分比进度条长度\n  let start = 1.5 * PI // 圆心正上方位置是 1.5PI\n  ctx.lineWidth = lineWidth\n\n  // 背景圆环\n  let x = circleRadios + lineWidth\n  let y = x\n  ctx.beginPath()\n  ctx.strokeStyle = &#39;rgb(241,247,255)&#39;\n  ctx.arc(x, y, circleRadios, start + long, start)\n  ctx.stroke()\n\n  // 进度圆环\n  ctx.beginPath()\n  let gradient = ctx.createLinearGradient(circleRadios * 2 + lineWidth * 2, lineWidth + circleRadios, 0 , circleRadios + lineWidth); // 从(130,130)到(160,160)渐变\n  gradient.addColorStop(0, &#39;#64E1FA&#39;); // 渐变的起点色\n  gradient.addColorStop(1, &#39;#215BF7&#39;); // 渐变的结束色\n  ctx.strokeStyle = gradient\n  ctx.arc(x, y, circleRadios, start, start + long)\n  ctx.lineCap = &quot;round&quot;;\n  ctx.stroke()\n&lt;/script&gt;</code></pre>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://juejin.im/post/5dc626125188253aec025a60#heading-10\">用初中数学知识撸一个canvas环形进度条</a></li>\n<li><a href=\"https://www.jianshu.com/p/e0fe05210134\">用canvas画一个进度条为圆角的环形图（圆环图）</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "canvas怎么绘制环形进度条",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "4个重点"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "简单代码实现"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "canvas怎么绘制环形进度条.md",
        "staticFileName": "canvas_progress.html",
        "author": "guoqzuo",
        "createDate": "2020/07/12",
        "description": "使用canvas绘制渐变的环形进度条，主要是使用arc函数，下面来看看。4个重点：1. 怎么画圆弧, ctx.arc函数里开始角度、结束角度以PI为基准，取值范围时：0 ~ 2PI，PI就是π值约等于3.14，圆心正上方位置为1.5PI，圆心右侧为 0 或 2*PI，圆心正下方为0.5PI，选定义额开始位置和结束位置就可以绘制任意一个弧形",
        "keywords": "canvas绘制环形进度条,js画环形渐变进度条,canvas画进度条",
        "category": "JavaScript",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"如果需要兼容ie还是用flex比较好，慎用grid\">如果需要兼容IE还是用flex比较好，慎用grid</h1>\n<p>grid适用于网格化布局，对于各个模块按百分比来的情况比较好，如果多个模块有的固定宽高有的非固定宽高就不怎么好分了, IE下支持需要加前缀，详情参见之前的笔记: <a href=\"https://www.yuque.com/guoqzuo/js_es6/kg7660#973d6cc6\">grid网格布局</a></p>\n<p>于是我在某个页面中使用了grid，但发现<strong>IE不兼容，grid的某些属性不兼容IE，加了-ms-都没用</strong>，最后为了不必要的麻烦和风险，还是换成flex布局了，改成flex后的代码居然比grid还简单...</p>\n<p>参考: <a href=\"http://www.imooc.com/wenda/detail/575101\">CSS网格布局即使带有前缀也不能在IE11中工作</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "如果需要兼容IE还是用flex比较好，慎用grid"
        }
      ],
      "config": {
        "source": "如果需要兼容IE还是用flex比较好，慎用grid.md",
        "staticFileName": "ie_grid.html",
        "author": "guoqzuo",
        "createDate": "2020/07/12",
        "description": "grid适用于网格化布局，对于各个模块按百分比来的情况比较好，如果多个模块有的固定宽高有的非固定宽高就不怎么好分了, IE下支持需要加前缀，详情参见之前的笔记: grid网格布局。于是我在某个页面中使用了grid，但发现IE不兼容，grid的某些属性不兼容IE，加了-ms-都没用，最后为了不必要的麻烦和风险，还是换成flex布局了，改成flex后的代码居然比grid还简单...",
        "keywords": "grid的兼容性,grid使用场景,grid,ie grid不兼容",
        "category": "CSS",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"mac-pro-retina屏两倍图，建议使用iconfont\">mac pro retina屏两倍图，建议使用iconfont</h1>\n<p>之前在处理canvas绘制模糊的问题时了解到，retina是两倍像素屏，50 x 50像素的图会绘制在 100 x 100 像素区域，会导致绘制模糊。</p>\n<p>同理，如果需要在retina屏上显示50 x 50的图，需要提供两倍图 100 * 100，然后设置样式宽高为50，这样才会清晰。</p>\n<p>最好的方式还是使用iconfont、svg矢量图等可以任意设置宽高(size)而不会失真的图或字体。这样就不会模糊。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "mac pro retina屏两倍图，建议使用iconfont"
        }
      ],
      "config": {
        "source": "mac pro retina屏两倍图，建议使用iconfont.md",
        "staticFileName": "retina_iconfont.html",
        "author": "guoqzuo",
        "createDate": "2020/07/12",
        "description": "之前在处理canvas绘制模糊的问题时了解到，retina是两倍像素屏，50 x 50像素的图会绘制在 100 x 100 像素区域，会导致绘制模糊。同理，如果需要在retina屏上显示50 x 50的图，需要提供两倍图 100 * 100，然后设置样式宽高为50，这样才会清晰。最好的方式还是使用iconfont、svg矢量图等可以任意设置宽高(size)而不会失真的图或字体。这样就不会模糊。",
        "keywords": "retina屏两倍图,建议使用iconfont",
        "category": "CSS",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-cli项目使用开头的路径是什么意思\">vue-cli项目使用@开头的路径是什么意思</h1>\n<p>我们在vue-cli创建的vue项目里，可以使用@开头的路径，表示从src目录开始，这样如果后面代码的目录层级有调整，或者复用代码时，都不会影响功能，代码更健壮</p>\n<pre><code class=\"language-js\">() =&gt; import(&#39;../../../components/xxx/xx&#39;)  // bad \n() =&gt; import(&#39;@/components/xxx/xx&#39;)  // good 对应 src/components/xxx/xx\nrequire(&#39;../../assets/img/xxx.png&#39;) // bad\nrequire(&#39;@/assets/img/xxx.png&#39;) // good 对应 src/assets/img/xxx.png</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue-cli项目使用@开头的路径是什么意思"
        }
      ],
      "config": {
        "source": "vue-cli项目使用@开头的路径是什么意思.md",
        "staticFileName": "vue_src_alias.html",
        "author": "guoqzuo",
        "createDate": "2020/07/12",
        "description": "我们在vue-cli创建的vue项目里，可以使用@开头的路径，表示从src目录开始，这样如果后面代码的目录层级有调整，或者复用代码时，都不会影响功能，代码更健壮",
        "keywords": "vue-cli项目使用@开头的路径是什么意思,@开头的路径,路径中有@",
        "category": "Vue",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"常用的gitignore配置\">常用的.gitignore配置</h1>\n<p>一般用git做代码管理时，需要将某些系统文件或配置文件不加入版本控制，就需要在.gitignore文件里加入对应的文件名或路径，下面是一个常用的.gitignore配置</p>\n<pre><code class=\"language-bash\">.DS_Store    # 苹果隐藏文件\nnode_modules # node包\n/dist        # dist目录\n\n# local env files\n.env.local\n.env.*.local\n\n# Log files\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Editor directories and files\n.idea\n.vscode\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw*\n\npackage-lock.json</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "常用的.gitignore配置"
        }
      ],
      "config": {
        "source": "常用的.gitignore配置.md",
        "staticFileName": "git_ignore.html",
        "author": "guoqzuo",
        "createDate": "2020/07/12",
        "description": "一般用git做代码管理时，需要将某些系统文件或配置文件不加入版本控制，就需要在.gitignore文件里加入对应的文件名或路径，下面是一个常用的.gitignore配置",
        "keywords": "gitignore配置,常用的.gitignore配置",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"uni-app开发需要了解的事情，uni-app开发体验怎么样\">uni-app开发需要了解的事情，uni-app开发体验怎么样</h1>\n<p>uni-app 读法为 u ni ai po，官网：<a href=\"https://uniapp.dcloud.io/README\">uni-app 官方文档</a></p>\n<h2 id=\"uni-app开发需要了解的事情\">uni-app开发需要了解的事情</h2>\n<ol>\n<li>uni-app开发需要下载HBuilderX开发工具</li>\n<li>需要注册ucloud账号，打包安卓、iOS时需要有证书。安卓的证书免费，iOS证书需要花钱</li>\n<li>uni开发和通常vue-cli搭的脚手架开发方式还是有一定区别的，更像是vue + 小程序开发的结合</li>\n<li>默认不支持 vue-router</li>\n<li>默认hello word打包安卓的apk包为 16M 左右</li>\n</ol>\n<h2 id=\"uni-app开发体验怎么样？\">uni-app开发体验怎么样？</h2>\n<p>如果你习惯开发vue，再来写uni，你会发现有很多问题</p>\n<ol>\n<li>vue-router非常不方便、vant组件用不了</li>\n<li>img标签到app上显示不了，需要使用image标签</li>\n<li>路由页面要在pages.json里设置，js跳转需要使用uni.navigator等内置API</li>\n</ol>\n<p>感觉开发体验很差。但如果你开发过小程序，你会发现</p>\n<ol>\n<li>template里UI组件部分基本类似于小程序开发</li>\n<li>script、style方面基本和vue开发体验保持一致，uni提供了许多类似于小程序的内置api，比如跳转路由、通用请求等</li>\n</ol>\n<p>综上：<strong>uni开发就是小程序开发和vue开发的结合</strong>，碰巧我在小程序开发和vue开发方面都有一定的开发经验，所以感觉还算得心应手，但对于没有开发过小程序的开发人员来讲，刚开始会觉得不怎么习惯。另外我个人不喜欢这种开发方式，有点乱，能少碰就尽量少碰，感觉整体代码很乱，强依赖uni框架与HBuilderX开发工具。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "uni-app开发需要了解的事情，uni-app开发体验怎么样",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "uni-app开发需要了解的事情"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "uni-app开发体验怎么样？"
            }
          ]
        }
      ],
      "config": {
        "source": "uni-app开发需要了解的事情，uni-app开发体验怎么样.md",
        "staticFileName": "uni_app_use.html",
        "author": "guoqzuo",
        "createDate": "2020/07/12",
        "description": "uni-app 读法为 u ni ai po，uni-app开发需要了解的事情：1. uni-app开发需要下载HBuilderX开发工具 2. 需要注册ucloud账号，打包安卓、iOS时需要有证书。安卓的证书免费，iOS证书需要花钱 3. uni开发和通常vue-cli搭的脚手架开发方式还是有一定区别的，更像是vue + 小程序开发的结合",
        "keywords": "uni-app,uni-app体验怎么样",
        "category": "移动端混合开发",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"uni设置tabbar后没显示的问题\">uni设置tabbar后没显示的问题</h1>\n<p>在pages.json里设置了tabbar配置，但设置成功后，在chrome运行却没效果，需要注意两点</p>\n<ol>\n<li>pages.json配置中tabBar参数设置的页面同时也需要在pages参数里设置</li>\n<li>pages数组中的第一项，必须是tabBar配置里的页面</li>\n</ol>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "uni设置tabbar后没显示的问题"
        }
      ],
      "config": {
        "source": "uni设置tabbar后没显示的问题.md",
        "staticFileName": "uni_tabbar_issue.html",
        "author": "guoqzuo",
        "createDate": "2020/07/12",
        "description": "在pages.json里设置了tabbar配置，但设置成功后，在chrome运行却没效果，需要注意两点：1. pages.json配置中tabBar参数设置的页面同时也需要在pages参数里设置 2. pages数组中的第一项，必须是tabBar配置里的页面",
        "keywords": "uni设置tabbar不生效,uni tabbar不生效",
        "category": "移动端混合开发",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"全国哀悼日，怎么用一行css代码将整个站点变灰\">全国哀悼日，怎么用一行css代码将整个站点变灰</h1>\n<p>前天4月4号全国哀悼日，各大网公司网站的风格都变灰了，是怎么实现的呢？其实很简单，一行代码就搞定。</p>\n<pre><code class=\"language-css\">/* 将html下的所有内容置灰 grayscale为灰度 */\nhtml {\n  filter: grayscale(100%);\n}</code></pre>\n<p>css filter是什么属性？用css filter mdn关键字查了下，这里filter翻译为 <strong>滤镜</strong>，<strong>他可以将模糊或色相等图形效果应用于元素</strong>，来看一些例子</p>\n<pre><code class=\"language-css\">/* 模糊，类似于马赛克效果 */\nfilter: blur(5px); \n/* 对比度 */\nfilter: contrast(100%);\n/* 色相 */\nfilter: hue-rotate(90deg);\n/* 阴影 */\nfilter: drop-shadow(16px 16px 20px red) invert(75%);</code></pre>\n<p>兼容性除了IE4-9，其他基本都兼容。Internet Explorer 4 to 9 implemented a non-standard filter property. The syntax was completely different from this one.</p>\n<p><img src=\"../../../images/blog/css/css_filter.png\" alt=\"css_filter.png\"></p>\n<p>更多filter文档及用法，参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter\">css filter - MDN</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "全国哀悼日，怎么用一行css代码将整个站点变灰"
        }
      ],
      "config": {
        "source": "全国哀悼日，怎么用一行css代码将整个站点变灰.md",
        "staticFileName": "css_filter_gray.html",
        "author": "guoqzuo",
        "createDate": "2020/07/12",
        "description": "前天4月4号全国哀悼日，各大网公司网站的风格都变灰了，是怎么实现的呢？其实很简单，一行代码就搞定。filter: grayscale(100%); css filter是什么属性？用css filter mdn关键字查了下，这里filter翻译为 滤镜，他可以将模糊或色相等图形效果应用于元素，来看一些例子",
        "keywords": "css滤镜,css filter,怎么用一行css代码将整个站点变灰,怎么将站点置灰",
        "category": "CSS",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"web前端bfc，什么是bfc\">web前端BFC，什么是BFC</h1>\n<p>虽然做前端好几年了，但只是听说个这个名词，一直不清楚具体是什么意思，今天来研究下</p>\n<h2 id=\"bfc相关示例\">BFC相关示例</h2>\n<p>BFC是 <strong>Block Formatting Context</strong> 的缩写，字面意思是 <strong>块格式化上下文</strong> 字面意思很难理解，我们先来看几个例子</p>\n<h3 id=\"1-margin塌陷问题\">1. margin塌陷问题</h3>\n<p>下面的例子中A、B两个元素的margin都为10px，理论上A、B上下间的距离为 20px，但实际却是 10px</p>\n<pre><code class=\"language-html\">&lt;div&gt;\n  &lt;div class=&quot;elementA&quot; style=&quot;margin: 10px&quot;&gt;123&lt;/div&gt;\n  &lt;div class=&quot;elementB&quot; style=&quot;margin: 10px&quot;&gt;456&lt;/div&gt;\n&lt;/div&gt; </code></pre>\n<p>利用BFC解决塌陷的问题，用父元素包裹并设置overflow为hidden，这样间隔就是20px了</p>\n<pre><code class=\"language-html\">&lt;div&gt;\n  &lt;div class=&quot;elementA&quot; style=&quot;margin: 10px&quot;&gt;123&lt;/div&gt;\n  &lt;div style=&quot;overflow:hidden&quot;&gt;\n    &lt;div class=&quot;elementB&quot; style=&quot;margin: 10px;&quot;&gt;456&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt; </code></pre>\n<h3 id=\"2-float父级元素高度为0的问题\">2. float父级元素高度为0的问题</h3>\n<p>wrapper的子元素使用了float，其高度为100px，但他的父级元素wrapper高度为0</p>\n<pre><code class=\"language-html\">&lt;div class=&quot;wrapper&quot;&gt;\n  &lt;div style=&quot;float:left;height:100px&quot;&gt;123&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<p>解决方案如下,给wrapper添加一个BFC属性，这时wrapper的高度就是子元素的高度</p>\n<pre><code class=\"language-html\">&lt;div class=&quot;wrapper&quot; style=&quot;overflow:hidden&quot;&gt;\n  &lt;div style=&quot;float:left;height:100px&quot;&gt;123&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<h3 id=\"3-float高度超出父元素容器区域的问题\">3. float高度超出父元素容器区域的问题</h3>\n<p>box元素为父元素，float元素高度为150，此时，float会超出父元素范围</p>\n<pre><code class=\"language-html\">&lt;div class=&quot;box&quot; style=&quot;background: blue;border:1px solid red;&quot;&gt;\n  &lt;div class=&quot;float&quot; style=&quot;float: left;width: 200px;height: 150px;border: 1px solid #ccc;background: white;&quot;&gt;\n    I am a floated box!\n  &lt;/div&gt;\n  &lt;p&gt;I am content inside the container.&lt;/p&gt;\n&lt;/div&gt;</code></pre>\n<p>利用BFC，使浮动内容和周围的内容等高，给box元素加一个overflow:hidden即可</p>\n<pre><code class=\"language-html\">&lt;div class=&quot;box&quot; style=&quot;background: blue;border:1px solid red;overflow:hidden&quot;&gt;\n  &lt;div class=&quot;float&quot; style=&quot;float: left;width: 200px;height: 150px;border: 1px solid #ccc;background: white;&quot;&gt;\n    I am a floated box!\n  &lt;/div&gt;\n  &lt;p&gt;I am content inside the container.&lt;/p&gt;\n&lt;/div&gt;</code></pre>\n<h2 id=\"bfc是什么\">BFC是什么</h2>\n<p>通过上面两个例子，我们会很好奇，为什么加个overlfow:hidden就能解决问题，BFC 块级格式化上下文到底是什么？</p>\n<p><strong>BFC 块级格式化上下文主要和float、clear、margin塌陷问题有关联</strong></p>\n<p>一般情况下BFC只存在于根级元素(html)，但设置某些CSS属性时也会让产生BFC。但是前提是必须是块级元素。</p>\n<p>以下属性声明会产生BFC：</p>\n<ul>\n<li>浮动元素（元素的 float 不是 none）</li>\n<li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li>\n<li>行内块元素（元素的 display 为 inline-block）</li>\n<li>表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）</li>\n<li>表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</li>\n<li>匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）</li>\n<li>overflow 值不为 visible 的块元素</li>\n<li>display 值为 flow-root 的元素（该属性safari不支持）</li>\n<li>contain 值为 layout、content或 paint 的元素</li>\n<li>弹性元素（display为 flex 或 inline-flex元素的直接子元素）</li>\n<li>网格元素（display为 grid 或 inline-grid 元素的直接子元素）</li>\n<li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li>\n<li>column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</li>\n</ul>\n<p>BFC布局规则</p>\n<ul>\n<li>垂直方向的间隔由margin决定，同一个BFC里同级别的两个元素之间的margin会产生坍塌（问题1）</li>\n<li>BFC计算高度时，float元素的高度也参与计算 （问题 2/3）</li>\n<li>每个BFC区域是隔离的，它里面元素不会影响外层，外层的各种变化也不会影响BFC区域。</li>\n</ul>\n<p>Block formatting contexts are important for the positioning (see float) and clearing (see clear) of floats. The rules for positioning and clearing of floats apply only to things within the same block formatting context. Floats don&#39;t affect the layout of the content inside other block formatting contexts, and clear only clears past floats in the same block formatting context. Margin collapsing also occurs only between blocks that belong to the same block formatting context.</p>\n<p>块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。</p>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://www.cnblogs.com/homehtml/articles/11960651.html\">BFC深入理解</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context\">Block formatting context - MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear\">css clear - MDN</a></li>\n<li><a href=\"\">css float - MDN</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "web前端BFC，什么是BFC",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "BFC相关示例",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "1. margin塌陷问题"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "2. float父级元素高度为0的问题"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "3. float高度超出父元素容器区域的问题"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "BFC是什么"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "web前端BFC，什么是BFC.md",
        "staticFileName": "web_bfc.html",
        "author": "guoqzuo",
        "createDate": "2020/07/12",
        "description": "虽然做前端好几年了，但只是听说个这个名词，一直不清楚具体是什么意思，今天来研究下。BFC是 Block Formatting Context 的缩写，字面意思是 块格式化上下文。 字面意思很难理解，我们先来看几个例子",
        "keywords": "web BFC,前端BFC,css BFC,什么是BFC",
        "category": "CSS",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"nginx以及koa实现301跳转：xxcom重定向到wwwxxcom\">nginx以及koa实现301跳转：xx.com重定向到<code>www.xx.com</code></h1>\n<p>今天帮一个同学测试网络，使用curl来请求百度，发现 baidu.com 到 <code>www.baidu.com</code> 的重定向使用的是 html 的meta元素</p>\n<pre><code class=\"language-bash\">curl -v baidu.com\n# &lt;html&gt;\n# &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;\n# &lt;/html&gt;</code></pre>\n<p>当访问 baidu.com时，0秒后刷新页面到 <code>http://www.baidu.com</code> ，以后如果在不依赖nginx配置的情况下，可以使用这种方式。meta元素使用方法可以参考之前的笔记：<a href=\"https://www.yuque.com/guoqzuo/js_es6/qk5v84#edbe1211\">http-equiv改写http标头字段</a></p>\n<h2 id=\"nginx重定向使用的是301跳转\">nginx重定向使用的是301跳转</h2>\n<p>之前我有处理过 zuo11.com 跳转到 <code>www.zuo11.com</code> 的情况，配置了nginx，具体方法参见 <a href=\"https://www.yuque.com/guoqzuo/csm14e/hd0tdl#c1a009e0\">nginx 访问不带www的域名，自动切到www</a></p>\n<p>curl -v zuo11.com nginx响应内容如下：</p>\n<pre><code class=\"language-bash\">curl -v zuo11.com\n* Rebuilt URL to: zuo11.com/\n*   Trying 47.107.190.93...\n* TCP_NODELAY set\n* Connected to zuo11.com (47.107.190.93) port 80 (#0)\n&gt; GET / HTTP/1.1\n&gt; Host: zuo11.com\n&gt; User-Agent: curl/7.54.0\n&gt; Accept: */*\n&gt; \n&lt; HTTP/1.1 301 Moved Permanently\n&lt; Server: nginx/1.16.1\n&lt; Date: Mon, 06 Apr 2020 12:56:22 GMT\n&lt; Content-Type: text/html\n&lt; Content-Length: 169\n&lt; Connection: keep-alive\n&lt; Location: http://www.zuo11.com/\n&lt; \n&lt;html&gt;\n&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;\n&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;\n&lt;hr&gt;&lt;center&gt;nginx/1.16.1&lt;/center&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>也就是当访问zuo11.com时，nginx会用301重定向到 <code>www.zuo11.com</code>。</p>\n<h2 id=\"koa实现301跳转\">koa实现301跳转</h2>\n<p>我们可以做一个测试，当接收到一个请求后，修改状态码为301，然后设置Location响应头为 <code>http://www.zuo11.com</code> 看是否可以重定向页面，来写个koa例子</p>\n<pre><code class=\"language-js\">const Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\napp.use((ctx) =&gt; {\n  console.log(ctx.url)\n  if (ctx.url === &#39;/test&#39;) {\n    // 当访问 /test 时 301重定向到 http://www.zuo11.com\n    ctx.status = 301\n    ctx.set({\n      &#39;Location&#39;: &#39;http://www.zuo11.com&#39;\n    })\n    return\n  }\n  // 非 /test 时，页面显示 welcome\n  ctx.body = &#39;welcome&#39;\n})\n\napp.listen(&#39;9000&#39;, () =&gt; { console.log(&#39;服务已开启，9000端口&#39;) })</code></pre>\n<p>通过测试上面的例子，发现只要响应的状态码设置为301，且响应头Location设置为要重定向的网页，就可以301跳转到对应的页面，新技能get</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "nginx以及koa实现301跳转：xx.com重定向到`www.xx.com`",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "nginx重定向使用的是301跳转"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "koa实现301跳转"
            }
          ]
        }
      ],
      "config": {
        "source": "nginx以及koa实现301跳转：xx.com重定向到www.xx.com.md",
        "staticFileName": "nginx_koa_301.html",
        "author": "guoqzuo",
        "createDate": "2020/07/12",
        "description": "今天帮一个同学测试网络，使用curl来请求百度，发现baidu.com到 www.baidu.com 的重定向使用的是 html 的meta元素。我们可以做一个测试，当接收到一个请求后，修改状态码为301，然后设置Location响应头为 http://www.zuo11.com 看是否可以重定向页面，来写个koa例子",
        "keywords": "nginx重定向使用301,koa实现301,xx.com重定向到www.xx.com",
        "category": "http与https",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"dateprototypetolocalestring在0点或12点时转换异常的问题\">Date.prototype.toLocaleString()在0点或12点时转换异常的问题</h1>\n<p>在使用toLocaleString把Date转为字符串时，需要额外注意时间为 &#39;00:00:00&#39; 和 &#39;12:00:00&#39; 的情况，它们分别会被转为 上午12:00:00，下午12点，下面来看看</p>\n<pre><code class=\"language-js\">a = new Date(&#39;2020/04/10 00:00:00&#39;) \n// Fri Apr 10 2020 00:00:00 GMT+0800 (中国标准时间)\n\na.toLocaleString() // &quot;2020/4/10 上午12:00:00&quot;\na.getHours() // 0\na.getMinutes() // 0\na.getSeconds() // 0</code></pre>\n<p>那我们来试试 &#39;12:00:00&#39; 的情况</p>\n<pre><code class=\"language-js\">a = new Date(&#39;2020/04/10 12:00:00&#39;) \n// Fri Apr 10 2020 12:00:00 GMT+0800 (中国标准时间)\na.toLocaleString() // &quot;2020/4/10 下午12:00:00&quot;\na.getHours() // 12</code></pre>\n<p>综上:<strong>虽然Date对象的toLocaleString()比较好用，但还是仅用日期方面的toLocaleDateString()，时间方面的还是尽量不要使用</strong></p>\n<p>参考：<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString\">Date.prototype.toLocaleString() - MDN</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Date.prototype.toLocaleString()在0点或12点时转换异常的问题"
        }
      ],
      "config": {
        "source": "Date.prototype.toLocaleString()在0点或12点时转换异常的问题.md",
        "staticFileName": "toLocaleString_exception.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "toLocaleString时间异常的情况，toLocaleString在0点或12点时时间转换问题，在使用toLocaleString把Date转为字符串时，需要额外注意时间为 '00:00:00' 和 '12:00:00' 的情况，它们分别会被转为 上午12:00:00，下午12点，下面来看看",
        "keywords": "toLocaleString时间异常的情况,toLocaleString在0点或12点时时间转换问题",
        "category": "JavaScript",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"怎么将date数据转为tz格式的字符串\">怎么将Date数据转为TZ格式的字符串</h1>\n<p>后台要求的数据格式 &quot;2020-04-10T04:01:00.000Z&quot; 为TZ格式的字符串。Date对象toString为 &quot;Fri Apr 10 2020 12:00:00 GMT+0800 (中国标准时间)&quot; 这种格式，那怎么转TZ字符串格式呢？<strong>用 Date.prototype.toJSON() 方法即可</strong> </p>\n<pre><code class=\"language-js\">a = new Date(&#39;2020/04/10 12:00:00&#39;) \nFri Apr 10 2020 12:00:00 GMT+0800 (中国标准时间)\n\na.toJSON() //&quot;2020-04-10T04:01:00.000Z&quot;</code></pre>\n<p>参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toJSON\">Date.prototype.toJSON() - MDN</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "怎么将Date数据转为TZ格式的字符串"
        }
      ],
      "config": {
        "source": "怎么将Date数据转为TZ格式的字符串.md",
        "staticFileName": "date_tojson.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "TZ时间字符串，toJSON后时间转换为TZ格式，后台要求的数据格式 '2020-04-10T04:01:00.000Z' 为TZ格式的字符串。Date对象toString为 'Fri Apr 10 2020 12:00:00 GMT+0800 (中国标准时间)' 这种格式，那怎么转TZ字符串格式呢？用 Date.prototype.toJSON() 方法即可 ",
        "keywords": "TZ时间字符串,toJSON后时间转换为TZ格式,怎么将Date数据转为TZ格式的字符串",
        "category": "JavaScript",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"failed-to-resolve-directive-infinite-scroll\">Failed to resolve directive: infinite-scroll</h1>\n<p>在element InfiniteScroll无限滚动功能里，使用了v-infinite-scroll指令，但直接使用会发现提示 Failed to resolve directive: infinite-scroll，后面查了下，发现<strong>要使用该指令需要安装一个vue-infinite-scroll npm包，并且在main.js里引入才行</strong></p>\n<pre><code class=\"language-js\">// 安装vue-infinite-scroll\n// npm install vue-infinite-scroll --save\n\n// 在main.js里引入\nimport infiniteScroll from &quot;vue-infinite-scroll&quot;;\nVue.use(infiniteScroll);</code></pre>\n<p>这样就能正常使用了，注意加载数据 v-infinite-scroll=&quot;load&quot; 指定的load函数里，获取数据后，每次push到列表list即可。首次进入会自动加载一次，无需在created钩子里手动请求一次数据，注意当在load里要加个判断，如果获取数据长度为0，或超出数据页数时，就不再继续load了</p>\n<p>需要注意: <strong>v-infinite-scroll 必须放在一个单独的单文件组件里，不要放到某个组件的slot里。且不要用v-if控制，使用v-show，这样可以防止首次不触发loadMore的问题</strong>。详情参见：<a href=\"http://www.zuo11.com/blog/2020/7/v-infinite-scroll.html\">v-infinite-scroll放到slot里或者用v-if控制时首次无法触发loadMore的问题</a></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_38502227/article/details/103891962\">[Vue warn]: Failed to resolve directive: infinite-scroll</a></li>\n<li><a href=\"https://element.eleme.cn/#/zh-CN/component/infiniteScroll\">无限滚动指令 v-infinite-scroll - Element</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Failed to resolve directive: infinite-scroll"
        }
      ],
      "config": {
        "source": "Failed to resolve directive: infinite-scroll.md",
        "staticFileName": "infinite-scroll.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "在element InfiniteScroll无限滚动功能里，使用了v-infinite-scroll指令，但直接使用会发现提示 Failed to resolve directive: infinite-scroll，后面查了下，发现要使用该指令需要安装一个vue-infinite-scroll npm包，并且在main.js里引入才行",
        "keywords": "Failed to resolve directive: infinite-scroll,element v-infinite-scroll指令",
        "category": "Vue",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"v-infinite-scroll-放到slot里或者用v-if控制时首次无法触发loadmore的问题\">v-infinite-scroll 放到slot里或者用v-if控制时首次无法触发loadMore的问题</h1>\n<p>最新项目结构调整，发现一个问题，把 v-infinite-scroll 对应的元素放到 slot 里，首次无法触发loadMore, 不放到slot里面又是正常的，来看代码</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;-- 用 sub-comps-middle 组件嵌套，写在slot时，无法加载loadMore，去掉sub-comps-middle 就是正常的--&gt;\n    &lt;sub-comps-middle&gt;\n      &lt;div v-infinite-scroll=&quot;loadMore&quot; infinite-scroll-distance=&quot;10&quot;&gt;\n        测试\n      &lt;/div&gt;\n    &lt;/sub-comps-middle&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre>\n<p>带着这个问题，我看了下 v-infinite-scroll 的源码，在关键位置写了几个console，找到了其中的原因，来看看产生问题的地方</p>\n<pre><code class=\"language-js\">// InfiniteScroll 部分源码\n// github地址：https://github.com/ElemeFE/vue-infinite-scroll/blob/master/src/directive.js\nvar InfiniteScroll = {\n  bind: function bind(el, binding, vnode) {\n    el[ctx] = {\n      el: el,\n      vm: vnode.context,\n      expression: binding.value\n    };\n    var args = arguments;\n    console.log(&#39;bindfunc before mouted&#39;, el[ctx].vm, el[ctx])\n    el[ctx].vm.$on(&#39;hook:mounted&#39;, function () {\n      console.log(&#39;hook:mounted&#39;)\n      el[ctx].vm.$nextTick(function () {\n        if (isAttached(el)) {\n          doBind.call(el[ctx], args);\n        }</code></pre>\n<p>正常情况下，页面一加载，InfiniteScroll 会开始初始化，执行其bind函数。bind函数里加了一个监听，当接收到当前组件的 hook:mounted 事件，也就是mounted事件时，开始做真正的绑定，执行doBind方法。</p>\n<p>那么问题来了，正常情况下，在组件mounted之前，InfiniteScroll会完成初始化，这样就可以接收到页面的mounted消息，然后执行真正的相关事件绑定。</p>\n<p>假如我们把 v-infinite-scroll 写在slot里，当前页面组件mounted过后，InfiniteScroll才执行初始化，初始化时监听mounted再执行doBind，而页面已经mounted过了，所以会无法触发loadMore，同理，v-if 控制时，如果为false，可能会有InfiniteScroll没初始化之前，页面就已经mounted的情况。</p>\n<p>怎么解决这个问题呢？<strong>记住 v-infinite-scroll 必须放在一个单独的单文件组件里，不要放到某个组件的slot里。且不要用v-if控制，使用v-show，这样就不会有问题了。</strong></p>\n<p>测试demo，参见: <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/views/infiniteScrollTest\">v-infinite-scroll 测试demo</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "v-infinite-scroll 放到slot里或者用v-if控制时首次无法触发loadMore的问题"
        }
      ],
      "config": {
        "source": "v-infinite-scroll放到slot里或者用v-if控制时首次无法触发loadMore的问题.md",
        "staticFileName": "v-infinite-scroll.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "v-infinite-scroll不触发loadMore，element v-infinite-scroll指令, 最新项目结构调整，发现一个问题，把 v-infinite-scroll 对应的元素放到 slot 里，首次无法触发loadMore, 不放到slot里面又是正常的，来看代码",
        "keywords": "v-infinite-scroll不触发loadMore,element v-infinite-scroll指令",
        "category": "Vue",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"arrayprototypefill填充引用类型值的问题\">Array.prototype.fill()填充引用类型值的问题</h1>\n<p>在mock表格list数据时，我一般为了简洁会先创建一个对象info，然后new Array(10).fill(info) 来生成10条数据的数组</p>\n<p>但这次发现一个问题，由于表格有一个字段是状态值0 - 5，我想随机设置下值，发现修改后的值都一样，来看看例子</p>\n<pre><code class=\"language-js\">let a = {a: 1}\nlet b = Object.assign({}, a) // {a: 1}\nlet c = Object.assign({}, a) // {a: 1}\nb.b = 2 // 尝试修改值，看看a和c是否修改，发现只有b修改了，a,c没变说明地址不一样\n\n// 来看看fill\nlet list = new Array(5).fill(Object.assign({}, a))\n// 乍一看，貌似每个填充的地址都不一样，我们修改数组中的一个元素试试\nlist[0].b = 2</code></pre>\n<p>再打印list，发现list所有数组对象的值都变了，因此<strong>fill填充的对象都指向同一个地址</strong></p>\n<p>用 Array.prototype.fill() mdn查权威文档，发现里面确实有这一块的描述</p>\n<pre><code class=\"language-js\">// Objects by reference.\nvar arr = Array(3).fill({}) // [{}, {}, {}];\n// 需要注意如果fill的参数为引用类型，会导致都执行都一个引用类型\n// 如 arr[0] === arr[1] 为true\narr[0].hi = &quot;hi&quot;; // [{ hi: &quot;hi&quot; }, { hi: &quot;hi&quot; }, { hi: &quot;hi&quot; }]</code></pre>\n<p>那么遇到这种情况不能用fill要怎么处理呢</p>\n<pre><code class=\"language-js\">let a = {a: 1}\n// 这里还是用了fill 如果不fill内容到数组，map遍历时会忽略所有空的元素\nlet list = new Array(5).fill({}).map(item =&gt; {\n  item = Object.assign({}, a)\n  item.xxx = Math.round(Matn.random() * 5)\n  return item\n})</code></pre>\n<p>参考: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill\">Array.prototype.fill() - MDN</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Array.prototype.fill()填充引用类型值的问题"
        }
      ],
      "config": {
        "source": "Array.prototype.fill()填充引用类型值的问题.md",
        "staticFileName": "araay_fill.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "js 数组fill填充的对象都指向同一个地址，array fill填充引用类型问题，在mock表格list数据时，我一般为了简洁会先创建一个对象info，然后new Array(10).fill(info) 来生成10条数据的数。但这次发现一个问题，由于表格有一个字段是状态值0 - 5，我想随机设置下值，发现修改后的值都一样，来看看例子",
        "keywords": "js 数组fill填充的对象都指向同一个地址,array fill填充引用类型问题",
        "category": "JavaScript",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"jsonstringify的非常规用法以及内部执行顺序\">JSON.stringify的非常规用法以及内部执行顺序</h1>\n<p>JSON.stringify我们一般用于将JSON对象转为字符串，但他不仅仅只有一个参数，而是三个，除最常用的用法外，还可以用来做三种实用功能: 1.利用第三参数在console里更好的展示对象; 2.有选择性的过滤字段; 3.详细处理没有字段序列化的值</p>\n<h2 id=\"利用第三参数在console里更好的展示对象\">利用第三参数在console里更好的展示对象</h2>\n<pre><code class=\"language-js\">// 1. 对于像这种多层级的数据，console到控制台时，会不好查看需要一层层点击，很麻烦\nlet obj = { list: [ {a: 1}, {a: 2}], total: 100 }\nconsole.log(obj)\n\n// 更好的展现，第三参数可以在转JSON字符串时，在json对象的缩进位置填充字符并加上换行符\n// 缩进位置填充的内容，根据第三参数的类型决定：\n// 如果是整数，填充对应的空格数(最大为10)，如果是字符串，填充充对应的字符串\nJSON.stringify(obj, null, 2) </code></pre>\n<p><img src=\"../../../images/blog/js/json_stringify.png\" alt=\"json_stringify.png\"></p>\n<h2 id=\"有选择性的过滤字段\">有选择性的过滤字段</h2>\n<pre><code class=\"language-js\">let obj = { list: [ {a: 1}, {a: 2} ], total: 100 }\n// 如果我们想深拷贝obj，但只深拷贝其total字段，其他的字段不需要，就可以用第二个参数\nlet newObj = JSON.parse(JSON.stringify(obj, [&#39;total&#39;]))\n// newObj 值为 { total: 100 }\n\n// 实例：在vue项目中，用js删除当前url query参数中的id参数\nlet query = this.$route.query\nthis.$router.replace({ \n  path: this.$route.path, \n  query: JSON.parse(JSON.stringify(query, Object.keys(query).filter(item =&gt; item !== &#39;id&#39;))) \n})</code></pre>\n<h2 id=\"详细处理每个字段序列化的值\">详细处理每个字段序列化的值</h2>\n<pre><code class=\"language-js\">let obj = { list: [ {a: 1}, {a: 2} ], total: 100 }\nlet new = JSON.stringify(obj, (key, value) =&gt; {\n  return key === &#39;list&#39; ? &#39;改写list序列化的值&#39; : value\n}) \n// new 的值为 {&quot;list&quot;:&quot;改写list序列化的值&quot;,&quot;total&quot;:100}</code></pre>\n<p>JSON.stringify(obj)时，其实内部调用的是 obj 的 toJSON()方法，如果我们重写该方法，就可以改变序列化后返回的值</p>\n<h2 id=\"jsonstringify执行顺序\">JSON.stringify()执行顺序</h2>\n<ol>\n<li>如果对象中存在toJSON方法，且能通过它获取有效的值，则调用该方法，返回对应的值用于下一步，否则返回对象本身。</li>\n<li>如果提供了第二个参数，根据对应的参数过滤第(1)步得到的值</li>\n<li>对第(2)步返回的每个值进行进行相应的序列化</li>\n<li>如果提供了第三个参数，执行相应的格式化</li>\n</ol>\n<p>详情参考之前的笔记: <a href=\"https://www.yuque.com/guoqzuo/js_es6/strtxi#8960b7f6\">JSON.stringify() - JS高程3笔记</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "JSON.stringify的非常规用法以及内部执行顺序",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "利用第三参数在console里更好的展示对象"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "有选择性的过滤字段"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "详细处理每个字段序列化的值"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "JSON.stringify()执行顺序"
            }
          ]
        }
      ],
      "config": {
        "source": "JSON.stringify的非常规用法以及内部执行顺序.md",
        "staticFileName": "stringify_use.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "JSON.stringify，JSON.stringify用法总结,JSON.stringify内部执行顺序,JSON.stringify非常规用法，我们一般用于将JSON对象转为字符串，但他不仅仅只有一个参数，而是三个，除最常用的用法外，还可以用来做三种实用功能: 1.利用第三参数在console里更好的展示对象; 2.有选择性的过滤字段; 3.详细处理没有字段序列化的值",
        "keywords": "JSON.stringify,JSON.stringify用法总结,JSON.stringify内部执行顺序,JSON.stringify非常规用法",
        "category": "JavaScript",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"iconfont通过设置class来显示图标内部做了那些操作\">iconfont通过设置class来显示图标内部做了那些操作</h1>\n<p>注意我们在用class使用iconfont图标时，为什么可以使用，主要是iconfont.css里面做了三步操作:</p>\n<ol>\n<li>定义iconfont的 font-familay</li>\n<li>为.iconfont设置默认样式，指定为font-family字体</li>\n<li>为每个图标的class设置before的content</li>\n</ol>\n<p>来看具体的demo，示例</p>\n<pre><code class=\"language-css\">@font-face {\n  font-family: &quot;iconfont&quot;;\n  src: url(&#39;iconfont.eot?t=1586579952536&#39;); /* IE9 */\n  src: url(&#39;iconfont.eot?t=1586579952536#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */\n  url(&#39;data:application/x-font-woff2;charset=utf-8;base64,省略...&#39;) format(&#39;woff2&#39;),\n  url(&#39;iconfont.woff?t=1586579952536&#39;) format(&#39;woff&#39;),\n  url(&#39;iconfont.ttf?t=1586579952536&#39;) format(&#39;truetype&#39;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */\n  url(&#39;iconfont.svg?t=1586579952536#iconfont&#39;) format(&#39;svg&#39;); /* iOS 4.1- */\n}\n\n.iconfont {\n  font-family: &quot;iconfont&quot; !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.iconok:before {\n  content: &quot;\\e63c&quot;;\n}\n\n.iconerror1:before {\n  content: &quot;\\e651&quot;;\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iconfont通过设置class来显示图标内部做了那些操作"
        }
      ],
      "config": {
        "source": "iconfont通过设置class来显示图标内部做了那些操作.md",
        "staticFileName": "iconfont_class.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "iconfont是怎么通过class来加载图标的，内部做了哪些操作，注意我们在用class使用iconfont图标时，为什么可以使用，主要是iconfont.css里面做了三步操作: 1. 定义iconfont的 font-familay 2. 为.iconfont设置默认样式，指定为font-family字体 3. 为每个图标的class设置before的content",
        "keywords": "iconfont是怎么通过class来加载图标的,内部做了哪些操作,iconfont class字体图标",
        "category": "CSS",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue全局引入组件vueuse与vuecomponent的用法与区别\">vue全局引入组件Vue.use()与Vue.component()的用法与区别</h1>\n<p>之前的笔记里有将Vue.use()全局引入组件的方法，其实用 Vue.compoennt()也可以全局引入组件。下面来看具体用法，以及他们的区别</p>\n<pre><code class=\"language-bash\">alert\n├── src\n│   └── main.vue  # 组件实现\n└── index.js # install方法，供全局引入\nindex.js 提供install方法，供Vue.use()使用</code></pre>\n<pre><code class=\"language-js\">import Alert from &#39;./src/main&#39;;\n\n/* istanbul ignore next */\nAlert.install = function(Vue) {\n  Vue.component(Alert.name, Alert);\n};\n\nexport default Alert;</code></pre>\n<p>main.js全局引入组件的两种方式</p>\n<pre><code class=\"language-js\">// 1. Vue.use()\nimport Alert from &#39;@/components/alert/index.js&#39;\nVue.use(Alert)\n\n// 2. Vue.component()\nimport Alert from &quot;@/components/alert/src/main.vue&quot;\nVue.component(&#39;alert&#39;, Alert)</code></pre>\n<p>Vue.use 和Vue.component 全局引入组件之间的区别：</p>\n<ol>\n<li>Vue.component 只是单纯的引入组件、不需要额外写支持的js文件</li>\n<li>Vuew.use 除组件外，需要写额外的js实现install方法，但它不仅可以注入组件，还可以注入很多其他东西，比如全局实例属性等。</li>\n</ol>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue全局引入组件Vue.use()与Vue.component()的用法与区别"
        }
      ],
      "config": {
        "source": "vue全局引入组件Vue.use()与Vue.component()的用法与区别.md",
        "staticFileName": "vue_global_comps.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "vue全局组件，Vue.use与Vue.component区别，之前的笔记里有将Vue.use()全局引入组件的方法，其实用 Vue.compoennt()也可以全局引入组件。下面来看具体用法，以及他们的区别",
        "keywords": "vue全局组件,Vue.use()与Vue.component()的区别,Vue.use与Vue.component区别",
        "category": "Vue",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue页面中监听路由改变的2种方法\">vue页面中监听路由改变的2种方法</h1>\n<p>在vue中，怎么监听vue-router路由的变更呢？一般有两种方法</p>\n<ol>\n<li>单页面组件中，使用 beforeRouteEnter</li>\n<li>使用watch监听$route</li>\n</ol>\n<pre><code class=\"language-js\">// 1.单页面组件中，使用 beforeRouteEnter\ncreated() {\n},\nbeforeRouteEnter(to, from, next) {\n    next(vm =&gt; {\n        // vm就是this了\n    })\n},\n\n// 2.使用watch监听$route\nwatch: {\n    $route(to, from) {\n        // xxx\n    }\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue页面中监听路由改变的2种方法"
        }
      ],
      "config": {
        "source": "vue页面中监听路由改变的2种方法.md",
        "staticFileName": "vue_watch_router.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "vue监听路由变化,vue监听路由,在vue中，怎么监听vue-router路由的变更呢？一般有两种方法 1. 单页面组件中，使用 beforeRouteEnter 2. 使用watch监听$route",
        "keywords": "ue监听路由变化,vue监听路由,监听vue-router变化",
        "category": "Vue",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"git无法检测到文件名大小写的更改，为什么？怎么解决？\">git无法检测到文件名大小写的更改，为什么？怎么解决？</h1>\n<p>今天把开发分支合并到月底分支后，发现之前修改过文件名没有提交上去，手动改文件名后，git status 提示没有任何改动。</p>\n<p>于是百度了下，发现git默认配置为忽略大小写，因此无法正确检测大小写的更改。</p>\n<p><strong>临时解决办法：在当前项目使用git config core.ignorecase false，关闭git忽略大小写配置即可</strong></p>\n<p>问题来了，提交后，远程仓库服务器上可以会同时存在两个文件，原来的文件并没有删除，为什么呢？</p>\n<p><strong>macos是文件大小写不敏感的系统，而widonws/linux是大小写敏感的，假设把git上之前提交过的文件，修改大小写，再次提交后，git上会出现两个大小写不一样的文件</strong></p>\n<p>macos是大小写不敏感的文件系统，也就是在macos上你无法在同一个目录下同时创建test.vue和Test.vue，如果出现这种情况，本地感知不到文件的改动，但git服务器却有记录这两个文件。</p>\n<p><strong>最好的解决方法是将整个文件名都变更。而不是仅改变大小写</strong></p>\n<p>参考: <a href=\"https://blog.csdn.net/sqlquan/article/details/93722680\">Git无法检测到文件名大小写的更改</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "git无法检测到文件名大小写的更改，为什么？怎么解决？"
        }
      ],
      "config": {
        "source": "git无法检测到文件名大小写的更改，为什么？怎么解决？.md",
        "staticFileName": "git_file_name.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "git无法检测文件大小写改变,mac系统文件大小写不敏感，今天把开发分支合并到月底分支后，发现之前修改过文件名没有提交上去，手动改文件名后，git status 提示没有任何改动。于是百度了下，发现git默认配置为忽略大小写，因此无法正确检测大小写的更改。",
        "keywords": "mac文件大小写不敏感,macOS文件大小写不敏感,git无法检测文件大小写改变",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"css利用perspective画梯形\">css利用perspective画梯形</h1>\n<p>今天看小伙伴的代码，发现有一个梯形的实现居然是css写的，我以为需要UI提供icon。这里用到了 perspective 远景这个参数</p>\n<p><img src=\"../../../images/blog/css/css_perspective.png\" alt=\"css_perspective.png\"></p>\n<pre><code class=\"language-css\">/*  &lt;div class=&quot;tx&quot;&gt;&lt;/div&gt; */\n.tx {\n  width: 100px;\n  height: 40px;\n  margin: 100px;\n  border: 1px solid #ccc;\n  transform: perspective(2em) rotateX(-10deg);\n}</code></pre>\n<p>CSS 属性 perspective指定了观察者与 z=0 平面的距离，使具有三维位置变换的元素产生透视效果。 z&gt;0 的三维元素比正常大，而 z&lt;0 时则比正常小，大小程度由该属性的值决定。</p>\n<p>参考: </p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/perspective\">css perspective | MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform\">css transfrom | MDN</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "css利用perspective画梯形"
        }
      ],
      "config": {
        "source": "css利用perspective画梯形.md",
        "staticFileName": "css_perspective.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "今天看小伙伴的代码，发现有一个梯形的实现居然是css写的，我以为需要UI提供icon。这里用到了 perspective 远景这个参数",
        "keywords": "css画梯形,css perspective",
        "category": "CSS",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"element时间选择器限制选中：不能选择今天之后的日期，时间间隔不能超过一个月\">element时间选择器限制选中：不能选择今天之后的日期，时间间隔不能超过一个月</h1>\n<p>一般使用 picker-options 这个属性来disable某些时间段，注意 如果设置了default-time 00:00:00 - 23:59:59 会影响对应的日期判断，必要时可以去掉，逻辑可以由后端处理</p>\n<h2 id=\"不能选择今天之后的日期\">不能选择今天之后的日期</h2>\n<pre><code class=\"language-html\">&lt;el-date-picker\n  v-model=&quot;value1&quot;\n  type=&quot;date&quot;\n  :picker-options=&quot;pickerOptions&quot;\n  placeholder=&quot;选择日期&quot;&gt;\n&lt;/el-date-picker&gt;\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      // 时间不能选择今天之后的日期\n      pickerOptions: {\n        disabledDate(time) {\n          return time.getTime() &gt; Date.now()\n        }\n      }\n    }\n  }\n}\n&lt;/script&gt;</code></pre>\n<h2 id=\"时间间隔不能超过一个月\">时间间隔不能超过一个月</h2>\n<p>点击某个时间后会触发 pickerOptions里的 onPick函数，获取当前点击的时间，然后计算时间disabled前后一个月的时间</p>\n<pre><code class=\"language-js\">// &lt;el-date-picker v-model=&quot;date&quot; type=&quot;daterange&quot; :picker-options=&quot;pickerOptions&quot;&gt;\n// &lt;/el-date-picker&gt;\nexport default {\n  data() {\n    const pickerOptions = {\n      // 选中时间时触发 element第一次选中后会赋值给minDate\n      onPick: ({ maxDate, minDate }) =&gt; {\n        this._curClickDate = minDate.getTime()\n        // 第二次选中后，按两次点击的时间顺序依次赋值给 minDate、maxDate\n        // 且面板会关闭，这时要清空_curClickDate，供下一次使用\n        maxDate &amp;&amp; (this._curClickDate = &#39;&#39;)\n      },\n      disabledDate: time =&gt; {\n        const { _curClickDate } = this\n        const gap = 31 * 24 * 3600 * 1000 // 一个月，按31天算\n        const t = time.getTime()\n        let start = _curClickDate - gap\n        let end = _curClickDate + gap\n        return t &gt; Date.now() || (_curClickDate &amp;&amp; (t &gt; end || t &lt; start))\n      }\n    }\n    return {\n      date: &#39;&#39;,\n      pickerOptions,\n    }\n  }\n}</code></pre>\n<p>具体demo：<a href=\"https://zuoxiaobai.github.io/fedemo/src/DebugDemo/element%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9/\">在线体验</a> <a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/element%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9/index.html\">github demo源码地址</a></p>\n<h2 id=\"如果可选日期由后台的接口返回\">如果可选日期由后台的接口返回</h2>\n<p>这种情况可以把pickerOptions放到计算属性里</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "element时间选择器限制选中：不能选择今天之后的日期，时间间隔不能超过一个月",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "不能选择今天之后的日期"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "时间间隔不能超过一个月"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "如果可选日期由后台的接口返回"
            }
          ]
        }
      ],
      "config": {
        "source": "element时间选择器限制选中：不能选择今天之后的日期，时间间隔不能超过一个月.md",
        "staticFileName": "el-date-picker-limit.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "elmement el-date-picker限制选中,elmement el-date-picker disabled某些选中,element时间限制选中,一般使用 picker-options 这个属性来disable某些时间段，注意 如果设置了default-time 00:00:00 - 23:59:59 会影响对应的日期判断，必要时可以去掉，逻辑可以由后端处理",
        "keywords": "elmement el-date-picker限制选中,elmement el-date-picker disabled某些选中",
        "category": "Vue",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-router编程方式跳转路由以及其传参问题\">vue-router编程方式跳转路由以及其传参问题</h1>\n<p>vue-router有以下几种编程方式跳转路由的方法。一般push和repalce用的比较多，下面来看看</p>\n<pre><code class=\"language-js\">router.push(location, onComplete?, onAbort?)\nrouter.push(location).then(onComplete).catch(onAbort)\nrouter.replace(location, onComplete?, onAbort?)\nrouter.replace(location).then(onComplete).catch(onAbort)\nrouter.go(n)\nrouter.back()\nrouter.forward()</code></pre>\n<h2 id=\"push跳转页面\">push跳转页面</h2>\n<pre><code class=\"language-js\">// 知道路由名称，跳转\nthis.$router.push({\n  name: &#39;路由name&#39;,\n  params: { userId: &#39;123&#39; } // 参数，url上面不可见\n  query: { plan: &#39;private&#39; } // 查询参数 url上可见\n})\n\n// 知道路由path，跳转 /register?plan=private\nthis.$router.push({ path: &#39;register&#39;, query: { plan: &#39;private&#39; }})\n// 注意：如果提供了 path，params 会被忽略，只能使用query参数</code></pre>\n<h2 id=\"replce跳转页面\">replce跳转页面</h2>\n<p>push会在history添加一条记录，而replce不会，他只会改变当前页面</p>\n<pre><code class=\"language-js\">// router.replace(location, onComplete?, onAbort?)\nthis.$router.replace({\n  name: &#39;路由name&#39;,\n  params: { userId: &#39;123&#39; } // 参数，url上面不可见\n  query: { plan: &#39;private&#39; } // 查询参数 url上可见\n})</code></pre>\n<h2 id=\"thisrouterresolve\">this.$router.resolve()</h2>\n<p>在新的tab页打开，可以用 this.$router.resolve() 来处理路由信息，也可以直接使用相对路径，注意hash、history跳转方式的区别</p>\n<pre><code class=\"language-js\">const resolved: {\n  location: Location;\n  route: Route;\n  href: string;\n} = router.resolve(location, current?, append?)\nwindow.open(&#39;#/user/info&#39;) \n// ‘_blank’为默认，在新的窗口打开，&#39;_self&#39; 为在当前页打开</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue-router编程方式跳转路由以及其传参问题",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "push跳转页面"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "replce跳转页面"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "this.$router.resolve()"
            }
          ]
        }
      ],
      "config": {
        "source": "vue-router编程方式跳转路由以及其传参问题.md",
        "staticFileName": "vue-router-jump.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "vue-router有以下几种编程方式跳转路由的方法。一般push和repalce用的比较多，下面来看看",
        "keywords": "vue-router,vue-router编程式跳转方法,vue-router跳转路由方法",
        "category": "Vue",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"text-align-justify-两端对齐不生效的问题\">text-align: justify 两端对齐不生效的问题</h1>\n<p>一般直接设置text-align: justify是不会生效的。但你改为text又会立即居中对齐。我们需要注意的是我们需要将子元素设置一个after的属性或者后面放置一个空的占位标签，设置 display: inline-block; width: 100%，当出现高度占位间隙时，设置占位元素的height没用，需要设置元素的height。css 确实有点毫无逻辑的感觉....</p>\n<p><img src=\"../../../images/blog/css/text_align_justify.png\" alt=\"text_align_justify.png\"></p>\n<pre><code class=\"language-html\">&lt;head&gt;\n  &lt;style&gt;\n    .sec,\n    .sec2 {\n      width: 150px;\n      text-align: justify;\n    }\n\n    /* fix 占位元素高度问题 */\n    .sec&gt;div,\n    .sec2&gt;div {\n      height: 25px;\n      line-height: 25px;\n    }\n\n    .zw {\n      display: inline-block;\n      width: 100%\n    }\n\n    .sec2&gt;div::after {\n      content: &#39;&#39;;\n      display: inline-block;\n      width: 100%;\n      overflow: hidden;\n      height: 0;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div class=&quot;sec&quot;&gt;\n    &lt;div&gt;\n      我是较长&lt;p class=&quot;zw&quot;&gt;&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      我是较长的&lt;p class=&quot;zw&quot;&gt;&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      我是较长的文字&lt;p class=&quot;zw&quot;&gt;&lt;/p&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;hr&gt;\n  &lt;div class=&quot;sec2&quot;&gt;\n    &lt;div&gt;我是较长&lt;/div&gt;\n    &lt;div&gt;我是较长的&lt;/div&gt;\n    &lt;div&gt;我是较长的文字&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;</code></pre>\n<p>参考：<a href=\"https://blog.csdn.net/qq_29608143/article/details/83625318\">使用text-align:justify，让内容两端对齐，兼容IE及主流浏览器的方法</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "text-align: justify 两端对齐不生效的问题"
        }
      ],
      "config": {
        "source": "text-align: justify两端对齐不生效的问题.md",
        "staticFileName": "text-align.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "一般直接设置text-align: justify是不会生效的。但你改为text又会立即居中对齐。我们需要注意的是我们需要将子元素设置一个after的属性或者后面放置一个空的占位标签，设置 display: inline-block; width: 100%，当出现高度占位间隙时，设置占位元素的height没用，需要设置元素的height。css 确实有点毫无逻辑的感觉....",
        "keywords": "text-align:justify,text-align:justify不生效的问题",
        "category": "CSS",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"unirequest封装为类似axios的请求对象\">uni.request封装为类似axios的请求对象</h1>\n<p>在uni-app中为了抹平各平台的差异，官方提供了uni.request方法，和微信小程序的请求方法类似，一般这类请求是比较通用的，如果直接使用会有大量的重复代码，于是做了简单的封装，来看看代码</p>\n<p>axios.js</p>\n<pre><code class=\"language-js\">/**\n * @description 将uni.request封装成简单的aixos\n * @author guoqzuo\n * @example\n * axios.create(config) 根据配置，创建axios实例\n * axios.get(url[, config]) get请求\n * axios.post(url[, data[, config]]) post请求\n * config支持配置项\n * baseURL: &quot;https://some-domain.com/api/&quot;, // baseURL\n * timeout: 1000, // 超时时间\n * headers: { &quot;X-Custom-Header&quot;: &quot;foobar&quot; }, // 请求头\n * method: &#39;&#39; // 请求方法\n * url: &#39;&#39;, // 请求url\n * data: &#39;&#39; // post 请求的data\n * toastErrorMsg 是否用toast显示错误信息，默认为是\n * showLoading  是否显示loading\n * reTry 是否重试，默认为否，待实现\n * params: &#39;&#39; // url后面的查询参数，待实现\n */\n\nimport Utils from &#39;@/utils/utils.js&#39;\nclass Axios {\n  constructor() {\n    this.config = {}\n  }\n\n  // 全局配置，返回一个axios实例\n  create(config = {}) {\n    Object.assign(this.config, config)\n    return this\n  }\n\n  get(url = &#39;&#39;, data = {}, config = {}) {\n    // 暂不支持params\n    config = { ...this.config, ...config, url, method: &#39;GET&#39;, data }\n    return this._request(config)\n  }\n\n  post(url = &#39;&#39;, data = {}, config = {}) {\n    config = { ...this.config, ...config, url, method: &#39;POST&#39;, data }\n    return this._request(config)\n  }\n\n  // uni.request 封装\n  _request(config) {\n    return new Promise(async (resolve, reject) =&gt; {\n      const {\n        baseURL,\n        timeout,\n        headers,\n        method,\n        url,\n        data = {},\n        toastErrorMsg,\n        showLoading,\n        successCode = 0\n      } = config\n      showLoading &amp;&amp;\n        uni.showLoading({\n          mask: true\n        })\n      const token = uni.getStorageSync(&#39;shopUserToken&#39;);\n      token &amp;&amp; (data.token = token)\n      const [error, res] = await uni.request({\n        data,\n        method,\n        header: headers,\n        timeout,\n        url: baseURL + url\n      })\n\n      // 请求完成后做 complete 该执行的内容\n      showLoading &amp;&amp; uni.hideLoading()\n\n      // 判断请求是否成功，这里很奇怪，官方把error直接返回了，类似于node的callback\n      if (error) {\n        this._showToast(toastErrorMsg, error.errMsg)\n        reject(error.errMsg)\n        return\n      }\n\n      // statusCode === 200\n      const { statusCode, header, data: resData } = res\n      if (!resData || typeof resData !== &#39;object&#39;) {\n        const msg = &#39;接口异常，data数据出错&#39;\n        this._showToast(toastErrorMsg, msg)\n        reject(msg)\n        return\n      }\n\n      const { code = &#39;&#39;, msg = &#39;&#39; } = resData\n      // 请求成功，且状态码ok\n      if (Number.parseInt(code) === successCode) {\n        resolve(resData.data)\n      } else {\n        // msg: &quot;登录失效，请重新登录&quot; code: -400\n        if (`${code}` === &#39;-400&#39;) {\n          uni.redirectTo({\n            url: &#39;/pages/login/login&#39;\n          })\n          setTimeout(() =&gt; {\n            this._showToast(toastErrorMsg, msg)\n          }, 1000)\n        } else {\n          this._showToast(toastErrorMsg, msg)\n        }\n        reject(msg)\n      }\n    })\n  }\n\n  // 根据toastErrorMsg判断是否需要显示错误信息\n  _showToast(toastErrorMsg, msg) {\n    toastErrorMsg &amp;&amp;\n      uni.showToast({\n        title: msg,\n        icon: &#39;none&#39;,\n        image: &#39;&#39;,\n        duration: 1500,\n        mask: false\n      })\n  }\n}\n\nconst axios = new Axios()\nexport default axios\n</code></pre>\n<p>配置axios service.js</p>\n<pre><code class=\"language-js\">// service.js\nimport axios from &#39;./utils/axios&#39;\n\nconst axiosInstance = axios.create({\n  baseURL: &quot;/index.php&quot;,\n  successCode: 0, // 后端自己定义的成功或的错误码\n  toastErrorMsg: true, // 是否用toast显示错误信息，默认为是\n  showLoading: true  // 是否显示loading\n});\n\nexport default axiosInstance</code></pre>\n<p>模块 modules/user.js</p>\n<pre><code class=\"language-js\">import createServiceFromConfig from &#39;../utils/createServiceFromConfig&#39;\n\n// 用户模块service\nexport default createServiceFromConfig([\n  [&#39;login&#39;, &#39;/user/login&#39;, &#39;post&#39;] // 登录\n])</code></pre>\n<p>根据配置生成接口服务 createServiceFromConfig.js</p>\n<pre><code class=\"language-js\">import service from &#39;../service&#39;\n\nfunction createServiceFromConfig(configList) {\n  let serviceObj = {}\n  configList.forEach(item =&gt; {\n    let [apiName, url, method = &#39;get&#39;] = item\n    serviceObj[apiName] = (payload = {}, config = {}) =&gt; {\n      let url = item[1] // url 是第二位\n      // uni.request 设置data会直接附加到get请求末尾，所以不用转换\n      // let params = method === &#39;get&#39; ? [config] : [payload, config]\n      let params = [payload, config]\n      return service[method](url, ...params); // 等价于 return axios.get(..)\n    }\n  })\n  return serviceObj\n}\n\nexport default createServiceFromConfig</code></pre>\n<p>调用接口</p>\n<pre><code class=\"language-js\">import userService from &quot;@/service/modules/user&quot;;\nasync login() {\n  try {\n    let data = await userService.login({\n      mobile: &quot;xxx&quot;,\n      password: &quot;xxx&quot;\n    });\n    console.log(data);\n  } catch (e) {\n    console.error(e);\n  }\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "uni.request封装为类似axios的请求对象"
        }
      ],
      "config": {
        "source": "uni.request封装为类似axios的请求对象.md",
        "staticFileName": "uni_request.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "uni.request封装,uni axios分装,在uni-app中为了抹平各平台的差异，官方提供了uni.request方法，和微信小程序的请求方法类似，一般这类请求是比较通用的，如果直接使用会有大量的重复代码，于是做了简单的封装，来看看代码",
        "keywords": "uni.request封装,uni axios分装",
        "category": "移动端混合开发",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"uni-app跨域问题接口代理配置\">uni-app跨域问题接口代理配置</h1>\n<p>在uni-app中有一个manifest.json配置文件，里面的h5配置下有默认的devServer选项，和vue.config.js里的代理配置一致，都是使用的webpack的代理功能，默认配置为</p>\n<pre><code class=\"language-js\">&quot;h5&quot;: {\n  &quot;devServer&quot; : {\n      &quot;https&quot; : false,\n      &quot;port&quot; : 80\n  }\n}</code></pre>\n<p>根据具体情况，具体配置，下面是一个示范配置</p>\n<pre><code class=\"language-js\">&quot;h5&quot;: {\n  &quot;devServer&quot;: {\n    &quot;port&quot;: 8086,\n    &quot;disableHostCheck&quot;: true,\n    &quot;proxy&quot;: {\n      &quot;/&quot;: {\n          &quot;target&quot;: &quot;http://xxxx:8086/&quot;,\n          &quot;changeOrigin&quot;: true,\n          &quot;secure&quot;: false\n      }\n    }\n  }\n}</code></pre>\n<p>这里要注意的是，<strong>要在manifest.json文件配置，而不是pages.json里，每次修改配置后记得点击重新运行到浏览器，如果不生效关闭再开启HBuildeX，多试试</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "uni-app跨域问题接口代理配置"
        }
      ],
      "config": {
        "source": "uni-app跨域问题接口代理配置.md",
        "staticFileName": "uni-app-cros.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "uni配置跨域,uin接口跨域,uni配置接口代理,在uni-app中有一个manifest.json配置文件，里面的h5配置下有默认的devServer选项，和vue.config.js里的代理配置一致，都是使用的webpack的代理功能，默认配置为...",
        "keywords": "uni配置跨域,uin接口跨域,uni配置接口代理",
        "category": "移动端混合开发",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"使用curl向百度站长主动推送站点url\">使用curl向百度站长主动推送站点url</h1>\n<p>之前提交链接都是手动将url粘贴到输入框提交。这次试了下curl方式提交还是很方便的，来看看步骤</p>\n<pre><code class=\"language-bash\"># 先将要提交的url存放到 urls.txt 里\nvi urls.txt\n\n# 查看\ncat urls.txt \nhttp://www.zuo11.com/blog/2019/11/v-if_filters.html\nhttp://www.zuo11.com/blog/2019/12/web_storage.html\nhttp://www.zuo11.com/blog/2019/12/phantomjs-prebuilt.html\nhttp://www.zuo11.com/blog/2019/12/node_sleep_module.html\nhttp://www.zuo11.com/blog/2019/12/git_clone_timeout.html\nhttp://www.zuo11.com/blog/2019/11/git_push_branch.html\nhttp://www.zuo11.com/blog/2019/12/npm_resource.html\n\n# 确定内容没问题后提交，对应的链接在百度站长提交链接哪里会自动生成\ncurl -H &#39;Content-Type:text/plain&#39; --data-binary @urls.txt &quot;http://data.zz.baidu.com/urls?site=www.zuo11.com&amp;token=xxxxxxx&quot;\n\n# 执行后返回推送接口，实时推送成功\n{&quot;remain&quot;:99993,&quot;success&quot;:7}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "使用curl向百度站长主动推送站点url"
        }
      ],
      "config": {
        "source": "使用curl向百度站长主动推送站点url.md",
        "staticFileName": "push_url_baidu.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "之前提交链接都是手动将url粘贴到输入框提交。这次试了下curl方式提交还是很方便的，来看看步骤",
        "keywords": "向百度站长主动推送站点url,推送url到百度",
        "category": "网站建设与SEO",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"nginx配置二级域名解析目录\">nginx配置二级域名解析目录</h1>\n<p>最近看百度统计，有100多个河南的新ip访问，有些异常，而且都是访问的api.zuo11.com，最近两周明细里看到的ip段很有规律</p>\n<pre><code class=\"language-js\">111.7.100.16 - 111.7.100.27\n36.99.136.131 - 36.99.136.143</code></pre>\n<p>百度统计有个缺点，就是仅提供两周内的访问明细，最多5000条，后面有必要做一个自己的用户行为记录系统</p>\n<p>之前我将 <code>https://api.zuo11.com</code> 解析到了一个node服务用于https接口，但发现 <code>http://api.zuo11.com</code> 走的80端口，会直接访问zuo11.com，我仿照<code>zuo11.com</code> 301重定向到 <code>www.zuo11.com</code> 的方式写了下面的配置，但发现不生效，当时也没管。</p>\n<pre><code class=\"language-js\">if ($host = &#39;api.zuo11.com&#39;) {\n  rewrite ^/(.*)$ https://api.zuo11.com/$1 permanent;\n}</code></pre>\n<p>现在暴露出问题来了，就必须解决，让 <code>http://api.zuo11.com</code> 指向其他目录，花了好长时间才配置ok，以下是相关具体配置，省略了https配置</p>\n<pre><code class=\"language-js\">server {\n  listen       80;\n  server_name  zuo11.com www.zuo11.com;\n  charset utf-8;\n\n  if ($host = &#39;zuo11.com&#39;) {\n    rewrite ^/(.*)$ http://www.zuo11.com/$1 permanent;\n  }\n\n  location / {\n      root   C:\\Users\\Administrator\\Desktop\\dist;\n      index  index.html index.htm;\n  }\n}\n\nserver {\n  listen   80;\n  server_name  demo.zuo11.com;\n  charset  utf-8;\n  location / {\n        root  C:\\Users\\Administrator\\Desktop\\demo_dist;\n        index  index.html index.htm;\n    }\n}\n\nserver {\n  listen   80;\n  server_name  api.zuo11.com;\n  charset  utf-8;\n  location / {\n        root  C:\\Users\\Administrator\\Desktop\\api_dist;\n        index  index.html index.htm;\n    }\n}</code></pre>\n<p>其实就是多写一个server，把二级域名指向其他目录。中间有个坑的地方就是windows使用nginx时，关闭nginx运行的terminal后，进程不一定关闭，需要打开任务管理器，找nginx相关进程删掉，这样才彻底。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "nginx配置二级域名解析目录"
        }
      ],
      "config": {
        "source": "nginx配置二级域名解析目录.md",
        "staticFileName": "nginx_sencod_domain.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "nginx二级域名解析,nginx二级域名解析到不同的目录,最近看百度统计，有100多个河南的新ip访问，有些异常，而且都是访问的api.zuo11.com，最近两周明细里看到的ip段很有规律。其实就是多写一个server，把二级域名指向其他目录。中间有个坑的地方就是windows使用nginx时，关闭nginx运行的terminal后，进程不一定关闭，需要打开任务管理器，找nginx相关进程删掉，这样才彻底。",
        "keywords": "nginx二级域名解析,nginx二级域名解析,nginx二级域名解析到不同的目录",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"腾讯云慧眼架构相关设计学习\">腾讯云慧眼架构相关设计学习</h1>\n<p>昨晚看了一个关于腾讯云慧眼架构相关的分享，由于之前参与过该项目的一些开发，对业务比较了解。结合业务场景再来看构架设计，会有一种豁然开朗的感觉，下面对一些构架方面比较好的点做一个总结</p>\n<h2 id=\"要点\">要点</h2>\n<ul>\n<li>高可用，两地三中心、异常监控上报、弹性伸缩</li>\n<li>资源有限时服务降级来提高QPS：例如，常规情况会抽取视频的10个帧图片，QPS的瓶颈在这，如果资源有限，通过服务降级，减少抽取的帧，每次抽取3-4帧，极大提高QPS</li>\n<li>单个客户流量暴增时，分配独立资源池，不影响其他客户服务<ul>\n<li>客户提前告知，提前分配独立资源池</li>\n<li>未提前告知，就需要服务具备自动告警功能，怎么检测流量异常，什么时候提前通知，需要根据情况使用特定的策略。客户流量激增时，告警邮件、短信通知相关负责人，找客户确定是正常流量还是异常流量，如果异常流量，限制QPS，拒绝大部分服务。如果是正常流程，分配资源、快速扩容</li>\n</ul>\n</li>\n<li>高扩展，可配置化服务，满足各种差异化需求</li>\n<li>低耦合，服务拆分。新增功能特性时，减少各个服务需要做的改动；发布某个模块的功能时，对其他模块不会有干扰</li>\n<li>低成本方式，服务兜底，便宜的证照库可能缺少一些用户身份信息，当出现这种情况会兜底去查询价格高一点的证照库，节约成本的情况下，保证了体验</li>\n<li>提高成功率，多引擎融合策略，多个验证引擎识别成功率不一样，取多个引擎综合结果成功率会上升4-5个点</li>\n<li>引擎服务接口hang，怎么保证服务ok，监测引擎异常次数，切换处理引擎</li>\n</ul>\n<h2 id=\"新引擎功能接入线上前怎么测试？\">新引擎功能接入线上前怎么测试？</h2>\n<ul>\n<li>灰度策略，为某个客户灰度5%的流量，看识别结果</li>\n<li>旁路策略，比灰度更好，直接copy一份某个用户的流量请求新引擎版本的服务，得出结果，就是用户请求发送到后台后，后台除了正常响应当前稳定版本验证的结果外，再把请求转发一份给测试引擎，这个结果是不会给到用户的。仅用来比对成功率。</li>\n</ul>\n<h2 id=\"引擎自动化评测策略\">引擎自动化评测策略</h2>\n<ul>\n<li>正、负样本(手工标注)，多维度评测</li>\n<li>引擎在不同地域样本里的表现</li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "腾讯云慧眼架构相关设计学习",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "要点"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "新引擎功能接入线上前怎么测试？"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "引擎自动化评测策略"
            }
          ]
        }
      ],
      "config": {
        "source": "腾讯云慧眼架构相关设计学习.md",
        "staticFileName": "txy_frame_study.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "昨晚看了一个关于腾讯云慧眼架构相关的分享，由于之前参与过该项目的一些开发，对业务比较了解。结合业务场景再来看构架设计，会有一种豁然开朗的感觉，下面对一些构架方面比较好的点做一个总结",
        "keywords": "腾讯云慧眼架构相关设计学习,构架",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-v-model的理解\">vue v-model的理解</h1>\n<p>在前面讨论过，使用v-model的场景，来看一个实例，假如我们需要封装一个弹窗组件需要引入el-dialog组件</p>\n<p>首先，我们来看看我们写好这个组件后应该怎么调用，通过show这个参数来控制dialog显示或隐藏</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;my-dialog v-if=&quot;showDialog&quot; :show=&quot;showDialog&quot;&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  components: {\n    MyDialog: () =&gt; import(&#39;@/components/my-dialog&#39;)\n  },\n  data() {\n    return {\n      showDialog: flase\n    }\n  }\n}\n&lt;/script&gt;</code></pre>\n<p>来看看实现，这里看element官方demo里在visible属性上用了.sync修饰符，有什么用呢？</p>\n<pre><code class=\"language-html\">&lt;!-- https://element.eleme.cn/#/zh-CN/component/dialog --&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-dialog title=&quot;提示&quot; :visible.sync=&quot;dialogVisible&quot;&gt;\n      内容\n      &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;\n        &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt;\n        &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确 定&lt;/el-button&gt;\n      &lt;/span&gt;\n    &lt;/el-dialog&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre>\n<p>看来看源码</p>\n<pre><code class=\"language-html\">&lt;!-- https://github.com/ElemeFE/element/blob/dev/packages/dialog/src/component.vue --&gt;\n\n&lt;template&gt;\n  &lt;transition name=&quot;dialog-fade&quot; @after-enter=&quot;afterEnter&quot; @after-leave=&quot;afterLeave&quot;&gt;\n    &lt;div\n      v-show=&quot;visible&quot;\n      class=&quot;el-dialog__wrapper&quot;\n      @click.self=&quot;handleWrapperClick&quot;&gt;\n      &lt;!-- .... --&gt;\n    &lt;/div&gt;\n  &lt;/transition&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n// ...\nhide(cancel) {\n  if (cancel !== false) {\n    this.$emit(&#39;update:visible&#39;, false);\n    this.$emit(&#39;close&#39;);\n    this.closed = true;\n  }\n}\n//... \n&lt;/script&gt;</code></pre>\n<p>可以看到关闭弹窗时，使用了 </p>\n<pre><code class=\"language-js\">this.$emit(&#39;update:visible&#39;, false);</code></pre>\n<p>修改了父组件传入的visible的值，没有使用v-model, 所以在el-dialog传入visible属性的时候加了.sync修饰符</p>\n<pre><code class=\"language-html\">&lt;el-dialog title=&quot;提示&quot; :visible.sync=&quot;dialogVisible&quot;&gt;</code></pre>\n<p>vue里面有介绍这种方法可以使子组件可以修改父组件的值，而不用多加一个事件参数，参见文档 <a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6\">.sync修饰符</a></p>\n<p>但感觉这个接口设计的有点鸡肋，v-model不香吗？</p>\n<p>子组件封装dialog的特殊之处在于，通过showDialog显示子组件的dialog后，子组件点击关闭后会自己关闭弹窗，这时 父组件的showDialog还是true，因此并不能通过show参数来控制显示，我们需要在子组件点击dialog关闭时，触发一个事件给父组件，从而修改对应的值</p>\n<pre><code class=\"language-html\">&lt;my-dialog v-if=&quot;showDialog&quot; :show=&quot;showDialog&quot; @close=&quot;showDialog = false&quot;&gt;</code></pre>\n<p>这里当子组件关闭dialog时$emit一个close事件来手动将showDialog设置为false，以到达父组件可以通过showDialog来打开或关闭dialog的目的，我们可以来看看子组件的实现</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-dialog title=&quot;提示&quot; :visible.sync=&quot;dialogVisible&quot;&gt;\n      内容\n      &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;\n        &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt;\n        &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确 定&lt;/el-button&gt;\n      &lt;/span&gt;\n    &lt;/el-dialog&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n// 注意如果我们把show直接设置给el-dialog的visible属性，\n// el-dialog内部在关闭dialog时会触发一次 this.show = false操作\n// 而show是父组件通过props单向传递的值，改动会提示错误，我们需要使用computed属性来中转\nexport default {\n  props: {\n    show: { \n      type: Boolean,\n      required: true\n    }\n  }\n  computed: {\n    dialogVisible: {\n      get() {\n        return this.show // 父组件向下传递show的值时通过计算属性赋值到dialogVisible\n      }\n      set() {\n        // 当dialog关闭时，会触发this.dialogVisible = false，从而来到这个方法，我们在这里将关闭事件同步给父组件\n        this.$emit(&#39;close&#39;, false)\n      }\n    }\n  },\n  data() {\n\n  }\n}\n&lt;/script&gt;</code></pre>\n<p>上面的例子已经实现了功能，但缺点是，要使用两个参数，一个show属性，一个close事件。v-model就是一种简化参数的语法糖</p>\n<pre><code class=\"language-html\">&lt;my-dialog v-if=&quot;showDialog&quot; :show=&quot;showDialog&quot; @close=&quot;showDialog = false&quot;&gt;\n&lt;!-- 等价于 --&gt;\n&lt;my-dialog v-if=&quot;showDialog&quot; v-model=&quot;showDialog&quot;&gt;\n&lt;script&gt;\nexport default {\n  model: { // 新增了model属性，用来指定v-model赋值的属性名，以及改动父组件对应值需要$emit的事件名称\n    prop: &#39;show&#39;,\n    event: &#39;close&#39;\n  },\n  // 其他后面的逻辑不变\n  props\n    show: { \n      type: Boolean,\n      required: true\n    }\n  }\n  // ....\n}\n&lt;/script&gt;</code></pre>\n<p>关于v-model的文档，参考 <a href=\"https://cn.vuejs.org/v2/api/#model\">v-model | Vue API</a></p>\n<p>综上，v-model比.async更优雅，而在vue的refs里，也有建议使用v-model代替.async修饰符，且已经merge到了vue 3.0版本，相关文档 <a href=\"https://github.com/vuejs/rfcs/pull/8\">Replace v-bind&#39;s .sync with a v-model argument</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue v-model的理解"
        }
      ],
      "config": {
        "source": "vue v-model的理解.md",
        "staticFileName": "vue-v-model.html",
        "author": "guoqzuo",
        "createDate": "2020/07/26",
        "description": "在前面讨论过，使用v-model的场景，来看一个实例，假如我们需要封装一个弹窗组件需要引入el-dialog组件。首先，我们来看看我们写好这个组件后应该怎么调用，通过show这个参数来控制dialog显示或隐藏",
        "keywords": "v-model的理解,v-model与,.sync",
        "category": "Vue",
        "year": "2020",
        "month": "7"
      }
    },
    {
      "htmlStr": "<h1 id=\"为什么会有nodejs，其衍生框架express、koa、eggjs的演进过程\">为什么会有Node.js，其衍生框架Express、Koa、Egg.js的演进过程</h1>\n<p><img src=\"../../../images/blog/node/why_node_index.png\" alt=\"大纲\"></p>\n<h2 id=\"为什么会出现nodejs\">为什么会出现Node.js</h2>\n<p>首先，我们需要知道前端一般都是用Node.js来写测试接口，主要是因为他基于js，对于前端来讲，我们不需要另外去学习一门编程语言，很容易上手。这里我们先来了解下node的一些基础知识。</p>\n<h3 id=\"什么是nodejs？\">什么是Node.js？</h3>\n<p>官方解释：Node.js® is a JavaScript runtime built on Chrome&#39;s V8 JavaScript engine.</p>\n<p>Node.js 是一个基于Chrome V8引擎的JavaScript运行时，我们一般把Node.js简称为node</p>\n<h3 id=\"什么是js运行时？\">什么是JS运行时？</h3>\n<p>我们可以简单的理解为运行js的环境。一般网页是在浏览器里面打开运行的，浏览器就是一个运行js的环境。而node也提供了一个运行js的环境。</p>\n<h3 id=\"在node中为什么可以运行js代码？\">在node中为什么可以运行js代码？</h3>\n<p>主要是因为node集成了Chrome V8引擎，也就是Chrome浏览器的JS引擎。</p>\n<h3 id=\"node为什么要创建一个基于js的执行环境，作者的初衷是什么？\">node为什么要创建一个基于js的执行环境，作者的初衷是什么？</h3>\n<p>node的作者是Ryan Dahl /&#39;raiən da:l/，他的工作是用C/C++写高性能web服务，对于高性能，异步IO、事件驱动是基本原则，但用C/C++写就太痛苦了。于是他设想使用另一种高级语言开发Web服务，评估了很多语言，发现很多语言虽然同时提供了异步IO和同步IO，但开发人员一旦使用了同步IO，他们就再也懒得写异步IO了，所以最终Ryan选择了JS。</p>\n<p>综上，<strong>node是为了写高性能web服务而生的</strong>，它让js这门前端语言，也可以做后端服务器开发，Node目前的发展完全超出了作者的预料，它基本改变了前端的整个开发生态。下面我们来看看Node的一些应用场景</p>\n<h3 id=\"node的应用场景\">node的应用场景</h3>\n<p>node除了集成Chrome V8引擎来提供js运行时外，还集成了libuv、llhttp、c-ares、OpenSSL、zlib等第三方库的功能，用来支持<strong>创建http服务，解析请求、响应，操作(读写)文件，加密、压缩等</strong>。</p>\n<h4 id=\"打包构建、cli命令行工具脚手架\">打包构建、cli命令行工具脚手架</h4>\n<p>在浏览器端一般处于安全考虑，不会允许js在本地读写文件，而node作为服务端，操作文件的权限就完全放开了，于是出现了基于node的webpack、parcel、vue-cli等打包、构建、脚手架工具，使之前零碎的前端开发趋向于工程化，开发更加高效、规范。</p>\n<p>我们以vue-cli这个命令行工具来看，node是怎么执行的</p>\n<pre><code class=\"language-bash\">npm install -g @vue/cli # 安装vue-cli命令行工具</code></pre>\n<p>安装完成后，在terminal(终端)就有vue命令了，我之前对vue这个命令很迷惑，以为vue这个命令就是vue框架。之后才理解vue这个命令是vue-cli这个包提供的。我们来看看vue create xx 执行时的源码</p>\n<pre><code class=\"language-js\">// https://github.com/vuejs/vue-cli/blob/dev/packages/%40vue/cli/bin/vue.js\nprogram\n  .command(&#39;create &lt;app-name&gt;&#39;)\n  .description(&#39;create a new project powered by vue-cli-service&#39;)\n  .option(&#39;-p, --preset &lt;presetName&gt;&#39;, &#39;Skip prompts and use saved or remote preset&#39;)\n  .option(&#39;-d, --default&#39;, &#39;Skip prompts and use default preset&#39;)\n  .option(&#39;-i, --inlinePreset &lt;json&gt;&#39;, &#39;Skip prompts and use inline JSON string as preset&#39;)\n  .option(&#39;-m, --packageManager &lt;command&gt;&#39;, &#39;Use specified npm client when installing dependencies&#39;)\n  .option(&#39;-r, --registry &lt;url&gt;&#39;, &#39;Use specified npm registry when installing dependencies (only for npm)&#39;)\n  .option(&#39;-g, --git [message]&#39;, &#39;Force git initialization with initial commit message&#39;)\n  .option(&#39;-n, --no-git&#39;, &#39;Skip git initialization&#39;)\n  .option(&#39;-f, --force&#39;, &#39;Overwrite target directory if it exists&#39;)\n  .option(&#39;--merge&#39;, &#39;Merge target directory if it exists&#39;)\n  .option(&#39;-c, --clone&#39;, &#39;Use git clone when fetching remote preset&#39;)\n  .option(&#39;-x, --proxy&#39;, &#39;Use specified proxy when creating project&#39;)\n  .option(&#39;-b, --bare&#39;, &#39;Scaffold project without beginner instructions&#39;)\n  .option(&#39;--skipGetStarted&#39;, &#39;Skip displaying &quot;Get started&quot; instructions&#39;)\n  .action((name, cmd) =&gt; {\n    const options = cleanArgs(cmd)\n\n    if (minimist(process.argv.slice(3))._.length &gt; 1) {\n      console.log(chalk.yellow(&#39;\\n Info: You provided more than one argument. The first one will be used as the app\\&#39;s name, the rest are ignored.&#39;))\n    }\n    // --git makes commander to default git to true\n    if (process.argv.includes(&#39;-g&#39;) || process.argv.includes(&#39;--git&#39;)) {\n      options.forceGit = true\n    }\n    require(&#39;../lib/create&#39;)(name, options)\n  })</code></pre>\n<p>../lib/create.js源码</p>\n<pre><code class=\"language-js\">// https://github.com/vuejs/vue-cli/blob/dev/packages/%40vue/cli/lib/create.js\nconst fs = require(&#39;fs-extra&#39;)\nconst path = require(&#39;path&#39;)\nconst inquirer = require(&#39;inquirer&#39;)\nconst Creator = require(&#39;./Creator&#39;)\nconst { clearConsole } = require(&#39;./util/clearConsole&#39;)\nconst { getPromptModules } = require(&#39;./util/createTools&#39;)\nconst { chalk, error, stopSpinner, exit } = require(&#39;@vue/cli-shared-utils&#39;)\nconst validateProjectName = require(&#39;validate-npm-package-name&#39;)\n\nasync function create (projectName, options) {\n  if (options.proxy) {\n    process.env.HTTP_PROXY = options.proxy\n  }\n\n  const cwd = options.cwd || process.cwd()\n  const inCurrent = projectName === &#39;.&#39;\n  const name = inCurrent ? path.relative(&#39;../&#39;, cwd) : projectName\n  const targetDir = path.resolve(cwd, projectName || &#39;.&#39;)\n\n  const result = validateProjectName(name)\n  if (!result.validForNewPackages) {\n    console.error(chalk.red(`Invalid project name: &quot;${name}&quot;`))\n    result.errors &amp;&amp; result.errors.forEach(err =&gt; {\n      console.error(chalk.red.dim(&#39;Error: &#39; + err))\n    })\n    result.warnings &amp;&amp; result.warnings.forEach(warn =&gt; {\n      console.error(chalk.red.dim(&#39;Warning: &#39; + warn))\n    })\n    exit(1)\n  }\n\n  if (fs.existsSync(targetDir) &amp;&amp; !options.merge) {\n    if (options.force) {\n      await fs.remove(targetDir)\n    } else {\n      await clearConsole()\n      if (inCurrent) {\n        const { ok } = await inquirer.prompt([\n          {\n            name: &#39;ok&#39;,\n            type: &#39;confirm&#39;,\n            message: `Generate project in current directory?`\n          }\n        ])\n        if (!ok) {\n          return\n        }\n      } else {\n        const { action } = await inquirer.prompt([\n          {\n            name: &#39;action&#39;,\n            type: &#39;list&#39;,\n            message: `Target directory ${chalk.cyan(targetDir)} already exists. Pick an action:`,\n            choices: [\n              { name: &#39;Overwrite&#39;, value: &#39;overwrite&#39; },\n              { name: &#39;Merge&#39;, value: &#39;merge&#39; },\n              { name: &#39;Cancel&#39;, value: false }\n            ]\n          }\n        ])\n        if (!action) {\n          return\n        } else if (action === &#39;overwrite&#39;) {\n          console.log(`\\nRemoving ${chalk.cyan(targetDir)}...`)\n          await fs.remove(targetDir)\n        }\n      }\n    }\n  }\n\n  const creator = new Creator(name, targetDir, getPromptModules())\n  // // https://github.com/vuejs/vue-cli/blob/dev/packages/%40vue/cli/lib/Creator.js\n  await creator.create(options)\n}\n\nmodule.exports = (...args) =&gt; {\n  return create(...args).catch(err =&gt; {\n    stopSpinner(false) // do not persist\n    error(err)\n    if (!process.env.VUE_CLI_TEST) {\n      process.exit(1)\n    }\n  })\n}</code></pre>\n<h4 id=\"写后台接口、高并发web服务、服务端渲染\">写后台接口、高并发web服务、服务端渲染</h4>\n<p>node可以创建一个http服务，做接口的请求与响应。在这方面衍生出来的框架有express.js、koa.js、egg.js等，我们可以用这些框架写一些测试接口、静态文件服务、web服务等。</p>\n<p>在支持高并发、高性能web服务这块，目前阿里的使用场景是一个很好的例子，Java一般用来写变动少的基础设施或有事务要求的商业服务逻辑。而在需要快速迭代、需求变化非常快的用户侧，node用于替代过去php、jsp的使用场景。node已经经受了阿里双11的考验，技术上是可行的。</p>\n<blockquote>\n<p>题外话，在node服务端开发方面，mock数据、自己写测试接口玩玩可以，但小团队或node不是非常强的技术团队尽量不要用node来写服务端接口，因为阿里能做好这块是因为国内顶尖的node方面人才基本都在阿里，经过多年实践踩坑，拥有相对完善的node基建和生态。虽然阿里开源了用于写商业化应用的egg.js，但目前很多公司并没有用node来写服务端，拥有实际node服务端开发经验的技术人员不多，贸然使用会有一定的试错成本。</p>\n</blockquote>\n<h2 id=\"nodejs衍生框架发展\">Node.js衍生框架发展</h2>\n<p>对node.js做了一个基本介绍后，我们单独拿其中的一个知识点来讨论 --- 怎么用node来写接口。</p>\n<p>一般我们用的基于node的koa框架来写接口，为什么不直接用node呢，koa框架为什么这么流行？</p>\n<p>我们要知道，在技术方面能够流行的一些框架，一定是解决了某些痛点问题，让开发更加简单、高效，所以才会有这么多人用它。</p>\n<p>下面我们来追本溯源一下，看看为什么会有koa</p>\n<h3 id=\"nodejs的不足\">Node.js的不足</h3>\n<p><strong>如果用node本身的语法来写应用，会比较麻烦，需要自己做一些基础模块的封装</strong>，来看几个例子</p>\n<h4 id=\"路由相关操作\">路由相关操作</h4>\n<p>第一个例子: 用node写一个http服务：</p>\n<ul>\n<li>get 请求 &#39;/&#39; 时，返回index.html文本</li>\n<li>get 请求 &#39;/users&#39; 时返回 {a: 1}</li>\n<li>post请求 &#39;/info&#39; 时返回 {b: 1}</li>\n</ul>\n<pre><code class=\"language-js\">const http = require(&#39;http&#39;)\nconst fs = require(&#39;fs&#39;)\n\nconst server = http.createServer((req, res)=&gt; {\n  const { url, method } = req\n  console.log(&#39;url, method: &#39;, url, method)\n\n  if (url === &#39;/&#39; &amp;&amp; method === &#39;GET&#39;) {\n    fs.readFile(&#39;index.html&#39;, (err, data) =&gt; {\n      if (err) throw err\n      res.statusCode = 200\n      res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;)\n      res.end(data)\n    })\n  } else if (url === &#39;/users&#39; &amp;&amp; method === &#39;GET&#39;) {\n    res.writeHead(200, {\n      &#39;Content-Type&#39;: &#39;application/json&#39;\n    })\n    res.end(JSON.stringify({a: 1}))\n  } else if (url === &#39;/info&#39; &amp;&amp; method === &#39;post&#39;) {\n    res.writeHead(200, {\n      &#39;Content-Type&#39;: &#39;application/json&#39;\n    })\n    res.end(JSON.stringify({b: 1}))\n  } else {\n    res.end(&#39;404&#39;)\n  }\n})\n\nserver.listen(9000, () =&gt; { console.log(&#39;端口开启于9000&#39;) })</code></pre>\n<p>用node提供的api写，还要自己封装路由模块，这是一个不方便的地方。</p>\n<h4 id=\"静态文件服务\">静态文件服务</h4>\n<p>第二个例子: 将 public 目录作为静态文件目录，让该目录里的文件可以通过http方式访问</p>\n<pre><code class=\"language-js\">const http = require(&#39;http&#39;)\nconst fs = require(&#39;fs&#39;)\n\nconst server = http.createServer((req, res)=&gt; {\n  const { url, method } = req\n  console.log(&#39;url, method: &#39;, url, method)\n\n  let staticPath = &#39;./public&#39;\n  if (url === &#39;/&#39; &amp;&amp; method === &#39;GET&#39;) {\n    fs.readFile(staticPath + &#39;/index.html&#39;, (err, data) =&gt; {\n      if (err) throw err\n      res.statusCode = 200\n      res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;)\n      res.end(data)\n    })\n  } else if (url === &#39;/test.png&#39; &amp;&amp; method === &#39;GET&#39;) {\n    fs.readFile(staticPath + url, (err, data) =&gt; {\n      if (err) throw err\n      res.statusCode = 200\n      res.setHeader(&#39;Content-Type&#39;, &#39;image/png&#39;)\n      res.end(data)\n    })\n  } else {\n    res.end(&#39;404&#39;)\n  }\n})\nserver.listen(9000, () =&gt; { console.log(&#39;端口开启于9000&#39;) })</code></pre>\n<p>上面我只用两个简单的文件来示范，实际上静态文件目录下会有多个层级，多种不同的文件类型。需要处理很多逻辑，用node提供的api，你还需要写静态文件服务的逻辑，比较麻烦。</p>\n<h4 id=\"post参数解析\">post参数解析</h4>\n<p>第三个例子，接收get请求和post请求的参数</p>\n<p>get /user?a=1&amp;b=2</p>\n<p>post /user  {x:1, y: 2}</p>\n<pre><code class=\"language-js\">const http = require(&#39;http&#39;)\nconst URL = require(&#39;url&#39;)\nconst querystring = require(&#39;querystring&#39;)\n\nconst server = http.createServer((req, res)=&gt; {\n  const { url, method } = req\n  console.log(&#39;url, method: &#39;, url, method) // url, method:  /user?a=1&amp;b=2 GET\n\n  let urlObj = URL.parse(url) // 返回一个Url对象\n  console.log(urlObj)\n  let path = urlObj.pathname\n  if (path === &#39;/user&#39; &amp;&amp; method === &#39;GET&#39;) {\n    // 加 true 的二参后，会将 Url对象的 query 属性\n    // 由字符串 &#39;a=1&amp;b=2&#39; 转换为对象 { a: &#39;1&#39;, b: &#39;2&#39; }\n    let query =  URL.parse(url, true).query\n    res.end(JSON.stringify(query))\n  } else if (path === &#39;/user&#39; &amp;&amp; method === &#39;POST&#39;) {\n    var postData = &#39;&#39;; // 接收POST请求数据\n    // POST请求数据需要监听request的data事件来获取\n    console.log(req.headers)\n    req.on(&#39;data&#39;, function (chunk) {\n      postData += chunk;\n      console.log(&#39;接收到了数据&#39;, chunk)\n    });\n    // 在end事件触发后,将post_data解析为真正的POST请求格式，可以用.语法来获取值\n    req.on(&#39;end&#39;, function(){\n      // postData = querystring.parse(post_data);\n      console.log(postData)\n      let contentType = req.headers[&#39;content-type&#39;]\n      switch(contentType) {\n        case &#39;application/x-www-form-urlencoded&#39;:\n          postData = querystring.parse(postData)\n          // Object.fromEntries(new URLSearchParams(postData))\n          break\n        case &#39;application/json&#39;:\n          postData = JSON.parse(postData)\n          break\n        default:\n          if (contentType.startsWith(&#39;multipart/form-data&#39;)) {\n            postData = postData.split(&#39;\\r\\n&#39;)\n          }\n      }\n      console.log(typeof postData, postData)\n      res.end(&#39;end&#39;)\n    });\n  }\n})\nserver.listen(9000, () =&gt; { console.log(&#39;端口开启于9000&#39;) })</code></pre>\n<h4 id=\"post请求数据类型\">post请求数据类型</h4>\n<p>content-type 请求数据类型</p>\n<p><strong>1. postman Body = form-data</strong></p>\n<p><strong>&#39;content-type&#39;:&#39;multipart/form-data; boundary=----WebKitFormBoundary8YBfQtM6JDVUJFFZ&#39;,</strong></p>\n<pre><code class=\"language-js\">// 后台接收到的字符串数据\n------WebKitFormBoundary8YBfQtM6JDVUJFFZ\nContent-Disposition: form-data; name=&quot;a&quot;\n\n1\n------WebKitFormBoundary8YBfQtM6JDVUJFFZ--</code></pre>\n<p><strong>2. postman Body = x-www-form-urlencoded</strong></p>\n<p><strong>&#39;content-type&#39;: &#39;application/x-www-form-urlencoded&#39;,</strong></p>\n<pre><code class=\"language-js\">// 后台接收到的字符串数据\na=1</code></pre>\n<p><strong>3. postman Body = raw =&gt; JSON</strong></p>\n<p><strong>&#39;content-type&#39;: &#39;application/json&#39;</strong></p>\n<pre><code class=\"language-js\">// 后台接收到的字符串数据\n{\n        &quot;a&quot;: 1\n}</code></pre>\n<h3 id=\"express-对模块的整合\">express 对模块的整合</h3>\n<p>通过上面的三个例子，我们了解到想要用node的api来做开发，需要封装一些模块，并进行一定的整合。node有一个专门的包管理工具 ---- npm(Node Package Management)，任何人都可以注册npm账号、发布npm包，在项目中使用某个模块只需要npm install对应的模块，再require就可以了。</p>\n<p>express就是其中的一个npm包，它把node中复杂的操作做了一定的封装、整合。 <strong>内置了路由、静态文件服务、请求数据解析、中间件等功能</strong>，相比自己用node api来写web应用，要方便很多，我们把上面的三个例子，用express来实现下</p>\n<pre><code class=\"language-js\">const express = require(&#39;express&#39;)\nconst multer = require(&#39;multer&#39;); // multipart/form-data\nconst app = express()\napp.use(express.static(&#39;public&#39;)) // 静态服务\n\n// 路由\napp.get(&#39;/users&#39;, (req, res) =&gt; res.json({a: 1}))\napp.post(&#39;/info&#39;, (req, res) =&gt; res.json({b: 1}))\n\n// post、get参数\napp.use(express.json()) // for parsing application/json\napp.use(express.urlencoded({ extended: true })) // for parsing application/x-www-form-urlencoded\n\napp.get(&#39;/user&#39;, (req, res) =&gt; res.json(req.query))\napp.post(&#39;/user&#39;, (req, res) =&gt; res.json(req.body))\n// 注意post请求头选择form-data会被请求头设置覆盖\napp.post(&#39;/test&#39;, multer().none(), (req, res) =&gt; res.json(req.body)) \n\napp.use(&#39;/&#39;, (req, res) =&gt; res.send(&#39;404&#39;))\napp.listen(9000, () =&gt; console.log(`Example app listening on port 9000!`))</code></pre>\n<h3 id=\"koa-对express的改进\">koa 对express的改进</h3>\n<p>express已经够优秀了，为什么又演进出了koa呢？我们用koa重写上面的例子，来做一下对比</p>\n<pre><code class=\"language-js\">const Koa = require(&#39;koa&#39;)\nconst Router = require(&#39;koa-router&#39;)\nconst multer = require(&#39;@koa/multer&#39;)\nconst app = new Koa()\nconst router = new Router()\n\napp.use(require(&#39;koa-static&#39;)(__dirname + &#39;/public&#39;)) // 静态服务\napp.use(require(&#39;koa-bodyparser&#39;)()) // 解析\n\n// 路由\nrouter.get(&#39;/users&#39;, ctx =&gt; ctx.body = &#39;users&#39;)\nrouter.post(&#39;/info&#39;, ctx =&gt; ctx.body = { b: 1 })\n\n// 请求参数\nrouter.get(&#39;/user&#39;, ctx =&gt; ctx.body = ctx.query)\nrouter.post(&#39;/user&#39;, ctx =&gt; ctx.body = ctx.request.body)\nrouter.post(&#39;/test&#39;, multer().none(), ctx =&gt; ctx.body = ctx.request.body) \n\napp.use(router.routes()).use(router.allowedMethods())\n\napp.listen(9000, () =&gt; console.log(&#39;服务已开启，端口 9000&#39;))</code></pre>\n<h4 id=\"轻量无捆绑\">轻量无捆绑</h4>\n<p>对比两个例子来看，看起来改动很小，细心一点你会发现koa把路由、static、post参数解析等功能都从框架内部移除了，以中间件的方式引入。以前express相对来讲是比较重的，捆绑了很多功能，koa设计的就比较轻量、灵活，按需引入，渐进式增强。像vue也是这种设计，渐进式增强，按需引入，一般框架设计都有共通之处。</p>\n<h4 id=\"api设计更加易用优雅\">api设计更加易用优雅</h4>\n<p>仅从上面的例子，你可能看不出来什么，因为上面的信息比较少，实际express的api还有很多，我们来看看api文档</p>\n<p><strong>响应数据方面</strong>，express响应数据有多个api：res.end()，res.json()，res.send()，res.download()，res.sendFile()</p>\n<p><img src=\"../../../images/blog/node/why_node_response_express.png\" alt=\"response_express\"></p>\n<p>koa，砍掉无用的api，只保留 ctx.body = 根据不同的数据类型，自动处理</p>\n<p><img src=\"../../../images/blog/node/why_node_response_koa.png\" alt=\"response_koa.png\"></p>\n<p><strong>回调函数参数合并：res, req 合并为 ctx（context）</strong></p>\n<ul>\n<li>ctx.req、ctx.res 保留node原来的req与res</li>\n<li>再对原来的res和req进行优化、增强，演变为 ctx.request，ctx.response, 也就是koa自己的request和response</li>\n<li>aliases别名，由于ctx.request.xx 和 ctx.response.xx 比较长，所以通过定义ctx的访问器属性(get/set方法)设置了一些别名<pre><code class=\"language-js\">// 举两个例子\n// ctx.request.query 可以简写为 ctx.query\n// ctx.response.body 可以简写为 ctx.body</code></pre>\n</li>\n</ul>\n<h4 id=\"中间件构架增强---洋葱圈模型\">中间件构架增强 - 洋葱圈模型</h4>\n<p>我们先来看看express的中间件，非异步函数，只能顺序向下传递</p>\n<pre><code class=\"language-js\">var express = require(&#39;express&#39;)\nvar app = express()\n\nvar requestTime = function (req, res, next) {\n  req.requestTime = Date.now()\n  next()\n}\n\napp.use(requestTime)\n\napp.get(&#39;/&#39;, function (req, res) {\n  var responseText = &#39;Hello World!&lt;br&gt;&#39;\n  responseText += &#39;&lt;small&gt;Requested at: &#39; + req.requestTime + &#39;&lt;/small&gt;&#39;\n  res.send(responseText)\n})\n\napp.listen(3000)</code></pre>\n<p>再来看koa的中间件，异步函数，从上到下传递后，可以再自下而上传递，实现&quot;真正&quot; 的中间件</p>\n<pre><code class=\"language-js\">const Koa = require(&#39;koa&#39;);\nconst app = new Koa();\n\n// x-response-time\napp.use(async (ctx, next) =&gt; {\n  const start = Date.now();\n  await next();\n  const ms = Date.now() - start;\n  ctx.set(&#39;X-Response-Time&#39;, `${ms}ms`);\n});\n\n// logger\napp.use(async (ctx, next) =&gt; {\n  const start = Date.now();\n  await next();\n  const ms = Date.now() - start;\n  console.log(`${ctx.method} ${ctx.url} - ${ms}`);\n});\n\n// response\napp.use(async ctx =&gt; {\n  ctx.body = &#39;Hello World&#39;;\n});\n\napp.listen(3000);</code></pre>\n<p><img src=\"../../../images/blog/node/why_node_koa_middleware_mode.png\" alt=\"koa_middleware_mode.png\"></p>\n<h3 id=\"eggjs-为企业级框架和应用而生\">Egg.js 为企业级框架和应用而生</h3>\n<p>koa轻量简洁、但没有约束任何目录结构层级，Egg.js提供了更好的组织代码的方式，可以开发出更健壮的代码。可以帮助开发团队和开发人员降低开发和维护成本。</p>\n<p>参考：<a href=\"https://eggjs.org/zh-cn/basics/structure.html\">Egg.js 自动生成框架文件结构及说明</a></p>\n<h3 id=\"自己写一个koa\">自己写一个koa</h3>\n<p>koa中间件机制是：利用compose函数组合，将一组需要顺序执行的函数复合为一个函数，外层函数的参数是内层函数的返回值。</p>\n<p>执行顺序:</p>\n<ol>\n<li>先引入模块，创建koa对象</li>\n<li>执行app.use()引入各种中间件，返回this，支持链式调用 app.use(m1).user(m2)</li>\n<li>app.listen() 开始创建http服务，接收请求响应</li>\n</ol>\n<pre><code class=\"language-js\">const http = require(&#39;http&#39;)\nconst context = require(&#39;./context&#39;)\nconst request = require(&#39;./request&#39;)\nconst response = require(&#39;./response&#39;)\n\nclass MyKoa {\n  // app.use 调用 app.use(callback)\n  constructor() {\n    this.middlewares = []\n  }\n  use(middleware) {\n    this.middlewares.push(middleware)\n    return this // 支持链式调用 app.use().use()\n  }\n\n  listen(...args) {\n    console.log(args)\n    const server = http.createServer(async (req, res) =&gt; {\n      // 需要先创建上下文\n      let ctx = this.createContext(req, res)\n\n      // 组合函数、koa中间件核心\n      let fn = this.compose(this.middlewares) // 合并为一个执行函数\n      await fn(ctx)\n\n      // ctx.body设置值后，并没有响应给前端，来简单写下响应的逻辑\n      // 这里简单的处理了下ctx.body 但实际要有很多处理\n      let bodyType = typeof ctx.body\n      let result = bodyType === &#39;object&#39; ? JSON.stringify(ctx.body) : ctx.body\n      // 解决中文乱码的问题\n      res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/html; charset=utf-8&#39;});\n      res.end(result)\n    })\n    server.listen(...args)\n  }\n\n  createContext(req, res) {\n    // 先继承一些我们写的对象\n    const ctx = Object.create(context)\n    ctx.request = Object.create(request)\n    ctx.response = Object.create(response)\n\n    ctx.req = ctx.request.req = req\n    ctx.res = ctx.response.res = res\n\n    return ctx\n  }\n\n  compose(middlewares) {\n    return function(ctx) {\n      return dispatch(0) // 先执行第一个中间件\n      // 定义一个函数\n      function dispatch(i) { // 递归执行函数\n        let middleware = middlewares[i]\n        if (!middleware) { // 递归退出条件\n          return Promise.resolve()\n        }\n        return Promise.resolve(\n          middleware(ctx, () =&gt; {  // 对应 app.use(ctx, next =&gt; { await next() })\n            // dispatch(i + 1)\n            return dispatch(i + 1) // 如果不执行next，无法执行下一个中间件\n          })\n        )\n      }\n    }\n  }\n}\n\nmodule.exports = MyKoa</code></pre>\n<p>在上面的例子中，我们发现将next的函数里面 return dispatch(i + 1) 改为 dispatch(i + 1)，会导致await没有按预期等待。<strong>await 后面的内容如果函数返回值为promise，则等待promise执行完再向下执行，如果返回值非promise，await不会等待(await下面的代码和await等待的函数会同步执行)</strong></p>\n<p>koa compose源码</p>\n<pre><code class=\"language-js\">// koa compose  https://github.com/koajs/compose/blob/master/index.js\n\n&#39;use strict&#39;\n\n/**\n * Expose compositor.\n */\n\nmodule.exports = compose\n\n/**\n * Compose `middleware` returning\n * a fully valid middleware comprised\n * of all those which are passed.\n *\n * @param {Array} middleware\n * @return {Function}\n * @api public\n */\n\nfunction compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError(&#39;Middleware stack must be an array!&#39;)\n  for (const fn of middleware) {\n    if (typeof fn !== &#39;function&#39;) throw new TypeError(&#39;Middleware must be composed of functions!&#39;)\n  }\n\n  /**\n   * @param {Object} context\n   * @return {Promise}\n   * @api public\n   */\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i &lt;= index) return Promise.reject(new Error(&#39;next() called multiple times&#39;))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}</code></pre>\n<h3 id=\"自己写一个请求拦截中间件\">自己写一个请求拦截中间件</h3>\n<p>koa中间件规范:</p>\n<ol>\n<li>一个async函数</li>\n<li>接收ctx和next两个参数</li>\n<li>任务结束需要执行next</li>\n</ol>\n<pre><code class=\"language-js\">const mid = async (ctx, next) =&gt; {\n  // 来到中间件，洋葱圈左边\n  next() // 进入其他中间件\n  // 再次来到中间件，洋葱圈右边\n}</code></pre>\n<p>实现一个请求拦截中间件，对于黑名单内的ip，禁止访问</p>\n<pre><code class=\"language-js\">const Koa = require(&#39;koa&#39;)\nconst app = new Koa()\nconst intercept = require(&#39;./intercept&#39;)\n\n// 请求拦截中间件\napp.use(intercept)\n\napp.use((ctx, next) =&gt; {\n  ctx.body = &#39;hello&#39;\n})\napp.listen(3000)</code></pre>\n<p>intercept.js实现</p>\n<pre><code class=\"language-js\">async function intercept(ctx, next) {\n  let { res, req } = ctx\n  const blacklist = [\n    &#39;127.0.0.1&#39;,\n    &#39;192.168.1.2&#39;\n  ]\n  const ip = getClientIp(req)\n\n  if (blacklist.includes(ip)) {\n    ctx.body = &#39;您无权限访问&#39;\n    // 如果不执行next，就无法进入到下一个中间件\n  } else {\n    await next()\n  }\n}\n\n// 获取当前IP\nfunction getClientIp(req) {\n  let curIp = (\n    req.headers[&#39;x-forwarded-for&#39;] ||  // 是否有反向代理 IP\n    req.connection.remoteAddress || // 判断 connection 的远程 IP\n    req.socket.remoteAddress || // 判断后端的 socket 的 IP\n    req.connection.socket.remoteAddress \n  )\n  curIp.startsWith(&#39;::ffff:&#39;) &amp;&amp; (curIp = curIp.split(&#39;::ffff:&#39;)[1])\n  console.log(&#39;当前ip是&#39;, curIp)\n  return curIp\n}\n\nmodule.exports = intercept</code></pre>\n<p>可用性扩展</p>\n<pre><code class=\"language-js\">// let blacklist = [\n//   &#39;127.0.0.1&#39;,\n//   &#39;192.168.1.2&#39;\n// ]\n// // 请求拦截中间件\n// app.use(intercept(blacklist))\n\nfunction intercept(blacklist) {\n  return async (ctx, next) =&gt; {\n    // 获取当前IP\n    function getClientIp(req) {\n      let curIp = (\n        req.headers[&#39;x-forwarded-for&#39;] ||  // 是否有反向代理 IP\n        req.connection.remoteAddress || // 判断 connection 的远程 IP\n        req.socket.remoteAddress || // 判断后端的 socket 的 IP\n        req.connection.socket.remoteAddress \n      )\n      curIp.startsWith(&#39;::ffff:&#39;) &amp;&amp; (curIp = curIp.split(&#39;::ffff:&#39;)[1])\n      console.log(&#39;当前ip是&#39;, curIp)\n      return curIp\n    }\n\n    let { res, req } = ctx\n    const ip = getClientIp(req)\n\n    if (blacklist.includes(ip)) {\n      ctx.body = &#39;您无权限访问&#39;\n      // 如果不执行next，就无法进入到下一个中间件\n    } else {\n      await next()\n    }\n  }\n}\n\nmodule.exports = intercept</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "为什么会有Node.js，其衍生框架Express、Koa、Egg.js的演进过程",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "为什么会出现Node.js",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "什么是Node.js？"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "什么是JS运行时？"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "在node中为什么可以运行js代码？"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "node为什么要创建一个基于js的执行环境，作者的初衷是什么？"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "node的应用场景",
                  "children": [
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "打包构建、cli命令行工具脚手架"
                    },
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "写后台接口、高并发web服务、服务端渲染"
                    }
                  ]
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Node.js衍生框架发展",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "Node.js的不足",
                  "children": [
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "路由相关操作"
                    },
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "静态文件服务"
                    },
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "post参数解析"
                    },
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "post请求数据类型"
                    }
                  ]
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "express 对模块的整合"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "koa 对express的改进",
                  "children": [
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "轻量无捆绑"
                    },
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "api设计更加易用优雅"
                    },
                    {
                      "type": "heading",
                      "depth": 4,
                      "text": "中间件构架增强 - 洋葱圈模型"
                    }
                  ]
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "Egg.js 为企业级框架和应用而生"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "自己写一个koa"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "自己写一个请求拦截中间件"
                }
              ]
            }
          ]
        }
      ],
      "config": {
        "source": "为什么会有Node.js，其衍生框架Express、Koa、Egg.js的演进过程.md",
        "staticFileName": "why_node.html",
        "author": "guoqzuo",
        "createDate": "2020/08/02",
        "description": "为什么会有Node.js，在前端开发中，经常会用到node.js，那大家有没有想过 为什么会出现node.js这个技术？它解决了前端开发中的哪些问题？假设在前端面试中问你这个问题？你会怎么回答，下面是我自己的一个理解",
        "keywords": "为什么会有Node.js,node.js的不足",
        "category": "前端工程化",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"ui设计视觉差问题，总感觉没有居中对齐时怎么办\">UI设计视觉差问题，总感觉没有居中对齐时怎么办</h1>\n<p>当实现设计稿后，总感觉上下没对齐，怎么办呢？<strong>建议放大n倍，截图画框，看是否在一条水平线上</strong>。这里涉及到视觉差的问题，下面来看看相关知识</p>\n<h2 id=\"测量面积和视觉面积\">测量面积和视觉面积</h2>\n<ul>\n<li>视觉体量是人眼如何察觉物体的大小和感觉，不需要等同于物体的实际像素值</li>\n<li>圆、菱形、三角形和其他非方形形状为了与方形形状保持一样的视觉大小，应适当放大</li>\n<li>图标区域应为视觉平衡保留一定的空间，这一点对保持同系列图标视觉平衡很重要。(<strong>这也是iconfont上为什么有的图标周围有留白，而有的图标没有留白的原因</strong>)</li>\n</ul>\n<h2 id=\"不同形状之间的对齐\">不同形状之间的对齐</h2>\n<ul>\n<li>具有锐利边缘的形状应该更大，以便于其相邻的矩形对象保持视觉平衡</li>\n<li>大写字母对齐是一种有效且被广泛运用的方法，用于文本和按钮背景对齐</li>\n<li>将三角型图标正确放置按钮中的一种有效办法是，将其圈住并使此圈与背景对齐。</li>\n</ul>\n<h2 id=\"视觉圆角\">视觉圆角</h2>\n<ul>\n<li>几何圆角看起来假是因为人眼可以清楚地看到直线突然变成曲线的点</li>\n<li>视觉正确的圆角需要一些特殊的算法或手动调整形状</li>\n</ul>\n<p>参考：<a href=\"https://www.sohu.com/a/328932717_612419\">设计师必须知道，什么是视觉差对比？</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "UI设计视觉差问题，总感觉没有居中对齐时怎么办",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "测量面积和视觉面积"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "不同形状之间的对齐"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "视觉圆角"
            }
          ]
        }
      ],
      "config": {
        "source": "UI设计视觉差问题，总感觉没有居中对齐时怎么办.md",
        "staticFileName": "ui_vision_difference.html",
        "author": "guoqzuo",
        "createDate": "2020/08/02",
        "description": "当实现设计稿后，总感觉上下没对齐，怎么办呢？建议放大n倍，截图画框，看是否在一条水平线上。这里涉及到视觉差的问题，下面来看看相关知识，测量面积和视觉面积 - 视觉体量是人眼如何察觉物体的大小和感觉，不需要等同于物体的实际像素值 - 圆、菱形、三角形和其他非方形形状为了与方形形状保持一样的视觉大小，应适当放大",
        "keywords": "视觉差,视觉差怎么解决,UI视觉差,iconfont上为什么有的图标周围有留白，而有的图标没有留白的原因",
        "category": "CSS",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"关于商品价格有小数点时精度异常的问题\">关于商品价格有小数点时精度异常的问题</h1>\n<p>在价格显示时，如果有小数位，<strong>由于js浮点数的缺陷，累加的价格可能会有经度差，我们直接 toFixed(2) 即可</strong>。一般不会超过3位小数点，且精度异常一般都是小数点很多位以后，注意js小数点运算时一定要注意这个问题，确定要保留几位小数点</p>\n<pre><code class=\"language-js\">37998.91 + 0.01\n// 37998.920000000006\n\n0.1+0.2\n0.30000000000000004</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "关于商品价格有小数点时精度异常的问题"
        }
      ],
      "config": {
        "source": "关于商品价格有小数点时精度异常的问题.md",
        "staticFileName": "goods_price_float.html",
        "author": "guoqzuo",
        "createDate": "2020/08/02",
        "description": "在价格显示时，如果有小数位，由于js浮点数的缺陷，累加的价格可能会有经度差，我们直接 toFixed(2) 即可。一般不会超过3位小数点，且精度异常一般都是小数点很多位以后，注意js小数点运算时一定要注意这个问题，确定要保留几位小数点",
        "keywords": "商品价格有小数点时精度异常的问题",
        "category": "JavaScript",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"0-9数字中，每个数字的宽度是多少\">0-9数字中，每个数字的宽度是多少</h1>\n<p>什么数字最宽，以字体PingFangSC-Regular，大小12px为例</p>\n<pre><code class=\"language-bash\"># 测试10个x width宽度\n10个0 # 72\n10个1 # 48.13\n10个2 # 72\n10个3 # 72\n10个4 # 72\n10个5 # 72\n10个6 # 72\n10个7 # 65.64\n10个8 # 72\n10个9 # 72</code></pre>\n<p>总结，一般宽度 1 &lt; 7 &lt; 0,2,3,4,5,6,8,9  但不排除其他字体没有差异，同理我们可以使用这种方法看26个字母里每个字母的占用宽度为多少</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "0-9数字中，每个数字的宽度是多少"
        }
      ],
      "config": {
        "source": "0-9数字中，每个数字的宽度是多少.md",
        "staticFileName": "number_width.html",
        "author": "guoqzuo",
        "createDate": "2020/08/02",
        "description": "什么数字最宽，以字体PingFangSC-Regular，大小12px为例, 一般宽度 1 < 7 < 0,2,3,4,5,6,8,9  但不排除其他字体没有差异，同理我们可以使用这种方法看26个字母里每个字母的占用宽度为多少",
        "keywords": "数字宽度,什么数字最宽",
        "category": "CSS",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"使用ssh方式拉取代码的步骤\">使用ssh方式拉取代码的步骤</h1>\n<p>在使用git拉取远程分支代码时，有两种方式，一种是git clone，另一种是 ssh。在文件太大git clone超时时，我们可以试试ssh这种方法，下面来看看具体步骤</p>\n<pre><code class=\"language-bash\"># 使用git平台邮箱账号生成公钥和私钥，全部默认、回车\nssh-keygen -t rsa -C &quot;xxx@qq.com&quot;\n\n# 执行成功过后会在 ~/.ssh 目录下生成 id_rsa.pub 和 id_rsa 两个文件，一个公钥、一个私钥\n\n# 查看公钥，并配置到对应的git平台里\ncat ~/.ssh/id_rsa.pub\n\n# 测试配置是否成功\nssh -T git@xxx.com \n\n# 拉取 \ngit clone git@xxx.com/xxxproject</code></pre>\n<p>参考：<a href=\"https://blog.csdn.net/u013778905/article/details/83501204\">GitHub如何配置SSH Key</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "使用ssh方式拉取代码的步骤"
        }
      ],
      "config": {
        "source": "使用ssh方式拉取代码的步骤.md",
        "staticFileName": "git_ssh.html",
        "author": "guoqzuo",
        "createDate": "2020/08/02",
        "description": "在使用git拉取远程分支代码时，有两种方式，一种是git clone，另一种是 ssh。在文件太大git clone超时时，我们可以试试ssh这种方法，下面来看看具体步骤",
        "keywords": "git ssh",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"git删除远程分支与本地分支\">git删除远程分支与本地分支</h1>\n<p>当我们常见远程分支，使用完成后，怎么删除远程的分支呢？我们以删除file_backup分支为例，来看看具体步骤</p>\n<ol>\n<li>先查看本地分支</li>\n</ol>\n<pre><code class=\"language-bash\">git branch -a # 查看当前分\n# file_backup\n# master\n# remotes/origin/HEAD -&gt; origin/master\n# remotes/origin/file_backup</code></pre>\n<ol start=\"2\">\n<li>删除远程的file_backup分支</li>\n</ol>\n<pre><code class=\"language-bash\">git push origin --delete file_backup</code></pre>\n<ol start=\"3\">\n<li>删除本地分支</li>\n</ol>\n<pre><code class=\"language-bash\">git branch -d file_backup</code></pre>\n<p>参考：<a href=\"https://www.cnblogs.com/luosongchao/p/3408365.html\">git删除远程分支和本地分支</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "git删除远程分支与本地分支"
        }
      ],
      "config": {
        "source": "git删除远程分支与本地分支.md",
        "staticFileName": "git_branch_del.html",
        "author": "guoqzuo",
        "createDate": "2020/08/02",
        "description": "git删除分支,git删除远程分支,git怎么删除远程分支,当我们常见远程分支，使用完成后，怎么删除远程的分支呢？我们以删除file_backup分支为例，来看看具体步骤 1. 先查看本地分支 2. 删除远程的file_backup分支 3. 删除本地分支",
        "keywords": "git删除分支,git删除远程分支,git怎么删除远程分支",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"objectobserve与proxy\">Object.observe()与Proxy</h1>\n<p>Object.observe()是js实现观察者设计模式的一个API，现在已废弃，由Proxy取代，但Proxy不支持IE。</p>\n<p>它用于异步地监视一个对象的修改。当对象属性被修改时，方法的回调函数会提供一个有序的修改流。</p>\n<p>在vue2.0的双向绑定的实现里，会遍历data对象，通过建立对应的getter/setter访问器属性来追踪属性变化。Vue 3.0里已使用Proxy来追踪属性变化</p>\n<pre><code class=\"language-js\">// 截取至vue 3.0相关代码\n// https://github.com/vuejs/vue-next/blob/40bdd51bf5ec24b8e3faab3e1cb4d91b076e456a/packages/reactivity/src/reactive.ts#L99\nfunction createReactiveObject(\n  target: unknown,\n  toProxy: WeakMap&lt;any, any&gt;,\n  toRaw: WeakMap&lt;any, any&gt;,\n  baseHandlers: ProxyHandler&lt;any&gt;,\n  collectionHandlers: ProxyHandler&lt;any&gt;\n) {\n  if (!isObject(target)) {\n    if (__DEV__) {\n      console.warn(`value cannot be made reactive: ${String(target)}`)\n    }\n    return target\n  }\n  // target already has corresponding Proxy\n  let observed = toProxy.get(target)\n  if (observed !== void 0) {\n    return observed\n  }\n  // target is already a Proxy\n  if (toRaw.has(target)) {\n    return target\n  }\n  // only a whitelist of value types can be observed.\n  if (!canObserve(target)) {\n    return target\n  }\n  const handlers = collectionTypes.has(target.constructor)\n    ? collectionHandlers\n    : baseHandlers\n  observed = new Proxy(target, handlers)\n  toProxy.set(target, observed)\n  toRaw.set(observed, target)\n  return observed\n}</code></pre>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/observe\">Object.observe() | MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy | MDN</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/reactivity.html\">vue2.0 深入响应式原理 | vue官网</a></li>\n<li><a href=\"https://github.com/vuejs/vue-next/tree/40bdd51bf5ec24b8e3faab3e1cb4d91b076e456a/packages/reactivity\">vue3.0 数据响应式相关源码 | github </a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Object.observe()与Proxy"
        }
      ],
      "config": {
        "source": "Object.observe()与Proxy.md",
        "staticFileName": "observe_proxy.html",
        "author": "guoqzuo",
        "createDate": "2020/08/02",
        "description": "Object.observe()是js实现观察者设计模式的一个API，现在已废弃，由Proxy取代，但Proxy不支持IE。它用于异步地监视一个对象的修改。当对象属性被修改时，方法的回调函数会提供一个有序的修改流。在vue2.0的双向绑定的实现里，会遍历data对象，通过建立对应的getter/setter访问器属性来追踪属性变化。Vue 3.0里已使用Proxy来追踪属性变化",
        "keywords": "observe与proxy",
        "category": "JavaScript",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"websocket的使用场景\">WebSocket的使用场景</h1>\n<p>WebSocket是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议。之前在工作中基本没用到过，今天偶然看到一个网站，他里面列出了WebSocket的几种使用场景，如下：</p>\n<ul>\n<li>在线多人点菜</li>\n<li>远程画版同步</li>\n<li>在线选座</li>\n<li>游戏 (只要涉及到多人对战、协同的就需要用到)</li>\n<li>扫码登录/支付</li>\n<li>IM 聊天</li>\n</ul>\n<p>而且还可以在线体验，还不错，体验地址：<a href=\"https://www.goeasy.io/cn/demos/demos.html\">https://www.goeasy.io/cn/demos/demos.html</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "WebSocket的使用场景"
        }
      ],
      "config": {
        "source": "WebSocket的使用场景.md",
        "staticFileName": "websocket_scene.html",
        "author": "guoqzuo",
        "createDate": "2020/08/10",
        "description": "WebSocket是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议。之前在工作中基本没用到过，今天偶然看到一个网站，他里面列出了WebSocket的几种使用场景，如下：在线多人点菜、远程画版同步、在线选座、游戏 (只要涉及到多人对战、协同的就需要用到)、扫码登录/支付、IM 聊天",
        "keywords": "WebSocket的使用场景,websocket可以做什么",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"为什么要写单元测试\">为什么要写单元测试</h1>\n<p>20/04/30日发版，持续到到今天凌晨2点左右，测试发现有个bug：时间区间组件DatePicker前面一个时间没有显示，而这里应该显示最近一周的时间区间，现在只显示了后面一个时间。</p>\n<p>但测试环境测试、UAT测试都是过了的，怎么突然就有问题了呢？于是看同事的代码定位问题，发现根据当前时间计算最近一周的日期逻辑有问题，只是简单粗暴的把 day 减了 6 天，之前一直是4月中下旬，大于6，所以没有出问题，这次正好是5月1号， 1 - 6 就是 -5 了, 时间拼接为 2020-05-0-5，这就导致有bug了。还好今天是5月1号，不然测不出这个bug就会导致后面生成环境的bug了。</p>\n<p>从发现问题到定位问提、解决问题，大概用了5-10分钟左右。最后用当前时间戳 - 6 * 24 * 3600 * 1000 来解决。 </p>\n<p>我们一般在写程序时，很难发现自己逻辑上的bug，假设我们这里有写单元测试，考虑了很多种情况，那就可以避免这个问题。但现实是，我们目前大部分人都没有这个习惯，只要测试过了，就基本以为没问题了。但对于那种测试都测试不出来的在特定时间才会触发的bug，真的很可能造成线上bug，完全依赖于个人写代码时的逻辑严谨性。</p>\n<p>怎么让自己写的代码更严谨，出问题的几率更小呢？那就是写单元测试。这样我们会考虑更多的特殊场景、而不是靠人肉测试。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "为什么要写单元测试"
        }
      ],
      "config": {
        "source": "为什么要写单元测试.md",
        "staticFileName": "why_unit_test.html",
        "author": "guoqzuo",
        "createDate": "2020/08/10",
        "description": "20/04/30日发版，持续到到今天凌晨2点左右，测试发现有个bug：时间区间组件DatePicker前面一个时间没有显示，而这里应该显示最近一周的时间区间，现在只显示了后面一个时间。但测试环境测试、UAT测试都是过了的，怎么突然就有问题了呢？于是看同事的代码定位问题，发现根据当前时间计算最近一周的日期逻辑有问题，只是简单粗暴的把 day 减了 6 天，之前一直是4月中下旬，大于6，所以没有出问题，这次正好是5月1号， 1 - 6 就是 -5 了, 时间拼接为 2020-05-0-5，这就导致有bug了。还好今天是5月1号，不然测不出这个bug就会导致后面生成环境的bug了。",
        "keywords": "为什么要写单元测试,单元测试有什么好处",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"怎么看chrome浏览器更新记录及内容\">怎么看chrome浏览器更新记录及内容</h1>\n<p>最近发现办公电脑的chrome浏览器console里不支持 ?? 运算符，而我自己的电脑就可以，对比了下版本，我的是最新的81版本，而办公电脑还是71的版本，于是我就想看看chrome每次版本的更新记录，这个貌似要翻墙，我用了一个开源的chrome访问助手，找到了对应的位置</p>\n<p><a href=\"https://developers.google.com/web/updates/2020\">Web Updates (2020)  |  Google Developers&quot;</a></p>\n<p>这里有介绍每次chrome的更新记录，按月份来，以4月的 Chrome 81来讲 <a href=\"https://developers.google.com/web/updates/2020/04/nic81\">New in Chrome 81</a> 介绍了对应的改动，比如</p>\n<ul>\n<li>I&#39;ve got an update on the adjusted Chrome release schedule.</li>\n<li>App Icon Badging graduates from its origin trial.</li>\n<li>Hit testing for augmented reality is now available in the browser.（WebXR hit testing）</li>\n<li>Web NFC starts its origin trial.</li>\n<li>And more.</li>\n</ul>\n<p>感觉发现了新大陆，web还可以操作NFC... 对于了解一些新的技术，是很有必要看看这些的，顺便练习下英语</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "怎么看chrome浏览器更新记录及内容"
        }
      ],
      "config": {
        "source": "怎么看chrome浏览器更新记录及内容.md",
        "staticFileName": "chrome_update_log.html",
        "author": "guoqzuo",
        "createDate": "2020/08/10",
        "description": "最近发现办公电脑的chrome浏览器console里不支持 ?? 运算符，而我自己的电脑就可以，对比了下版本，我的是最新的81版本，而办公电脑还是71的版本，于是我就想看看chrome每次版本的更新记录，这个貌似要翻墙，我用了一个开源的chrome访问助手，找到了对应的位置",
        "keywords": "怎么看chrome浏览器更新记录及内容,怎么看chrome浏览器每个版本更新了什么",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"uni复制功能只支持app、小程序，怎么兼容h5\">uni复制功能只支持app、小程序，怎么兼容H5</h1>\n<p>uni复制功能只支持app、小程序，怎么兼容H5呢？当H5时，我们可以引导用户自己选择后copy，如果是app调用uni的api，代码如下</p>\n<pre><code class=\"language-js\">copy() {\n  // #ifdef H5\n  prompt(&#39;复制失败。请选中下列微信号，手动复制&#39;, this.copyInfo)\n  // #endif\n\n  // #ifdef APP-PLUS\n  uni.setClipboardData({\n    data: this.contact,\n    success: function () {\n      uni.showToast({\n        title: &#39;复制成功&#39;,\n        icon: &#39;none&#39;,\n        image: &#39;&#39;,\n        duration: 1500,\n        mask: false,\n      })\n    }\n  });\n  // #endif\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "uni复制功能只支持app、小程序，怎么兼容H5"
        }
      ],
      "config": {
        "source": "uni复制功能只支持app、小程序，怎么兼容H5.md",
        "staticFileName": "uni_copy_h5.html",
        "author": "guoqzuo",
        "createDate": "2020/08/10",
        "description": "uni复制功能只支持app、小程序，怎么兼容H5呢？当H5时，我们可以引导用户自己选择后copy，如果是app调用uni的api，代码如下",
        "keywords": "uni复制兼容H5,uni复制 h5",
        "category": "移动端混合开发",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"uni动态修改导航栏按钮文案\">uni动态修改导航栏按钮文案</h1>\n<p>一般uni导航栏按钮是在配置文件里面写的，那怎么动态的修改配置呢？先来看导航栏按钮配置文件，导航栏右侧有一个按钮 &quot;编辑&quot;</p>\n<pre><code class=\"language-js\">{\n  &quot;path&quot;: &quot;pages/cart/cart&quot;,\n  &quot;style&quot;: {\n    &quot;navigationBarTitleText&quot;: &quot;标题&quot;,\n    &quot;app-plus&quot;: {\n      &quot;autoBackButton&quot;: false,\n      &quot;titleNView&quot;: {\n        // 这里没有用搜索栏\n        // &quot;searchInput&quot;: {\n        //     &quot;align&quot;: &quot;center&quot;,\n        //     &quot;backgroundColor&quot;: &quot;#eee&quot;,\n        //     &quot;borderRadius&quot;: &quot;5px&quot;, // 只能用px作单位\n        //     &quot;placeholder&quot;: &quot;请输入内容&quot;,\n        //     &quot;placeholderColor&quot;: &quot;#ccc&quot;\n        // },\n        &quot;buttons&quot;: [{\n            &quot;color&quot;: &quot;#222222&quot;,\n            &quot;colorPressed&quot;: &quot;#eee&quot;,\n            &quot;float&quot;: &quot;right&quot;,\n            &quot;fontSize&quot;: &quot;14px&quot;,\n            &quot;width&quot;: &quot;45px&quot;,\n            &quot;text&quot;: &quot;编辑&quot; // 字体图标\\u 开头，加上字体图标unicode后面四位\n        }]\n      }\n    }\n  }\n}</code></pre>\n<p>再来看看对应的js</p>\n<pre><code class=\"language-js\">export default {\n  // 导航栏右侧按钮  编辑 =&gt; 完成\n  // 点击编辑或完成，会触发该函数\n  onNavigationBarButtonTap(e) {\n    let isApp = !!this.$mp.page.$getAppWebview\n    if (isApp) {\n      // 如果是app场景\n      this.changeNavButtonText()\n    } else {\n      // 如果是H5\n      let btnEle = document.querySelectorAll(&#39;.uni-page-head-btn i&#39;)[1]\n      let curText = btnEle.textContent\n      btnEle.textContent = curText === &#39;完成&#39; ? &#39;编辑&#39; : &#39;完成&#39;\n      this.isEdit = curText === &#39;编辑&#39;\n    }\n  },\n  methods: {\n     // 修改导航栏标题\n    changeNavButtonText(text) {\n      let webview = this.$mp.page.$getAppWebview()\n      let tn = webview.getStyle().titleNView;\n      let curText = webview.getStyle().titleNView.buttons[0].text\n\n      webview.setTitleNViewButtonStyle(0, {  \n        text: curText === &#39;完成&#39; ? &#39;编辑&#39; : &#39;完成&#39;\n      }); \n      this.isEdit = curText === &#39;编辑&#39; \n      // 用于真机调试时 log\n      // uni.showToast({\n      //   title: curText + &#39;/&#39; + this.isEdit + &#39;/&#39; + uni.getSystemInfoSync().platform,\n      //   icon: &#39;none&#39;,\n      //   image: &#39;&#39;,\n      //   duration: 1500,\n      //   mask: false,\n      // })\n    }\n  }\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "uni动态修改导航栏按钮文案"
        }
      ],
      "config": {
        "source": "uni动态修改导航栏按钮文案.md",
        "staticFileName": "uni_eidt_nav.html",
        "author": "guoqzuo",
        "createDate": "2020/08/10",
        "description": "一般uni导航栏按钮是在配置文件里面写的，那怎么动态的修改配置呢？先来看导航栏按钮配置文件，导航栏右侧有一个按钮 编辑",
        "keywords": "uni动态修改导航栏按钮、文案",
        "category": "移动端混合开发",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue多层级组件，父组件怎么将事件传递给孙组件\">vue多层级组件，父组件怎么将事件传递给孙组件?</h1>\n<p>来看一个例子，假设A组件包含组件B，B组件又包含组件C，我们知道，在B组件里 this.$emit(&#39;open-tab&#39;) 会执行其父组件A里面对应的方法，但如果B的子组件C，也想触发A组件的事件，那要怎么做呢？</p>\n<pre><code class=\"language-html\">&lt;comp-a :detail=&quot;detail&quot; @open-tab=&quot;openTab&quot;&gt;&lt;/comp-a&gt;\n&lt;comp-b&gt;&lt;/comp-b&gt;\n&lt;comp-c&gt;&lt;/comp-c&gt;</code></pre>\n<p>这就要用到 v-on=&quot;$listeners&quot;，在B组件上加上这个属性，可以将A组件上v-on绑定的事件（不含 .native 修饰器的）传递到其子组件，对创建高层级组件非常有用。</p>\n<pre><code class=\"language-html\">&lt;comp-b v-on=&quot;$listeners&quot;&gt;&lt;/comp-b&gt;</code></pre>\n<p>同理怎么将A组件的props值传递到C组件？可以通过加 v-bind=&quot;$attrs&quot; 来实现</p>\n<p><a href=\"https://cn.vuejs.org/v2/api/#vm-listeners\">vm.$listeners API — Vue.js</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue多层级组件，父组件怎么将事件传递给孙组件?"
        }
      ],
      "config": {
        "source": "vue多层级组件，父组件怎么将事件传递给孙组件?.md",
        "staticFileName": "vue_listeners.html",
        "author": "guoqzuo",
        "createDate": "2020/08/10",
        "description": "来看一个例子，假设A组件包含组件B，B组件又包含组件C，我们知道，在B组件里 this.$emit('open-tab') 会执行其父组件A里面对应的方法，但如果B的子组件C，也想触发A组件的事件，那要怎么做呢？",
        "keywords": "vue多层级组件，父组件怎么将事件传递给孙组件",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue动态组件怎么动态绑定一个或多个v-bind属性\">vue动态组件怎么动态绑定一个或多个v-bind属性</h1>\n<p>最近有封装一个tabs标签页组件，引入组件，可以将页面进行tab化。</p>\n<p>原先的页面作为子组件放到tabs组件里，由于标签页跳转页面时有需要打开新的标签页。所以tabs组件里会包含多个页面组件。</p>\n<p>为了避免像el-tabs那样，每次引入tabs组件都需要自己写v-if的逻辑来切换tab显示。我把这一步封装到了自定义tabs组件内部，内部使用动态组件component、is来切换组件显示。</p>\n<p>为了页面tab化时最好不要改动，我需要根据不同的组件，动态v-bind不同的组件名。但问题是动态v-bind属性局限性很强，由于动态属性还包含修饰符，所以只能是单个的变量，不能是 tabs[curTabIndex].prop 这种写法，且这种方法只能传入一个参数，如果tab页组件需要传入多个参数，那怎么办？我暂时直接用options传入一个对象，在需要tab化的组件里转换一下才行。</p>\n<p>如果需要更好的处理，可能需要写render函数了。</p>\n<pre><code class=\"language-html\">&lt;component is=&quot;comsMap[tabs[curTabIndex]]&quot; :[tabs[curTabIndex].prop]=&quot;tabs[curTabIndex].value&quot;&gt;&lt;/component&gt;</code></pre>\n<p>另外如果在动态组件里加了 keep-alive 也是有坑的，因为假如可以打开多个详情标签页，那多个标签页是同一个组件，只是不同的值在切换，如果加了keep-alive那每次打开的都是同一个详情页，我们可以使用watch监听下options值的变动，值改动时，触发页面数据跟着改变，也就是tabs页对于需要打开多个相同组件，不同内容的tab，是做不到keep-alive的，除非自己写缓存逻辑，-_-</p>\n<p>组件封装的目的很简单，就是封装变化、减少代码量。易用性、可扩展、可维护性之间要寻找一个平衡。看哪些是必须要提供的功能，在这个前提下尽量精简，精简到不能继续封装为止。另外我们在使用这个组件时，需要做的工作尽可能少，代码尽量优雅。核心问题还是提高效率，增加代码结构化。</p>\n<p>在大话设计模式的书里，有讲到，产品可能会频繁的变动、新增功能。我们要考虑到页面可能发生的各种变化，尽量在发生变动时，不用怎么改代码，这也是设计模式的核心理念：封装变化。这样才能写出更健壮的代码。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue动态组件怎么动态绑定一个或多个v-bind属性"
        }
      ],
      "config": {
        "source": "vue动态组件怎么动态绑定一个或多个v-bind属性.md",
        "staticFileName": "component_vbind.html",
        "author": "guoqzuo",
        "createDate": "2020/08/10",
        "description": "最近有封装一个tabs标签页组件，引入组件，可以将页面进行tab化。原先的页面作为子组件放到tabs组件里，由于标签页跳转页面时有需要打开新的标签页。所以tabs组件里会包含多个页面组件，为了避免像el-tabs那样，每次引入tabs组件都需要自己写v-if的逻辑来切换tab显示。我把这一步封装到了自定义tabs组件内部，内部使用动态组件component、is来切换组件显示。",
        "keywords": "动态组件怎么动态绑定一个或多个v-bind属性",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue在自定义组件上使用v-model指令\">vue在自定义组件上使用v-model指令</h1>\n<p>在自定义组件上，<strong>使用v-model指令，默认会向子组件传递一个字段名为 value 的 prop 属性，以及绑定一个名为 input 的事件。在子组件里，可以用props来接收value字段，可以用 this.$emit(&#39;input&#39;) 来对父组件里value的值进行修改。</strong></p>\n<p>它主要的应用在子组件需要修改父组件属性值的情况，你不需要额外再调用子组件时，传递一个修改值的事件，节省了一个事件监听。来看看示例</p>\n<pre><code class=\"language-html\">&lt;my-div v-model=&quot;someValue&quot;&gt;&lt;/my-div&gt;\n&lt;!-- 等价于 --&gt;\n&lt;my-div :value=&quot;someValue&quot; @input=&quot;someValue = $event&quot;&gt;\n\n&lt;script&gt;\nexport default {\n  props: {\n    value: {\n      type: String,\n      required: true\n    }\n  },\n  data() {\n    return {}\n  },\n  methods: {\n    modifyParentCompsValue() {\n      this.$emit(&#39;input&#39;, &#39;要设置的值&#39;)\n    }\n  }\n}\n&lt;/script&gt;</code></pre>\n<h2 id=\"怎么修改v-model的默认行为\">怎么修改v-model的默认行为</h2>\n<blockquote>\n<p>model选项，允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。</p>\n</blockquote>\n<pre><code class=\"language-js\">export default {\n  model: {\n    prop: &#39;show&#39;,\n    event: &#39;close&#39;\n  }\n  props: {\n    show: {\n      type: String,\n      required: true\n    }\n  },\n  data() {\n    return {}\n  },\n  methods: {\n    modifyParentCompsValue() {\n      this.$emit(&#39;close&#39;, &#39;要设置的值&#39;)\n    }\n  }\n}</code></pre>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/api/#model\">选项 model | Vue.js API</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model\">自定义组件的 v-model | Vue.js</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue在自定义组件上使用v-model指令",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "怎么修改v-model的默认行为"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "vue在自定义组件上使用v-model指令.md",
        "staticFileName": "custom_comp_v_model.html",
        "author": "guoqzuo",
        "createDate": "2020/08/15",
        "description": "vue自定义组件使用使用v-model,vue v-model,vue v-model原理,vue v-model内部实现,在自定义组件上，使用v-model指令，默认会向子组件传递一个字段名为 value 的 prop 属性，以及绑定一个名为 input 的事件。在子组件里，可以用props来接收value字段，可以用 this.$emit('input') 来对父组件里value的值进行修改。它主要的应用在子组件需要修改父组件属性值的情况，你不需要额外再调用子组件时，传递一个修改值的事件，节省了一个事件监听。来看看示例",
        "keywords": "vue自定义组件使用使用v-model,vue v-model,vue v-model原理,vue v-model内部实现",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue中v-model与sync的区别\">vue中v-model与.sync的区别</h1>\n<p>一般父组件给子组件传值是单向的，对于非引用类型，子组件怎么修改父组件传给子组件prop对应的值呢？除了通过 $parent、$root、Bus(发布，订阅)、状态管理(vuex)、额外定义一个方法外，还有两种方法：使用 v-model，或者为加.sync，来看下对比</p>\n<p>先来看v-model</p>\n<pre><code class=\"language-html\">&lt;my-div v-model=&quot;someValue&quot; /&gt;\n&lt;!-- 等价于 --&gt;\n&lt;my-div :value=&quot;someValue&quot; @input=&quot;someValue = $event&quot;&gt;\n\n&lt;script&gt;\n  // this.$emit(&#39;input&#39;, &#39;修改somevalue的值为这里的值&#39;)\n&lt;/script&gt;</code></pre>\n<p>再来看.sync</p>\n<pre><code class=\"language-html\">&lt;my-div :someValue.sync=&quot;doc.title&quot; /&gt;\n&lt;!-- 等价于 --&gt;\n&lt;my-div :someValue=&quot;doc.title&quot; @update:someValue=&quot;doc.title = $event&quot; /&gt;\n\n\n&lt;script&gt;\n  // this.$emit(&#39;update:someValue&#39;, &#39;修改somevalue的值为这里的值&#39;)\n&lt;/script&gt;</code></pre>\n<p>两者的区别: </p>\n<ul>\n<li>v-model主要用于表单输入的双向绑定，注重值的改变，.sync主要用于状态的切换</li>\n<li>v-model事件及prop的名称，子组件接收时是可以通过model自定义的，.sync子组件接收到的值是固定的</li>\n</ul>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6\">.sync修饰符 | Vue.js</a></li>\n<li><a href=\"https://www.jianshu.com/p/f0673a9eba3f\">vue中v-model和.sync修饰符区别</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue中v-model与.sync的区别"
        }
      ],
      "config": {
        "source": "vue中v-model与.sync的区别.md",
        "staticFileName": "v-model_vs_sync.html",
        "author": "guoqzuo",
        "createDate": "2020/08/15",
        "description": "v-model与.sync的区别,v-model vs .sync, vue v-model与 .sync的区别,一般父组件给子组件传值是单向的，对于非引用类型，子组件怎么修改父组件传给子组件prop对应的值呢？除了通过 $parent、$root、Bus(发布，订阅)、状态管理(vuex)、额外定义一个方法外，还有两种方法：使用 v-model，或者为加.sync，来看下对比",
        "keywords": "v-model与.sync的区别,v-model vs .sync, vue v-model与 .sync的区别",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue中attrs-和-listeners-的使用场景\">vue中<code>$attrs</code> 和 <code>$listeners</code> 的使用场景</h1>\n<p>在vue中，$attrs，$listeners 分别记录了当前组件上绑定的属性以及事件，一般可能用的比较少，下面来看看</p>\n<h2 id=\"thisattrs\">this.$attrs</h2>\n<blockquote>\n<p><code>$attrs</code>包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。</p>\n</blockquote>\n<p><code>v-bind=&quot;$attrs&quot;</code> 他类似属性展开运算符，将父组件调用子组件时传入的属性展开(不包含props已接收的)、v-bind到当前的元素上。这里以封装input表单组件为例，来看看效果</p>\n<pre><code class=\"language-html\">&lt;!-- 调用 zuo-input组件时传参 --&gt;\n&lt;zuo-input v-model=&quot;value&quot; placeholder=&quot;请输入&quot; maxlength=&quot;50&quot;/&gt;\n\n&lt;!-- zuo-input 组件内部实现 --&gt;\n&lt;input :value=&quot;value&quot; @input=&quot;oninput&quot; v-bind=&quot;$attrs&quot;&gt; \n&lt;!-- 上面的代码渲染出来效果如下 --&gt;\n&lt;input :value=&quot;value&quot; @input=&quot;oninput&quot; placeholder=&quot;请输入&quot; maxlength=&quot;50&quot;/&gt;</code></pre>\n<h2 id=\"thislisteners\">this.$listeners</h2>\n<blockquote>\n<p>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。</p>\n</blockquote>\n<p>之前的笔记有提过，如果A组件包含B组件，B组件包含C组件。C组件想要触发A组件的方法，可以在B组件上加 <code>v-on=&quot;$listeners&quot;</code> , 这样 C组件可以直接通过emit触发A组件的事件</p>\n<pre><code class=\"language-js\">// this.$listeners\n{\n  focus: function (event) { /* ... */ }\n  input: function (value) { /* ... */ },\n}</code></pre>\n<p>除了跨层级向下传递事件外，还可以用于将原生事件绑定到组件</p>\n<pre><code class=\"language-html\">&lt;zuo-input @focus=&quot;focus&quot; @input=&quot;xxx&quot; @change=&quot;xx&quot;/&gt;\n&lt;!-- zuo-input 组件内部实现 --&gt;\n&lt;input v-on=&quot;$listeners&quot;&gt; \n&lt;!-- 上面的代码渲染出来效果如下 --&gt;\n&lt;input onfocus=&quot;focus&quot; oninput=&quot;xxx&quot; onchange=&quot;xx&quot;&gt; </code></pre>\n<h2 id=\"实战应用\">实战应用</h2>\n<p>为了实践上面的<code>$attrs</code>和<code>$listeners</code>我们可以自己尝试封装一个element form表单组件，参考示例 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/views/elementForm\">elementForm表单组件模仿实现 | github</a></p>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html#%E5%B0%86%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%88%B0%E7%BB%84%E4%BB%B6\">深入了解组件 - 自定义事件 - 将原生事件绑定到组件 | Vue.js</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#vm-attrs\"><code>$attrs</code>和<code>$listeners</code> | Vue.js</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue中`$attrs` 和 `$listeners` 的使用场景",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "this.$attrs"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "this.$listeners"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "实战应用"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "vue中$attrs 和 $listeners 的使用场景.md",
        "staticFileName": "vue_attrs_listeners.html",
        "author": "guoqzuo",
        "createDate": "2020/08/15",
        "description": "$attrs与$listeners,vue $attrs,vue $listeners,vue $attrs使用场景,vue $listeners使用场景,在vue中，$attrs，$listeners 分别记录了当前组件上绑定的属性以及事件，一般可能用的比较少，下面来看看。`v-bind=$attrs` 他类似属性展开运算符，将父组件调用子组件时传入的属性展开(不包含props已接收的)、v-bind到当前的元素上。listeners除了跨层级向下传递事件外，还可以用于将原生事件绑定到组件",
        "keywords": "$attrs与$listeners,vue $attrs,vue $listeners,vue $attrs使用场景,vue $listeners使用场景",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue为什么要将插槽slotaaa的写法变更为v-slotaaa\">vue为什么要将插槽slot=&quot;aaa&quot;的写法变更为v-slot:aaa</h1>\n<blockquote>\n<p>在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除</p>\n</blockquote>\n<p>具名插槽 主要用于当有多个插槽时，通过名字对不同的插槽进行区分</p>\n<h2 id=\"先来看看聚名插槽使用时的一个特殊场景\">先来看看聚名插槽使用时的一个特殊场景</h2>\n<p>由于在父组件里调用用子组件，会写上对应的插槽，这时插槽的作用域为当前的父组件，插槽内部使用的变量名默认都是从父组件取的。下面的例子中 slotA插槽内部调用的 user，它默认是当前组件的变量（父组件）</p>\n<pre><code class=\"language-html\">&lt;base-layout&gt;\n  &lt;template v-slot:slotA&gt;  &lt;!-- 等价于 &lt;template slot=&quot;slotA&quot;&gt; --&gt;\n    &lt;h1&gt;Here might be a page title {{ user }}&lt;/h1&gt;\n  &lt;/template&gt;\n\n  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n&lt;/base-layout&gt;</code></pre>\n<p>那如果想在插槽里面获取对应子组件作用域里的变量，也就是我想获取base-layout组件里面的变量，就需要<strong>作用域插槽</strong>了</p>\n<h2 id=\"作用域插槽使用方法\">作用域插槽使用方法</h2>\n<p>在调用时通过增加一个 slot-scope属性 拿到子组件slot上 v-bind的所有属性。</p>\n<pre><code class=\"language-html\">&lt;base-layout&gt;\n  &lt;template v-slot:slotA=&quot;slotProps&quot;&gt; \n  &lt;!-- 上面是语法糖等价于 &lt;template slot=&quot;slotA&quot; slot-scope=&quot;slotProps&quot;&gt; --&gt;\n    &lt;h1&gt;Here might be a page title {{slotProps.user}}&lt;/h1&gt;\n  &lt;/template&gt;\n\n  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n&lt;/base-layout&gt;</code></pre>\n<p>base-layout子组件实现时，将需要给出的属性v-bind到对应的slot，这样在父组件调用时，插槽内部就可以放到子组件内部的属性了，来看代码</p>\n<pre><code class=\"language-html\">&lt;!-- base-layout组件实现 --&gt;\n&lt;div&gt;\n  &lt;header&gt;\n    &lt;slot name=&quot;slotA&quot; v-bind:user=&quot;user&quot;&gt;&lt;/slot&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;slot&gt;&lt;/slot&gt;\n  &lt;/main&gt;\n&lt;/div&gt;</code></pre>\n<h2 id=\"v-slotaaa是slotaaa的语法糖\">v-slot:aaa是slot=&quot;aaa&quot;的语法糖</h2>\n<p>v-slot将slot和slot-scope简写为一个属性，且v-slot更符合vue的语法规则，来对比下</p>\n<pre><code class=\"language-html\">&lt;!-- base-layout组件调用 新的写法 --&gt;\n&lt;base-layout&gt;\n  &lt;!-- \n    通过template(不能是其他元素) 指定其子元素的内容放到name为slotA的插槽里\n    可以通过slotProps拿到slot位置bind的所有属性 \n  --&gt;\n  &lt;template v-slot:slotA=&quot;slotProps&quot;&gt;\n    &lt;h1&gt;Here might be a page title {{slotProps.user}}&lt;/h1&gt;\n  &lt;/template&gt;\n\n  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n&lt;/base-layout&gt;\n\n&lt;!-- base-layout组件调用 旧的写法 --&gt;\n&lt;base-layout&gt;\n  &lt;!-- \n    通过普通元素和template 指定其子元素的内容放到name为slotA的插槽里\n    可以通过slotProps拿到slot位置bind的所有属性 \n  --&gt;\n  &lt;div slot=&quot;slotA&quot; slot-scope=&quot;slotProps&quot;&gt;\n    &lt;h1&gt;Here might be a page title {{slotProps.user}}&lt;/h1&gt;\n  &lt;/div&gt;\n\n  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n&lt;/base-layout&gt;</code></pre>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md\"> v-slot | vue rfcs</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/components-slots.html\">插槽 | Vue.js</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue为什么要将插槽slot=\"aaa\"的写法变更为v-slot:aaa",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "先来看看聚名插槽使用时的一个特殊场景"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "作用域插槽使用方法"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "v-slot:aaa是slot=\"aaa\"的语法糖"
            }
          ]
        }
      ],
      "config": {
        "source": "vue为什么要将插槽slot='aaa'的写法变更为v-slot:aaa.md",
        "staticFileName": "slot_vs_v-slot.html",
        "author": "guoqzuo",
        "createDate": "2020/08/15",
        "description": "vue slot v-slot区别,v-slot是slot的语法糖，在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除。具名插槽 主要用于当有多个插槽时，通过名字对不同的插槽进行区分，先来看看聚名插槽使用时的一个特殊场景，由于在父组件里调用用子组件，会写上对应的插槽，这时插槽的作用域为当前的父组件，插槽内部使用的变量名默认都是从父组件取的。下面的例子中 slotA插槽内部调用的 user，它默认是当前组件的变量（父组件）",
        "keywords": "vue slot v-slot区别,v-slot是slot的语法糖",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue组件之间传值通信方式总结\">vue组件之间传值(通信)方式总结</h1>\n<p>在vue中一般组件之间传值是必须要理解的，下面来总结下组件间传值的方法，分为以下几种情况</p>\n<ol>\n<li>父组件 =&gt; 子组件</li>\n<li>子组件 =&gt; 父组件</li>\n<li>兄弟组件</li>\n<li>父组件 =&gt; 子组件</li>\n<li>祖先和后代之间</li>\n<li>任意两个组件之间</li>\n</ol>\n<h2 id=\"父组件--子组件\">父组件 =&gt; 子组件</h2>\n<ul>\n<li><p>props</p>\n<pre><code class=\"language-js\">// child\nprops: { msg: string }\n\n// parent\n&lt;hello-word msg=&quot;xxxx&quot; /&gt;</code></pre>\n</li>\n<li><p>引用refs</p>\n<pre><code class=\"language-js\">// parent\n&lt;hellow-word ref=&quot;hw&quot; /&gt;\n\nthis.$refs.hw.xx</code></pre>\n</li>\n</ul>\n<h2 id=\"子组件--父组件\">子组件 =&gt; 父组件</h2>\n<pre><code class=\"language-js\">// child\nthis.$emit(&#39;add&#39;, &#39;val&#39;)\n\n// parent\n&lt;hello-word @add=&quot;cartAdd($event)&quot; /&gt;</code></pre>\n<h2 id=\"兄弟组件\">兄弟组件</h2>\n<p>通过共同的祖辈组件(<code>$parent</code>或<code>$root</code>) 利用vue内置的发布订阅模式功能</p>\n<pre><code class=\"language-js\">// brother1\nthis.$parent.$on(&#39;foo&#39;, handle)\n// brother2\nthis.$parent.$emit(&#39;foo&#39;)</code></pre>\n<h2 id=\"祖先和后代之间\">祖先和后代之间</h2>\n<h3 id=\"provide--inject-祖先给后代传值\">provide / inject 祖先给后代传值</h3>\n<pre><code class=\"language-js\">// 祖先组件\nprovide() {\n    return { foo: &#39;foo&#39;}  // 要像data一样，用函数包裹\n}\n\n// 后代组件\ninject: [&#39;foo&#39;]</code></pre>\n<h3 id=\"dispatch：后代给祖先传值\">dispatch：后代给祖先传值</h3>\n<pre><code class=\"language-js\">function dispatch(eventName, data) {\n    let parent = this.$parent\n    // 只要还存在父元素就继续往上找\n    while (parent) {\n        // 父元素用$emit触发\n        parent.$emit(eventName, data)\n        // 继续传给上一层父元素\n        parent = parent.$parent\n    }\n}</code></pre>\n<h2 id=\"任意两个组件之间：事件总线bus或vuex\">任意两个组件之间：事件总线(Bus)或vuex</h2>\n<pre><code class=\"language-js\">// vue组件自身实现了发布订阅模式\n// Bus.js\nexport default new Vue()\n\n// A组件\nimport Bus from &#39;Bus&#39;\nBus.$on(&#39;foo&#39;, handle)\n// B组件\nimport Bus from &#39;Bus&#39;\nBus.$emit(&#39;foo&#39;, &#39;val&#39;)</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue组件之间传值(通信)方式总结",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "父组件 => 子组件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "子组件 => 父组件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "兄弟组件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "祖先和后代之间",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "provide / inject 祖先给后代传值"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "dispatch：后代给祖先传值"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "任意两个组件之间：事件总线(Bus)或vuex"
            }
          ]
        }
      ],
      "config": {
        "source": "vue组件之间传值(通信)方式总结.md",
        "staticFileName": "vue_comp_transmit.html",
        "author": "guoqzuo",
        "createDate": "2020/08/15",
        "description": "vue组件之间传值,vue传值方式,vue传值方式总结,vue通信方式总结,在vue中一般组件之间传值是必须要理解的，下面来总结下组件间传值的方法，分为以下几种情况 1. 父组件 => 子组件 2. 子组件 => 父组件 3. 兄弟组件 4. 父组件 => 子组件 5. 祖先和后代之间 6. 任意两个组件之间",
        "keywords": "vue组件之间传值,vue传值方式,vue传值方式总结,vue通信方式总结",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue里简单的总线bus发布订阅模式实现\">vue里简单的总线(bus)发布订阅模式实现</h1>\n<p>在vue组件内部有实现发布订阅模式，类似于bus，在兄弟组件或任意两组件之间传值可以使用这种方法，代码如下</p>\n<h2 id=\"vue内部发布订阅模式使用场景\">vue内部发布订阅模式使用场景</h2>\n<pre><code class=\"language-js\">// 兄弟组件之间\n// brother1\nthis.$parent.$on(&#39;foo&#39;, handle)\n// brother2\nthis.$parent.$emit(&#39;foo&#39;) \n\n\n// 任意两组间之间\n// Bus.js\nexport default new Vue()\n\n// A组件\nimport Bus from &#39;Bus&#39;\nBus.$on(&#39;foo&#39;, handle)\n// B组件\nimport Bus from &#39;Bus&#39;\nBus.$emit(&#39;foo&#39;, &#39;val&#39;) </code></pre>\n<h2 id=\"自己实现一个发布订阅\">自己实现一个发布订阅</h2>\n<p>那内部是怎么实现的呢？我们先写一个调用demo，如下</p>\n<pre><code class=\"language-js\">// main.js\nimport Bus from &#39;Bus.js&#39;\nVue.prototype.$bus = new Bus()\n\n// child1\nthis.$bus.$on(&#39;foo&#39;, handle)\n// child2\nthis.$bus.$emit(&#39;foo&#39;)</code></pre>\n<p>再来写Bus.js实现简单的发布订阅</p>\n<pre><code class=\"language-js\">class Bus {\n  constructor() {\n    this.callbacks = {}\n  }\n  $on(name, fn) {\n    // 如果之前没有监听，就创建一个新的数组\n    !this.callbacks[name] &amp;&amp; (this.callbacks[name] = [])\n    typeof fn === &#39;function&#39; &amp;&amp; this.callbacks[name].push(fn)\n  }\n  $emit(name, args) {\n    if (this.callbacks[name]) {\n      this.callbacks[name].forEach(cb =&gt; cb(args))\n    }\n  }\n  $off(name, fn) {\n    if (this.callbacks[name]) {\n      // 如果没传fn， 移除所有，如果传了移除对应的函数，这里只做移除素有的\n      this.callbacks[name] = undefined // 讲思路\n    }\n  } \n} \n\nexport default Bus</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue里简单的总线(bus)发布订阅模式实现",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "vue内部发布订阅模式使用场景"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "自己实现一个发布订阅"
            }
          ]
        }
      ],
      "config": {
        "source": "vue里简单的总线(bus)发布订阅模式实现.md",
        "staticFileName": "vue_on_emit.html",
        "author": "guoqzuo",
        "createDate": "2020/08/15",
        "description": "vue publish/subscription,vue发布订阅模式实现,vue bus发布订阅实现, 在vue组件内部有实现发布订阅模式，类似于bus，在兄弟组件或任意两组件之间传值可以使用这种方法，那内部是怎么实现的呢？我们先写一个调用demo",
        "keywords": "vue publish/subscription,vue发布订阅模式实现,vue bus发布订阅实现",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue项目文件以及文件夹命名规范问题，前端代码规范风格指南\">vue项目文件以及文件夹命名规范问题，前端代码规范风格指南</h1>\n<p>在以vue为主的开发中，vue项目文件以及文件夹命名规范文件，在开发团队里面是需要统一的。我们尽量按照一种规范来开发，形成一种风格，这样更有利于项目迭代维护，下面来逐一介绍</p>\n<h2 id=\"个人总结的vue功能组件、目录结构风格\">个人总结的vue功能组件、目录结构风格</h2>\n<pre><code class=\"language-js\">// 新建文件夹，命名以小写字母开头，驼峰命名\n- moduleA // 模块A目录\n  - comps // 组件目录\n    - CustomerRefuse.vue // 单文件组件命名规则，参考vue风格指南\n    // 如果组件内容较多，创建一个文件夹\n    // 命名以npm包命名规则一致，全小写、-分隔，建议不超过3个单词\n    - no-permission\n      - src // 其他资源目录，参考Element组件源码\n      - index.vue // 入口或者使用index.js 方便 Vue.use 引入\n  - index.vue // 模块A入口</code></pre>\n<h2 id=\"业界较权威的风格指南\">业界较权威的风格指南</h2>\n<p>Vue、HTML、JS、CSS编码风格，可以看看下面比较好的风格指南：</p>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/style-guide/\">Vue风格指南</a></li>\n<li><a href=\"https://codeguide.bootcss.com/\">Bootstrap 编码规范: 编写一致、灵活和可持续的 HTML 和 CSS 代码的规范。</a></li>\n<li><a href=\"http://google.github.io/styleguide/jsguide.html\">Google JavaScript Style Guide</a></li>\n<li><a href=\"https://github.com/airbnb/javascript\">Airbnb JS风格指南</a></li>\n</ul>\n<h2 id=\"其他风格\">其他风格</h2>\n<p>当然你也可以使用其他风格，下面是在网上找了一个看起来还算靠谱的命名规则：</p>\n<ul>\n<li>文件或文件夹的命名遵循以下原则： 单文件组件文件名 <strong>要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。</strong></li>\n<li>index.js 或者 index.vue，统一使用小写字母开头的(kebab-case)命名规范</li>\n<li>属于组件或类的，统一使用大写字母开头的(PascalCase)命名规范</li>\n<li>其他非组件或类的，统一使用小写字母开头的(kebab-case)命名规范</li>\n</ul>\n<p>参考 <a href=\"https://www.cnblogs.com/mouseleo/p/11484550.html\">Vue项目中的文件/文件夹命名规范</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue项目文件以及文件夹命名规范问题，前端代码规范风格指南",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "个人总结的vue功能组件、目录结构风格"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "业界较权威的风格指南"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "其他风格"
            }
          ]
        }
      ],
      "config": {
        "source": "vue项目文件以及文件夹命名规范问题，前端代码规范风格指南.md",
        "staticFileName": "vue_code_style.html",
        "author": "guoqzuo",
        "createDate": "2020/08/15",
        "description": "vue代码规范,vue命名规范,vue组件命名,前端代码规范,前端代码风格指南,vue代码风格指南,vue文件命名,在以vue为主的开发中，vue项目文件以及文件夹命名规范文件，在开发团队里面是需要统一的。我们尽量按照一种规范来开发，形成一种风格，这样更有利于项目迭代维护，下面来逐一介绍：1.个人总结的vue功能组件、目录结构风格 2.业界较权威的风格指南 3.其他风格",
        "keywords": "vue代码规范,vue命名规范,vue组件命名,前端代码规范,前端代码风格指南,vue代码风格指南,vue文件命名",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue为什么建议永远不要把-v-if-和-v-for-同时用在同一个元素上\">vue为什么建议永远不要把 v-if 和 v-for 同时用在同一个元素上</h1>\n<p>在vue风格指南中，将&quot;避免 v-if 和 v-for 用在一起&quot;列为必要优先级，建议永远不要把 v-if 和 v-for 同时用在同一个元素上。官网文档如下: </p>\n<blockquote>\n<p>一般我们在两种常见的情况下会倾向于这样做：</p>\n<ol>\n<li>为了过滤一个列表中的项目 (比如 v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;)。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。</li>\n<li>为了避免渲染本应该被隐藏的列表 (比如 v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;)。这种情形下，请将 v-if 移动至容器元素上 (比如 ul、ol)。</li>\n</ol>\n</blockquote>\n<p>实际运行时v-for 比 v-if 优先级高，来看个例子</p>\n<pre><code class=\"language-html\">&lt;ul&gt;\n  &lt;li\n    v-for=&quot;user in users&quot;\n    v-if=&quot;user.isActive&quot;\n    :key=&quot;user.id&quot;\n  &gt;\n    {{ user.name }}\n  &lt;/li&gt;\n&lt;/ul&gt;</code></pre>\n<p>将进行如下计算，<strong>其实显示是正常的，但v-for会遍历所有的元素，哪怕我们只想通过v-if渲染出少部分元素</strong>，渲染逻辑里，每次重新渲染的时候都会遍历整个列表，并判断是否需要显示</p>\n<pre><code class=\"language-js\">this.users.map(function (user) {\n  if (user.isActive) {\n    return user.name\n  }\n})</code></pre>\n<p>这种情况，建议使用 computed属性过滤需要显示的数组，这样渲染逻辑理就不用再加v-if判断了</p>\n<pre><code class=\"language-js\">computed: {\n  activeUsers: function () {\n    return this.users.filter(function (user) {\n      return user.isActive\n    })\n  }\n}</code></pre>\n<p>在实际的使用场景中，如果渲染逻辑需要使用v-if过滤的情况，都可以尝试先考虑是否能使用computed属性代替，让渲染时只用考虑数据，不需要考虑逻辑。即 <code>渲染 + 判断逻辑 + 数据</code> =&gt; <code>渲染 + 数据</code></p>\n<p>参考：<a href=\"https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BF%85%E8%A6%81\">避免-v-if-和-v-for-用在一起必要 | Vue.js</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue为什么建议永远不要把 v-if 和 v-for 同时用在同一个元素上"
        }
      ],
      "config": {
        "source": "vue为什么建议永远不要把 v-if 和 v-for 同时用在同一个元素上.md",
        "staticFileName": "v-if_v-for.html",
        "author": "guoqzuo",
        "createDate": "2020/08/15",
        "description": "vue v-if为什么不能和v-for一起用,vue v-if v-for一起用,vue v-if和v-for一起时优先级,在vue风格指南中，将'避免 v-if 和 v-for 用在一起'列为必要优先级，建议永远不要把 v-if 和 v-for 同时用在同一个元素上。官网文档如下: 一般我们在两种常见的情况下会倾向于这样做： 1. 为了过滤一个列表中的项目 (比如 v-for='user in users' v-if='user.isActive')。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。2. 为了避免渲染本应该被隐藏的列表 (比如 v-for='user in users' v-if='shouldShowUsers')。这种情形下，请将 v-if 移动至容器元素上 (比如 ul、ol)。",
        "keywords": "vue v-if为什么不能和v-for一起用,vue v-if v-for一起用,vue v-if和v-for一起时优先级",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"less使用mixin抽取css公共代码，减少重复代码\">less使用mixin抽取css公共代码，减少重复代码</h1>\n<p>由于没有系统的学习less，之前只用到less的嵌套写法，很少用变量，基本没用mixin模块化封装，这次尝试了下，发现还是不错的，下面来用封装一个基础的布局组件，主要涉及三个知识点</p>\n<ol>\n<li>把css单独提成文件使用 @import (reference) url(&#39;&#39;) 引入</li>\n<li>封装mixin函数，在需要引入的地方执行函数</li>\n<li>使用 @headerHeight: 100px 这种方法定义变量</li>\n</ol>\n<p>示例如下，完成代码：<a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/views/lessMixinTest\">less mixin封装测试 | github</a></p>\n<pre><code class=\"language-html\">&lt;!-- pageA --&gt;\n&lt;template&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;\n      &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;\n      &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {}\n&lt;/script&gt;\n\n&lt;style lang=&quot;less&quot; scoped&gt;\n@import (reference) url(&#39;./common/base.less&#39;);\n.container-mixin(); /* 调用base.less里面定义的mixin方法 */\n&lt;/style&gt;</code></pre>\n<p>common/base.less</p>\n<pre><code class=\"language-less\">.container-mixin() {\n  .container {\n    @headerHeight: 100px; /* 变量，顶部高度 */\n    .top {\n      height: @headerHeight;\n      background: #999;\n    }\n    .main {\n      display: flex;\n      height: calc(100vh - @headerHeight);\n      background-color: rgba(255, 0, 0, 0.2);\n      .left {\n        width: 20%;\n        background-color: greenyellow;\n      }\n      .right {\n        width: 80%;\n        background-color: turquoise;\n      }\n    }\n  }\n}</code></pre>\n<p>公共方法封装的好处在于，下次如果相同的页面，就不需要再写一遍了，虽然用class也可以，但less的mixin会更加强大，灵活，他还可以传参数，我们在页面B引入时，可以对默认样式进行修改</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;\n      &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;\n      &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {}\n&lt;/script&gt;\n\n&lt;style lang=&quot;less&quot; scoped&gt;\n@import (reference) url(&#39;./common/base.less&#39;);\n.container-mixin();\n// 引入公共样式后，再修改部分公共的样式\n.container {\n  .top {\n    background: red;\n  }\n}\n&lt;/style&gt;</code></pre>\n<p>上面的例子中使用 (reference) 是为了防止在不同的组件中引入导致公共代码多次打包问题</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "less使用mixin抽取css公共代码，减少重复代码"
        }
      ],
      "config": {
        "source": "less使用mixin抽取css公共代码，减少重复代码.md",
        "staticFileName": "less_mixin.html",
        "author": "guoqzuo",
        "createDate": "2020/08/22",
        "description": "less函数,less mixin实例,less mixin,less封装css,less怎么抽取公共样式,less抽取公共样式，由于没有系统的学习less，之前只用到less的嵌套写法，很少用变量，基本没用mixin模块化封装，这次尝试了下，发现还是不错的，下面来用封装一个基础的布局组件，主要涉及三个知识点 1. 把css单独提成文件使用 @import (reference) url('') 引入 2. 封装mixin函数，在需要引入的地方执行函数 3. 使用 @headerHeight: 100px 这种方法定义变量",
        "keywords": "less函数,less mixin实例,less mixin,less封装css,less怎么抽取公共样式,less抽取公共样式",
        "category": "CSS",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"什么情况下-a--1--a--2，什么情况-a--1--a--2\">什么情况下 a == 1 &amp;&amp; a == 2，什么情况 a + 1 === a + 2</h1>\n<p>在js面试时，有时候会考察 ==（比较运算符）隐式转换的问题，问  a == 1 &amp;&amp; a == 2 怎么使他成立，这个有好几种方法。还有一种情况下 a + 1 全等于 a + 2，这就涉及到最大安全整数的问题了，下面来具体看看</p>\n<h2 id=\"什么情况下a--1--a--2为true\">什么情况下a == 1 &amp;&amp; a == 2为true</h2>\n<p>有两种方法可以实现，一是使用对象隐式转换的方法，二是使用对象的defineProperty定义get访问器属性</p>\n<h3 id=\"对象的tostring或valueof方法\">对象的toString或valueOf方法</h3>\n<p>对象与数字比较，转字符串比较，会调用对象的toString/valueOf方法，把toString或valueOf函数处理下即可，在chrome浏览器的console里，两种函数都可以</p>\n<pre><code class=\"language-js\">var a = { \n  count: 1, \n  toString() { \n    return this.count++ \n  }\n}\na == 1 &amp;&amp; a == 2 // true</code></pre>\n<pre><code class=\"language-js\">var a = { \n  count: 1, \n  valueOf() { \n    return this.count++ \n  }\n}</code></pre>\n<h3 id=\"使用objectdefineproperty设置get访问器属性\">使用Object.defineProperty设置get访问器属性</h3>\n<p>可以为对象定义访问器属性(get)，访问该对象的属性时，就会直接调用get函数，在get函数做一些处理也可以实现</p>\n<pre><code class=\"language-js\">var a = {\n  count: 1\n}\nObject.defineProperty(a, &#39;prop&#39;, {\n  get() {\n    return this.count++\n  }\n})\na.prop == 1 &amp;&amp; a.prop == 2</code></pre>\n<p>参考：<a href=\"https://blog.csdn.net/qq_41569151/article/details/100147805\">js面试题：a==1&amp;&amp;a==2&amp;&amp;a=3的两个思路</a></p>\n<h2 id=\"a--1--a--2-为true的情况，注意是全等\">a + 1 === a + 2 为true的情况，注意是全等</h2>\n<p>注意这里是全等。我现在了解的有两种情况：Infinity、或最大安全整数Number.MAX_SAFE_INTEGER</p>\n<pre><code class=\"language-js\">// 1. Infinity\nvar a = Infinity // Infinity是这个神奇的数，我试了下除了 * 0等于NAN外，其他情况基本都等于他自己\na + 1 === a + 2 // true\n\n// 2. Math.pow(2, 53) - 1 最大的安全整数\nNumber.MAX_SAFE_INTEGER === Math.pow(2, 53) -1 // true\na = Number.MAX_SAFE_INTEGER\na + 1 === a + 2 // true</code></pre>\n<p>以上，当大于2的53次方-1时，就不安全了，结果会超出常规，ES2020引入了bigint来处理大于2的53次方-1的数据</p>\n<pre><code class=\"language-js\">// bigint类型的数与n结尾\na = BigInt(Number.MAX_SAFE_INTEGER) // 9007199254740991n\na + 1n // 9007199254740992n\na + 2n // 9007199254740993n</code></pre>\n<p>参考：<a href=\"http://www.zuo11.com/blog/2019/12/bigint.html\">ES2020 bigint数据类型，为什么要新增这个数据类型?</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "什么情况下 a == 1 && a == 2，什么情况 a + 1 === a + 2",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "什么情况下a == 1 && a == 2为true",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "对象的toString或valueOf方法"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "使用Object.defineProperty设置get访问器属性"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "a + 1 === a + 2 为true的情况，注意是全等"
            }
          ]
        }
      ],
      "config": {
        "source": "什么情况下 a == 1 && a == 2，什么情况 a + 1 === a + 2.md",
        "staticFileName": "js_a1_a2.html",
        "author": "guoqzuo",
        "createDate": "2020/08/22",
        "description": "a == 1 && a == 2,a == 1 && a == 2 && a == 3,a + 1 === a + 2,在js面试时，有时候会考察 ==（比较运算符）隐式转换的问题，问  a == 1 && a == 2 怎么使他成立，这个有好几种方法。还有一种情况下 a + 1 全等于 a + 2，这就涉及到最大安全整数的问题了，下面来具体看看",
        "keywords": "a == 1 && a == 2,a == 1 && a == 2 && a == 3,a + 1 === a + 2",
        "category": "JavaScript",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"h5原生拖放drag-and-dropdemo以及浏览器兼容性处理\">H5原生拖放(Drag and Drop)demo以及浏览器兼容性处理</h1>\n<p>一般在网页中，如果需要实现拖放，首先要有两个元素</p>\n<ol>\n<li>可拖动的元素，元素draggable=&quot;true&quot;属性就是可拖放，如果设置为false就是不可拖放</li>\n<li>可以放置的区域，注意chrome如果不将放置区域的onenter和onover事件阻止默认行为，无法触发drop函数</li>\n</ol>\n<p><img src=\"../../../images/blog/js/js_drag_1.png\" alt=\"js_drag_1.png\"></p>\n<h2 id=\"拖放的过程中的钩子\">拖放的过程中的钩子</h2>\n<ol>\n<li>拖动元素时，会触发元素的 dragstart 钩子函数，在函数里可以设置数据、以及拖动到放置区域的鼠标样式</li>\n<li>当拖动元素进入放置区域时，放置区域元素会触发一次dragenter钩子(拖动进入)，触发多次dragover(拖动元素在放置区域移动中)，放下时再触发放置元素的drop钩子，这里可以用来接收拖拽元素dragstart设置的data，处理拖动的行为</li>\n</ol>\n<h2 id=\"注意事项：浏览器兼容性处理\">注意事项：浏览器兼容性处理</h2>\n<ol>\n<li><p>在Chrome中，放置区域的ondrop事件不触发，需要在onenter和onover事件里阻止默认行为（火狐不需要这样处理）</p>\n</li>\n<li><p>event.dataTransfer.effectAllowed只能设置鼠标样式，不能设置拖动元素行为，drag后之前的元素会消失，想要保留需要使用cloneNode来操作</p>\n</li>\n</ol>\n<pre><code class=\"language-js\">// 放置后，删除原来的图片\n// ev.target.appendChild(document.querySelector(`#${reciveData}`))\n// 放置后，保留原图片\nev.target.appendChild(document.querySelector(`#${reciveData}`).cloneNode(true))</code></pre>\n<ol start=\"3\">\n<li>在Firefox（火狐）浏览器里drop图片后，会新在新的tab也打开图片，不仅要在drop里阻止默认行为，还要阻止事件冒泡</li>\n</ol>\n<h2 id=\"demo实例\">demo实例</h2>\n<p>demo如下，demo <a href=\"https://zuoxiaobai.github.io/fedemo/src/DebugDemo/%E6%8B%96%E5%8A%A8%E5%9B%BE%E7%89%87demo/\">在线体验地址</a>，demo <a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/%E6%8B%96%E5%8A%A8%E5%9B%BE%E7%89%87demo/index.html\">github源码</a></p>\n<p><img src=\"../../../images/blog/js/js_drag_2.png\" alt=\"js_drag_2.png\"></p>\n<pre><code class=\"language-html\">&lt;!-- 图片默认的 draggable=&quot;true&quot; 而想 h1这种默认为false不可拖动 --&gt;\n&lt;img id=&quot;img&quot; src=&quot;test.png&quot; &gt;\n&lt;!-- 放置区域a --&gt;\n&lt;div class=&quot;wrap&quot; id=&quot;targetA&quot;&gt;&lt;/div&gt;\n\n&lt;script&gt;\n// 被拖动元素的事件监听\nlet img = document.getElementById(&#39;img&#39;)\n// 当元素开始拖动时触发，仅触发一次\nimg.addEventListener(&#39;dragstart&#39;, (ev) =&gt; {\n  // 设置值，在放置区域触发drop事件时，可以通过ev.dataTransfer.getData获取这里的值\n  ev.dataTransfer.setData(&quot;text&quot;, ev.target.id)\n  // link 会影响拖动到放置区域的鼠标样式，只是样式，并不决定行为 \n  ev.dataTransfer.effectAllowed = &#39;copy&#39;; \n})\n\n// 放置区域A的事件监听\nlet targetA = document.getElementById(&#39;targetA&#39;)\n// 当有拖动元素(放到)落到放置区域时触发，一次\ntargetA.addEventListener(&#39;drop&#39;, (ev) =&gt; {\n  ev.stopPropagation(); // 必要，阻止冒泡，防止火狐浏览器放置图片后打开新的窗口\n  ev.preventDefault(); // 必要，阻止默认行为 防止火狐浏览器放置后直接打开图片\n\n  // 放置落下时，接收被拖拽的元素在 dragstart时用ev.dataTransfer.setData设置的值\n  // 这里传的id备用\n  let reciveData = ev.dataTransfer.getData(&quot;text&quot;)\n  console.log(&#39;drop, recive data&#39;, reciveData, ev.dataTransfer.dropEffect)\n\n  // 必要，设置拖动后放置的效果，移动还是copy\n  // 放置后，删除原来的图片\n  // ev.target.appendChild(document.querySelector(`#${reciveData}`))\n  // 放置后，保留原图片\n  ev.target.appendChild(document.querySelector(`#${reciveData}`).cloneNode(true))\n\n  ev.target.classList.remove(&#39;active&#39;) // 必要，放置在区域里后，还原样式\n})\n\n// 当拖动元素移动到放置区域时触发，触发多次\ntargetA.addEventListener(&#39;dragover&#39;, (ev) =&gt; {\n  ev.preventDefault() // 必要，chrome drop兼容必须\n})\n// 当拖动元素进入放置区域时触发，一次\ntargetA.addEventListener(&#39;dragenter&#39;, (ev) =&gt; {\n  ev.preventDefault() // 必要，chrome drop兼容必须\n  ev.target.classList.add(&#39;active&#39;) // 必要，设置进入时的样式\n})\n  // 当拖动元素离开放置区域时触发，一次\ntargetA.addEventListener(&#39;dragleave&#39;, (ev) =&gt; {\n  ev.target.classList.remove(&#39;active&#39;) // 必要，设置离开后的样式\n})\n&lt;/script&gt;</code></pre>\n<h2 id=\"参考资料文档\">参考资料文档</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API\">HTML 拖放 API - Web API 接口参考 | MDN</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000011761601/\">dataTransfer.setData无效，drop不触发的问题</a></li>\n<li><a href=\"https://www.cnblogs.com/liulei-cherry/p/8440609.html\">火狐drop后会打开新tab的问题</a></li>\n<li><a href=\"https://zhidao.baidu.com/question/1449513599728916460.html\">js 拖动后,怎么保持原来的元素不消失，drop后拖动元素消失的问题</a></li>\n<li><a href=\"https://www.yuque.com/guoqzuo/js_es6/hoglme\">cloneNode | JS高程3笔记</a></li>\n</ul>\n<p>扩展：</p>\n<ul>\n<li><a href=\"https://www.yuque.com/guoqzuo/js_es6/nocthb#bdcc30d7\">从电脑拖放文件到浏览器，读取拖拽文件并上传 | JS高程3笔记</a></li>\n<li><a href=\"https://www.yuque.com/guoqzuo/js_es6/aquxsq#eeddf2fd\">非H5原生拖放实现拖放 | JS高程3笔记</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "H5原生拖放(Drag and Drop)demo以及浏览器兼容性处理",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "拖放的过程中的钩子"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "注意事项：浏览器兼容性处理"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "demo实例"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考资料文档"
            }
          ]
        }
      ],
      "config": {
        "source": "H5原生拖放(Drag and Drop)demo以及浏览器兼容性处理.md",
        "staticFileName": "js_drag_drop.html",
        "author": "guoqzuo",
        "createDate": "2020/08/22",
        "description": "js拖拽,原生js拖放,js拖放,js拖放浏览器兼容性,HTML5 拖放,dragstart,drop,一般在网页中，如果需要实现拖放，首先要有两个元素：1. 可拖动的元素，元素draggable='true' 属性就是可拖放，如果设置为false就是不可拖放 2. 可以放置的区域，注意chrome如果不将放置区域的onenter和onover事件阻止默认行为，无法触发drop函数。拖放的过程中的钩子 1. 拖动元素时，会触发元素的 dragstart 钩子函数，在函数里可以设置数据、以及拖动到放置区域的鼠标样式 2. 当拖动元素进入放置区域时，放置区域元素会触发一次dragenter钩子(拖动进入)，触发多次dragover(拖动元素在放置区域移动中)，放下时再触发放置元素的drop钩子，这里可以用来接收拖拽元素dragstart设置的data，处理拖动的行为",
        "keywords": "js拖拽,原生js拖放,js拖放,js拖放浏览器兼容性,HTML5 拖放,dragstart,drop",
        "category": "JavaScript",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"怎么解决sessionstorage新打开一个tab页就失效的问题\">怎么解决sessionStorage新打开一个tab页就失效的问题</h1>\n<p>首页我们要知道3点：</p>\n<ol>\n<li>sessionStorage在浏览器的两个tab页之前是无法共享的，一个tab页中sessionStorage修改后，不能触发其他tab页的storage事件</li>\n<li>当前tab页的localStorage修改是无法触发当前页的storage事件的，他会触发其他tab页的storage事件</li>\n<li>localStorage的共享，只发生在同源的地址里。非同源无法共享localStorage</li>\n</ol>\n<p>怎么将就页面的sessionStorage传递到新开的tab页呢？</p>\n<p>由于sessionStorage打开新tab页默认会丢失。那新开tab页的sessionStorage就是空的。我们可以判断，如果sessionStorage.length值为0，那么就是新开的页面。这时我们通过设置一个localStorage字段的值，触发之前打开页面的Storage事件，在这个事件里我们将当前页面的sessionStorage通过localStorage设置值，来触发新页面的Storage事件，把sessionStorage传递到新的页面</p>\n<p>下面是部分核心代码，详细demo参见 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/views/sessionFailureNewTabTest\">github demo地址</a></p>\n<pre><code class=\"language-html\">&lt;script&gt;\nimport NewTabSessionShare from &quot;./newTabSessionShare&quot;;\nexport default {\n  data() {\n    return {\n      alreadyCheck: false\n    };\n  },\n  created() {\n    this.alreadyCheck = sessionStorage.getItem(&quot;TEST_alreadyCheck&quot;) === &quot;true&quot;;\n    NewTabSessionShare.init(() =&gt; {\n      this.alreadyCheck =\n        sessionStorage.getItem(&quot;TEST_alreadyCheck&quot;) === &quot;true&quot;;\n    });\n  }\n}</code></pre>\n<p>newTabSessionShare.js</p>\n<pre><code class=\"language-js\">class NewTabSessionShare {\n  constructor() {}\n\n  static init(cb) {\n    let tempFields = &quot;TEST_tempEmit&quot;;\n\n    window.addEventListener(&quot;storage&quot;, event =&gt; {\n      console.log(event);\n      // 由于每个页面都会触发该事件，我们需要判断当前页是新开的tab页，还是旧的\n      // 如果是新开的tab页，负责接收localStorage.getItem(&#39;sessionStorage&#39;) 并删除\n      // 如果是旧的tab页，负责写入localStorage.setItem(&#39;sessionStorage&#39;)\n\n      // 旧的tab页接收到事件时，key会是tempFields\n      if (event.key === tempFields) {\n        console.log(&quot;接收到新tab页打开时触发的消息&quot;);\n        // 触发新tab页的storage事件，传递当前页的sessioinStorage事件\n        localStorage.setItem(&quot;sessionStorage&quot;, JSON.stringify(sessionStorage));\n        // 清除localStorage\n        localStorage.removeItem(&quot;sessionStorage&quot;);\n        // 这里会触发两次新tab页的storage事件\n        // 1. newValue: &quot;{&quot;TEST_alreadyCheck&quot;:&quot;true&quot;}&quot;  oldValue: null\n        // 2. newValue: null oldValue: &quot;{&quot;TEST_alreadyCheck&quot;:&quot;true&quot;}&quot;\n      } else if (event.key === &quot;sessionStorage&quot;) {\n        console.log(\n          &quot;新tab页接收到老tab页，设置的localStorage，接收并删除&quot;,\n          localStorage.getItem(&quot;sessionStorage&quot;)\n        );\n        // 新打开窗口如果newValue的值不为null，那就是旧tab页将其sessionStorage传递到了当前页\n        // 然后，将传过来的数据原封不动的设置到当前页\n        if (event.newValue !== null) {\n          let data = JSON.parse(event.newValue);\n          for (let key in data) {\n            sessionStorage.setItem(key, data[key]);\n          }\n          typeof cb === &quot;function&quot; &amp;&amp; cb();\n        }\n      }\n    });\n\n    // 如果是新开的tab页，那么sessoinStorage为空\n    if (!sessionStorage.length) {\n      // 通过触发其他页面的storage事件，来读取之前页面的sessionStorage并传递到当前页\n      localStorage.setItem(tempFields, Date.now());\n    }\n  }\n}\n\nexport default NewTabSessionShare;\n</code></pre>\n<p>参考</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/web-chuan/p/9335311.html\">新开一个tab页，页面sessionStorage失效的问题</a></li>\n<li><a href=\"https://www.yuque.com/guoqzuo/js_es6/sp2k81#70400d01\">storage事件 JS高程3笔记</a></li>\n<li><a href=\"https://zuoxiaobai.github.io/fedemo/src/JS_ES6/JS%E9%AB%98%E7%A8%8B3/%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/storage.html\">storage demo示例，同时在两个tab页中打开该页面，console里设置localStorage试试</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "怎么解决sessionStorage新打开一个tab页就失效的问题"
        }
      ],
      "config": {
        "source": "怎么解决sessionStorage新打开一个tab页就失效的问题.md",
        "staticFileName": "sessionStorage_loss.html",
        "author": "guoqzuo",
        "createDate": "2020/08/22",
        "description": "sessionStorage新打开一个tab页就失效,sessionStorage打开新tab丢失,首页我们要知道3点：1. sessionStorage在浏览器的两个tab页之前是无法共享的，一个tab页中sessionStorage修改后，不能触发其他tab页的storage事件 2. 当前tab页的localStorage修改是无法触发当前页的storage事件的，他会触发其他tab页的storage事件 3. localStorage的共享，只发生在同源的地址里。非同源无法共享localStorage 怎么将就页面的sessionStorage传递到新开的tab页呢？",
        "keywords": "sessionStorage新打开一个tab页就失效,sessionStorage打开新tab丢失",
        "category": "JavaScript",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"pinyin中文转拼音npm包在前端使用时的坑ie下js错误调试方法\">pinyin中文转拼音npm包在前端使用时的坑,IE下js错误调试方法</h1>\n<p>在很早之前node项目中就使用过这个npm包。这次由于Element table组件排序时，无法按照首字母排序，就引入了这个包。由于是单页面应用，import进来是没问题的，chrome里面正常。</p>\n<pre><code class=\"language-js\">import pinyin from &quot;pinyin&quot;;\n\nconsole.log(\n  pinyin(&quot;测试&quot;, {\n    style: pinyin.STYLE_NORMAL, // 设置拼音风格\n    heteronym: true\n  }).join(&quot;&quot;) \n);\n// ceshi</code></pre>\n<p>后面在IE11里出现了一个bug，就是页面路由不能正常加载，调了好久。最开始以为是路由层级的问题，调到怀疑人生，最后发现是 pinyin 这个包的问题，他在IE下无法正常加载，偶尔报错 &quot;函数错误&quot;，导致整个页面执行失败，路由无法加载。<strong>所以在遇到难调试的问题时，先把error的报错全部解决再调</strong>, 已经遇到好几次这种情况了</p>\n<h2 id=\"ie下调试js错误的方法\">IE下调试js错误的方法</h2>\n<p>IE下出现异常，console里是无法看到是哪个文件报错的，需要在F12里点击断点位置，选择遇到错误时停止，这样出现问题就会自动跳转到对应的位置</p>\n<p><img src=\"../../../images/blog/js/ie_jserror.png\" alt=\"ie_jserror.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "pinyin中文转拼音npm包在前端使用时的坑,IE下js错误调试方法",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "IE下调试js错误的方法"
            }
          ]
        }
      ],
      "config": {
        "source": "pinyin中文转拼音npm包在前端使用时的坑,IE下js错误调试方法.md",
        "staticFileName": "pinyin_ie.html",
        "author": "guoqzuo",
        "createDate": "2020/08/22",
        "description": "pinyin npm,前端中文转拼音,web中文转拼音,在很早之前node项目中就使用过这个npm包。这次由于Element table组件排序时，无法按照首字母排序，就引入了这个包。由于是单页面应用，import进来是没问题的，chrome里面正常。后面在IE11里出现了一个bug，就是页面路由不能正常加载，调了好久。最开始以为是路由层级的问题，调到怀疑人生，最后发现是 pinyin 这个包的问题，他在IE下无法正常加载，偶尔报错 '函数错误'，导致整个页面执行失败，路由无法加载。**所以在遇到难调试的问题时，先把error的报错全部解决再调**, 已经遇到好几次这种情况了",
        "keywords": "pinyin npm,前端中文转拼音,web中文转拼音",
        "category": "前端工程化",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-tabs标签页组件的坑，能不使用就不要使用\">vue tabs标签页组件的坑，能不使用就不要使用</h1>\n<p>最近项目中需要在一个页面中打开多个tab标签页，刚才是觉得element有现成的组件，觉得没啥问题，后面发现迭代维护新功能时真的是大坑。</p>\n<p>个人建议<strong>能不使用tab标签页的情况，就不要使用</strong>，下面来看看需要注意的地方</p>\n<p><img src=\"../../../images/blog/vue/vue_tabs_pit.png\" alt=\"vue_tabs_pit.png\"></p>\n<h2 id=\"不要使用el-tab-pane插槽\">不要使用el-tab-pane插槽</h2>\n<p>不要使用el-tabs里面el-tab-pane的插槽，如果是多个组件切换或加keep-alive钩子函数逻辑会比较怪，建议el-tabs只用来做顶部tab，内容切换自己控制，不要使用 el-tab-pane插槽写法</p>\n<pre><code class=\"language-html\">&lt;el-tabs v-model=&quot;activeName&quot; @tab-click=&quot;handleClick&quot;&gt;\n    &lt;el-tab-pane label=&quot;用户管理&quot; name=&quot;first&quot;&gt;用户管理&lt;/el-tab-pane&gt;\n    &lt;el-tab-pane label=&quot;配置管理&quot; name=&quot;second&quot;&gt;配置管理&lt;/el-tab-pane&gt;\n    &lt;el-tab-pane label=&quot;角色管理&quot; name=&quot;third&quot;&gt;角色管理&lt;/el-tab-pane&gt;\n    &lt;el-tab-pane label=&quot;定时任务补偿&quot; name=&quot;fourth&quot;&gt;定时任务补偿&lt;/el-tab-pane&gt;\n&lt;/el-tabs&gt;\n\n&lt;!-- 分开 --&gt;\n&lt;el-tabs v-model=&quot;activeName&quot; @tab-click=&quot;handleClick&quot;&gt;\n    &lt;el-tab-pane label=&quot;用户管理&quot; name=&quot;first&quot;&gt;&lt;/el-tab-pane&gt;\n    &lt;el-tab-pane label=&quot;配置管理&quot; name=&quot;second&quot;&gt;&lt;/el-tab-pane&gt;\n    &lt;el-tab-pane label=&quot;角色管理&quot; name=&quot;third&quot;&gt;&lt;/el-tab-pane&gt;\n    &lt;el-tab-pane label=&quot;定时任务补偿&quot; name=&quot;fourth&quot;&gt;&lt;/el-tab-pane&gt;\n&lt;/el-tabs&gt;\n&lt;!-- 使用动态组件切换tab内容--&gt;\n&lt;component :is=&quot;activeName&quot;&gt;&lt;/component&gt;</code></pre>\n<h2 id=\"同组件tab切换时使用watch\">同组件tab切换时使用watch</h2>\n<p>组件打开一次后，created已执行，再打开一个tab时，不会触发created或mounted，<strong>需要用watch监听prop传值的改变进行一些请求接口的初始化操作，如果组件还有子组件，也需要这样做，防止数据不刷新的问题</strong></p>\n<h2 id=\"刷新页面保存已打开tab列表\">刷新页面保存已打开tab列表</h2>\n<p>当刷新网页时，我们暂时没有保存已打开tabs记录，会回到首页。对于这种情况，如果产品需要就需要考虑了。</p>\n<h2 id=\"同组件tab来回切取消请求问题\">同组件tab来回切取消请求问题</h2>\n<p>点击一个tab后，如果请求比较慢，再点击另一个tab，数据可能会乱，<strong>注意tab切换时，取消发出的请求</strong></p>\n<h2 id=\"activated与watch同时触发避免多次请求\">activated与watch同时触发避免多次请求</h2>\n<p>使用keep-alive包裹组件，不同组件切换触发 activated 钩子，如果打开过一个详情页。在列表页再打开一个详情页，会同时触发 watch、activated，需要注意刷新逻辑，防止多次请求，需要用个变量来标记，只执行一次</p>\n<h2 id=\"同组件有表单时，建议只能打开一个\">同组件有表单时，建议只能打开一个</h2>\n<p>如果修改详情信息可以打开多个，那多个表单的数据肯定会串，很麻烦。最好一次只能打开一个修改页面，打开多个没必要。</p>\n<p>综上，看起来简单，其实后面逻辑越加越多时，会变的很不好维护，需要考虑的问题会比较多</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue tabs标签页组件的坑，能不使用就不要使用",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "不要使用el-tab-pane插槽"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "同组件tab切换时使用watch"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "刷新页面保存已打开tab列表"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "同组件tab来回切取消请求问题"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "activated与watch同时触发避免多次请求"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "同组件有表单时，建议只能打开一个"
            }
          ]
        }
      ],
      "config": {
        "source": "vue tabs标签页组件的坑，能不使用就不要使用.md",
        "staticFileName": "vue_tabs_pit.html",
        "author": "guoqzuo",
        "createDate": "2020/08/22",
        "description": "vue tabs标签页,vue 标签页,vue便签页的坑，最近项目中需要在一个页面中打开多个tab标签页，刚才是觉得element有现成的组件，觉得没啥问题，后面发现迭代维护新功能时真的是大坑。个人建议**能不使用tab标签页的情况，就不要使用**，下面来看看需要注意的地方",
        "keywords": "vue tabs标签页,vue 标签页,vue便签页的坑",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-element表单组件简单实现\">vue element表单组件简单实现</h1>\n<p>在写表单时，一般我们会用到el-form相关组件，那它内部是怎么实现的呢？下面我们来写个demo，尝试实现下。</p>\n<p><img src=\"../../../images/blog/vue/mock_el_form.png\" alt=\"mock_el_form.png\"></p>\n<h2 id=\"测试组件demo\">测试组件demo</h2>\n<p>先来写一个调用示例，把el-前缀换成z-，然后我们需要实现z-form, z-form-item, z-input组件</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;!-- /elementForm --&gt;\n  &lt;div&gt;\n    &lt;z-form ref=&quot;ruleForm&quot; v-model=&quot;form&quot; :rules=&quot;rules&quot;&gt;\n      {{ form }}\n      &lt;z-form-item label=&quot;姓名&quot; prop=&quot;name&quot;&gt;\n        &lt;z-input v-model=&quot;form.name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/z-input&gt;\n      &lt;/z-form-item&gt;\n      &lt;z-form-item label=&quot;电话&quot; prop=&quot;mobile&quot;&gt;\n        &lt;z-input v-model=&quot;form.mobile&quot; placeholder=&quot;请输入电话&quot;&gt;&lt;/z-input&gt;\n      &lt;/z-form-item&gt;\n      &lt;button @click=&quot;submitForm(&#39;ruleForm&#39;)&quot;&gt;提交&lt;/button&gt;\n      &lt;button @click=&quot;resetForm(&#39;ruleForm&#39;)&quot;&gt;重置&lt;/button&gt;\n    &lt;/z-form&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  components: {\n    ZInput: () =&gt; import(&quot;./ZInput&quot;),\n    ZFormItem: () =&gt; import(&quot;./ZFormItem&quot;),\n    ZForm: () =&gt; import(&quot;./ZForm&quot;)\n  },\n  data() {\n    return {\n      form: {\n        name: &quot;&quot;,\n        mobile: &quot;&quot;\n      },\n      rules: {\n        name: [\n          { required: true, message: &quot;请输入姓名&quot;, trigger: &quot;blur&quot; },\n          { min: 3, max: 5, message: &quot;长度在 3 到 5 个字符&quot;, trigger: &quot;blur&quot; }\n        ],\n        mobile: [{ required: true, message: &quot;请输入电话&quot;, trigger: &quot;change&quot; }]\n      }\n    };\n  },\n  methods: {\n    submitForm(formName) {\n      this.$refs[formName].validate(valid =&gt; {\n        console.log(&quot;valid&quot;, valid);\n        if (valid) {\n          alert(&quot;submit!&quot;);\n        } else {\n          console.log(&quot;error submit!!&quot;);\n        }\n      });\n    },\n    resetForm(formName) {\n      this.$refs[formName].resetFields();\n    }\n  }\n};\n&lt;/script&gt;</code></pre>\n<h2 id=\"表单组件的封装\">表单组件的封装</h2>\n<p>z-form, z-form-item, z-input</p>\n<h3 id=\"zinputvue\">ZInput.vue</h3>\n<ol>\n<li>双向绑定:@input、:value 派发校验事件</li>\n<li>派发校验事件</li>\n</ol>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;!-- \n      1. &lt;z-input v-model=&quot;searchForm.name&quot;&gt;&lt;/z-input&gt; 等价于\n      &lt;z-input :value=&quot;searchForm.name&quot; @input=&quot;searchForm.name = $event&quot;&gt;&lt;/z-input&gt;\n      虽然等价，区别是什么呢？v-model在输入法组合过程中不会更新值，而@input这种是会更新的，详情参见之前的笔记\n      2. v-bind=&quot;$attrs&quot; 接收z-input上的除props接收外设置的其它属性，比如placeholder等\n    --&gt;\n    &lt;input :value=&quot;value&quot; @input=&quot;oninput&quot; v-bind=&quot;$attrs&quot; /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  props: {\n    value: {\n      type: String,\n      required: true\n    }\n  },\n  methods: {\n    oninput(e) {\n      this.$emit(&quot;input&quot;, e.target.value); // 双向绑定\n      this.$parent.$emit(&quot;validate&quot;); // 触发父组件的校验\n    }\n  }\n};\n&lt;/script&gt;</code></pre>\n<h3 id=\"zformitemvue\">ZFormItem.vue</h3>\n<ol>\n<li>给Input预留插槽 </li>\n<li>slot 能够展示label和校验信息</li>\n<li>能够进行校验</li>\n</ol>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div class=&quot;z-form-item&quot;&gt;\n    &lt;div class=&quot;label&quot;&gt;{{ label }}:&lt;/div&gt;\n    &lt;div class=&quot;input&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;\n    &lt;div class=&quot;error&quot; v-if=&quot;errMsg&quot;&gt;{{ errMsg }}&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport Schema from &quot;async-validator&quot;;\nexport default {\n  inject: [&quot;form&quot;], // 从祖先组件接收searchForm传参\n  props: {\n    label: {\n      // 对应的标签名\n      type: String,\n      required: true,\n      default: &quot;&quot;\n    },\n    prop: {\n      // 对应的字段名\n      type: String\n    }\n  },\n\n  data() {\n    return {\n      errMsg: &quot;&quot; // 错误信息\n    };\n  },\n\n  mounted() {\n    // 当前组件监听validate事件，子组件通过$parent.$emit触发\n    this.$on(&quot;validate&quot;, () =&gt; {\n      this.validate();\n    });\n  },\n\n  methods: {\n    // 返回promise, 注意 asyc-validator的版本，需要是新的\n    validate() {\n      let value = this.form.model[this.prop];\n      let rules = this.form.rules[this.prop];\n      console.log(this.prop, value, rules);\n\n      let desc = { [this.prop]: rules };\n      let schema = new Schema(desc);\n      return schema.validate({ [this.prop]: value }, errors =&gt; {\n        if (errors) {\n          this.errMsg = errors[0].message;\n        } else {\n          console.log(&quot;验证成功&quot;);\n          this.errMsg = &quot;&quot;;\n        }\n      });\n    },\n    //  rules: {\n    //     name: [\n    //       { required: true, message: &quot;请输入姓名&quot;, trigger: &quot;blur&quot; },\n    //       { min: 3, max: 5, message: &quot;长度在 3 到 5 个字符&quot;, trigger: &quot;blur&quot; }\n    //     ],\n    //     mobile: [{ required: true, message: &quot;请输入电话&quot;, trigger: &quot;change&quot; }]\n    //   }\n    resetFields() {\n      this.form.model[this.prop] = &quot;&quot;; // 重置值\n      this.errMsg = &quot;&quot;; // 重置错误消息\n    }\n  }\n};\n&lt;/script&gt;</code></pre>\n<h3 id=\"zformvue\">ZForm.vue</h3>\n<ol>\n<li>给FormItem留插槽 </li>\n<li>设置数据和校验规则 </li>\n<li>全局校验</li>\n</ol>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;!-- el-form 模拟--&gt;\n  &lt;div&gt;\n    &lt;slot&gt;&lt;/slot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  // 将z-form元素上的model以及rules属性的值传递到z-form-item，用于校验，显示错误信息\n  provide() {\n    return {\n      form: {\n        model: this.value,\n        rules: this.rules\n      }\n    };\n  },\n  props: {\n    value: {\n      type: Object\n    },\n    rules: {\n      type: Object\n    }\n  },\n  methods: {\n    // submit时的校验\n    async validate(cb) {\n      // this.$children 所有form-item vue实例 获取实例的this.prop属性，有值则校验\n      let tasks = this.$children\n        .filter(item =&gt; item.prop)\n        .map(item =&gt; item.validate());\n\n      console.log(&quot;tasks&quot;, tasks);\n      // 执行他们的校验方法，如果大家的Promise全部都resolve，校验通过\n      // 如果其中有reject，catch()中可以处理错误提示信息\n      try {\n        await Promise.all(tasks);\n        cb(true);\n      } catch (e) {\n        cb(false);\n      }\n    },\n\n    resetFields() {\n      // form，这样做可能只是清空了值，但没有清楚form-item的错误提示信息\n      // Object.keys(this.value).forEach(key =&gt; {\n      //   this.value[key] = &quot;&quot;;\n      // });\n      this.$children\n        .filter(item =&gt; item.prop)\n        .forEach(item =&gt; item.resetFields());\n    }\n  }\n};\n&lt;/script&gt;</code></pre>\n<h2 id=\"与element-el-form源码的区别\">与element el-form源码的区别</h2>\n<p>这里的实现和element-ui的实现有什么区别呢？可以参考<a href=\"https://github.com/ElemeFE/element/tree/dev/packages/form/src\">element源码</a>，我这里简单说几个区别</p>\n<ol>\n<li>element使用的表单校验 async-validator是 1.x.x 版本，而上面的示例需要使用的版本 3.x.x版本</li>\n<li>Form组件里provide，上面只为form绑定了rules和props，element中指定绑定了当前this</li>\n<li>事件的监听和触发，这里使用的是$parent来处理，element里面通过 this.dispatch事件来触发</li>\n<li>element form支持很多参数，这里只是简单的模拟，element里面会复杂很多。</li>\n</ol>\n<p>完整demo参见 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/views/elementForm\">element form实现 - fedemo | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue element表单组件简单实现",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "测试组件demo"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "表单组件的封装",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "ZInput.vue"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "ZFormItem.vue"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "ZForm.vue"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "与element el-form源码的区别"
            }
          ]
        }
      ],
      "config": {
        "source": "vue element表单组件简单实现.md",
        "staticFileName": "mock_element_form.html",
        "author": "guoqzuo",
        "createDate": "2020/08/22",
        "description": "element form实现,element 表单模拟实现,element form模拟实现，在写表单时，一般我们会用到el-form相关组件，那它内部是怎么实现的呢？下面我们来写个demo，尝试实现下。先来写一个调用示例，把el-前缀换成z-，然后我们需要实现z-form, z-form-item, z-input组件",
        "keywords": "element form实现,element 表单模拟实现,element form模拟实现",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"node-packagejson中版本前的--与--分别代表什么\">node package.json中版本前的 ~ 与 ^ 分别代表什么</h1>\n<p>来看看element ui的package.json，其中async-validator是 ~ 开头，而其他都是 ^ 开头，有什么区别呢？</p>\n<pre><code class=\"language-js\">&quot;dependencies&quot;: {\n  &quot;async-validator&quot;: &quot;~1.8.1&quot;,\n  &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.0&quot;,\n  &quot;deepmerge&quot;: &quot;^1.2.0&quot;,\n  &quot;normalize-wheel&quot;: &quot;^1.0.1&quot;,\n  &quot;resize-observer-polyfill&quot;: &quot;^1.5.0&quot;,\n  &quot;throttle-debounce&quot;: &quot;^1.0.1&quot;\n},</code></pre>\n<p>版本格式 1.8.1 对应 major.minor.patch</p>\n<ul>\n<li>major：表示版本有了一个大更改。</li>\n<li>minor：表示增加了新的功能，并且可以向后兼容。</li>\n<li>patch：表示修复了bug，并且可以向后兼容。</li>\n</ul>\n<p>~：他会更新到当前minor version（也就是中间的那位数字）中最新的版本，也就是只变动patch到最新版本，它不会自动更新minor版本, 波浪符号是曾经npm安装时候的默认符号，现在已经变为了插入符号。</p>\n<p>^：这个符号就显得非常的灵活了，他将会把当前库的版本更新到当前major version（也就是第一位数字）中最新的版本。也就是更新minor到最新版本，他不会自动更新major版本。</p>\n<p>当我们使用最新的Node运行&#39;npm instal --save xxx&#39;，的时候，会优先考虑使用插入符号（^）而不是波浪符号（~）了。</p>\n<p>可以手动安装指定版本</p>\n<pre><code class=\"language-bash\"># 安装最新版本\nnpm instlal xxx \n# 默认情况下，会安装最新版本npm包，等价于\nnpm install xxx@latest\n# 安装指定版本\nnpm install xxx@[指定版本号]\n# 安装未来版本，未正式发布的beta版本\nnpm install xxx@next \n</code></pre>\n<p>参考：<a href=\"https://www.cnblogs.com/jimaww/p/10179326.html\">Node.js中package.json中库的版本号详解(^和~区别)</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "node package.json中版本前的 ~ 与 ^ 分别代表什么"
        }
      ],
      "config": {
        "source": "node package.json中版本前的 ~ 与 ^ 分别代表什么.md",
        "staticFileName": "node_package_symbol.html",
        "author": "guoqzuo",
        "createDate": "2020/08/22",
        "description": "node版本~与^,npm 包~与^是什么意思,npm包版本前的~是什么意思npm包版本前^是什么意思, 在element ui的package.json，其中async-validator是 ~ 开头，而其他都是 ^ 开头，有什么区别呢？版本格式 1.8.1 对应 major.minor.patch。- major：表示版本有了一个大更改。 - minor：表示增加了新的功能，并且可以向后兼容。- patch：表示修复了bug，并且可以向后兼容。",
        "keywords": "node版本~与^,npm 包~与^是什么意思,npm包版本前的~是什么意思npm包版本前^是什么意思",
        "category": "前端工程化",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"怎么用js手动触发window-resize事件\">怎么用js手动触发window resize事件</h1>\n<p>这里手动触发window.resize事件的目的，主要用于fix改变窗口大小后其他tab页echarts图表显示异常的问题</p>\n<p>在echarts图表组件里，有时候需要图表大小自适应浏览器窗口大小。这种情况echart宽高都会设定为100%，依赖父元素的宽高。然后再监听window的resize事件，当窗口大小改变后，重绘图表。那么问题来了</p>\n<p>在单个页面里没有问题，但在tab组件切换时，各个tab页是懒加载(keep-alive)的状态，tab切换时，会有页面组件被隐藏，但由于是keep-alive的，所以不会触发beforeDesotry事件，也就是没有销毁组件只是隐藏了。dom被隐藏后，window的resize事件没有被移除。导致调整窗口大小后，被隐藏的页面也会执行重绘操作，宽高都是百分比的，被隐藏后，宽高会异常，导致图表显示异常</p>\n<p>除非每次切tab都重绘图表或者不使用keep-alive每次都刷新页面，才不会有问题。最后想了个方法，每次点击tab手动触发window的resize事件进行重绘，下面是手动触发window resize事件的方法</p>\n<pre><code class=\"language-js\">tabClick(e) {\n  console.log(&#39;tab click&#39;, e)\n  // 触发window的resize事件\n  this.$nextTick(e =&gt; {\n    let resizeEvent = document.createEvent(&#39;Event&#39;)\n    resizeEvent.initEvent(&#39;resize&#39;, true, true)\n    window.dispatchEvent(resizeEvent)\n  })\n}</code></pre>\n<p>为什么不在tab切换后的activated里重绘图表呢？由于有十几个图表，这就需要写十几个手动重绘的函数，在tabclick的事件里写是改动最小的</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "怎么用js手动触发window resize事件"
        }
      ],
      "config": {
        "source": "怎么用js手动触发window resize事件.md",
        "staticFileName": "manual_dispatch_resize.html",
        "author": "guoqzuo",
        "createDate": "2020/08/30",
        "description": "js手动触发resize事件,手动触发resize事件,自定义resize事件,这里手动触发window.resize事件的目的，主要用于fix改变窗口大小后其他tab页echarts图表显示异常的问题，在echarts图表组件里，有时候需要图表大小自适应浏览器窗口大小。这种情况echart宽高都会设定为100%，依赖父元素的宽高。然后再监听window的resize事件，当窗口大小改变后，重绘图表。那么问题来了",
        "keywords": "js手动触发resize事件,手动触发resize事件,自定义resize事件,改变窗口大小后其他tab页echarts图表显示异常的问题",
        "category": "JavaScript",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue--element实现在用户列表页同时打开多个用户详情页tab功能\">vue + element实现在用户列表页同时打开多个用户详情页tab功能</h1>\n<p>在使用el-tabs时，如果涉及到同组件会打开多个tab的情况，同组件切换需要使用watch来监听数据改变，再进行数据的初始化</p>\n<p>下面结合一个实例来看看，使用 vue + elementUI 实现在用户列表页同时打开多个用户详情页tab功能</p>\n<p><img src=\"../../../images/blog/vue/same_comp_switch.png\" alt=\"same_comp_switch.png\"></p>\n<p>目录结果如下</p>\n<pre><code class=\"language-bash\">sameCompTabs\n├── comps\n│   ├── UserDetail.vue # 用户详情组件\n│   └── UserList.vue # 用户列表组件\n└── index.vue # 入口页，el-tabs页面</code></pre>\n<h2 id=\"tabs入口页\">tabs入口页</h2>\n<p>index.vue</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div class=&quot;same-comp-tabs&quot;&gt;\n    curTab: {{ curTab }} curDetail: {{ curUserDetail }}\n\n    &lt;el-tabs v-model=&quot;curTab&quot; type=&quot;card&quot; closable @tab-remove=&quot;tabRemove&quot;&gt;\n      &lt;el-tab-pane\n        v-for=&quot;item in tabList&quot;\n        :key=&quot;item.name&quot;\n        :label=&quot;item.title&quot;\n        :name=&quot;item.name&quot;\n      &gt;\n      &lt;/el-tab-pane&gt;\n    &lt;/el-tabs&gt;\n\n    &lt;keep-alive&gt;\n      &lt;component\n        :is=&quot;curComp&quot;\n        :detail=&quot;curUserDetail&quot;\n        @open-detail=&quot;openDetail&quot;\n      &gt;&lt;/component&gt;\n    &lt;/keep-alive&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  components: {\n    UserList: () =&gt; import(&quot;./comps/UserList&quot;),\n    UserDetail: () =&gt; import(&quot;./comps/UserDetail&quot;)\n  },\n\n  computed: {\n    curComp() {\n      return this.curTab.split(&quot;|&quot;)[0];\n    },\n    curUserDetail() {\n      for (let i = 0, len = this.tabList.length; i &lt; len; i++) {\n        let item = this.tabList[i];\n        // console.log(&quot;item&quot;, item);\n        if (item.name === this.curTab &amp;&amp; item.name.includes(&quot;UserDetail&quot;)) {\n          return item.detail;\n        }\n      }\n      return {};\n    }\n  },\n\n  data() {\n    return {\n      curTab: &quot;UserList&quot;, // v-model的值为el-tab-pane name值\n      tabList: [\n        {\n          title: &quot;用户列表&quot;,\n          name: &quot;UserList&quot;\n        }\n      ]\n    };\n  },\n\n  methods: {\n    openDetail(detail) {\n      console.log(&quot;open detail in index.vue&quot;, JSON.stringify(detail));\n\n      let name = `UserDetail|${detail.id}`;\n      this.curTab = name;\n\n      // 之前打开过\n      if (this.tabList.some(item =&gt; item.name === name)) {\n        return;\n      }\n\n      this.tabList.push({\n        title: &quot;用户详情&quot; + detail.name,\n        name,\n        detail\n      });\n    },\n\n    tabRemove(name) {\n      console.log(&quot;remove name&quot;, name);\n      if ([&quot;UserList&quot;].includes(name)) {\n        return;\n      }\n      this.tabList = this.tabList.filter(item =&gt; item.name !== name);\n      this.curTab = &quot;UserList&quot;;\n    }\n  }\n};\n&lt;/script&gt;\n\n&lt;style lang=&quot;less&quot; scoped&gt;\n.same-comp-tabs {\n  padding: 20px;\n}\n&lt;/style&gt;\n</code></pre>\n<h2 id=\"用户列表组件\">用户列表组件</h2>\n<p>UserList.vue</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-table\n      :data=&quot;tableData&quot;\n      size=&quot;small&quot;\n      height=&quot;250&quot;\n      border\n      style=&quot;width: 100%&quot;\n    &gt;\n      &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;\n      &lt;el-table-column label=&quot;操作&quot; width=&quot;180&quot;&gt;\n        &lt;template v-slot:default=&quot;scope&quot;&gt;\n          &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; @click=&quot;openDetail(scope.row)&quot;&gt;\n            详情\n          &lt;/el-button&gt;\n        &lt;/template&gt;\n      &lt;/el-table-column&gt;\n    &lt;/el-table&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      tableData: [\n        { name: &quot;张三&quot;, id: &quot;zhangsan&quot; },\n        { name: &quot;李四&quot;, id: &quot;lisi&quot; },\n        { name: &quot;王五&quot;, id: &quot;wangwu&quot; }\n      ]\n    };\n  },\n  methods: {\n    openDetail(detail) {\n      console.log(JSON.stringify(detail, null, 2));\n      this.$emit(&quot;open-detail&quot;, detail);\n    }\n  }\n};\n&lt;/script&gt;\n\n&lt;style&gt;&lt;/style&gt;\n</code></pre>\n<h2 id=\"用户详情组件\">用户详情组件</h2>\n<p>UserDetail.vue</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;!-- 用户详情页 --&gt;\n  &lt;div&gt;\n    &lt;h1&gt;用户详情页&lt;/h1&gt;\n    &lt;div&gt;userId: {{ detail.id }} userDetail: {{ userDetail }}&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  props: [&quot;detail&quot;],\n\n  data() {\n    return {\n      userDetail: {}\n    };\n  },\n\n  created() {\n    console.log(&quot;create&quot;);\n    this.getDetailById();\n  },\n\n  methods: {\n    getDetailById() {\n      console.log(&quot;get detail by id&quot;, this.detail.id);\n      this.userDetail = {\n        id: this.detail.id\n      };\n    }\n  },\n\n  // 同组件之间的切换\n  watch: {\n    detail: {\n      handler: function(val, oldVal) {\n        console.log(\n          &quot;detail change&quot;,\n          JSON.stringify(val),\n          JSON.stringify(oldVal)\n        );\n        this.getDetailById();\n      },\n      deep: true\n    }\n  }\n};\n&lt;/script&gt;\n\n&lt;style&gt;&lt;/style&gt;\n</code></pre>\n<p>完整demo地址：<a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/views/sameCompTabs\">用户列表打开多个用户详情demo | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue + element实现在用户列表页同时打开多个用户详情页tab功能",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "tabs入口页"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "用户列表组件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "用户详情组件"
            }
          ]
        }
      ],
      "config": {
        "source": "vue + element实现在用户列表页同时打开多个用户详情页tab功能.md",
        "staticFileName": "sameCompSwtich.html",
        "author": "guoqzuo",
        "createDate": "2020/08/30",
        "description": "在使用el-tabs时，如果涉及到同组件会打开多个tab的情况，同组件切换需要使用watch来监听数据改变，再进行数据的初始化。下面结合一个实例来看看，使用 vue + elementUI 实现在用户列表页同时打开多个用户详情页tab功能",
        "keywords": "vue element el-tabs标签页功能demo",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"elementui-el-tabs组件切换tab时会触发组件的哪些钩子函数\">ElementUI el-tabs组件切换tab时会触发组件的哪些钩子函数</h1>\n<p>这里主要是要弄清楚el-tabs是怎么实现组件切换的，使用el-tab-pane slot和不用这个插槽触发的钩子函数会相同吗？</p>\n<p>如果不使用el-tab-pane的slot，只使用tab的导航，下面的内容自己控制，就看是使用component还是v-if来控制了，这种情况el-tabs组件不会干扰切换的逻辑。</p>\n<p>问题来了，如果内容放到了el-tab-pane的slot呢？他有一个lazy属性，用来设置某个tab标签页是否延迟渲染，这个会对钩子函数有什么影响呢？我们改写上面的例子，通过demo来看看</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;div&gt;当前组件{{ activeName }}&lt;/div&gt;\n    &lt;el-button @click=&quot;gotoOtherPage&quot; size=&quot;mini&quot;&gt;离开当前页面&lt;/el-button&gt;\n\n    &lt;!-- 不使用el-tab-pane slot的逻辑，仅用tab控制顶部tab栏 --&gt;\n    &lt;!-- &lt;el-tabs v-model=&quot;activeName&quot; @tab-click=&quot;handleClick&quot;&gt;\n      &lt;el-tab-pane label=&quot;组件A&quot; name=&quot;compA&quot;&gt;&lt;/el-tab-pane&gt;\n      &lt;el-tab-pane label=&quot;组件B&quot; name=&quot;compB&quot;&gt;&lt;/el-tab-pane&gt;\n    &lt;/el-tabs&gt;\n    &lt;div&gt;\n      &lt;keep-alive&gt;\n        &lt;component :is=&quot;activeName&quot;&gt;&lt;/component&gt;\n      &lt;/keep-alive&gt;\n    &lt;/div&gt; --&gt;\n\n    &lt;!-- 使用el-tab-pane slot --&gt;\n    &lt;el-tabs v-model=&quot;activeName&quot; @tab-click=&quot;handleClick&quot;&gt;\n      &lt;el-tab-pane label=&quot;组件A&quot; name=&quot;compA&quot; :lazy=&quot;false&quot;&gt;\n        &lt;!-- &lt;keep-alive&gt; --&gt;\n          &lt;comp-a&gt;&lt;/comp-a&gt;\n          &lt;!-- &lt;comp-a v-if=&quot;activeName === &#39;compA&#39;&quot;&gt;&lt;/comp-a&gt; --&gt;\n        &lt;!-- &lt;/keep-alive&gt; --&gt;\n      &lt;/el-tab-pane&gt;\n      &lt;el-tab-pane label=&quot;组件B&quot; name=&quot;compB&quot; :lazy=&quot;false&quot;&gt;\n        &lt;!-- &lt;keep-alive&gt; --&gt;\n          &lt;comp-b&gt;&lt;/comp-b&gt;\n          &lt;!-- &lt;comp-b v-if=&quot;activeName === &#39;compB&#39;&quot;&gt;&lt;/comp-b&gt; --&gt;\n        &lt;!-- &lt;/keep-alive&gt; --&gt;\n      &lt;/el-tab-pane&gt;\n    &lt;/el-tabs&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre>\n<ol>\n<li>如果默认lazy为false，且slot直接写对应的组件\n首次进入会触发A/B/index三个组件的新进入页面相关钩子，<strong>再切换到B，不会触发A/B的任何钩子</strong>，仅触发index的updated相关钩子, 再切换到A或来回切换，同上不会触发A/B任何钩子，离开页面，触发A/B/index的destroy相关钩子</li>\n<li>如果lazy设置为ture，且slot直接写对应的组件\n首次进入会触发A/index两个组件的新进入页面相关钩子，<strong>再切换到B，不会触发A的任何钩子</strong>，仅触发index的updated相关钩子以及新进入页面B的钩子, 再切换到A或来回切换，不会触发A/B任何钩子，离开页面，触发A/B/index的destroy相关钩子</li>\n<li>如果lazy为false，slot里对应的组件用keep-alive包裹\n首次进入会触发A/B/index三个组件的新进入页面相关钩子，外加A/B的activated钩子；再切换到B，不会触发A/B的任何钩子，仅触发index的updated相关钩子, 再切换到A或来回切换，同上不会触发A/B任何钩子，离开页面，触发A/B/index的destroy相关钩子以及A/B的deactivated相关钩子</li>\n<li>如果lazy为true，slot里对应的组件用keep-alive包裹\n首次进入会触发A/index两个组件的新进入页面相关钩子，外加A的activated钩子；再切换到B，不会触发A的任何钩子，仅触发index的updated相关钩子以及新进入页面B的钩子外加B的activated钩子, 再切换到A或来回切换，不会触发A/B任何钩子，离开页面，触发A/B/index的destroy相关钩子</li>\n<li>如果lazy默认为false或者true，给组件加上v-if（或者component)来控制组件显示\n和不使用slot，单独在外部用v-if时的钩子保持一致</li>\n<li>如果lazy默认为false或true，给组件加上v-if（或者component)来控制组件显示，再加上keep-alive\n和不使用slot，单独在外部用v-if时的钩子并加上keep-avlie保持一致</li>\n</ol>\n<p><strong>综上，el-tabs组件el-tab-pane的slot有好多种情况，会比较混乱，对于需要精准控制tabs组件切换逻辑的场景，个人建议不要使用他的slot，除非你能很明确的知道其钩子函数的执行顺序与逻辑，最好还是仅使用其顶部tab，下面的主内容写在外部，不要写在el-tab-pane内部</strong>。其实主要区别是，如果slot里不用v-if控制，首次加载后，A/B来回切换不会触发A/B的任何钩子函数。完整demo参见 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/views/elementTabs/\">el-tabs 切换逻辑demo| github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "ElementUI el-tabs组件切换tab时会触发组件的哪些钩子函数"
        }
      ],
      "config": {
        "source": "ElementUI el-tabs组件切换tab时会触发组件的哪些钩子函数.md",
        "staticFileName": "el_tabs_hooks.html",
        "author": "guoqzuo",
        "createDate": "2020/08/30",
        "description": "element el-tabs钩子,el-tabs钩子函数,这里主要是要弄清楚el-tabs是怎么实现组件切换的，使用el-tab-pane slot和不用这个插槽触发的钩子函数会相同吗？如果不使用el-tab-pane的slot，只使用tab的导航，下面的内容自己控制，就看是使用component还是v-if来控制了，这种情况el-tabs组件不会干扰切换的逻辑。问题来了，如果内容放到了el-tab-pane的slot呢？他有一个lazy属性，用来设置某个tab标签页是否延迟渲染，这个会对钩子函数有什么影响呢？我们改写上面的例子，通过demo来看看",
        "keywords": "element el-tabs钩子,el-tabs钩子函数",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"component动态组件与使用v-if控制组件显示有什么区别？\">component动态组件与使用v-if控制组件显示有什么区别？</h1>\n<p>component动态组件可以理解为它就是v-if控制组件显示的语法糖。我们用一个例子来测试，之前我们写过compoennt用is切换时的钩子函数demo，我们把demo改写下，使用 v-if来替换component，对比页面渲染以及钩子函数的执行情况。改写如下：</p>\n<pre><code class=\"language-html\">&lt;div&gt;\n  &lt;!-- 这里用来打开或关闭keep-alive --&gt;\n  &lt;keep-alive&gt;\n    &lt;!-- &lt;component :is=&quot;curComp&quot;&gt;&lt;/component&gt; --&gt;\n    &lt;comp-a v-if=&quot;curComp === &#39;compA&#39;&quot;&gt;&lt;/comp-a&gt;\n    &lt;comp-b v-else&gt;&lt;/comp-b&gt;\n  &lt;/keep-alive&gt;\n&lt;/div&gt;</code></pre>\n<p>测试后发现，component和v-if的页面显示效果，钩子函数执行情况一模一样，不管是否加keep-alive，完整demo参见 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/views/componentAndIs/\">component vs v-if | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "component动态组件与使用v-if控制组件显示有什么区别？"
        }
      ],
      "config": {
        "source": "component动态组件与使用v-if控制组件显示有什么区别？.md",
        "staticFileName": "component_v-if.html",
        "author": "guoqzuo",
        "createDate": "2020/08/30",
        "description": "component动态组件与v-if控制组件有什么区别,component动态组件可以理解为它就是v-if控制组件显示的语法糖。我们用一个例子来测试，之前我们写过compoennt用is切换时的钩子函数demo，我们把demo改写下，使用 v-if来替换component，对比页面渲染以及钩子函数的执行情况。改写如下：",
        "keywords": "component动态组件与v-if控制组件有什么区别",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"component用is进行组件切换时会触发哪些钩子函数，加了keep-alive后呢？\">component用is进行组件切换时会触发哪些钩子函数，加了keep-alive后呢？</h1>\n<p>假设动态组件component使用is控制组件显示，默认显示为A组件，可以切换到B组件。问：</p>\n<p><strong>首次进入页面以及用is切换组件时，会触发A/B组件的哪些钩子函数，加了keep-alive后呢？</strong></p>\n<p>先给出结论</p>\n<ol>\n<li><p>如果不加keep-alive，和正常的进入页面和离开页面触发的钩子函数一致。</p>\n</li>\n<li><p>如果加了keep-alive，组件首次加载才会触发 created,mounted等钩子函数，切换时就不会触发created,mounted,beforedestroyed等，所以额外加一个activated和deactivated钩子来提示页面已切换，离开当前页面，才会销毁A/B两个组件触发beforeDestroyed和destroyed两个钩子</p>\n</li>\n</ol>\n<p>这里面涉及到一些钩子函数的触发顺序问题，我们来写详细的demo来验证下</p>\n<pre><code class=\"language-html\">&lt;!-- index.vue 主页面 --&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;div&gt;当前组件{{ curComp }}&lt;/div&gt;\n    &lt;el-radio v-model=&quot;curComp&quot; label=&quot;compA&quot;&gt;组件A&lt;/el-radio&gt;\n    &lt;el-radio v-model=&quot;curComp&quot; label=&quot;compB&quot;&gt;组件B&lt;/el-radio&gt;\n    &lt;el-button @click=&quot;gotoOtherPage&quot; size=&quot;mini&quot;&gt;离开当前页面&lt;/el-button&gt;\n    &lt;div&gt;\n      &lt;!-- 这里用来打开或关闭keep-alive --&gt;\n      &lt;!-- &lt;keep-alive&gt; --&gt;\n        &lt;component :is=&quot;curComp&quot;&gt;&lt;/component&gt;\n      &lt;!-- &lt;/keep-alive&gt; --&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  components: {\n    compA: () =&gt; import(&quot;./A&quot;),\n    compB: () =&gt; import(&quot;./B&quot;)\n  },\n  data() {\n    return {\n      curComp: &quot;compA&quot;\n    };\n  },\n  methods: {\n    gotoOtherPage() {\n      this.$router.push(&quot;/echarts&quot;);\n    }\n  },\n  beforeCreate() {\n    console.log(&quot;index beforeCreate&quot;);\n  },\n  created() {\n    console.log(&quot;index created&quot;);\n  },\n  beforeMount() {\n    console.log(&quot;index beforeMount&quot;);\n  },\n  mounted() {\n    console.log(&quot;index mounted&quot;);\n  },\n  beforeUpdate() {\n    console.log(&quot;index beforeUpdate&quot;);\n  },\n  updated() {\n    console.log(&quot;index updated&quot;);\n  },\n  activated() {\n    console.log(&quot;index activated&quot;);\n  },\n  deactivated() {\n    console.log(&quot;index deactivated&quot;);\n  },\n  beforeDestroy() {\n    console.log(&quot;index beforeDestroy&quot;);\n  },\n  destroyed() {\n    console.log(&quot;index destroyed&quot;);\n  },\n  errorCaptured() {\n    console.log(&quot;index errorCaptured&quot;);\n  }\n};\n&lt;/script&gt;\n\n&lt;style&gt;&lt;/style&gt;</code></pre>\n<p>组件A.vue和B.vue代码基本一致，下面是A.vue示例，B.vue只是将A改为了B</p>\n<pre><code class=\"language-html\">&lt;!-- A.vue --&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    我是A组件内容\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  beforeCreate() {\n    console.log(&quot;A beforeCreate&quot;);\n  },\n  created() {\n    console.log(&quot;A created&quot;);\n  },\n  beforeMount() {\n    console.log(&quot;A beforeMount&quot;);\n  },\n  mounted() {\n    console.log(&quot;A mounted&quot;);\n  },\n  beforeUpdate() {\n    console.log(&quot;A beforeUpdate&quot;);\n  },\n  updated() {\n    console.log(&quot;A updated&quot;);\n  },\n  activated() {\n    console.log(&quot;A activated&quot;);\n  },\n  deactivated() {\n    console.log(&quot;A deactivated&quot;);\n  },\n  beforeDestroy() {\n    console.log(&quot;A beforeDestroy&quot;);\n  },\n  destroyed() {\n    console.log(&quot;A destroyed&quot;);\n  },\n  errorCaptured() {\n    console.log(&quot;A errorCaptured&quot;);\n  }\n};\n&lt;/script&gt;\n\n&lt;style&gt;&lt;/style&gt;</code></pre>\n<p>keep-alive和非keep-alive钩子函数执行对比图</p>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>非keep-alive</th>\n<th>keep-alive</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>首次进入</td>\n<td>index beforeCreate<br>index created<br>index beforeMount<br>index mounted<br>index beforeUpdate<br>A beforeCreate<br>A created<br>A beforeMount<br>A mounted<br>index updated<br></td>\n<td>index beforeCreate<br>index created<br>index beforeMount<br>index mounted<br>index beforeUpdate<br>A beforeCreate<br>A created<br>A beforeMount<br>A mounted<br>A activated<br>index updated</td>\n</tr>\n<tr>\n<td>切换到B组件</td>\n<td>index beforeUpdate<br>A beforeDestroy<br>A destroyed<br>index updated<br>index beforeUpdate<br>B beforeCreate<br>B created<br>B beforeMount<br>B mounted<br>index updated</td>\n<td>A deactivated<br>index updated<br>index beforeUpdate<br>B beforeCreate<br>B created<br>B beforeMount<br>B mounted<br>B activated<br>index updated</td>\n</tr>\n<tr>\n<td>再切回到A组件</td>\n<td>index beforeUpdate<br>A beforeCreate<br>A created<br>A beforeMount<br>B beforeDestroy<br>B destroyed<br>A mounted<br>index updated</td>\n<td>index beforeUpdate<br>B deactivated<br>A activated<br>index updated</td>\n</tr>\n<tr>\n<td>再切回B组件</td>\n<td>index beforeUpdate<br>B beforeCreate<br>B created<br>B beforeMount<br>A beforeDestroy<br>A destroyed<br>B mounted<br>index updated</td>\n<td>index beforeUpdate<br>A deactivated<br>B activated<br>index updated</td>\n</tr>\n<tr>\n<td>点击离开当前页面</td>\n<td>index beforeDestroy<br>B beforeDestroy<br>B destroyed<br>index destroyed</td>\n<td>index beforeDestroy<br>B deactivated<br>A beforeDestroy<br>A destroyed<br>B beforeDestroy<br>B destroyed<br>index destroyed</td>\n</tr>\n</tbody></table>\n<p>完整demo地址，参见 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/views/vuehooks/\">vue hooks demo | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "component用is进行组件切换时会触发哪些钩子函数，加了keep-alive后呢？"
        }
      ],
      "config": {
        "source": "component用is进行组件切换时会触发哪些钩子函数，加了keep-alive后呢？.md",
        "staticFileName": "component_is_hooks.html",
        "author": "guoqzuo",
        "createDate": "2020/08/30",
        "description": "component is hooks,component is 钩子函数,假设动态组件component使用is控制组件显示，默认显示为A组件，可以切换到B组件。问：首次进入页面以及用is切换组件时，会触发A/B组件的哪些钩子函数，加了keep-alive后呢？先给出结论 1. 如果不加keep-alive，和正常的进入页面和离开页面触发的钩子函数一致。2. 如果加了keep-alive，组件首次加载才会触发 created,mounted等钩子函数，切换时就不会触发created,mounted,beforedestroyed等，所以额外加一个activated和deactivated钩子来提示页面已切换，离开当前页面，才会销毁A/B两个组件触发beforeDestroyed和destroyed两个钩子",
        "keywords": "component is hooks,component is 钩子函数",
        "category": "Vue",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"深入koa-router源码理解allowedmethods中间件作用\">深入koa-router源码理解allowedMethods中间件作用</h1>\n<p>在使用koa koa-router mock接口时，我们会看到 <code>app.use(router.routes()).use(router.allowedMethods())</code>，使用 router中间件后，又链式调用了router.allowedMethods()这个中间件，那为什么要加router.allowedMethods()中间件呢？他有什么作用？我们写个demo来测试下</p>\n<p>先下结论：</p>\n<ol>\n<li>router.allowedMethods()中间件，主要用于 405 Method Not Allowed 这个状态码相关</li>\n<li>如果不加这个中间件，如果接口是get请求，而前端使用post请求，会返回 404 状态码，接口未定义。如果加了这个中间件，这种情况时，会返回405 Method Not Allowed ，提示 request method 不匹配，并在响应头返回接口支持的请求方法，更有利于调试</li>\n</ol>\n<p>下面来看一个demo</p>\n<pre><code class=\"language-js\">let koa = require(&#39;koa&#39;);\nlet Router = require(&#39;koa-router&#39;)\n\nlet app = new koa()\nlet router = new Router()\n\nrouter.post(&#39;/user&#39;, ctx =&gt; {\n  ctx.body = {\n    a: 1\n  }\n})\n\napp.use(router.routes())\n// app.use(router.routes()).use(router.allowedMethods())\n\napp.listen(&#39;9000&#39;, () =&gt; {\n  console.log(&#39;server listen on 9000 port&#39;)\n})</code></pre>\n<p>上面的例子中，我们定义一个 /user 接口，他需要使用post请求方法。这里我们先通过get方法来请求这个接口试试</p>\n<pre><code class=\"language-bash\">curl -v http://127.0.0.1:9000/user\n# 以下是请求响应的内容，可以看到接口会返回404，因为我们接口现在只能是post请求的\n* Connected to 127.0.0.1 (127.0.0.1) port 9000 (#0)\n&gt; GET /user HTTP/1.1\n&gt; Host: 127.0.0.1:9000\n&gt; User-Agent: curl/7.64.1\n&gt; Accept: */*\n&gt; \n&lt; HTTP/1.1 404 Not Found\n&lt; Content-Type: text/plain; charset=utf-8\n&lt; Content-Length: 9\n&lt; Date: Thu, 25 Jun 2020 09:13:14 GMT\n&lt; Connection: keep-alive\n&lt; </code></pre>\n<p>我们再调整下上面的demo，使用 router.allowedMethods() 中间件</p>\n<pre><code class=\"language-js\">// app.use(router.routes())\napp.use(router.routes()).use(router.allowedMethods())</code></pre>\n<p>再发一遍get请求</p>\n<pre><code class=\"language-bash\">curl -v http://127.0.0.1:9000/user\n# 以下是返回结果\n* TCP_NODELAY set\n* Connected to 127.0.0.1 (127.0.0.1) port 9000 (#0)\n&gt; GET /user HTTP/1.1\n&gt; Host: 127.0.0.1:9000\n&gt; User-Agent: curl/7.64.1\n&gt; Accept: */*\n&gt; \n&lt; HTTP/1.1 405 Method Not Allowed\n&lt; Allow: POST\n&lt; Content-Type: text/plain; charset=utf-8\n&lt; Content-Length: 18\n&lt; Date: Thu, 25 Jun 2020 09:13:55 GMT\n&lt; Connection: keep-alive\n&lt; </code></pre>\n<p>我们可以看到加router.allowedMethods()中间件和不加这个中间件的区别，当我们定义了post方法接口却发送对应的get请求时，执行结果对比</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>响应状态码</th>\n<th>响应头变化</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>默认情况</td>\n<td>404 Not Found</td>\n<td>无</td>\n</tr>\n<tr>\n<td>router.allowedMethods()</td>\n<td>405 Method Not Allowed</td>\n<td>新增响应头 Allow: POST</td>\n</tr>\n</tbody></table>\n<p>下面我们来看下对应的源码：<a href=\"https://github.com/koajs/router/blob/master/\">koa-router源码 | github</a></p>\n<p>由于它是一个npm包，我们先在package.json里面看看他的入口</p>\n<pre><code class=\"language-bash\"># package.json里面的main就是我们 require对应npm包后，引入的实际文件地址\n&quot;main&quot;: &quot;lib/router.js&quot;,</code></pre>\n<p>也就是源码入口在lib/router.js</p>\n<pre><code class=\"language-js\">// 源码截取至https://github.com/koajs/router/blob/master/lib/router.js\n/**\n * Returns separate middleware for responding to `OPTIONS` requests with\n * an `Allow` header containing the allowed methods, as well as responding\n * with `405 Method Not Allowed` and `501 Not Implemented` as appropriate.\n * @param {Object=} options\n * @param {Boolean=} options.throw throw error instead of setting status and header\n * @param {Function=} options.notImplemented throw the returned value in place of the default NotImplemented error\n * @param {Function=} options.methodNotAllowed throw the returned value in place of the default MethodNotAllowed error\n * @returns {Function}\n */\nRouter.prototype.allowedMethods = function (options) {\n  options = options || {};\n  const implemented = this.methods;\n\n  return function allowedMethods(ctx, next) {\n    return next().then(function() {\n      const allowed = {};\n\n      if (!ctx.status || ctx.status === 404) {\n        for (let i = 0; i &lt; ctx.matched.length; i++) {\n          const route = ctx.matched[i];\n          for (let j = 0; j &lt; route.methods.length; j++) {\n            const method = route.methods[j];\n            allowed[method] = method;\n          }\n        }\n\n        const allowedArr = Object.keys(allowed);\n\n        if (!~implemented.indexOf(ctx.method)) {\n          if (options.throw) {\n            let notImplementedThrowable = (typeof options.notImplemented === &#39;function&#39;)\n            ? options.notImplemented()  // set whatever the user returns from their function\n            : new HttpError.NotImplemented();\n\n            throw notImplementedThrowable;\n          } else {\n            ctx.status = 501;\n            ctx.set(&#39;Allow&#39;, allowedArr.join(&#39;, &#39;));\n          }\n        } else if (allowedArr.length) {\n          if (ctx.method === &#39;OPTIONS&#39;) {\n            ctx.status = 200;\n            ctx.body = &#39;&#39;;\n            ctx.set(&#39;Allow&#39;, allowedArr.join(&#39;, &#39;));\n          } else if (!allowed[ctx.method]) {\n            if (options.throw) {\n              let notAllowedThrowable = (typeof options.methodNotAllowed === &#39;function&#39;) \n              ? options.methodNotAllowed() // set whatever the user returns from their function\n              : new HttpError.MethodNotAllowed();\n\n              throw notAllowedThrowable;\n            } else {\n              ctx.status = 405;\n              ctx.set(&#39;Allow&#39;, allowedArr.join(&#39;, &#39;));\n            }\n          }\n        }\n      }\n    });\n  };\n};</code></pre>\n<p>怎么弄清楚源码的执行呢？一般我们可以在源码里加入一些console.log，来打印一些关键的信息，注意:</p>\n<ol>\n<li>一般npm install koa-router --save后，当前目录下的node_modules里面会有对应的源码，可以在里面修改源码</li>\n<li>修改源码后，需要ctrl+s一下index.js触发nodemon重启服务，这样执行的才是修改过源码后的代码</li>\n</ol>\n<p>以下是我在调试这个demo时，在源码中加的console信息，如下</p>\n<pre><code class=\"language-js\">Router.prototype.allowedMethods = function (options) {\n  options = options || {};\n  const implemented = this.methods;\n\n  console.log(&#39;koa router log, implemented&#39;, implemented)\n  // [ &#39;HEAD&#39;, &#39;OPTIONS&#39;, &#39;GET&#39;, &#39;PUT&#39;, &#39;PATCH&#39;, &#39;POST&#39;, &#39;DELETE&#39; ]\n\n  return function allowedMethods(ctx, next) {\n    return next().then(function() {\n      const allowed = {};\n\n      if (!ctx.status || ctx.status === 404) {\n        console.log(&#39;ctx.matched&#39;, ctx.matched)\n        //  ctx.matched 当前请求匹配到的路由，当发送 /user 请求时，这个数组只有一个元素\n        // [ Layer {\n        //   opts:\n        //    { end: true,\n        //      name: null,\n        //      sensitive: false,\n        //      strict: false,\n        //      prefix: &#39;&#39;,\n        //      ignoreCaptures: undefined },\n        //   name: null,\n        //   methods: [ &#39;POST&#39; ],\n        //   paramNames: [],\n        //   stack: [ [Function] ],\n        //   path: &#39;/user&#39;,\n        //   regexp: /^\\/user[\\/#\\?]?$/i } ]\n        for (let i = 0; i &lt; ctx.matched.length; i++) {\n          const route = ctx.matched[i];\n          // 有些接口可能支持多种methods请求，这里遍历当前接口支持的所有方法数组,/user 只支持一个post方法\n          for (let j = 0; j &lt; route.methods.length; j++) {\n            const method = route.methods[j];\n            allowed[method] = method;\n          }\n        }\n        console.log(&#39;allowed&#39;, allowed) // { POST: &#39;POST&#39; }\n\n        const allowedArr = Object.keys(allowed); // [&#39;POST&#39;]\n\n        console.log(&#39;implemented.indexOf(ctx.method)&#39;, implemented.indexOf(ctx.method)) // 2\n\n        // if (!~value) 等价于 if (value === -1)\n        if (!~implemented.indexOf(ctx.method)) { // ctx.method  GET\n          // 如果当前请求方法不是下面数组中的某一种\n          // [ &#39;HEAD&#39;, &#39;OPTIONS&#39;, &#39;GET&#39;, &#39;PUT&#39;, &#39;PATCH&#39;, &#39;POST&#39;, &#39;DELETE&#39; ]\n          if (options.throw) {\n            let notImplementedThrowable = (typeof options.notImplemented === &#39;function&#39;)\n            ? options.notImplemented()  // set whatever the user returns from their function\n            : new HttpError.NotImplemented();\n\n            throw notImplementedThrowable;\n          } else {\n            ctx.status = 501;\n            ctx.set(&#39;Allow&#39;, allowedArr.join(&#39;, &#39;));\n          }\n        } else if (allowedArr.length) {\n          // 当前路由404，但对应的接口可以使用其他的method进行请求\n          if (ctx.method === &#39;OPTIONS&#39;) {\n            ctx.status = 200;\n            ctx.body = &#39;&#39;;\n            ctx.set(&#39;Allow&#39;, allowedArr.join(&#39;, &#39;));\n          } else if (!allowed[ctx.method]) { // allowed: { POST: &#39;POST&#39; } ctx.method: GET\n            // 当前请求方法，并不在接口允许的方法(allowed)里面\n            if (options.throw) {\n              // throw error instead of setting status and header\n              let notAllowedThrowable = (typeof options.methodNotAllowed === &#39;function&#39;) \n              ? options.methodNotAllowed() // set whatever the user returns from their function\n              : new HttpError.MethodNotAllowed();\n\n              throw notAllowedThrowable;\n            } else {\n              // 默认请求，如果不传 throw方法的情况\n              ctx.status = 405;\n              ctx.set(&#39;Allow&#39;, allowedArr.join(&#39;, &#39;));\n            }\n          }\n        }\n      }\n    });\n  };\n};</code></pre>\n<p>总结，router.allowedMethods() 的执行逻辑大致如下</p>\n<ol>\n<li>如果当前接口为404时(!ctx.status的情况貌似没遇到过)，才执行该中间件的逻辑</li>\n<li>遍历当前请求匹配到的路由信息数组 ctx.matched，将匹配到的路由允许的methods存入 allowed 对象</li>\n<li>判断当前请求方法ctx.method是否是正常的请求方法，如果不是，抛异常，注意抛异常时，如果调用该中间件时有传入throw参数，则表示自己处理异常，这种情况默认返回501，提示服务异常<pre><code class=\"language-js\">// 注意这里用到了 !~ 来判断是否 === -1，这里可以使用ES2016新出的Array.prototype.includes来判断\n// if (!~value) 等价于 if (value === -1)\nif (!~implemented.indexOf(ctx.method)) { //</code></pre>\n</li>\n<li>如果当前路由404，但对应的接口可以使用其他的method进行请求，如果是 options(或预检请求)，不返回404，返回200，并设置allow响应头</li>\n<li>如果当前请求方法不在允许的方法里面，如果传入了throw自己处理异常，否则返回 405 method not allowed，且设置allow响应头</li>\n</ol>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "深入koa-router源码理解allowedMethods中间件作用"
        }
      ],
      "config": {
        "source": "深入koa-router源码理解allowedMethods中间件作用.md",
        "staticFileName": "allowedMethods_use.html",
        "author": "guoqzuo",
        "createDate": "2020/08/30",
        "description": "koa-router router.allowedMethods()中间件作用,router.allowedMethods 405,在使用koa koa-router mock接口时，我们会看到 `app.use(router.routes()).use(router.allowedMethods())`，使用 router中间件后，又链式调用了router.allowedMethods()这个中间件，那为什么要加router.allowedMethods()中间件呢？他有什么作用？我们写个demo来测试下。先下结论：1. router.allowedMethods()中间件，主要用于 405 Method Not Allowed 这个状态码相关 2. 如果不加这个中间件，如果接口是get请求，而前端使用post请求，会返回 404 状态码，接口未定义。如果加了这个中间件，这种情况时，会返回405 Method Not Allowed ，提示 request method 不匹配，并在响应头返回接口支持的请求方法，更有利于调试",
        "keywords": "koa-router router.allowedMethods()中间件作用,router.allowedMethods 405",
        "category": "前端工程化",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"symbol和arrayprototypeincludes不兼容ie，有babel就可以，他的原理是什么\">Symbol和Array.prototype.includes不兼容IE，有babel就可以，他的原理是什么</h1>\n<p>在mdn上可以查相关API的兼容性,可以看到Symbol和Array.prototype.includes是不支持IE的，但我们在vue-cli的项目中，发现使用了这些api，在IE下也可以运行，这是为什么呢？</p>\n<p>主要是安装了babel，babel有进行转换，当IE不支持某个方法时，会使用替代的pollyfill，那它是怎么打包进项目的？</p>\n<p><img src=\"../../../images/blog/js/array_includes_compatibility.png\" alt=\"array_includes_compatibility.png\"></p>\n<h2 id=\"什么是babel？\">什么是babel？</h2>\n<p>为什么会有babel，babel出现的原因是JS的一些很好的新特性在一些低浏览器版本或者IE下无法使用。为了用最新的JS语法特性写的代码在某些不兼容的环境下也可以正常运行，babel应运而生。</p>\n<blockquote>\n<p>Babel is a JavaScript compiler，Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments. Here are the main things Babel can do for you:</p>\n</blockquote>\n<p>babel是一个js编译器，他是一个工具链(toolchain)，它主要用于将 ES6(ES2015)+ 的代码转换为在低版本浏览器或执行环境可以跑起来的代码。他主要做了以下事情：</p>\n<ol>\n<li>Transform syntax(语法转换)</li>\n<li>Polyfill features that are missing in your target environment (through @babel/polyfill) (当浏览器会运行环境不支持某些API时，通过使用@babel/polyfill补充上对应的API实现内容(polyfill features))</li>\n<li>Source coude transformations（codemods） 源码转换</li>\n<li>And more！（check out these videos for inspiration）（更多，查看这些<a href=\"https://babeljs.io/videos.html\">视频</a>以获取灵感）</li>\n</ol>\n<pre><code class=\"language-js\">// Babel Input: ES2015 arrow function\n[1, 2, 3].map((n) =&gt; n + 1);\n\n// Babel Output: ES5 equivalent\n[1, 2, 3].map(function(n) {\n  return n + 1;\n});</code></pre>\n<h2 id=\"关于babelpolyfill与core-js\">关于@babel/polyfill与core-js</h2>\n<p>一般polyfill只会提供es2015+相关的内容，且当某些新特性还没到 Stage 4 proposals(第4阶段的提议)之前，是不支持的</p>\n<p>As of Babel 7.4.0, this package has been deprecated in favor of directly including core-js/stable (to polyfill ECMAScript features) and regenerator-runtime/runtime (needed to use transpiled generator functions):</p>\n<p>在 Babel 7.4.0 中，@babel/polyfill这个包被废弃了，现在由 <a href=\"https://github.com/zloirock/core-js\"><code>core-js/stable</code></a> 来polyfill features</p>\n<pre><code class=\"language-js\">import &quot;core-js/stable&quot;;\nimport &quot;regenerator-runtime/runtime&quot;;</code></pre>\n<p>参考 <a href=\"https://babeljs.io/docs/en/babel-polyfill#tc39-proposals\">@babel/polyfill</a></p>\n<p>我们在core-js的源码中找找 symbol 和includes的实现，一般源码目录在 core-js/internals 目录下，下面是 include polyfill的实现</p>\n<pre><code class=\"language-js\">// /core-js/internals/array-includes.js\nvar toIndexedObject = require(&#39;../internals/to-indexed-object&#39;);\nvar toLength = require(&#39;../internals/to-length&#39;);\nvar toAbsoluteIndex = require(&#39;../internals/to-absolute-index&#39;);\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES &amp;&amp; el != el) while (length &gt; index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;  // ??????\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length &gt; index; index++) {\n      if ((IS_INCLUDES || index in O) &amp;&amp; O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES &amp;&amp; -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};</code></pre>\n<p>tc39官网介绍：When the includes method is called, the following steps are taken:</p>\n<pre><code class=\"language-js\">// https://tc39.github.io/ecma262/#sec-array.prototype.includes\n1. Let O be ? ToObject(this value).\n2. Let len be ? LengthOfArrayLike(O).\n3. If len is 0, return false.\n4. Let n be ? ToInteger(fromIndex).\n5. Assert: If fromIndex is undefined, then n is 0.\n6. If n ≥ 0, then\n     Let k be n.\n   Else,\n     Let k be len + n.\n     If k &lt; 0, set k to 0.\n8. Repeat, while k &lt; len,\n     Let elementK be the result of ? Get(O, ! ToString(k)).\n     If SameValueZero(searchElement, elementK) is true, return true.\n     Set k to k + 1.\n9. Return false.</code></pre>\n<p>关于 sameValueZero算法，参见 <a href=\"https://tc39.es/ecma262/#sec-samevaluezero\">samevaluezero tc39</a></p>\n<h2 id=\"symbol-polyfill实现\">symbol polyfill实现</h2>\n<pre><code class=\"language-js\">// `Symbol.prototype.description` getter\n// https://tc39.github.io/ecma262/#sec-symbol.prototype.description\n// /core-js/modules/es.symbol.description.js\nvar NativeSymbol = global.Symbol;\n\nif (DESCRIPTORS &amp;&amp; typeof NativeSymbol == &#39;function&#39; &amp;&amp; (!(&#39;description&#39; in NativeSymbol.prototype) ||\n  // Safari 12 bug\n  NativeSymbol().description !== undefined\n)) {\n  var EmptyStringDescriptionStore = {};\n  // wrap Symbol constructor for correct work with undefined description\n  var SymbolWrapper = function Symbol() {\n    var description = arguments.length &lt; 1 || arguments[0] === undefined ? undefined : String(arguments[0]);\n    var result = this instanceof SymbolWrapper\n      ? new NativeSymbol(description)\n      // in Edge 13, String(Symbol(undefined)) === &#39;Symbol(undefined)&#39;\n      : description === undefined ? NativeSymbol() : NativeSymbol(description);\n    if (description === &#39;&#39;) EmptyStringDescriptionStore[result] = true;\n    return result;\n  };\n  copyConstructorProperties(SymbolWrapper, NativeSymbol);\n  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;\n  symbolPrototype.constructor = SymbolWrapper;\n\n  var symbolToString = symbolPrototype.toString;\n  var native = String(NativeSymbol(&#39;test&#39;)) == &#39;Symbol(test)&#39;;\n  var regexp = /^Symbol\\((.*)\\)[^)]+$/;\n  defineProperty(symbolPrototype, &#39;description&#39;, {\n    configurable: true,\n    get: function description() {\n      var symbol = isObject(this) ? this.valueOf() : this;\n      var string = symbolToString.call(symbol);\n      if (has(EmptyStringDescriptionStore, symbol)) return &#39;&#39;;\n      var desc = native ? string.slice(7, -1) : string.replace(regexp, &#39;$1&#39;);\n      return desc === &#39;&#39; ? undefined : desc;\n    }\n  });</code></pre>\n<h2 id=\"babel是怎么自动打包进vue-cli项目里的\">babel是怎么自动打包进vue-cli项目里的</h2>\n<p>在babel github官方仓库里面有一个 <code>babel-loader</code> 项目，主要是Babel loader for webpack，另外vue-cli的package.json里也引入了 <code>@vue/cli-plugin-babel</code>，后面有时间再深入研究</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Symbol和Array.prototype.includes不兼容IE，有babel就可以，他的原理是什么",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "什么是babel？"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "关于@babel/polyfill与core-js"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "symbol polyfill实现"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "babel是怎么自动打包进vue-cli项目里的"
            }
          ]
        }
      ],
      "config": {
        "source": "Symbol和Array.prototype.includes不兼容IE，有babel就可以，他的原理是什么.md",
        "staticFileName": "includes_babel.html",
        "author": "guoqzuo",
        "createDate": "2020/08/30",
        "description": "vue项目里使用includes，IE11支持吗？在mdn上可以查相关API的兼容性,可以看到Symbol和Array.prototype.includes是不支持IE的，但我们在vue-cli的项目中，发现使用了这些api，在IE下也可以运行，这是为什么呢？主要是安装了babel，babel有进行转换，当IE不支持某个方法时，会使用替代的pollyfill，那它是怎么打包进项目的？",
        "keywords": "vue项目里使用includes，IE11支持吗？",
        "category": "JavaScript",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"判断一个字符串出现次数最多的字符，并输出其次数\">判断一个字符串出现次数最多的字符，并输出其次数</h1>\n<p>在js处理数组时，有一个reduce方法是比较实用的，特别是计算字符串出现次数的时候。下面来逐步介绍，怎么用js写一个函数，显示判断一个字符串出现次数最多的字符，并输出其次数</p>\n<pre><code class=\"language-js\">let str = &quot;ababadectwestsfdadsfb&quot;\nconsole.log(getMostChar(str))\n\nfunction getMostChar(str) {\n\n}</code></pre>\n<p>思路：我们先实现获取字符串中每个字符出现的次数</p>\n<pre><code class=\"language-js\">function getCharCount(str) {\n  // 先把字符串切分为数组\n  return str.split(&#39;&#39;).reduce((result, item) =&gt; {\n    if (result[item] === undefined) {\n      result[item] = 1\n    } else {\n      result[item]++\n    }\n    return result\n  }, {})\n}</code></pre>\n<p>上面的例子中，使用了Array.prototype.reduce，如果不知道reduce执行情况，就需要好好看下<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\">mdn</a>的文档了，上面的代码其实等价于下面的代码，可以看到reduce使用第二参数时，</p>\n<pre><code class=\"language-js\">function getCharCount(str) {\n  // 先把字符串切分为数组\n  let result = {}\n  str.split(&#39;&#39;).forEach(item =&gt; {\n    if (result[item] === undefined) {\n      result[item] = 1\n    } else {\n      result[item]++\n    }\n  })\n  return result\n}</code></pre>\n<p>执行下这个函数</p>\n<pre><code class=\"language-js\">console.log(&#39;每个字符串出现的次数&#39;, JSON.stringify(getCharCount(str)))\n// {&quot;a&quot;:4,&quot;b&quot;:3,&quot;d&quot;:3,&quot;e&quot;:2,&quot;c&quot;:1,&quot;t&quot;:2,&quot;w&quot;:1,&quot;s&quot;:3,&quot;f&quot;:2}</code></pre>\n<p>根据上面的例子，我们再来思考怎么获取出现次数最多的字符，<strong>其实在reduce里面每次的result我们可以获取到当前字符、以及其出现的次数。我们可以用一个变量来存储出现次数最多的字符，每次遍历是都与这个变量进行比较就可以了</strong></p>\n<pre><code class=\"language-js\">let str = &quot;ababadectwestsfdadsfb&quot;\nfunction getMostChar(str) {\n  // 先把字符串切分为数组\n  let mostChar = {\n    count: 0,\n    char: &#39;&#39;\n  }\n\n  let charCountObj = str.split(&#39;&#39;).reduce((result, item) =&gt; {\n    if (result[item] === undefined) {\n      result[item] = 1\n    } else {\n      result[item]++\n    }\n\n    if (result[item] &gt; mostChar.count) {\n      mostChar.count = result[item]\n      mostChar.char = item\n    }\n\n    return result\n  }, {})\n\n  return {\n    mostChar, // 出现次数最多的字符\n    charCountObj, // 字符串中所有字符出现的次数\n  }\n}</code></pre>\n<p>上面的例子中mostChar输出了出现次数最多的字符以及其次数，那问题来了，如果字符串是 &quot;aabbcc&quot;，那出现最多次数的字符就不只一个了，可能会是数组。我们需要对上面的例子再进行一些增强，如下</p>\n<pre><code class=\"language-js\">// 主要是修改当前字符和出现次数最多的字符相等的情况\nif (result[item] &gt; mostChar.count) {\n  mostChar.count = result[item]\n  mostChar.char = item\n} else if (result[item] === mostChar.count) {\n  if (typeof mostChar.char === &#39;string&#39;) {\n    mostChar.char = [mostChar.char, item]\n  } else {\n    mostChar.char.push(item)\n  }\n}</code></pre>\n<p>以上就是完整实现了，完整demo参见：<a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6/index.html\">判断一个字符串出现最多的字符 | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "判断一个字符串出现次数最多的字符，并输出其次数"
        }
      ],
      "config": {
        "source": "判断一个字符串出现次数最多的字符，并输出其次数.md",
        "staticFileName": "char_most_count.html",
        "author": "guoqzuo",
        "createDate": "2020/08/30",
        "description": "reduce使用场景,js 判断一个字符串出现次数最多的字符,在js处理数组时，有一个reduce方法是比较实用的，特别是计算字符串出现次数的时候。下面来逐步介绍，怎么用js写一个函数，显示判断一个字符串出现次数最多的字符，并输出其次数",
        "keywords": "reduce使用场景,js 判断一个字符串出现次数最多的字符",
        "category": "JavaScript",
        "year": "2020",
        "month": "8"
      }
    },
    {
      "htmlStr": "<h1 id=\"macos下怎么将mp4和m4a文件合并\">macOS下怎么将mp4和m4a文件合并</h1>\n<p>可以使用ffmpeg命令行工具，输入如下命令进行合并，注意这个合并时间非常长，要等很久</p>\n<pre><code class=\"language-bash\"># 下载ffmpeg解压后会有一个ffmpeg-4.2.3-macos64-static文件夹，然后进入这个目录的bin目录下，执行\n./ffmpeg -i /Users/kevin/Desktop/17下.mp4 -i /Users/kevin/Desktop/17下.m4a out2.mp4</code></pre>\n<p>其实合并视频和音频可以使用mac下的imovie或者一些其他的视频剪辑软件，比这个要快很多</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "macOS下怎么将mp4和m4a文件合并"
        }
      ],
      "config": {
        "source": "macOS下怎么将mp4和m4a文件合并.md",
        "staticFileName": "m4a_m4a_merge.html",
        "author": "guoqzuo",
        "createDate": "2020/09/07",
        "description": "mp4 m4a合并,mp4 m4a,音视频合并, 可以使用ffmpeg命令行工具，输入如下命令进行合并，注意这个合并时间非常长，要等很久，下载ffmpeg解压后会有一个ffmpeg-4.2.3-macos64-static文件夹，然后进入这个目录的bin目录下，执行 ./ffmpeg -i /Users/kevin/Desktop/17下.mp4 -i /Users/kevin/Desktop/17下.m4a out2.mp4，其实合并视频和音频可以使用mac下的imovie或者一些其他的视频剪辑软件，比这个要快很多",
        "keywords": "mp4 m4a合并,mp4 m4a,音视频合并",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"element-v-loading在ie下可能会关不掉的问题\">element v-loading在IE下可能会关不掉的问题</h1>\n<p>对于请求非常快的情况，loading一加载很快就关闭。在IE下，可能出现 v-loading设置的值已经是 false，但loading还是一直显示，关闭不了的情况，解决方法是：在关闭loading前，加一个500ms的延时，就没问题了。</p>\n<pre><code class=\"language-js\">setTimeout(() =&gt; {\n  this.loading = false\n}, 500)</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "element v-loading在IE下可能会关不掉的问题"
        }
      ],
      "config": {
        "source": "element v-loading在IE下可能会关不掉的问题.md",
        "staticFileName": "v_loading_cannotclose.html",
        "author": "guoqzuo",
        "createDate": "2020/09/07",
        "description": "v-loading在IE下无法关闭的问题,IE 无法关闭v-loading，对于请求非常快的情况，loading一加载很快就关闭。在IE下，可能出现 v-loading设置的值已经是 false，但loading还是一直显示，关闭不了的情况，解决方法是：在关闭loading前，加一个500ms的延时，就没问题了。",
        "keywords": "v-loading在IE下无法关闭的问题,IE 无法关闭v-loading",
        "category": "Vue",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"element-v-loading在ie下可能会溢出到全屏的问题\">element v-loading在IE下可能会溢出到全屏的问题</h1>\n<p>在IE下，有可能出现v-loading指令在loading时不是作用在添加 v-loading 指令的元素区域里，而是溢出到全屏了。</p>\n<p>这种情况我查了下dom，了解到v-loading是position: absolute布局，而v-loading position不是relatvie 导致溢出到全屏了。这种情况给使用v-loading指令的元素手动加一个 position: relative就可以了。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "element v-loading在IE下可能会溢出到全屏的问题"
        }
      ],
      "config": {
        "source": "element v-loading在IE下可能会溢出到全屏的问题.md",
        "staticFileName": "v_loading_fullscreen.html",
        "author": "guoqzuo",
        "createDate": "2020/09/07",
        "description": "v-loading在IE下溢出到全屏,IE v-loading全屏，在IE下，有可能出现v-loading指令在loading时不是作用在添加 v-loading 指令的元素区域里，而是溢出到全屏了。这种情况我查了下dom，了解到v-loading是position: absolute布局，而v-loading position不是relatvie 导致溢出到全屏了。这种情况给使用v-loading指令的元素手动加一个 position: relative就可以了。",
        "keywords": "v-loading在IE下溢出到全屏,IE v-loading全屏",
        "category": "Vue",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"v-loading指令的实现，怎么通过一个指令自动加骨架屏\">v-loading指令的实现，怎么通过一个指令自动加骨架屏</h1>\n<p>这里需要用到vue自定义指令，我们先写个v-zloading来实现loading，在loading过程中加骨架屏</p>\n<pre><code class=\"language-html\">&lt;div v-zloading=&quot;loading&quot; class=&quot;div&quot;&gt;\n  测试\n&lt;/div&gt;</code></pre>\n<p><img src=\"../../../images/blog/vue/v_loading.gif\" alt=\"v_loading.gif\"></p>\n<p>由于是全局自定义指令，所以在main.js里写</p>\n<pre><code class=\"language-js\">// 挂载dom\nfunction mountDom(el) {\n  el.style.position = &quot;relative&quot;;\n\n  let div = document.createElement(&quot;div&quot;);\n  div.style.position = &quot;absolute&quot;;\n  div.style.top = &quot;0&quot;;\n  div.style.left = &quot;0&quot;;\n  div.style.right = &quot;0&quot;;\n  div.style.bottom = &quot;0&quot;;\n  div.style.backgroundColor = &quot;white&quot;;\n  div.classList.add(&quot;zloading&quot;);\n\n  let htmlStr = `\n    &lt;div style=&quot;positon:absolute;top:0;left:0;z-index:999;width: 100%;margin: 10 auto;&quot;&gt;\n      &lt;div class=&quot;fast-loading&quot;&gt;&lt;/div&gt;\n      &lt;div class=&quot;fast-loading w40&quot;&gt;&lt;/div&gt;\n      &lt;div class=&quot;fast-loading w80&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  `;\n  div.innerHTML = htmlStr;\n  el.appendChild(div);\n}\n\nVue.directive(&quot;zloading&quot;, {\n  bind: (el, binding) =&gt; {\n    // console.log(&quot;v-zloading bind&quot;);\n    // console.log(binding, vnode);\n    if (binding.value) {\n      mountDom(el);\n    }\n  },\n  update: (el, binding) =&gt; {\n    // console.log(&quot;v-zloading update&quot;);\n    // console.log(el, binding, vnode);\n    let zloadingDom = el.querySelector(&quot;.zloading&quot;);\n    // console.log(&quot;zloading dom&quot;, zloadingDom);\n    if (zloadingDom) {\n      zloadingDom.style.display = binding.value ? &quot;block&quot; : &quot;none&quot;;\n    } else {\n      binding.value &amp;&amp; mountDom(el);\n    }\n  }\n});</code></pre>\n<p>骨架屏的样式common.css，然后在App.vue里引入</p>\n<pre><code class=\"language-css\">.fast-loading {\n    height: 20px;\n    margin: 10px 0;\n    width: 200px;\n    background-color: rgb(245, 245, 245);\n    background-image: repeating-linear-gradient(90deg, #eee, #f5f5f5 100%);\n\n    animation-name: fastLoading;\n    animation-timing-function: linear;\n    animation-duration: 1s;\n    animation-iteration-count: infinite;\n}\n@keyframes fastLoading {\n    from {\n    background-position: 0 0;\n    }\n    to {\n    background-position: 100px 0;\n    }\n}\n\n.w100 { width: 100% }\n.w80 { width: 80% }\n.w60 { width: 60% }\n.w40 { width: 50% }\n.w30 { width: 30% }</code></pre>\n<p>这样就模拟实现了一个v-loading, 完整demo参见<a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/vuecli-demo/src/views/vloading/index.vue\">v-zloading 实现 | github</a>  注意，指令的实现是放在main.js里面的</p>\n<h2 id=\"v-loading源码\">v-loading源码</h2>\n<p>我们自己简单实现v-loaidng的功能后，再来看看v-loading的源码</p>\n<pre><code class=\"language-js\">// 截取至element v-loading部分源码 \n// https://github.com/ElemeFE/element/blob/dev/packages/loading/src/directive.js\nVue.directive(&#39;loading&#39;, {\n    bind: function(el, binding, vnode) {\n      //....\n      const mask = new Mask({\n        el: document.createElement(&#39;div&#39;),\n        data: {\n          text: vm &amp;&amp; vm[textExr] || textExr,\n          spinner: vm &amp;&amp; vm[spinnerExr] || spinnerExr,\n          background: vm &amp;&amp; vm[backgroundExr] || backgroundExr,\n          customClass: vm &amp;&amp; vm[customClassExr] || customClassExr,\n          fullscreen: !!binding.modifiers.fullscreen\n        }\n      });\n      el.instance = mask;\n      el.mask = mask.$el;\n      el.maskStyle = {};\n\n      // 如果v-loading设置的值为true，挂载maskdom(toggleLoading方法)\n      binding.value &amp;&amp; toggleLoading(el, binding);\n    },\n\n    update: function(el, binding) {\n      el.instance.setText(el.getAttribute(&#39;element-loading-text&#39;));\n      if (binding.oldValue !== binding.value) {\n        toggleLoading(el, binding);\n      }\n    },\n\n    unbind: function(el, binding) {\n      if (el.domInserted) {\n        el.mask &amp;&amp;\n        el.mask.parentNode &amp;&amp;\n        el.mask.parentNode.removeChild(el.mask);\n        toggleLoading(el, { value: false, modifiers: binding.modifiers });\n      }\n      el.instance &amp;&amp; el.instance.$destroy();\n    }\n  });</code></pre>\n<p>回过头来看看之前element UI在IE下可能会出现的两个bug</p>\n<h2 id=\"element-v-loading在ie下可能会溢出到全屏的问题\">element v-loading在IE下可能会溢出到全屏的问题</h2>\n<p>我的理解是，我觉得主要的核心在于在v-loading作用的元素上添加position:relative没有成功</p>\n<pre><code class=\"language-js\">// ...\nif (el.originalPosition !== &#39;absolute&#39; &amp;&amp; el.originalPosition !== &#39;fixed&#39;) {\n  addClass(parent, &#39;el-loading-parent--relative&#39;);\n}\n// ...</code></pre>\n<h2 id=\"element-v-loading在ie下可能会关不掉的问题\">element v-loading在IE下可能会关不掉的问题</h2>\n<p>我的理解是，当binding.value有值时，它是在Vue.nextTick下次渲染周期才挂载loading的dom，如果设置true,false间隔非常快，还没在下个渲染周期，那么其实loading已经是false了，但它才开始挂载，导致关闭不了</p>\n<pre><code class=\"language-js\">// ...\nif (binding.value) {\n    Vue.nextTick(() =&gt; {\n      if (binding.modifiers.fullscreen) {\n        el.originalPosition = getStyle(document.body, &#39;position&#39;);\n        el.originalOverflow = getStyle(document.body, &#39;overflow&#39;);\n        el.maskStyle.zIndex = PopupManager.nextZIndex();\n\n        addClass(el.mask, &#39;is-fullscreen&#39;);\n        insertDom(document.body, el, binding);\n      } else {\n        removeClass(el.mask, &#39;is-fullscreen&#39;);\n// ...</code></pre>\n<p>后面有机会在 node_modules 下修改源码加上console，然后在IE下调试看看，这个是目前来说最好的方法。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/custom-directive.html\">vue自定义指令 | Vue.js</a></li>\n<li><a href=\"https://www.yuque.com/guoqzuo/yyxr05/hp742n\">vue自定义指令笔记 | 语雀</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "v-loading指令的实现，怎么通过一个指令自动加骨架屏",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "v-loading源码"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "element v-loading在IE下可能会溢出到全屏的问题"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "element v-loading在IE下可能会关不掉的问题"
            }
          ]
        }
      ],
      "config": {
        "source": "v-loading指令的实现，怎么通过一个指令自动加骨架屏.md",
        "staticFileName": "z_loading.html",
        "author": "guoqzuo",
        "createDate": "2020/09/07",
        "description": "v-loading的实现,怎么通过一个指令自动加载骨架屏,element v-loading在IE下可能会溢出到全屏的问题,element v-loading在IE下可能会关不掉的问题，这里需要用到vue自定义指令，我们先写个v-zloading来实现loading，在loading过程中加骨架屏，由于是全局自定义指令，所以在main.js里写",
        "keywords": "v-loading的实现,怎么通过一个指令自动加载骨架屏,element v-loading在IE下可能会溢出到全屏的问题,element v-loading在IE下可能会关不掉的问题",
        "category": "Vue",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"输入过程中，怎么实时高亮部分文字xxx高亮实现\">输入过程中，怎么实时高亮部分文字(@xxx高亮实现)</h1>\n<p><img src=\"../../../images/blog/vue/input_highlight_key.gif\" alt=\"input_highlight_key.gif\"></p>\n<p>实现思路是，使用富文本编辑器，当监听到输入的文件包含关键字时，使用replace对当前的输入内容进行替换，给关键字加上span给个highlight的class，代码如下</p>\n<pre><code class=\"language-html\">&lt;div id=&quot;editdiv&quot; contenteditable&gt;&lt;/div&gt;\n&lt;script&gt;\n  let editdiv = document.querySelector(&#39;#editdiv&#39;)\n  // 输入内容改变\n  editdiv.oninput = (e) =&gt; {\n    let curValue = editdiv.innerHTML\n    console.log(&#39;当前富文本输入内容&#39;, curValue)\n    let needHighlightArr = keyArr.filter(item =&gt; curValue.includes(item))\n    // 开始高亮\n    needHighlightArr.forEach(item =&gt; {\n      console.log(item, curValue)\n      // 如果之前已经设置了highlight，就不设置了\n      let nextText = `&lt;span class=&quot;highlight&quot;&gt;${item}&lt;/span&gt;`\n      if (!curValue.includes(nextText)) {\n        curValue = curValue.replace(item, nextText)\n      }\n    })\n    editdiv.innerHTML = curValue\n  }\n&lt;/script&gt;</code></pre>\n<h2 id=\"1replace后，光标移动到了输入框最前面\">1.replace后，光标移动到了输入框最前面</h2>\n<pre><code class=\"language-js\">// 解决方法：replace后，把输入光标移动到最后面\n// set 光标到末尾\n// https://www.cnblogs.com/jonie-wong/p/5519822.html\n// div输入@光标定位\n// 知乎div编辑器，@功能的光标定位问题\n// https://segmentfault.com/q/1010000005617160\nfunction focusToElementEnd(el) {\n  el.focus();\n  if (!window.getSelection) {\n    var range = document.selection.createRange();\n    this.last = range;\n    range.moveToElementText(el);\n    range.select();\n    document.selection.empty(); //取消选中\n  }\n  else {\n    var range = document.createRange();\n    range.selectNodeContents(el);\n    range.collapse();\n    var sel = window.getSelection();\n    sel.removeAllRanges();\n    sel.addRange(range);\n  }\n}</code></pre>\n<h2 id=\"2替换后虽然高亮了，但再次输入的文字，也会一直是高亮的\">2.替换后虽然高亮了，但再次输入的文字，也会一直是高亮的</h2>\n<p>注意，后面输入的字母没有放到replace span后面</p>\n<pre><code class=\"language-js\">// [Log] 当前富文本输入内容  &quot;123zuo&quot; \n// [Log] zuo &quot;123zuo&quot;\n// [Log] 替换后，再次获取富文本输入内容 &quot;123&lt;span class=&quot;highlight&quot;&gt;zuo&lt;/span&gt;&quot;\n\n// [Log] 当前富文本输入内容 – &quot;123&lt;span class=\\&quot;highlight\\&quot;&gt;zuok&lt;/span&gt;&quot;\n// [Log] zuo – &quot;123&lt;span class=\\&quot;highlight\\&quot;&gt;zuok&lt;/span&gt;&quot;</code></pre>\n<p>网上找了下，最相似的答案是 <a href=\"https://www.jianshu.com/p/b419a695d11b\">实现动态输入关键字时关键字高亮</a>，从这里捕捉到一个很重要的信息，就是里面提到的是替换text而不是html，而我替换的是innerHTML，所以我换了下思路</p>\n<p>在onkeyup键盘抬起时对textContent进行replace，解决了这个问题</p>\n<pre><code class=\"language-js\">const keyArr = [&#39;今天&#39;, &#39;明天&#39;, &#39;上午&#39;, &#39;下午&#39;, &#39;11点&#39;, &#39;12点&#39;, &#39;zuo&#39;]\nlet editdiv = document.querySelector(&#39;#editdiv&#39;)\neditdiv.onkeyup = (e) =&gt; {\n  console.log(&#39;onkeyup&#39;, e, editdiv.textContent)\n  // document.execCommand(&#39;forecolor&#39;, false, &#39;black&#39;)\n  let curValue = editdiv.textContent\n  let needHighlightArr = keyArr.filter(item =&gt; curValue.includes(item))\n  // 开始高亮\n  needHighlightArr.forEach(item =&gt; {\n    console.log(item, curValue)\n    // 如果之前已经设置了highlight，就不设置了 class=&quot;highlight&quot;\n    let nextText = `&lt;span class=&quot;highlight&quot;&gt;${item}&lt;/span&gt;`\n    if (!curValue.includes(nextText)) {\n      curValue = curValue.replace(item, nextText)\n    }\n  })\n  editdiv.innerHTML = curValue\n  focusToElementEnd(editdiv) // 将光标移动到末尾\n}</code></pre>\n<h2 id=\"3输入法组合文件的过程中也会进行replace，中文无法输入\">3.输入法组合文件的过程中也会进行replace，中文无法输入</h2>\n<p>上面的demo还存在一个问题，就是在输入法组合文件的过程中也会进行replace，导致中文无法输入，这里我们结合之前研究<a href=\"http://www.zuo11.com/blog/2019/12/v_model_text.html\">v-model无法实时监听输入法组合文字过程</a>的经验。当组合文字时，不进行替换</p>\n<pre><code class=\"language-html\">&lt;div id=&quot;editdiv&quot; contenteditable&gt;&lt;/div&gt;\n&lt;button onclick=&quot;alert(document.querySelector(&#39;#editdiv&#39;).textContent)&quot;&gt;获取textContent&lt;/button&gt;\n&lt;button onclick=&quot;alert(document.querySelector(&#39;#editdiv&#39;).innerHTML)&quot;&gt;获取innerHTML&lt;/button&gt;\n&lt;script&gt;\n  const keyArr = [&#39;今天&#39;, &#39;明天&#39;, &#39;上午&#39;, &#39;下午&#39;, &#39;11点&#39;, &#39;12点&#39;, &#39;zuo&#39;]\n  let composition = false // 是否是在输入法组合文字的过程中\n  let editdiv = document.querySelector(&#39;#editdiv&#39;)\n\n  editdiv.onkeyup = (e) =&gt; {\n    console.log(&#39;输入法组合文字过程,composition: &#39;, composition)\n    if (composition) {\n      return \n    }\n    console.log(&#39;onkeyup&#39;, e, editdiv.textContent)\n\n    let curValue = editdiv.textContent\n    let needHighlightArr = keyArr.filter(item =&gt; curValue.includes(item))\n    // 开始高亮\n    needHighlightArr.forEach(item =&gt; {\n      console.log(item, curValue)\n      // 如果之前已经设置了highlight，就不设置了 class=&quot;highlight&quot;\n      let nextText = `&lt;span class=&quot;highlight&quot;&gt;${item}&lt;/span&gt;`\n      if (!curValue.includes(nextText)) {\n        curValue = curValue.replace(item, nextText)\n      }\n    })\n    editdiv.innerHTML = curValue\n    focusToElementEnd(editdiv) // 将光标移动到末尾\n  }\n\n  editdiv.addEventListener(&#39;compositionstart&#39;, (e) =&gt; {\n    console.log(&#39;oncompositionstart&#39;)\n    composition = true\n  });\n\n  editdiv.addEventListener(&#39;compositionend&#39;,  (e) =&gt; {\n    console.log(&#39;oncompositionend&#39;)\n    composition = false\n  });\n&lt;/script&gt;</code></pre>\n<p>以上，我们基本实现了输入过程中实时高亮关键字的功能，替换的细节还需要优化，这里只是一个实现思路。完整demo参见: <a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%AB%98%E4%BA%AE%E5%85%B3%E9%94%AE%E5%AD%97/index.html\">输入内容过程中高亮关键字 | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "输入过程中，怎么实时高亮部分文字(@xxx高亮实现)",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "1.replace后，光标移动到了输入框最前面"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "2.替换后虽然高亮了，但再次输入的文字，也会一直是高亮的"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "3.输入法组合文件的过程中也会进行replace，中文无法输入"
            }
          ]
        }
      ],
      "config": {
        "source": "输入过程中，怎么实时高亮部分文字(@xxx高亮实现).md",
        "staticFileName": "highlight_when_input.html",
        "author": "guoqzuo",
        "createDate": "2020/09/07",
        "description": "输入过程中高亮部分文字,输入过程中高亮关键字,前端@高亮实现,输入过程中，怎么实时高亮部分文字(@xxx高亮实现)，实现思路是，使用富文本编辑器，当监听到输入的文件包含关键字时，使用replace对当前的输入内容进行替换，给关键字加上span给个highlight的class，代码如下",
        "keywords": "输入过程中高亮部分文字,输入过程中高亮关键字,前端@高亮实现",
        "category": "Vue",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"echarts画高自定义仪表盘，echart本质是图的堆叠\">echarts画高自定义仪表盘，echart本质是图的堆叠</h1>\n<p>最近有个UI需求，画一个自定义的仪表盘，看起来很不好实现，后面在看了echarts社区的一些例子，经过写demo测试后，找到了规律，<strong>核心是化繁为简，对于复杂的UI，可以拆分为多个小的模块，一个个实现</strong></p>\n<p><img src=\"../../../images/blog/vue/echarts_round.png\" alt=\"echarts_round.png\"></p>\n<p>下面是一个很粗糙的测试demo，option如下，完整demo参见: <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/views/echarts\">自定义仪表盘 | github</a></p>\n<pre><code class=\"language-js\">var placeHolderStyle = {\n  normal: {\n    label: {\n      show: false\n    },\n    labelLine: {\n      show: false\n    },\n    color: &quot;rgba(0,0,0,0)&quot;,\n    borderWidth: 0\n  },\n  emphasis: {\n    color: &quot;rgba(0,0,0,0)&quot;,\n    borderWidth: 0\n  }\n};\n\nvar bg = [\n  {\n    type: &quot;pie&quot;,\n    radius: &quot;53%&quot;, // 半径\n    center: [\n      // 圆心\n      &quot;40%&quot;,\n      &quot;50%&quot;\n    ],\n    z: 1,\n    itemStyle: {\n      normal: {\n        color: {\n          type: &quot;linear&quot;,\n          x: 0,\n          y: 0,\n          x2: 0,\n          y2: 1,\n          colorStops: [\n            {\n              offset: 0,\n              color: &quot;#ffffff&quot; // 0% 处的颜色\n            },\n            {\n              offset: 1,\n              color: &quot;#f3f4f9&quot; // 100% 处的颜色\n            }\n          ],\n          global: false // 缺省为 false\n        },\n        label: {\n          show: false\n        },\n        labelLine: {\n          show: false\n        }\n      }\n    },\n    hoverAnimation: false,\n    label: {\n      show: false\n    },\n    tooltip: {\n      show: false\n    },\n    data: [\n      {\n        value: 70 // 背景部分\n      },\n      {\n        value: 30, // 空缺部分\n        itemStyle: {\n          color: &quot;transparent&quot;\n        }\n      }\n    ],\n    startAngle: 216\n  }\n];\n\n// 仪表盘外层\nvar roundList = [\n  {\n    type: &quot;pie&quot;,\n    hoverAnimation: true, //鼠标经过的特效\n    radius: [&quot;50%&quot;, &quot;55%&quot;],\n    center: [&quot;40%&quot;, &quot;50%&quot;],\n    startAngle: 180,\n    labelLine: {\n      normal: {\n        show: false\n      }\n    },\n    label: {\n      normal: {\n        position: &quot;center&quot;\n      }\n    },\n    data: [\n      {\n        value: 100, // 显示长度\n        itemStyle: {\n          normal: {\n            color: &quot;rgba(236,172,112, 1.0)&quot; // 橙色 1\n          }\n        }\n      },\n      {\n        value: 100, // 总长度\n        itemStyle: placeHolderStyle\n      }\n    ]\n  },\n\n  {\n    type: &quot;pie&quot;,\n    hoverAnimation: false, //鼠标经过的特效\n    radius: [&quot;50%&quot;, &quot;55%&quot;], // 内半径、外半径\n    center: [&quot;40%&quot;, &quot;50%&quot;], // 圆心坐标, 距离左侧、顶部\n    startAngle: 180, // 0 为圆心左侧开始，起始角度，支持范围[0, 360]。\n    labelLine: {\n      normal: {\n        show: false\n      }\n    },\n    label: {\n      normal: {\n        position: &quot;center&quot;\n      }\n    },\n    data: [\n      {\n        value: 11,\n        itemStyle: {\n          normal: {\n            color: &quot;white&quot; // 3 紫色\n          }\n        }\n        // label: dataStyle, 显示标签\n      },\n      {\n        value: 100,\n        itemStyle: placeHolderStyle\n      }\n    ]\n  },\n\n  //上层环形配置\n  {\n    type: &quot;pie&quot;,\n    hoverAnimation: false, //鼠标经过的特效\n    radius: [&quot;50%&quot;, &quot;55%&quot;], // 内半径、外半径\n    center: [&quot;40%&quot;, &quot;50%&quot;], // 圆心坐标, 距离左侧、顶部\n    startAngle: 180, // 0 为圆心左侧开始，起始角度，支持范围[0, 360]。\n    labelLine: {\n      normal: {\n        show: false\n      }\n    },\n    label: {\n      normal: {\n        position: &quot;center&quot;\n      }\n    },\n    data: [\n      {\n        value: 10,\n        itemStyle: {\n          normal: {\n            color: &quot;rgba(170,185,227,1.0)&quot; // 3 紫色\n          }\n        }\n        // label: dataStyle,  // label: dataStyle, 显示标签\n      },\n      {\n        value: 100,\n        itemStyle: placeHolderStyle\n      }\n    ]\n  }\n];\n\nvar pointer = [\n  {\n    name: &quot;指针&quot;,\n    type: &quot;gauge&quot;,\n    title: {\n      show: false\n    },\n    detail: {\n      show: false\n    },\n    data: [\n      {\n        value: 29\n      }\n    ],\n    radius: &quot;55%&quot;, // 内半径、外半径\n    center: [&quot;40%&quot;, &quot;50%&quot;], // 圆心坐标, 距离左侧、顶部\n    itemStyle: {\n      color: &quot;#000&quot;\n    },\n    axisLine: {\n      lineStyle: {\n        show: false,\n        width: 0\n      }\n    },\n    axisLabel: {\n      show: false\n    },\n    axisTick: {\n      show: false\n    },\n    splitLine: {\n      show: false\n    },\n    pointer: {\n      show: true,\n      length: &quot;80%&quot;,\n      width: 40\n    }\n  }\n];\n\nvar circles = [\n  {\n    type: &quot;pie&quot;,\n    radius: &quot;80&quot;, // 半径\n    center: [\n      // 圆心\n      &quot;40%&quot;,\n      &quot;50%&quot;\n    ],\n    z: 10,\n    itemStyle: {\n      normal: {\n        color: &quot;#fff&quot;,\n        label: {\n          show: true\n        },\n        labelLine: {\n          show: false\n        },\n        shadowColor: &quot;rgba(122, 122, 122, 0.21)&quot;,\n        shadowBlur: 30\n      }\n    },\n    animation: false,\n    tooltip: {\n      show: false\n    },\n    data: [\n      {\n        value: 36, // 背景部分\n        label: {\n          normal: {\n            formatter: &quot;{c}%&quot;,\n            position: &quot;center&quot;,\n            show: true,\n            textStyle: {\n              fontSize: &quot;40&quot;,\n              fontFamily: &quot;Impact&quot;,\n              fontWeight: &quot;normal&quot;,\n              color: &quot;#4a4a4a&quot;\n            }\n          }\n        }\n      }\n    ],\n    startAngle: 0,\n    text: &quot;36%&quot;,\n    textStyle: {\n      color: &quot;red&quot;\n    }\n  },\n  {\n    name: &quot;Line&quot;,\n    type: &quot;pie&quot;, // 圆圈\n    clockWise: false,\n    radius: [&quot;28%&quot;, &quot;28.5%&quot;],\n    center: [\n      // 圆心\n      &quot;40%&quot;,\n      &quot;50%&quot;\n    ],\n    z: 11,\n    tooltip: {\n      show: false\n    },\n    label: {\n      show: false\n    },\n    animation: false,\n    data: [\n      {\n        value: 100,\n        itemStyle: {\n          color: &quot;#ececec&quot;\n        }\n      }\n    ]\n  }\n];\n\nvar texts = [];\n\nvar option = {\n  backgroundColor: &quot;#fff&quot;,\n  title: [\n    {\n      text: &quot;0&quot;,\n      left: &quot;13%&quot;,\n      top: &quot;51%&quot;,\n      textAlign: &quot;center&quot;,\n      textStyle: {\n        fontWeight: &quot;normal&quot;,\n        fontFamily: &quot;PingFangSC-Semibold&quot;,\n        fontSize: &quot;16&quot;,\n        color: &quot;#4a4a4a&quot;,\n        textAlign: &quot;center&quot;\n      }\n    },\n    {\n      text: &quot;48万&quot;,\n      left: &quot;65%&quot;,\n      top: &quot;51%&quot;,\n      textAlign: &quot;center&quot;,\n      textStyle: {\n        color: &quot;#4a4a4a&quot;,\n        fontFamily: &quot;PingFangSC-Semibold&quot;,\n        fontWeight: &quot;normal&quot;,\n        fontSize: &quot;16&quot;,\n        textAlign: &quot;center&quot;\n      }\n    }\n  ],\n  series: [\n    ...bg, // 背景\n    ...roundList, // 最外面顶部样式\n    ...pointer, // 指针\n    ...circles, // 中间圆圈部分\n    ...texts // 左右侧文字\n  ]\n};\n\nconsole.log(option);</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "echarts画高自定义仪表盘，echart本质是图的堆叠"
        }
      ],
      "config": {
        "source": "echarts画高自定义仪表盘，echart本质是图的堆叠.md",
        "staticFileName": "echart_dashboard.html",
        "author": "guoqzuo",
        "createDate": "2020/09/07",
        "description": "echart自定义仪表盘,echarts复杂图,echart堆叠图,最近有个UI需求，画一个自定义的仪表盘，看起来很不好实现，后面在看了echarts社区的一些例子，经过写demo测试后，找到了规律，核心是化繁为简，对于复杂的UI，可以拆分为多个小的模块，一个个实现",
        "keywords": "echart自定义仪表盘,echarts复杂图,echart堆叠图",
        "category": "图表可视化",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"macos大小写不敏感，修改文件名大小写后git会异常\">macos大小写不敏感，修改文件名大小写后git会异常</h1>\n<p>macos是文件大小写不敏感的系统，而widonws/linux是大小写敏感的，假设把git上之前提交过的文件，修改大小写，再次提交后，git上会出现两个大小写不一样的文件？为什么呢</p>\n<p>macos是大小写不敏感的文件系统，也就是在macos上你无法在同一个目录下同时创建test.vue和Test.vue，如果出现这种情况，本地感知不到文件的改动，但git服务器却有记录这两个文件。</p>\n<p>最好的解决方法是将整个文件名都变更。而不是仅改变大小写</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "macos大小写不敏感，修改文件名大小写后git会异常"
        }
      ],
      "config": {
        "source": "macos大小写不敏感，修改文件名大小写后git会异常.md",
        "staticFileName": "mac_git_case.html",
        "author": "guoqzuo",
        "createDate": "2020/09/07",
        "description": "怎么解决git修改文件大小后报错,git修改文件大小写,mac上git修改文件大小写,macos是文件大小写不敏感的系统，而widonws/linux是大小写敏感的，假设把git上之前提交过的文件，修改大小写，再次提交后，git上会出现两个大小写不一样的文件？为什么呢。macos是大小写不敏感的文件系统，也就是在macos上你无法在同一个目录下同时创建test.vue和Test.vue，如果出现这种情况，本地感知不到文件的改动，但git服务器却有记录这两个文件。最好的解决方法是将整个文件名都变更。而不是仅改变大小写",
        "keywords": "怎么解决git修改文件大小后报错,git修改文件大小写,mac上git修改文件大小写",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"通过koa写demo彻底理解前端http缓存\">通过koa写demo彻底理解前端http缓存</h1>\n<p>在前端性能优化中，有一个方法是使用缓存。前端缓存可以减少网络请求次数，减少流量消耗，提升用户体验，降低服务器负载。</p>\n<p>前端缓存分为两种：http缓存、浏览器缓存，这里主要介绍http缓存</p>\n<blockquote>\n<p>相关文档可以搜索对应请求头的MDN文档、另外可以参考《http权威指南》第7章 缓存</p>\n</blockquote>\n<p>http缓存策略的核心在于<strong>新鲜度检测</strong>，一般有两种策略来保持已缓存数据与服务器数据之间的充分一致</p>\n<ol>\n<li>强缓存 - 设置文档过期时间(document expiration)：给当前请求设置一个过期时间，这段时间内可以直接使用缓存数据，不必再去请求服务器拿数据</li>\n<li>弱缓存/协商缓存 - 服务器再验证(server revalidation)：服务器响应某个请求时，在响应头加一个版本信息或最后一次修改时间的标记，当下次该请求发生时，请求头会携带这个标记信息，服务器会通过标记值来判断是否使用缓存内容</li>\n</ol>\n<h2 id=\"强缓存-document-expiration\">强缓存 document expiration</h2>\n<p>当第一次发送某个http请求后，会把内容缓存一段时间。在这段时间里，都认为内容是 &quot;新鲜的&quot;，可以在不联系服务器的情况下，直接响应该文档。</p>\n<h3 id=\"expires相对时间\">Expires(相对时间)</h3>\n<p>Expires [ɪk&#39;spaɪəz] 响应头包含日期/时间， 即在此时候之后，响应过期。无效的日期，比如 0, 代表着过去的日期，即该资源已经过期。如果在Cache-Control响应头设置了 &quot;max-age&quot; 或者 &quot;s-max-age&quot; 指令，那么 Expires 头会被忽略。</p>\n<p>我们来写个demo试试，我们用koa来写个listData接口，将接口的Expires时间设置为当前时间+1小时，也就是一个小时后失效，koa代码如下</p>\n<pre><code class=\"language-js\">const Koa = require(&#39;koa&#39;)\nconst Router = require(&#39;koa-router&#39;)\nconst app = new Koa()\nconst router = new Router()\n\napp.use(require(&#39;koa-static&#39;)(__dirname + &#39;/public&#39;))\n\nrouter.get(&#39;/listData&#39;, ctx =&gt; {\n  // 打印log，用来看服务端是否收到了请求\n  console.log(&#39;recive req&#39;, ctx.url)\n  // 实际效果：Expires: Sat Jul 04 2020 19:28:42 GMT+0800 (GMT+08:00)\n  ctx.set(&#39;Expires&#39;, new Date(+new Date() + 3600 * 1000)) // UTC时间\n  ctx.body = {\n    info: &#39;hello world&#39;\n  }\n})\n\napp.use(router.routes()).use(router.allowedMethods())\napp.listen(9000, () =&gt; {\n  console.log(&#39;server start on 9000 port&#39;)\n})</code></pre>\n<p>前端测试demo：public/index.html如下</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n  &lt;div&gt; \n    &lt;button id=&quot;btn&quot;&gt;发送请求&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    let btn = document.getElementById(&#39;btn&#39;)\n    btn.onclick = () =&gt; {\n      sendRequest()\n    }\n\n    async function sendRequest() {\n      try {\n        let res = await  axios.get(&#39;/listData&#39;);\n        console.log(res)\n      } catch(e) {\n        console.log(e)\n      }\n    }\n  &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p>当我们点击两次发送请求，测试结果如下：第一次请求时正常接收请求，由于我们设置了Expires响应头，前端再次请求时，服务端没有接收到请求，浏览器直接从硬盘读的缓存(from disk cache)，响应头对比图如下</p>\n<p><img src=\"../../../images/blog/web/expires_header.png\" alt=\"expires_header.png\"></p>\n<p>参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires\">Expires - HTTP | MDN</a></p>\n<h3 id=\"cache-control\">Cache-Control</h3>\n<p>Expries是http1.0的标准，在HTTP/1.1版本里，Expire已经被Cache-Control替代，除了可以设置时间外，还加了更多控制，Cache-Control可以设置很多值</p>\n<p>可缓存性相关值</p>\n<ul>\n<li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li>\n<li>private：所有内容只有客户端可以缓存，（即代理服务器不能缓存它）Cache-Control的默认取值</li>\n<li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定（除非资源进行了再验证(协商缓存验证)，否则客户端不会使用已换成的资源）</li>\n<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存（缓存应当尽快从服务器中删除文档的所有痕迹，因为其中可能包含敏感信息）</li>\n</ul>\n<p>到期相关值</p>\n<ul>\n<li>max-age=seconds 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。</li>\n<li>s-maxage=seconds 覆盖max-age或者Expires头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。</li>\n</ul>\n<p>我们将上个例子中设置Expires替换为Cache-Control的写法</p>\n<pre><code class=\"language-js\">ctx.set(&quot;Cache-control&quot;, &quot;max-age=3600&quot;)  // 设置缓存有效时间为3600s，1个小时</code></pre>\n<p>执行结果和之前的基本一致，只是响应头有点变化，如下图</p>\n<p><img src=\"../../../images/blog/web/cachecontrol_max-age.png\" alt=\"cachecontrol_max-age.png\"></p>\n<p>这里要特别注意，Catch-Control不止响应头可以设置，前端在请求头也是可以设置的</p>\n<pre><code class=\"language-bash\">Cache-Control: max-age=&lt;seconds&gt; # 如果后端不设置改值，前端无效\nCache-Control: max-stale[=&lt;seconds&gt;]\nCache-Control: min-fresh=&lt;seconds&gt;\nCache-control: no-cache  # 可以使用，等价于 Pragma: no-cache\nCache-control: no-store\nCache-control: no-transform\nCache-control: only-if-cached</code></pre>\n<p>我们可以在axios请求时加请求头参数</p>\n<pre><code class=\"language-js\">let res = await  axios.get(&#39;/listData&#39;, {\n  headers: {&#39;Cache-Control&#39;: &#39;no-cache&#39;}, // 如果前端使用这个请求头，那么后端设置的max-age或Expires就会被忽略\n});</code></pre>\n<p>参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control\">Cache-Control - HTTP | MDN</a></p>\n<h2 id=\"弱缓存协商缓存-server-revalidation\">弱缓存/协商缓存 server revalidation</h2>\n<p>直接给某个请求设置缓存有效期是简单粗暴的方法，因为一般我们无法准确的知道需要缓存的资源具体可能会变动的时间。于是就有了服务器再验证的这种策略，注意下面讨论的是get请求，涉及到304状态码，对于412相关的post参见具体的mdn文档</p>\n<p><img src=\"../../../images/blog/web/week_cache.png\" alt=\"week_cache.png\"></p>\n<h3 id=\"last-modifiedif-modified-since\">Last-Modified/If-Modified-Since</h3>\n<p>在响应某个请求时，响应头加一个Last-Modified，值设置为某个资源的最后一次修改时间。注意：这里会有一个问题，加了Last-Modified后，下次请求浏览器直接使用了强缓存，直接读disk cache，没有请求服务器，那我们服务器再验证就验证不了，所以需要设置一个no-cache的请求头，不使用强缓存，代码如下：</p>\n<pre><code class=\"language-js\">let fileInfo = fs.statSync(&#39;./public/index.html&#39;)\nlet mtime = fileInfo.mtime\nctx.set(&quot;Cache-control&quot;,&quot;no-cache&quot;);\nctx.set(&quot;Last-Modified&quot;, mtime)</code></pre>\n<p>这样设置后，下次请求时，请求头会自动携带If-Modified-Since，值为之前响应头设置的Last-Modified的值，然后我们根据If-Modified-Since请求头的时间，与某个文件修改的时间进行比对，如果相等，直接返回304状态码，浏览器会使用该接口上一次接口的缓存的数据</p>\n<pre><code class=\"language-js\">// 完整接口如下\nrouter.get(&#39;/listData&#39;, ctx =&gt; {\n  console.log(&#39;recive req&#39;, ctx.url)\n  let fileInfo = fs.statSync(&#39;./public/index.html&#39;)\n  let mtime = fileInfo.mtime\n  // console.log(fileInfo, fileInfo.mtime)\n  // 响应头设置后，下次这个请求会在请求头自动加上 If-Modified-Since: Sat Jul 04 2020 21:19:30 GMT+0800 (GMT+08:00) 字段\n  console.log(ctx.headers)\n  ctx.set(&quot;Cache-control&quot;,&quot;no-cache&quot;);\n  ctx.set(&quot;Last-Modified&quot;, mtime)\n  if (ctx.headers[&#39;if-modified-since&#39;] &amp;&amp; ctx.headers[&#39;if-modified-since&#39;] == mtime) {\n    console.log(&quot;304&quot;);\n    ctx.status = 304\n  } else {\n    ctx.body = {\n      info: &#39;hello world&#39;\n    }\n  }\n})</code></pre>\n<p>注意：<strong>当与 If-None-Match 一同出现时，它（If-Modified-Since）会被忽略掉，除非服务器不支持 If-None-Match。</strong></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified\">Last-Modified - HTTP | MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since\">If-Modified-Since - HTTP | MDN</a></li>\n</ul>\n<h3 id=\"etagif-none-macth\">ETag/if-None-Macth</h3>\n<p>有些请求验证最后修改时间是不够的，比如：</p>\n<ul>\n<li>某些文件会被周期性的重写，但文件内容是一样的，可最后一次修改时间变了</li>\n<li>有些文档被改了，但改动并不重要，比如拼写或注释的修改，不需要让所有缓存都更新</li>\n<li>有些文档会在亚秒间发生变化，对设置服务器来说，1s的粒度会不够用</li>\n</ul>\n<p>因此，Last-Modified由于精确度比ETag(实体标签)要低，所以Last-Modified只是一个备用机制。一般Last-Modified设置的是修改时间，而ETag设置的一般是某个资源的标识符(版本号或者md5，表示一个文件的指纹fingerprints)，来看代码</p>\n<pre><code class=\"language-js\">const calcMd5 = require(&#39;./md5&#39;)\nrouter.get(&#39;/listData&#39;, (ctx, next) =&gt; {\n  console.log(&#39;recive req&#39;, ctx.url)\n  let md5 =  calcMd5(&#39;./public/index.html&#39;)\n  ctx.set(&quot;Cache-control&quot;,&quot;no-cache&quot;);\n  ctx.set(&#39;ETag&#39;, md5)\n  if (ctx.headers[&#39;if-none-match&#39;] &amp;&amp; ctx.headers[&#39;if-none-match&#39;] === md5) {\n    console.log(&quot;304&quot;);\n    ctx.status = 304\n  } else {\n    ctx.body = {\n      info: &#39;hello world&#39;\n    }\n  }\n})</code></pre>\n<p>md5.js 计算文件md5</p>\n<pre><code class=\"language-js\">const crypto = require(&#39;crypto&#39;);\nconst fs = require(&#39;fs&#39;);\n\nmodule.exports = (filePath) =&gt; {\n    //读取一个Buffer\n    let buffer = fs.readFileSync(filePath);\n    let fsHash = crypto.createHash(&#39;md5&#39;);\n\n    fsHash.update(buffer);\n    return fsHash.digest(&#39;hex&#39;);\n}</code></pre>\n<p>参考:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag\">ETag - HTTP | MDN</a> </li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match\">If-None-Match - HTTP| MDN</a></li>\n</ul>\n<h2 id=\"chrome下注意事项\">Chrome下注意事项</h2>\n<p>在进行缓存测试时，你会发现浏览器的真实情况和书上或文档里的会有一点不一样的地方，我们需要注意：</p>\n<ol>\n<li><strong>如果ETag和If-None-Match的值一致，且koa返回了304，但前端一直是200时，可能是浏览器的问题，关掉浏览器当前页面，再打开可能就好了</strong>。这一块调的我差点怀疑人生</li>\n<li><strong>书上或文档里说，no-cache只是不使用强缓存，需要服务器二次验证、而no-store是既不使用强缓存也不使用协商缓存，但是在chrome浏览器里，如果你的请求头里有Cache-Control&#39;: &#39;no-cache&#39;，不管是强缓存还是协商缓存都不会生效；</strong></li>\n<li><strong>在F12 chrome调试面板，勾选disable cache，请求头会自动携带Pragma: no-cache，等价于请求头里设置cache-control： no-cache</strong></li>\n<li><strong>在chrome浏览器下，请求头里使用Cache-Control&#39;: &#39;no-store&#39;，没有任何用处</strong></li>\n</ol>\n<p>关于以上完整的HTTP缓存测试demo，参见 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/DebugDemo/%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98\">http缓存测试 | github</a></p>\n<p>参考:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Headers/Pragma\">Pragma - HTTP | MDN</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "通过koa写demo彻底理解前端http缓存",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "强缓存 document expiration",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "Expires(相对时间)"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "Cache-Control"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "弱缓存/协商缓存 server revalidation",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "Last-Modified/If-Modified-Since"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "ETag/if-None-Macth"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "Chrome下注意事项"
            }
          ]
        }
      ],
      "config": {
        "source": "通过koa写demo彻底理解前端http缓存.md",
        "staticFileName": "web_cache.html",
        "author": "guoqzuo",
        "createDate": "2020/09/07",
        "description": "http缓存,web缓存,前端缓存,强缓存,Expires,Cache-Control,弱缓存,协商缓存,sever revalidataion,Last-Modified/If-Modified-Since,ETag/if-None-Macth,在前端性能优化中，有一个方法是使用缓存。前端缓存可以减少网络请求次数，减少流量消耗，提升用户体验，降低服务器负载。前端缓存分为两种：http缓存、浏览器缓存。相关文档可以搜索对应请求头的MDN文档、另外可以参考《http权威指南》第7章 缓存",
        "keywords": "http缓存,web缓存,前端缓存,强缓存,Expires,Cache-Control,弱缓存,协商缓存,sever revalidataion,Last-Modified/If-Modified-Since,ETag/if-None-Macth",
        "category": "http与https",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue中为什么要使用js调用单文件组件？怎么实现js调用组件？\">vue中为什么要使用js调用单文件组件？怎么实现js调用组件？</h1>\n<p>如果自己写一个组件。一般情况下，vue项目中在某个组件里调用另一个组件，至少需要修改三个位置</p>\n<ol>\n<li>在 template 里写引入组件，加上传参等</li>\n<li>在 components 里声明组件（如果全局引入了，可以省去这一步）</li>\n<li>data 里面写对应的传参数</li>\n</ol>\n<p>代码对应如下，这种组件对于使用地方比较多时候，我们就需要想办法直接使用js来调用组件，而不是每次都要在 template 里面声明对应的组件，这样会有很多重复代码，可维护性较差。</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;el-button @click=&quot;showToast&quot;&gt;打开toast&lt;/el-button&gt;\n  &lt;!-- template中使用组件 --&gt;\n  &lt;toast v-model=&quot;showToast&quot;&gt;&lt;/toast&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  components: {\n    Toast: () =&gt; import(&#39;./Toast.vue&#39;)\n  }\n  data() {\n    return {\n      showToast: false\n    }\n  }\n}\n&lt;/script&gt;</code></pre>\n<h2 id=\"较早之前使用js加载组件尝试\">较早之前使用js加载组件尝试</h2>\n<p>在较早之前，用js写过一个直接挂载组件到当前dom上的一个方法，分三步：</p>\n<ol>\n<li>使用 Vue.extend，处理需要用js调用的vue单文件组件，返回该vue组件的一个子类</li>\n<li>new对应的组件子类，生成对应的组件实例，并使用 <code>.$mount()</code> 挂载组件，返回对应组件的 vm</li>\n<li>这样可以通过 vm.$el 拿到组件dom，append到当前组件dom里，即可完成加载</li>\n</ol>\n<p>具体写法如下</p>\n<pre><code class=\"language-js\">// 假设写好了 showInfo.vue 组件，执行clickShow函数直接显示dialog\n// 组件中 dialog :visible.sync=&quot;dialogTableVisible&quot;初始值设置为true\n\n// demo.vue 在需要调用的vue文件中引入该组件\nimport ShowInfo from &#39;showInfo.vue&#39;\n// ...\nclickShow() {\n  const Component = Vue.extend(ShowInfo)\n\n  // 挂载后返回对应组件的vm\n  let showInfoVue = new Component().$mount() \n\n  // 将组件vm的dom，append到当前页面\n  this.$el.appendChild(showInfoVue.$el) \n}\n// ... </code></pre>\n<p>具体参考：<a href=\"http://www.zuo11.com/blog/2020/2/js_vue_comp.html\">使用js调用vue单文件组件</a></p>\n<p>但它有一个缺点，常规调用组件时，我们会向子组件里面传入参数或事件。而这种情况不能向调用的子组件传入参数。下面来看另一种方法</p>\n<h2 id=\"使用js将单文件组件挂载到body的通用方法\">使用js将单文件组件挂载到body的通用方法</h2>\n<p>我们来看看下面的create方法，其实和上面的方法流程基本一致，只是改变了创建对应vue单文件组件实例的方法。这里用render函数来替代之前的Vue.extend来创建对应组件实例，这样可以通过render函数的createElement函数向子组件内部传参数，传方法等。</p>\n<pre><code class=\"language-js\">// create.js\nimport Vue from &quot;vue&quot;;\n\nexport default function create(Component, props) {\n  // 先创建实例\n  const vm = new Vue({\n    render(h) {\n      // h就是createElement，它返回VNode\n      return h(Component, { props });\n    }\n  }).$mount();\n\n  // 手动挂载\n  document.body.appendChild(vm.$el);\n\n  // 销毁方法\n  const comp = vm.$children[0];\n  comp.remove = function() {\n    document.body.removeChild(vm.$el);\n    vm.$destroy();\n  };\n  return comp;\n}</code></pre>\n<p>上面的例子中，create函数参数接收一个单文件组件对象，以及在调用组件时需要传递给组件的参数，来看看具体使用例子</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;el-button @click=&quot;showToast&quot;&gt;打开toast&lt;/el-button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport Toast from &quot;./Toast.vue&quot;;\nimport create from &quot;./create&quot;;\nexport default {\n  methods: {\n    showToast() {\n      console.log(&quot;show toast&quot;);\n      let toast = create(Toast, {\n        show: true,\n        message: &quot;我是错误信息&quot;,\n        type: &quot;error&quot;\n      });\n      // 等价于 &lt;toast :show=&quot;true&quot; message=&quot;xx&quot; :type=&quot;error&quot;&gt;&lt;/toast&gt;\n      console.log(toast);\n      setTimeout(() =&gt; {\n        toast.remove();\n      }, 2000);\n    }\n  }\n};\n&lt;/script&gt;</code></pre>\n<p>Toast.vue 单文件组件代码如下</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div class=&quot;my-toast&quot; v-if=&quot;show&quot;&gt;\n    &lt;div :class=&quot;type&quot;&gt;{{ message }}&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  props: {\n    message: {\n      type: String,\n      required: true\n    },\n    type: {\n      type: String,\n      default: &quot;error&quot;\n    }\n    show: {\n      type: Boolean,\n    }\n  }\n};\n&lt;/script&gt;\n&lt;style lang=&quot;less&quot; scoped&gt;\n.my-toast {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  width: 300px;\n  border: 1px solid #ccc;\n  text-align: center;\n  .error {\n    color: red;\n  }\n  .success {\n    color: green;\n  }\n}\n&lt;/style&gt;</code></pre>\n<h2 id=\"再进一步封装\">再进一步封装</h2>\n<p>上面的例子中，我们引入了 create.js 以及 对应的单文件组件。它还是不够简洁，我们可以再封装一次，只需要调用一个js就搞定。如果我们将它在main.js里面引入并挂载到vue实例属性，那么调用就非常方便了。</p>\n<pre><code class=\"language-js\">// 在main.js里注册实例属性\nimport showDialog from &#39;@/views/jsDialog/index.js&#39;\nVue.prototype.$showDialog = showDialog\n\n// 其他地方直接使用 this.$showDialog(options) 即可调用组件</code></pre>\n<p>下面来看看实现思路，关于render函数createElement的options的配置，参见 <a href=\"https://cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1\">createElement 参数 - 深入数据对象</a></p>\n<pre><code class=\"language-js\">// showDialog/index.js\nimport Vue from &quot;vue&quot;;\nimport DialogComponent from &#39;@/views/jsDialog/src/index.vue&#39;\n\nlet TheDialog = null\nexport default function showDialog(options) {\n  // 如果未移除，先移除\n  TheDialog &amp;&amp; TheDialog.remove()\n\n  TheDialog = create(DialogComponent, {\n    on: {\n      // 单文件组件内部可以emit该事件，销毁TheDialog组件\n      &#39;close-dialog&#39;: () =&gt; {\n        TheDialog.remove()\n      }\n    },\n    props: {\n      // 需要传入的属性，单文件组件需要使用props接收\n      title: &#39;标题&#39;,\n      content: &#39;内容&#39; \n    }\n    // 其他参数\n    ...options\n  })\n\n  function create(Component, options) {\n    // 先创建实例\n    const vm = new Vue({\n      render(h) {\n        // h就是createElement，它返回VNode\n        return h(Component, options);\n      }\n    }).$mount();\n\n    // 手动挂载\n    document.body.appendChild(vm.$el);\n\n    // 销毁方法\n    const comp = vm.$children[0];\n    comp.remove = function() {\n      document.body.removeChild(vm.$el);\n      vm.$destroy();\n    };\n    return comp;\n  }\n}</code></pre>\n<p><strong>注意，虽然js调用更方便了，但js处理、render组件的传参复杂度会增加。它和普通组件各有各的优缺点。</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue中为什么要使用js调用单文件组件？怎么实现js调用组件？",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "较早之前使用js加载组件尝试"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "使用js将单文件组件挂载到body的通用方法"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "再进一步封装"
            }
          ]
        }
      ],
      "config": {
        "source": "vue中为什么要使用js调用单文件组件？怎么实现js调用组件？.md",
        "staticFileName": "vue_why_js_comp.html",
        "author": "guoqzuo",
        "createDate": "2020/09/12",
        "description": "vue js直接调用组件,js调用vue组件,js加载vue组件,js vue组件，如果自己写一个组件。一般情况下，vue项目中在某个组件里调用另一个组件，至少需要修改三个位置 1. 在 template 里写引入组件，加上传参等 2. 在 components 里声明组件（如果全局引入了，可以省去这一步） 3. data 里面写对应的传参数 代码对应如下，这种组件对于使用地方比较多时候，我们就需要想办法直接使用js来调用组件，而不是每次都要在 template 里面声明对应的组件，这样会有很多重复代码，可维护性较差。",
        "keywords": "vue js直接调用组件,js调用vue组件,js加载vue组件,js vue组件",
        "category": "Vue",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"axios取消请求具体使用场景及实现原理\">axios取消请求具体使用场景及实现原理</h1>\n<p>取消请求在前端有时候会用到，以下是两个工作中可能会用到的场景</p>\n<ol>\n<li>tab切换时刷新某个列表数据，如果他们共用一个变量存储数据列表，当请求有延时，可能会导致两个tab数据错乱</li>\n<li>导出文件或下载文件时，中途取消</li>\n</ol>\n<p>下面来看看axios是怎么取消请求的，以及对应的原理</p>\n<pre><code class=\"language-js\">const CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\n\n// get 方法 假设这个接口需要50s才返回\naxios.get(&#39;/user/12345&#39;, {\n  cancelToken: source.token\n}).catch(function (thrown) {\n  if (axios.isCancel(thrown)) {\n    console.log(&#39;Request canceled&#39;, thrown.message);\n  } else {\n    // handle error\n  }\n});\n\n// post 方法时 假设这个接口需要50s才返回\n// axios.post(&#39;/user/12345&#39;, {\n//   name: &#39;new name&#39;\n// }, {\n//   cancelToken: source.token\n// })\n\n// 3庙后取消请求\nsetTimeout(() =&gt; {\n  // cancel the request (the message parameter is optional)\n  source.cancel(&#39;Operation canceled by the user.&#39;);\n}, 3000)</code></pre>\n<h2 id=\"axios是怎么实现取消请求的\">axios是怎么实现取消请求的</h2>\n<p>本质上axios是对 XMLHttpRequest 的封装，取消请求时，使用XMLHttpRequest实例的 abort() 方法即可取消请求。</p>\n<p>我们在node_modules里面axios目录下搜索 abort 即可找到对应的源码</p>\n<pre><code class=\"language-js\">// 源码截取至 https://github.com/axios/axios/blob/master/lib/adapters/xhr.js\nif (config.cancelToken) {\n  // Handle cancellation\n  config.cancelToken.promise.then(function onCanceled(cancel) {\n    if (!request) {\n      return;\n    }\n\n    request.abort();\n    reject(cancel);\n    // Clean up request\n    request = null;\n  });\n}</code></pre>\n<p>参考：<a href=\"https://github.com/axios/axios#cancellation\">axios cancellation | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "axios取消请求具体使用场景及实现原理",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "axios是怎么实现取消请求的"
            }
          ]
        }
      ],
      "config": {
        "source": "axios取消请求具体使用场景及实现原理.md",
        "staticFileName": "axios_cancel.html",
        "author": "guoqzuo",
        "createDate": "2020/09/12",
        "description": "axios取消请求用法,axios取消请求是怎么实现的,axios取消请求原理，取消请求在前端有时候会用到，以下是两个工作中可能会用到的场景 1. tab切换时刷新某个列表数据，如果他们共用一个变量存储数据列表，当请求有延时，可能会导致两个tab数据错乱 2. 导出文件或下载文件时，中途取消 下面来看看axios是怎么取消请求的，以及对应的原理",
        "keywords": "axios取消请求用法,axios取消请求是怎么实现的,axios取消请求原理",
        "category": "http与https",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"imovie剪辑的视频没有全屏显示，上下被截断的解决方法\">iMovie剪辑的视频没有全屏显示，上下被截断的解决方法</h1>\n<p>使用iMovie剪辑视频时，直接点击视频预览时ok的，但把视频拖动到iMovie时间轴后, 就不是全屏的了。屏幕上方和下方被截断了</p>\n<p><img src=\"../../../images/blog/others/imove_not_fullscreeen_1.png\" alt=\"imove_not_fullscreeen_1.png\"></p>\n<p>注意这种情况，需要在时间轴，选中视频，然后在预览器，点击 &quot;全部还原&quot;，就可以了。</p>\n<p><img src=\"../../../images/blog/others/imove_not_fullscreeen_2.png\" alt=\"imove_not_fullscreeen_2.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "iMovie剪辑的视频没有全屏显示，上下被截断的解决方法"
        }
      ],
      "config": {
        "source": "iMovie剪辑的视频没有全屏显示，上下被截断的解决方法.md",
        "staticFileName": "iMovie_not_fullscreen.html",
        "author": "guoqzuo",
        "createDate": "2020/09/12",
        "description": "iMovie视频没有全屏,iMovie视频上下被截断，使用iMovie剪辑视频时，直接点击视频预览时ok的，但把视频拖动到iMovie时间轴后, 就不是全屏的了。屏幕上方和下方被截断了，注意这种情况，需要在时间轴，选中视频，然后在预览器，点击 '全部还原'，就可以了。",
        "keywords": "iMovie视频没有全屏,iMovie视频上下被截断",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"引用数据类型数组去重，去掉id重复的元素\">引用数据类型数组去重，去掉id重复的元素</h1>\n<p>有一个需求，客户信息列表，需要去除重复的客户。于是想着怎么优雅的写去重的逻辑，下面是最后使用的方法，使用 filter 遍历数组，将遍历的id存入 Set 数组，判断该数组里是否存在该id，如果已经存在就过滤，这样返回的就是去重后的数组了，具体实现如下</p>\n<pre><code class=\"language-js\">let customerList = [ \n  { id: &#39;1&#39;, info: &#39;xxx&#39; },\n  { id: &#39;3&#39;, info: &#39;xxx&#39; },\n  { id: &#39;1&#39;, info: &#39;xxx&#39; },\n  { id: &#39;2&#39;, info: &#39;xxx&#39; },\n  { id: &#39;3&#39;, info: &#39;xxx&#39; },\n]\n\n// 去重\nlet tempSet = new Set()\nlet newList = customerList.filter(item =&gt; {\n  if (tempSet.has(item.id)) {\n    return false\n  }\n  tempSet.add(item.id)\n  return true\n})\nconsole.log(newList)\n// [\n//   { id: &#39;1&#39;, info: &#39;xxx&#39; },\n//   { id: &#39;3&#39;, info: &#39;xxx&#39; },\n//   { id: &#39;2&#39;, info: &#39;xxx&#39; },\n// ]</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "引用数据类型数组去重，去掉id重复的元素"
        }
      ],
      "config": {
        "source": "引用数据类型数组去重，去掉id重复的元素.md",
        "staticFileName": "array_del_repeat.html",
        "author": "guoqzuo",
        "createDate": "2020/09/12",
        "description": "数组去重优雅写法,引用类型数组去重,有一个需求，客户信息列表，需要去除重复的客户。于是想着怎么优雅的写去重的逻辑，下面是最后使用的方法，使用 filter 遍历数组，将遍历的id存入 Set 数组，判断该数组里是否存在该id，如果已经存在就过滤，这样返回的就是去重后的数组了，具体实现如下",
        "keywords": "数组去重优雅写法,引用类型数组去重",
        "category": "JavaScript",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"obs录制视不是全屏、录制视频模糊的问题\">obs录制视不是全屏、录制视频模糊的问题</h1>\n<h2 id=\"obs录制视不是全屏的问题\">obs录制视不是全屏的问题</h2>\n<p>解决方法：打开OBS =&gt; 点击顶部 &quot;编辑&quot; 按钮 =&gt; 选择 &quot;变换&quot; =&gt; 点击比例适配屏幕</p>\n<p><img src=\"../../../images/blog/others/obj_1.png\" alt=\"obj_1.png\"></p>\n<h2 id=\"obs录制视频模糊的问题\">obs录制视频模糊的问题</h2>\n<p>解决方法，右键显示捕获，选择调整输出大小到源大小，正常情况下是可以点击的。这里因为我已经设置了，且正在推流、录制，就是灰色的了。</p>\n<p><img src=\"../../../images/blog/others/obj_2.png\" alt=\"obj_2.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "obs录制视不是全屏、录制视频模糊的问题",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "obs录制视不是全屏的问题"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "obs录制视频模糊的问题"
            }
          ]
        }
      ],
      "config": {
        "source": "obs录制视不是全屏、录制视频模糊的问题.md",
        "staticFileName": "obj_issue.html",
        "author": "guoqzuo",
        "createDate": "2020/09/12",
        "description": "obs录制视频不是全屏的问题,obs录制视频模糊的问题，1. obs录制视不是全屏的问题, 解决方法：打开OBS => 点击顶部 '编辑' 按钮 => 选择 '变换' => 点击比例适配屏幕，2. obs录制视频模糊的问题 解决方法，右键显示捕获，选择调整输出大小到源大小，正常情况下是可以点击的。这里因为我已经设置了，且正在推流、录制，就是灰色的了。",
        "keywords": "obs录制视频不是全屏的问题,obs录制视频模糊的问题",
        "category": "计算机基础与开发工具",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"为什么vconsole直接new一下就能引入，实现原理是什么？\">为什么vconsole直接new一下就能引入，实现原理是什么？</h1>\n<p>在移动端真机调试时，一般会用到vconsole，那你会发现在vue中vconsole的引入非常简单，只需要在main.js里面引入，并new一下。相比其他组件需要Vue.use引入来说，会很迷惑，这个是怎么引入到项目的？页面底部时怎么显示vconsole的按钮的？</p>\n<pre><code class=\"language-js\">// main.js\nimport VConsole from &quot;vconsole&quot;;\nnew VConsole();</code></pre>\n<p>先来看结论，vconsole大致实现思路</p>\n<ol>\n<li>通过window监听页面加载，加载ok后向页面append vconsle相关的dom（右下角按钮）</li>\n<li>像log、network等相关的渲染显示，都是通过重写window下对应的系统方法来加入一些自定义操作</li>\n</ol>\n<p>下面我们看看vconsole的源码，看看到底是怎么实现的：</p>\n<h2 id=\"vconsole构造函数\">VConsole构造函数</h2>\n<p>入口在 src/core/core.js，有一个VConsole的class，可以看到这里用了单例模式，只允许有一个vconsole</p>\n<pre><code class=\"language-js\">// src/core/core.js\n// ...\nclass VConsole {\n\n  constructor(opt) {\n    if (!!$.one(VCONSOLE_ID)) {\n      console.debug(&#39;vConsole is already exists.&#39;);\n      return;\n    }\n    // ....\n// ...</code></pre>\n<p>Log、System、Network、Element、Storage都是单独的模块</p>\n<pre><code class=\"language-js\">// src/core/core.js\n// ...\n// built-in plugins\nimport VConsolePlugin from &#39;../lib/plugin.js&#39;;\nimport VConsoleLogPlugin from &#39;../log/log.js&#39;;\nimport VConsoleDefaultPlugin from &#39;../log/default.js&#39;;\nimport VConsoleSystemPlugin from &#39;../log/system.js&#39;;\nimport VConsoleNetworkPlugin from &#39;../network/network.js&#39;;\nimport VConsoleElementPlugin from &#39;../element/element.js&#39;;\nimport VConsoleStoragePlugin from &#39;../storage/storage.js&#39;;\n// ...</code></pre>\n<h3 id=\"加载右下角按钮逻辑\">加载右下角按钮逻辑</h3>\n<p>constructor 里面挂载dom的方法如下，直接监听window的事件，当确定页面加载ok后，再将vconsole相关dom挂载上去</p>\n<pre><code class=\"language-js\">// src/core/core.js\n// ...\n// try to init\nlet _onload = function() {\n  if (that.isInited) {\n    return;\n  }\n  that._render();\n  that._mockTap();\n  that._bindEvent();\n  that._autoRun();\n};\nif (document !== undefined) {\n  if (document.readyState === &#39;loading&#39;) {\n    $.bind(window, &#39;DOMContentLoaded&#39;, _onload);\n  } else {\n    _onload();\n  }\n} else {\n  // if document does not exist, wait for it\n  let _timer;\n  let _pollingDocument = function() {\n    if (!!document &amp;&amp; document.readyState == &#39;complete&#39;) {\n      _timer &amp;&amp; clearTimeout(_timer);\n      _onload();\n    } else {\n      _timer = setTimeout(_pollingDocument, 1);\n    }\n  };\n  _timer = setTimeout(_pollingDocument, 1);\n}</code></pre>\n<h2 id=\"log模块：系统console方法重写加拦截\">log模块：系统console方法重写加拦截</h2>\n<p>下面看看console是怎么拦截的，通过下面的代码我们可以看到重写了window.console.log/info/warn等方法，改为执行自己的printLog方法，用于记录log，并渲染到vconsole面板里</p>\n<pre><code class=\"language-js\">// src/log/log.js\n// ...\n/**\n * replace window.console with vConsole method\n * @private\n */\nmockConsole() {\n  const that = this;\n  const methodList = [&#39;log&#39;, &#39;info&#39;, &#39;warn&#39;, &#39;debug&#39;, &#39;error&#39;];\n\n  if (!window.console) {\n    window.console = {};\n  } else {\n    methodList.map(function (method) {\n      that.console[method] = window.console[method];\n    });\n    that.console.time = window.console.time;\n    that.console.timeEnd = window.console.timeEnd;\n    that.console.clear = window.console.clear;\n  }\n\n  methodList.map(method =&gt; {\n    window.console[method] = (...args) =&gt; {\n      this.printLog({\n        logType: method,\n        logs: args,\n      });\n    };\n  });</code></pre>\n<p>当vconsole remove后，还原现场</p>\n<pre><code class=\"language-js\">// src/log/log.js\n// ...\n/**\n * before remove\n * @public\n */\nonRemove() {\n  window.console.log = this.console.log;\n  window.console.info = this.console.info;\n  window.console.warn = this.console.warn;\n  window.console.debug = this.console.debug;\n  window.console.error = this.console.error;\n  window.console.time = this.console.time;\n  window.console.timeEnd = this.console.timeEnd;\n  window.console.clear = this.console.clear;\n  this.console = {};\n\n  const idx = ADDED_LOG_TAB_ID.indexOf(this.id);\n  if (idx &gt; -1) {\n    ADDED_LOG_TAB_ID.splice(idx, 1);\n  }\n}</code></pre>\n<h2 id=\"network模块：重写xmlhttprequest方法加请求拦截\">network模块：重写XMLHttpRequest方法加请求拦截</h2>\n<p>我们再来看看Network相关，也是重写了原生的window.XMLHttpRequest.prototype.open/send等方法，在里面加入了拦截逻辑</p>\n<pre><code class=\"language-js\">// src/network/network.js\n/**\n * mock ajax request\n * @private\n */\nmockAjax() {\n  let _XMLHttpRequest = window.XMLHttpRequest;\n  if (!_XMLHttpRequest) { return; }\n\n  let that = this;\n  let _open = window.XMLHttpRequest.prototype.open,\n      _send = window.XMLHttpRequest.prototype.send;\n  that._open = _open;\n  that._send = _send;\n\n  // mock open()\n  window.XMLHttpRequest.prototype.open = function() {\n    let XMLReq = this;\n    let args = [].slice.call(arguments),\n  // ...\n  // mock send()\n  window.XMLHttpRequest.prototype.send = function() {\n    let XMLReq = this;\n    let args = [].slice.call(arguments),\n        data = args[0];</code></pre>\n<p>完整源码可以先npm install vconsole后再在node_modules里面查看，或者在github上看 <a href=\"https://github.com/Tencent/vConsole\">vconsole - github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "为什么vconsole直接new一下就能引入，实现原理是什么？",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "VConsole构造函数",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "加载右下角按钮逻辑"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "log模块：系统console方法重写加拦截"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "network模块：重写XMLHttpRequest方法加请求拦截"
            }
          ]
        }
      ],
      "config": {
        "source": "为什么vconsole直接new一下就能引入，实现原理是什么？.md",
        "staticFileName": "vconsole.html",
        "author": "guoqzuo",
        "createDate": "2020/09/12",
        "description": "在移动端真机调试时，一般会用到vconsole，那你会发现在vue中vconsole的引入非常简单，只需要在main.js里面引入，并new一下。相比其他组件需要Vue.use引入来说，会很迷惑，这个是怎么引入到项目的？页面底部时怎么显示vconsole的按钮的？先来看结论，vconsole大致实现思路 1. 通过window监听页面加载，加载ok后向页面append vconsle相关的dom（右下角按钮） 2. 像log、network等相关的渲染显示，都是通过重写window下对应的系统方法来加入一些自定义操作",
        "keywords": "vconsole实现原理,vconsole实现,vconsole为什么只需要new就能引入,为什么vconsole在vue中不用Vue.use就能使用",
        "category": "Vue",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"输入法组合文字事件compositionstart等不能用on监听\">输入法组合文字事件compositionstart等不能用on监听</h1>\n<p>今天用原生的js来写demo时发现使用oncompositoinstart无法监听到输入法组合文件的过程，后面替换为addEventListener就可以了。因此对于输入法组合文字过程事件必须要使用DOM2级事件监听</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n  &lt;input id=&quot;input&quot;&gt;&lt;/input&gt;\n  &lt;script&gt;\n    let input = document.querySelector(&#39;#input&#39;)\n    console.log(&#39;input&#39;, input)\n    let composition = false\n\n    // input.addEventListener(&#39;compositionstart&#39;, (e) =&gt; {\n    //   console.log(&#39;oncompositionstart&#39;)\n    //   composition = true\n    // });\n    // input.addEventListener(&#39;compositionend&#39;, (e) =&gt; {\n    //   console.log(&#39;oncompositionend&#39;)\n    //   composition = false\n    // });\n\n    input.oncompositionstart = (e) =&gt; {\n      // 换了大小写也不行\n      // console.log(&#39;onCompositionstart&#39;, composition)\n      console.log(&#39;oncompositionstart&#39;, composition)\n      composition = true\n    }\n\n    input.oncompositionend = (e) =&gt; {\n      console.log(&#39;oncompositionend&#39;, composition)\n      composition = false\n    }\n  &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "输入法组合文字事件compositionstart等不能用on监听"
        }
      ],
      "config": {
        "source": "输入法组合文字事件compositionstart等不能用on监听.md",
        "staticFileName": "oncompositionstart_issue.html",
        "author": "guoqzuo",
        "createDate": "2020/09/12",
        "description": "今天用原生的js来写demo时发现使用oncompositoinstart无法监听到输入法组合文件的过程，后面替换为addEventListener就可以了。因此对于输入法组合文字过程事件必须要使用DOM2级事件监听",
        "keywords": "compositionstart等输入法组合文字过程的事件不能使用on监听",
        "category": "JavaScript",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"为什么有效的uri不能包含空格等其他字符，uri编码方法详解\">为什么有效的URI不能包含空格等其他字符，URI编码方法详解</h1>\n<p>在JS高程3里介绍URI编码方法时，有这样一个描述：<strong>有效的URI中不能包含某些字符，比如空格。使用URI编码方法可以把所有无效的字符替换为特殊的utf-8编码，从而让浏览器能够接受和理解</strong></p>\n<h2 id=\"为什么有效的uri不能包含空格等其他字符？\">为什么有效的URI不能包含空格等其他字符？</h2>\n<p>在《HTTP权威指南》第2章URL与资源 - 各种令人头疼的字符(p38)里有介绍原因：</p>\n<p>URL是可移植的(portable)，它要统一的命名网上所有的资源，意味着要通过各种不同的协议来传送这些资源，这些协议在传输数据时都会使用不同的机制，在设计URL时，需要满足以下特性：</p>\n<ol>\n<li>可以通过任意协议进行<strong>安全的传输</strong>：完整/不丢失信息，以SMTP电子邮件的简单邮件传输协议为例，它使用的传输方法会剥去一些特定字符，为了避开这些问题，URL只能使用一些相对较小的、通用的安全字母表中的字符。</li>\n<li><strong>URL具有可读性</strong>：即使是看不见，不可打印的字符也能在URL中使用，比如空格</li>\n<li><strong>完整性</strong>：人们可能会希望URL中可以包含除通用安全字母表之外的二进制数据或字符，因此需要一种转义机制，能够将不安全的字符编码转为安全字符再进行传输</li>\n</ol>\n<h2 id=\"js中两种uri编码方法的区别\">js中两种URI编码方法的区别</h2>\n<p>之前有简单说明encodeURIComponent与encodeURI的区别：<del>encodeURI只转义空格，encodeURIComponent会转义所有的非字母数字字符</del></p>\n<p>其实上面的说法是错误的，在mdn的一个示例中，有更加详细说明两者的区别</p>\n<pre><code class=\"language-js\">// encodeURI vs encodeURIComponent\n// encodeURI() differs from encodeURIComponent() as follows:\nvar set1 = &quot;;,/?:@&amp;=+$#&quot;; // Reserved Characters\nvar set2 = &quot;-_.!~*&#39;()&quot;;   // Unreserved Marks\nvar set3 = &quot;ABC abc 123&quot;; // Alphanumeric Characters + Space  [ˌælfənjuːˈmerɪk] 字母数字 + 空格\n\nconsole.log(encodeURI(set1)); // ;,/?:@&amp;=+$#\nconsole.log(encodeURI(set2)); // -_.!~*&#39;()\nconsole.log(encodeURI(set3)); // ABC%20abc%20123 (the space gets encoded as %20)\n\nconsole.log(encodeURIComponent(set1)); // %3B%2C%2F%3F%3A%40%26%3D%2B%24%23\nconsole.log(encodeURIComponent(set2)); // -_.!~*&#39;()\nconsole.log(encodeURIComponent(set3)); // ABC%20abc%20123 (the space gets encoded as %20)</code></pre>\n<p>上面的例子中可以看到，URI编码方法一般有3种类型的字符</p>\n<table>\n<thead>\n<tr>\n<th>字符类型(中)</th>\n<th>字符类型(英)</th>\n<th>包含</th>\n<th>encodeURI</th>\n<th>encodeURIComponent</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>URI保留字符</td>\n<td>Reserved Characters</td>\n<td>&quot;;,/?:@&amp;=+$#&quot;</td>\n<td>不转义</td>\n<td>转义(escaped)</td>\n</tr>\n<tr>\n<td>非转义字符</td>\n<td>Unreserved Marks or Alphanumeric Characters</td>\n<td>&quot;-_.!~*&#39;()&quot;以及数字(0-9)、字母(a-zA-Z)</td>\n<td>不转义</td>\n<td>不转义</td>\n</tr>\n<tr>\n<td>空格等其他字符/中文等</td>\n<td>space or other character etc</td>\n<td>&quot; 中文？&quot;等其他字符</td>\n<td>转义</td>\n<td>转义</td>\n</tr>\n</tbody></table>\n<p>通过上面的表格我们可以看到</p>\n<ul>\n<li><strong>encodeURI不会编码URI保留字符/非转义字符，只会对空格等其他字符(如中文字符，中文等)进行编码</strong></li>\n<li><strong>encodeURIComponent不会编码非转义字符，URI保留字符和其他字符都会编码</strong></li>\n</ul>\n<p>综上，encodeURI与encodeURIComponent的区别是：<strong>encodeURIComponent会对URI保留字符进行编码，而encodeURI则不会，其他逻辑基本一致</strong>。</p>\n<h2 id=\"标准\">标准</h2>\n<p>下面来看看ECMA262标准/规范(specification)对encodeURI()的定义(definition)</p>\n<pre><code class=\"language-js\">18.2.6.4 encodeURI ( uri )\nThe encodeURI function computes a new version of a UTF-16 encoded (6.1.4) URI in which each instance of certain code points is replaced by one, two, three, or four escape sequences representing the UTF-8 encoding of the code points.\n\nThe encodeURI function is the %encodeURI% intrinsic object. When the encodeURI function is called with one argument uri, the following steps are taken:\n\n  1. Let uriString be ? ToString(uri).\n  2. Let unescapedURISet be a String containing one instance of each code unit valid in uriReserved and uriUnescaped  \n     plus &quot;#&quot;.\n  3. Return ? Encode(uriString, unescapedURISet).\n\nNOTE\nThe code point # is not encoded to an escape sequence even though it is not a reserved or unescaped URI code point.</code></pre>\n<p>Runtime Semantics: Encode(string, unescapedSet)</p>\n<pre><code class=\"language-js\">The abstract operation Encode takes arguments string (a String) and unescapedSet (a String). It performs URI encoding and escaping. It performs the following steps when called:\n\n1. Let strLen be the number of code units in string.\n2. Let R be the empty String.\n3. Let k be 0.\n4. Repeat,\n     a. If k equals strLen, return R.\n     b. Let C be the code unit at index k within string.\n     c. If C is in unescapedSet, then\n          i. Set k to k + 1.\n          ii. Set R to the string-concatenation of the previous value of R and C.\n     d. Else,\n          i. Let cp be ! CodePointAt(string, k).\n          ii. If cp.[[IsUnpairedSurrogate]] is true, throw a URIError exception.\n          iii. Set k to k + cp.[[CodeUnitCount]].\n          iv. Let Octets be the List of octets resulting by applying the UTF-8 transformation to cp.[[CodePoint]].\n          v. For each element octet of Octets in List order, do\n               1. Set R to the string-concatenation of:\n                   - the previous value of R\n                   - &quot;%&quot;\n                   - the String representation of octet, formatted as a two-digit uppercase hexadecimal number, padded to the left with a zero if necessary</code></pre>\n<p>以上，在总结某个知识点的过程中，我们可以发现介绍js相关知识点的平台很多，我们可以大致的判断出文档的详细程度如下：</p>\n<p>菜鸟教程/w3school等 &lt;= JS高程3等技术类书籍 &lt;= MDN &lt;= tc39 ECMA标准文档</p>\n<p>js相关知识基本都是对API、tc39 ECMA标准文档的总结、梳理。区别在于：</p>\n<ol>\n<li>整理的意图：是仅仅展示API调用，还是介绍原理（简单说明/详细介绍）</li>\n<li>示例demo是否丰富？demo是否可以让人很好的理解知识点？</li>\n</ol>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://tc39.es/ecma262/#sec-uri-handling-functions\">URI Handling Functions | ECMA-262 Specifications</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI\">encodeURI() | MDN</a></li>\n<li><a href=\"http://www.zuo11.com/blog/2020/6/content-dispositon.html\">encodeURIComponent与encodeURI的区别</a></li>\n<li><a href=\"https://www.yuque.com/guoqzuo/js_es6/ep07nf#841dc4e5\">js高程3的引用类型 - 单体内置对象 - global对象 - URI编码方法笔记</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2010/02/url_encoding.html\">关于URL编码 | 阮一峰的网络日志</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "为什么有效的URI不能包含空格等其他字符，URI编码方法详解",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "为什么有效的URI不能包含空格等其他字符？"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "js中两种URI编码方法的区别"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "标准"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "参考"
            }
          ]
        }
      ],
      "config": {
        "source": "为什么有效的URI不能包含空格等其他字符，URI编码方法详解.md",
        "staticFileName": "uri.html",
        "author": "guoqzuo",
        "createDate": "2020/09/12",
        "description": "在JS高程3里介绍URI编码方法时，有这样一个描述：**有效的URI中不能包含某些字符，比如空格。使用URI编码方法可以把所有无效的字符替换为特殊的utf-8编码，从而让浏览器能够接受和理解** 为什么有效的URI不能包含空格等其他字符？ 在《HTTP权威指南》第2章URL与资源 - 各种令人头疼的字符(p38)里有介绍原因：",
        "keywords": "URI编码方法详解",
        "category": "http与https",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue递归组件，实现一个树形菜单\">vue递归组件，实现一个树形菜单</h1>\n<p>vue支持递归组件，也就是组件自己调用自己，一般用于树形组件，来写个简单tree组件实例</p>\n<p><img src=\"../../../images/blog/vue/vue_tree.png\" alt=\"vue_tree.png\"></p>\n<h2 id=\"调用demo\">调用demo</h2>\n<p>先写好调用demo，假设我们实现了一个 z-tree 组件，我们只需要传入data就可以渲染树形组件</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;z-tree :data=&quot;treeData&quot;&gt;&lt;/z-tree&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  components: {\n    ZTree: () =&gt; import(&quot;./ZTree&quot;)\n  },\n  data() {\n    return {\n      treeData: [\n        {\n          label: &quot;冰箱&quot;\n        },\n        {\n          label: &quot;水果&quot;,\n          list: [\n            { label: &quot;苹果&quot; },\n            { label: &quot;梨子&quot; },\n            { label: &quot;葡萄&quot; },\n            {\n              label: &quot;喜欢的水果&quot;,\n              list: [{ label: &quot;水果1&quot; }, { label: &quot;水果2&quot; }, { label: &quot;水果3&quot; }]\n            },\n            { label: &quot;香蕉&quot; }\n          ]\n        },\n        {\n          label: &quot;茶叶&quot;,\n          list: [\n            { label: &quot;铁观音&quot; },\n            { label: &quot;西湖龙井&quot; },\n            { label: &quot;毛尖&quot; },\n            {\n              label: &quot;红茶&quot;,\n              list: [{ label: &quot;红茶1&quot; }, { label: &quot;红茶2&quot; }, { label: &quot;红茶3&quot; }]\n            }\n          ]\n        }\n      ]\n    };\n  }\n};\n&lt;/script&gt;</code></pre>\n<h2 id=\"tree组件具体实现\">tree组件具体实现</h2>\n<p>写好demo后，再来实现ZTree.vue，注意递归组件的实用方法有两种</p>\n<ol>\n<li>在当前组件，使用components引入当前组件文件使用</li>\n<li>设置组件name，可以直接调用组件自己</li>\n</ol>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;!-- z-tree递归组件实现 --&gt;\n  &lt;div&gt;\n    &lt;ul&gt;\n      &lt;li v-for=&quot;item in data&quot; :key=&quot;item.label&quot;&gt;\n        {{ item.label }}\n        &lt;i class=&quot;iconfont el-icon-arrow-right&quot; v-if=&quot;item.list&quot;&gt;&lt;/i&gt;\n        &lt;z-tree v-if=&quot;item.list&quot; :data=&quot;item.list&quot;&gt;&lt;/z-tree&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  // components: {\n  //   ZTree: () =&gt; import(&quot;./ZTree&quot;)\n  // },\n  name: &quot;ZTree&quot;,\n  props: {\n    data: {\n      type: Array,\n      required: true\n    }\n  },\n  data() {\n    return {};\n  }\n};\n&lt;/script&gt;</code></pre>\n<h2 id=\"完整代码地址\">完整代码地址</h2>\n<p>完整demo地址参见: <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/views/tree\">tree组件demo | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue递归组件，实现一个树形菜单",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "调用demo"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "tree组件具体实现"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "完整代码地址"
            }
          ]
        }
      ],
      "config": {
        "source": "vue递归组件，实现一个树形菜单.md",
        "staticFileName": "vue_tree.html",
        "author": "guoqzuo",
        "createDate": "2020/09/20",
        "description": "vue递归组件,vue树形组件,vue tree组件,vue怎么使用递归组件,vue支持递归组件，也就是组件自己调用自己，一般用于树形组件，来写个简单tree组件实例，先写好调用demo，假设我们实现了一个 z-tree 组件，我们只需要传入data就可以渲染树形组件",
        "keywords": "vue递归组件,vue树形组件,vue tree组件,vue怎么使用递归组件",
        "category": "Vue",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"响应式设计和自适应设计的区别\">响应式设计和自适应设计的区别</h1>\n<p>响应式(Responsive)布局和自适(Adaptive)应布局，也叫响应式设计与自适应设计。他们都用于在不同屏幕尺寸的设备上显示合适的内容。当你在思考这个问题的时候，表示你已经开始死扣概念了，这个问题在网上争议较大，包括国外的CSS-Tricks上的文章也有产生争议的。阮一峰博客里面将Responsive Web Design直接翻译为自适应web设计。</p>\n<h2 id=\"概念区别对比\">概念区别对比</h2>\n<p>我们来对比下各个地方的解释，响应式web设计 responsive web design (RWD) ，自适应web设计 adaptive web design (AWD)</p>\n<h3 id=\"css-tricks\">CSS-Tricks</h3>\n<ul>\n<li>响应式强调的是浏浏览器窗口缩放时，页面元素布局、大小<strong>实时变化</strong>，整个变动的过程是平滑的 </li>\n<li>自适应强调的是窗口缩放到某几个<strong>特定的宽度</strong>时，页面元素布局、大小发生变化。整个变动的过程不是平滑的</li>\n</ul>\n<p><img src=\"../../../images/blog/css/responsive-vs-adapt.gif\" alt=\"respontive-vs-adaptive.gif\"></p>\n<p>在这篇文章的评论区 </p>\n<ul>\n<li>(responsive) uses relative units (e.g. percentages) to fluidly respond its layout to any browser/device conditions. 使用相对的单位(比如百分比)在任何浏览器或设备上，流畅的响应布局 </li>\n<li>(adaptive) uses fixed units (e.g. pixels) to adapt to a specific condition. 使用固定单位（例如像素）来适应特定条件。 </li>\n</ul>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://css-tricks.com/the-difference-between-responsive-and-adaptive-design/\">The Difference Between Responsive and Adaptive Design - CSS-Tricks</a> </li>\n<li><a href=\"https://www.fastcompany.com/3038367/9-gifs-that-explain-responsive-design-brilliantly-2\">9 GIFs That Explain Responsive Design Brilliantly</a></li>\n</ul>\n<h3 id=\"mdn\">MDN</h3>\n<p>Responsive design works on the principle of flexibility - a single fluid website that can look good on any device. Responsive websites use media queries, flexible grids, and responsive images to create a user experience that flexes and changes based on a multitude of factors.（响应式设计以灵活性为原则-一个流畅的网站，可以在任何设备上看起来不错。 响应式网站使用媒体查询，灵活的网格和响应式图像来创建基于多种因素而变化和变化的用户体验。）</p>\n<p>Adaptive design is more like the modern definition of progressive enhancement. Instead of one flexible design, adaptive design detects the device and other features, and then provides the appropriate feature and layout based on a predefined set of viewport sizes and other characteristics.（自适应设计更像是渐进增强的现代定义。 自适应设计代替一种灵活的设计，而是检测设备和其他功能，然后根据一组预定义的视口大小和其他特征提供适当的功能和布局。）</p>\n<p>参考: <a href=\"https://developer.mozilla.org/en-US/docs/Archive/Apps/Design/UI_layout_basics/Responsive_design_versus_adaptive_design\">Responsive design versus adaptive design - MDN</a></p>\n<h3 id=\"阮一峰博客\">阮一峰博客</h3>\n<p>直接将响应式翻译为自适应，概念一致。强调responsive web design概念提出者Ethan Marcotte对其定义：Fluid grids（流动布局，使用float）, flexible images(弹性自适应显示图片), and media queries(使用媒体查询) are the three technical ingredients for responsive web design</p>\n<p>参考: <a href=\"http://www.ruanyifeng.com/blog/2012/05/responsive_web_design.html\">自适应网页设计（Responsive Web Design）- 阮一峰</a></p>\n<h3 id=\"前端开发者博客\">前端开发者博客</h3>\n<p>响应式布局等于流动网格布局，自适应布局等于使用固定分割点来进行布局</p>\n<p>参考：<a href=\"http://caibaojian.com/356.html\">响应式布局和自适应布局详解 - 前端开发者博客</a></p>\n<h3 id=\"uxpin-studio\">uxpin studio</h3>\n<p>Put simply, responsive is fluid and adapts to the size of the screen no matter what the target device. Responsive uses CSS media queries to change styles based on the target device such as display type, width, height, etc., and only one of these is necessary for the site to adapt to different screens.（简而言之，响应是灵活的，并且无论目标设备是什么，都可以适应屏幕的大小。 响应式使用CSS媒体查询来根据目标设备更改样式，例如显示类型，宽度，高度等，并且站点只需要其中之一就可以适应不同的屏幕。）</p>\n<p>Adaptive design, on the other hand, uses static layouts based on breakpoints which don’t respond once they’re initially loaded. Adaptive works to detect the screen size and load the appropriate layout for it – generally you would design an adaptive site for six common screen widths: （自适应设计使用基于断点的静态布局，这些断点在最初加载时不会响应。 自适应可检测屏幕尺寸并为其加载适当的布局-通常，您会针对六个常见的屏幕宽度设计一个自适应站点：）320 480 760 960 1200 1600.\nOn the surface, it appears that adaptive requires more work as you have to design layouts for a minimum of six widths. However, responsive can be more complex as improper use of media queries (or indeed not using them at all) can make for display and performance issues.（从表面上看，自适应设计似乎需要更多的工作，因为您必须设计至少六个宽度的布局。 但是，由于媒体查询使用不当（或者根本根本不使用它们）会导致显示和性能问题，因此响应式响应可能会更加复杂。）</p>\n<p>参考：<a href=\"https://www.uxpin.com/studio/blog/responsive-vs-adaptive-design-whats-best-choice-designers/\">Responsive Design vs. Adaptive Design: What’s the Best Choice for Designers? (响应式与自适应设计：最佳选择是什么？)</a></p>\n<h3 id=\"博客园\">博客园</h3>\n<p>响应式几乎已经成为优秀页面布局的标准。</p>\n<p>1、布局特点：每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变。</p>\n<p>2、设计方法：媒体查询+流式布局。通常使用 @media 媒体查询 和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是综合响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术统称。</p>\n<p>优点：适应pc和移动端，如果足够耐心，效果完美</p>\n<p>缺点：（1）媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。（2）要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。</p>\n<p>自适应布局（Adaptive Layout）\n自适应布局的特点是分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。改变屏幕分辨率可以切换不同的静态局部（页面元素位置发生改变），但在每个静态布局中，页面元素不随窗口大小的调整发生变化。可以把自适应布局看作是静态布局的一个系列。\n1、布局特点：屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。\n2、设计方法：使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。</p>\n<p>参考：<a href=\"https://www.cnblogs.com/yanayana/p/7066948.html\">静态布局、自适应布局、流式布局、响应式布局、弹性布局等的概念和区别 - P妞酱儿 - 博客园</a></p>\n<h2 id=\"实际使用场景\">实际使用场景</h2>\n<p>一般在实际开发中，会根据产品具体的场景来使用不同的技术实现</p>\n<ol>\n<li>仅用在手机端: 使用rem+js</li>\n<li>用在pc端+手机+pad：使用 media媒体查询在不同的特定宽度区间使用不同的样式布局</li>\n<li>用在手机端和pad端：对于pad可能会显示更丰富的功能的场景会 rem+js+media媒体查询一起使用</li>\n</ol>\n<p>这些都不是绝对的，一些展示性较强的pc官网，可能也会用到rem+js，<strong>总之，概念都是虚的，技术只是工具，大可不必过多的的纠结什么是响应式和什么是自适应，我们只需要根据产品的功能需要，找出合适的技术方案即可。</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "响应式设计和自适应设计的区别",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "概念区别对比",
              "children": [
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "CSS-Tricks"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "MDN"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "阮一峰博客"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "前端开发者博客"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "uxpin studio"
                },
                {
                  "type": "heading",
                  "depth": 3,
                  "text": "博客园"
                }
              ]
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "实际使用场景"
            }
          ]
        }
      ],
      "config": {
        "source": "响应式设计和自适应设计的区别.md",
        "staticFileName": "rwd_awd.html",
        "author": "guoqzuo",
        "createDate": "2020/09/24",
        "description": "响应式(Responsive)布局和自适(Adaptive)应布局，也叫响应式设计与自适应设计。他们都用于在不同屏幕尺寸的设备上显示合适的内容。当你在思考这个问题的时候，表示你已经开始死扣概念了，这个问题在网上争议较大，包括国外的CSS-Tricks上的文章也有产生争议的。阮一峰博客里面将Responsive Web Design直接翻译为自适应web设计。",
        "keywords": "响应式布局和自适应设计的区别,响应式设计,自适应设计",
        "category": "CSS",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"移动端rem自适应与pc端rem自适应\">移动端rem自适应与pc端rem自适应</h1>\n<p>在还原设计稿稿时，对于展示型的页面，设计稿间距都是固定的px，那我们实现时，如果全部都用pixel(px)写死就会存在某些分辨率下显示比较差的问题。用百分比也可以，但你需要自己手动计算，现在一般比较好的方法是在合适的地方使用rem，他可以自动转换。</p>\n<p>先来复习下css rem的概念。在css中有以下几种相对长度单位</p>\n<ul>\n<li>em表示相对当前父元素字体大小的倍数</li>\n<li>rem表示相对根元素(html)字体的倍数。</li>\n<li>%百分比如果是font-size挂钩的是父元素的font-size的百分比，如果是width，挂钩的是元素包含块的宽度</li>\n<li>vh viewport视口高度，一般height可以设置为 html {min-height:100vh}</li>\n<li>vw 视口宽度(1vw = 1%)。不过一般默认宽度就是100%，宽度用百分比多。高度是由于默认高度不是100%，如果需要表示全屏，使用100vh会比较方便。</li>\n</ul>\n<p>参考 <a href=\"https://www.yuque.com/guoqzuo/js_es6/dg9u82#92bb76d4\">css相对长度 | HTML5权威指南笔记</a></p>\n<p>举个例子：</p>\n<p>设计稿尺寸是 750 * 1334，假设某个图片距离顶部是100px，且需要根据屏幕尺寸自动调整间距，那么我们将 margin-top 设置为 1rem 即可。如果是 45px，设置为 0.45rem。</p>\n<p>为了好还原UI图，1rem通常设计为100px。rem是相对于html元素font-size来计算的，我们可以通过动态的改变html元素的fontSize，来实现响应式布局</p>\n<p><img src=\"../../../images/blog/css/rem_h5.gif\" alt=\"rem_h5.gif\"></p>\n<h2 id=\"移动端rem自适应\">移动端rem自适应</h2>\n<p>获取当前浏览器窗口宽高 document.documentElement.clientHeight * document.documentElement.clientWidth</p>\n<table>\n<thead>\n<tr>\n<th>机型</th>\n<th>屏幕尺寸</th>\n<th>window.devicePixelRatio</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>iPhone 5/SE</td>\n<td>320 * 568</td>\n<td>2</td>\n</tr>\n<tr>\n<td>iPhone 6/7/8</td>\n<td>375 * 667</td>\n<td>2</td>\n</tr>\n<tr>\n<td>iPhone 6/7/8 Plus</td>\n<td>414 * 736</td>\n<td>3</td>\n</tr>\n<tr>\n<td>iPhone X</td>\n<td>375 * 812</td>\n<td>3</td>\n</tr>\n<tr>\n<td>iPhone XR</td>\n<td>414 * 896</td>\n<td>2</td>\n</tr>\n<tr>\n<td>iPhone XS Max</td>\n<td>414 * 896</td>\n<td>3</td>\n</tr>\n<tr>\n<td>iPad</td>\n<td>768 * 1024</td>\n<td>2</td>\n</tr>\n<tr>\n<td>iPad pro 10.5-inch</td>\n<td>834 * 1112</td>\n<td>2</td>\n</tr>\n<tr>\n<td>iPad pro 12.9-inch</td>\n<td>1024 * 1366</td>\n<td>2</td>\n</tr>\n</tbody></table>\n<p>假设标准设计图尺寸为750 * xx(iphone 6/7/8 或 iphone X全面屏)，以100为基准。</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;style&gt;\n    body {\n      font-size: 14px;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div style=&quot;margin-left: 1rem;&quot;&gt;margin-left: 1rem;&lt;/div&gt;\n  &lt;div style=&quot;margin-left: 100px;&quot;&gt;margin-left: 100px;&lt;/div&gt;\n  &lt;script src=&quot;./vconsole.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    var vConsole = new VConsole();\n    initRem()\n    function initRem() {\n      let html = document.documentElement\n      let resizeEventName = &#39;orientationchange&#39; in window ? &#39;orientationchange&#39; : &#39;resize&#39;\n      let recalc = () =&gt; {\n        console.log(&#39;recalc&#39;, html);\n        let w = html.clientWidth &lt; 320 ? 320 : html.clientWidth\n        let fontSize = w &gt; 750 ? 200 : ((w / 375) * 100) // iPhone8 w为375\n        html.style.fontSize = fontSize + &#39;px&#39;\n      }\n      recalc()\n      document.addEventListener(&#39;DOMContentLoaded&#39;, recalc, false)\n      window.addEventListener(resizeEventName, recalc, false)\n    }\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;</code></pre>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Events/DOMContentLoaded\">DOMContentLoaded | MDN</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25876048\">你不知道的 DOMContentLoaded | 知乎</a></li>\n</ul>\n<h2 id=\"pc样式自适应rem\">pc样式自适应rem</h2>\n<p>pc端如果做官网、展示类的UI，就需要使用rem了。相对移动端，pc端只需要改下设计稿宽度与最小宽度值</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;style&gt;\n    body {\n      font-size: 14px;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div style=&quot;margin-left: 1rem;&quot;&gt;margin-left: 1rem;&lt;/div&gt;\n  &lt;div style=&quot;margin-left: 100px;&quot;&gt;margin-left: 100px;&lt;/div&gt;\n  &lt;script&gt;\n    initRem()\n    function initRem() {\n      const recalc = () =&gt; {\n        console.log(&#39;resize&#39;)\n        let designSize = 1920\n        let minWidth = 520\n        let html = document.documentElement\n        let w = html.clientWidth &lt; minWidth ? minWidth : html.clientWidth\n        let rem = (w / designSize) * 100\n        html.style.fontSize = `${rem}px`  // 会影响所有页面\n\n      }\n      recalc()\n      // 窗口变更后，变更rem\n      window.addEventListener(&#39;resize&#39;, recalc)\n    }\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;</code></pre>\n<p>效果如下</p>\n<p><img src=\"../../../images/blog/css/rem_pc.gif\" alt=\"rem_pc.gif\"></p>\n<p>如果是在vue的单个文件中使用，示例如下</p>\n<pre><code class=\"language-js\">export default {\n  created() {\n    const recalc = () =&gt; {\n      let designSize = 1920\n      let minWidth = 1280 // 截gif图时为了好看效果，这里设置成了520，最小宽度\n      let html = document.documentElement\n      let w = html.clientWidth &lt; minWidth ? minWidth : html.clientWidth\n      let rem = ( w / designSize) * 100\n      this.rem = rem // 当前页面 使用时宽高使用 this.rem * (设计稿标记尺寸/100)\n      // html.style.fontSize = `${rem}px`  // 会影响所有页面\n    }\n    this.recalc = recalc\n    recalc()\n    // 窗口变更后，变更rem\n    window.addEventListener(&#39;resize&#39;, recalc)\n  },\n  // 组件销毁时移除resize事件的recalc\n  beforeDestroy() {\n    window.removeEventListener(&#39;resize&#39;, this.recalc, false)\n  }\n}</code></pre>\n<p>这里就凸显出 window.addEventListener(&#39;resize&#39;) 相对于 window.onresize 的优势，假设项目很大，其他代码已经监听了window.onresize如果你再用window.onresize可能会覆盖原来的方法，要特别小心，而window.addEventListener就不用担心这个问题，你只需要注意remove的时候，只移除你自己的监听函数即可。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "移动端rem自适应与pc端rem自适应",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "移动端rem自适应"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "pc样式自适应rem"
            }
          ]
        }
      ],
      "config": {
        "source": "移动端rem自适应与pc端rem自适应.md",
        "staticFileName": "rem.html",
        "author": "guoqzuo",
        "createDate": "2020/09/24",
        "description": "在还原设计稿稿时，对于展示型的页面，设计稿间距都是固定的px，那我们实现时，如果全部都用pixel(px)写死就会存在某些分辨率下显示比较差的问题。用百分比也可以，但你需要自己手动计算，现在一般比较好的方法是在合适的地方使用rem，他可以自动转换。先来复习下css rem的概念。在css中有以下几种相对长度单位，em表示相对当前父元素字体大小的倍数, rem表示相对根元素(html)字体的倍数。",
        "keywords": "pc rem,h5 rem,em与rem的区别",
        "category": "CSS",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"css-background设置图片背景\">css background设置图片背景</h1>\n<p>HTML5权威指南这本书对background的简写貌似有点不正确，使用起来会有问题，这次让图片在某个区域完全显示，是分开写的，如下：</p>\n<pre><code class=\"language-css\">div {\n  background: #fff url(&#39;/images/xxx.png&#39;) no-repeat;\n  background-size: cover;\n}</code></pre>\n<p>具体语法，参见 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/background\">background - CSS（层叠样式表） | MDN</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "css background设置图片背景"
        }
      ],
      "config": {
        "source": "css background设置图片背景.md",
        "staticFileName": "background.html",
        "author": "guoqzuo",
        "createDate": "2020/09/24",
        "description": "HTML5权威指南这本书对background的简写貌似有点不正确，使用起来会有问题，这次让图片在某个区域完全显示，是分开写的，如下：div { background: #fff url('/images/xxx.png') no-repeat; background-size: cover;}",
        "keywords": "background背景图片,background-size",
        "category": "CSS",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"角色权限vuex状态管理设计思路\">角色权限vuex状态管理设计思路</h1>\n<p>在vue项目中做角色权限控制时，如果角色较多、权限较复杂，或者很多地方需要使用，就需要使用vuex状态管理了，我们可以在vuex里提供一个getter方法，用于获取对应的角色权限，假设getter名为roleMuster，在需要用到的vue组件里，通过mapGetters导入，就可以使用了</p>\n<p>先来看看vuex store写法，把角色弄成role模块</p>\n<pre><code class=\"language-js\">// role/index.js，只用到getters\nimport getters from &#39;./getters&#39;\nexport default {\n  namespaced: true,\n  state: {},\n  mutations: {},\n  getters\n}\n\n// role/getters.js\nexport default {\n  roleMuster(state, getters, rootState, rootGetters) {\n    return {\n      role_admin: &#39;xx&#39;,\n      role_user: &#39;xx&#39;,\n    }\n  }\n}</code></pre>\n<p>在vue组件中使用</p>\n<pre><code class=\"language-js\">import { mapGetters } from &#39;vuex&#39;\n\n// 计算属性\ncomputed: {\n  ...mapGetters(&#39;role&#39;, [&#39;roleMuster&#39;])\n}\n\n// 如果有对应的权限，值则为true\nlet { role_admin, role_user, role_b, role_c } = this.roleMuster\n</code></pre>\n<p>在getter的逻辑里可以对角色对应的code进行转换，使用好理解变量代替，消除魔术字符串，当后端角色code变换时，我们这个变量不变，更有利于维护。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "角色权限vuex状态管理设计思路"
        }
      ],
      "config": {
        "source": "角色权限vuex状态管理设计思路.md",
        "staticFileName": "vuex_role.html",
        "author": "guoqzuo",
        "createDate": "2020/09/24",
        "description": "在vue项目中做角色权限控制时，如果角色较多、权限较复杂，或者很多地方需要使用，就需要使用vuex状态管理了，我们可以在vuex里提供一个getter方法，用于获取对应的角色权限，假设getter名为roleMuster，在需要用到的vue组件里，通过mapGetters导入，就可以使用了",
        "keywords": "vue角色权限,vuex权限",
        "category": "Vue",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"css表格怎么画斜线，怎么精准计算斜线rotate角度\">css表格怎么画斜线，怎么精准计算斜线rotate角度</h1>\n<p>在最近的需求中，有个表格表头里有斜线，我特意翻了 HTML5权威指南 的笔记，发现并没有介绍怎么画表头的斜线。找了下网上的实现，一般都是通过 css 来实现，使用 after 或者特定 span 画一条直线，然后通过 rotate 来旋转成斜线效果。这里涉及到怎么计算斜线角度，会用到一点点数学的知识</p>\n<p><img src=\"../../../images/blog/css/table_slash.png\" alt=\"table_slash.png\"></p>\n<p>在线预览地址: <a href=\"https://zuoxiaobai.github.io/fedemo/src/DebugDemo/%E8%A1%A8%E6%A0%BC%E6%80%8E%E4%B9%88%E7%94%BB%E6%96%9C%E7%BA%BF/index.html\">表格画斜线 | github</a></p>\n<p>先来看两个数学公式</p>\n<ol>\n<li>计算斜线的长度。勾股定理 a² + b² = c²</li>\n</ol>\n<pre><code class=\"language-css\">/* 斜边边长 */\n/* Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)) */\n/* Math.sqrt(Math.pow(150, 2) + Math.pow(80, 2)) = 170 */</code></pre>\n<ol start=\"2\">\n<li>根据th单元格的宽高计算斜线的rotate角度。给定直角三角形的边长，怎么计算角度? 这里我们知道宽高，不知道斜边边长,假设角度A，正切tanA = 对边(高) / 邻边(宽)，我们知道这个角度A的正切值，怎么反向计算A的角度呢。就需要用到反正切函数 Math.atan了，他会返回一个弧度值。在JS中 180度对应的值为 Math.PI，计算出来的值乘以 (180 / Math.PI) 就是可以在css中使用的度数了，单位为 deg</li>\n</ol>\n<pre><code class=\"language-css\">/* 角度计算公式 */ \n/*  Math.atan(height / width) * 180 / Math.PI  */\n/*  Math.atan(80 / 150) * 180 / Math.PI  = 28.072486935852954 */</code></pre>\n<p>完整代码如下</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;style&gt;\n    /* 基本表格元素 */\n    table {\n      border-collapse: collapse;\n    }\n    th,td {\n      border: 1px solid #666;\n      padding: 5px;\n    }\n\n    /* th单元格 */\n    .slash-wrap {\n      position: relative;\n      box-sizing: border-box;\n      width: 150px;\n      height: 80px;\n    }\n\n    /* 斜线 */\n    .slash {\n      position: absolute;\n      display: block;\n      top: 0;\n      left: 0;\n      /* 斜边边长 */\n      /* Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)) */\n      /* Math.sqrt(Math.pow(150, 2) + Math.pow(80, 2)) = 170 */\n      width: 170px;\n      height: 1px;\n      background-color:#000;\n      /* 旋转角度计算公式 */ \n      /*  Math.atan(height / width) * 180 / Math.PI  */\n      /*  Math.atan(80 / 150) * 180 / Math.PI  = 28.072486935852954 */\n      transform: rotate(28.072486935852954deg); \n      transform-origin: top left;\n    }\n\n    /* 左下角文字 */\n    .left {\n      position: absolute;\n      /* 左下角 left:0; bottom: 0; */\n      left: 15px;\n      bottom: 15px;\n    }\n\n    /* 右上角文字 */\n    .right {\n      position: absolute;\n      /* 右上角 right:0; top: 0; */\n      right: 15px;\n      top: 15px;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div&gt;\n    &lt;table&gt;\n      &lt;tr&gt;\n        &lt;th class=&quot;slash-wrap&quot;&gt;\n          &lt;span class=&quot;left&quot;&gt;姓名&lt;/span&gt;\n          &lt;span class=&quot;slash&quot;&gt;&lt;/span&gt;\n          &lt;span class=&quot;right&quot;&gt;科目&lt;/span&gt;\n        &lt;/th&gt;\n        &lt;th&gt;语文&lt;/th&gt;\n        &lt;th&gt;数学&lt;/th&gt;\n      &lt;/tr&gt;\n      &lt;tr&gt;\n        &lt;td&gt;张三&lt;/td&gt;\n        &lt;td&gt;89&lt;/td&gt;\n        &lt;td&gt;80&lt;/td&gt;\n      &lt;/tr&gt;\n      &lt;tr&gt;\n        &lt;td&gt;李四&lt;/td&gt;\n        &lt;td&gt;89&lt;/td&gt;\n        &lt;td&gt;80&lt;/td&gt;\n      &lt;/tr&gt;\n    &lt;/table&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;</code></pre>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/atan\">Math.atan | MDN</a></li>\n<li><a href=\"https://zhidao.baidu.com/question/1734209350028464467.html\">【数学】sin cos tan分别是什么意思</a></li>\n<li><a href=\"https://zhidao.baidu.com/question/1049676482244639019.html\">有边长怎么计算三角形的角度</a></li>\n<li><a href=\"https://tool.520101.com/calculator/sanjiaoxingjiaodu/\">在线三角形的角度计算器</a></li>\n<li><a href=\"https://www.cnblogs.com/zhaozhenzhen/p/12187482.html\">vue element 表头添加斜线</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "css表格怎么画斜线，怎么精准计算斜线rotate角度"
        }
      ],
      "config": {
        "source": "css表格怎么画斜线，怎么精准计算斜线rotate角度.md",
        "staticFileName": "table_slash.html",
        "author": "guoqzuo",
        "createDate": "2020/09/24",
        "description": "在最近的需求中，有个表格表头里有斜线，我特意翻了 HTML5权威指南 的笔记，发现并没有介绍怎么画表头的斜线。找了下网上的实现，一般都是通过 css 来实现，使用 after 或者特定 span 画一条直线，然后通过 rotate 来旋转成斜线效果。这里涉及到怎么计算斜线角度，会用到一点点数学的知识",
        "keywords": "css表格画斜线,css计算斜线角度,直角三角形给定直角边计算斜边角度",
        "category": "CSS",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"客户端修改host后js获取locationhref不真实的问题\">客户端修改host后js获取location.href不真实的问题</h1>\n<p>macOS 修改host文件 /etc/hosts 后，本地访问某个域名会按照host指定的ip去解析，就会造成前端location.href不准确的问题，下面来看看</p>\n<p><img src=\"../../../images/blog/web/a_com_tongji.png\" alt=\"a_com_tongji.png\"></p>\n<pre><code class=\"language-bash\"># 默认没有写的权限，无法编辑\nguoqzuo-mac:~ kevin$ ls -l /etc/hosts \n-rw-r--r--  1 root  wheel  244  3 24  2019 /etc/hosts\n# 新增写的权限\nguoqzuo-mac:~ kevin$ sudo chmod 0666 /etc/hosts\nPassword:\n# 再次查看权限\nguoqzuo-mac:~ kevin$ ls -l /etc/hosts \n-rw-rw-rw-  1 root  wheel  244  3 24  2019 /etc/hosts\n# 使用vi修改该文件\nguoqzuo-mac:~ kevin$ vi /etc/hosts\n# 新增a.com解析，在本地将a.com解析到47.107.190.93的服务器，也就是zuo11.com解析到的服务器\n47.107.190.93 a.com</code></pre>\n<p>macOS修改host是实时生效的，修改后，本地浏览器访问a.com，会访问47.107.190.93的服务器，显示的是zuo11.com的内容。这时用js获取location.href就是a.com，而不是zuo11.com。上面的图里是百度统计的数据，显示的就是a.com</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "客户端修改host后js获取location.href不真实的问题"
        }
      ],
      "config": {
        "source": "客户端修改host后js获取location.href不真实的问题.md",
        "staticFileName": "host_href_issue.html",
        "author": "guoqzuo",
        "createDate": "2020/09/24",
        "description": "macOS 修改host文件 /etc/hosts 后，本地访问某个域名会按照host指定的ip去解析，就会造成前端location.href不准确的问题，下面来看看",
        "keywords": "location.href不准确的问题,修改host后location.href也会变",
        "category": "JavaScript",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"github-clone下载太慢怎么解决\">github clone下载太慢怎么解决</h1>\n<p>以clone vue源码为例，默认git clone下载非常慢，我们可以把github.com链接改为镜像github.com.cnpmjs.org，这样下载速度就很快了，修改后效果对比图如下</p>\n<p><img src=\"../../../images/blog/web/github_clone_slow.png\" alt=\"github_clone_slow.png\"></p>\n<p>具体过程</p>\n<pre><code class=\"language-bash\"># git clone 下载vue源码，默认情况下速度只有10k/s\nguoqzuo-mac:source kevin$ git clone https://github.com/vuejs/vue.git\nCloning into &#39;vue&#39;...\nremote: Enumerating objects: 56366, done.\n^Cceiving objects:   5% (2823/56366), 556.01 KiB | 10.00 KiB/s   \nguoqzuo-mac:source kevin$ \n# 在github.com后面加上cnpmjs.org后，使用淘宝源，下载速度为 1.2M/s\nguoqzuo-mac:source kevin$ git clone https://github.com.cnpmjs.org/vuejs/vue.git\nCloning into &#39;vue&#39;...\nremote: Enumerating objects: 56366, done.\nremote: Total 56366 (delta 0), reused 0 (delta 0), pack-reused 56366\nReceiving objects: 100% (56366/56366), 26.75 MiB | 1.22 MiB/s, done.\nResolving deltas: 100% (39568/39568), done.\nguoqzuo-mac:source kevin$ </code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "github clone下载太慢怎么解决"
        }
      ],
      "config": {
        "source": "github clone下载太慢怎么解决.md",
        "staticFileName": "github_clone_slow.html",
        "author": "guoqzuo",
        "createDate": "2020/09/24",
        "description": "以clone vue源码为例，默认git clone下载非常慢，我们可以把github.com链接改为镜像github.com.cnpmjs.org，这样下载速度就很快了，修改后效果对比图如下",
        "keywords": "github clone慢,github clone超时,github clone不下来",
        "category": "运维部署与版本控制",
        "year": "2020",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"设置允许跨域的响应头后，为什么还是不能跨域\">设置允许跨域的响应头后，为什么还是不能跨域</h1>\n<p>在 post 请求中，设置了允许跨域的响应头，且考虑了 preflight 预检请求，但为什么还是报不能跨域的错误呢？下面来看看下面的例子，POST 请求中设置了允许跨域、允许预检的响应头</p>\n<pre><code class=\"language-js\">router.post(&#39;/corsTest&#39;, ctx =&gt; {\n  // 以及允许跨域了\n  ctx.set({\n    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,\n    &#39;Access-Control-Allow-Methods&#39;: &#39;*&#39;,\n    &#39;Access-Control-Allow-Headers&#39;: &#39;*&#39;\n  })\n  ctx.body = { a: 123 }\n})</code></pre>\n<p>我们需要深入了解预检请求的过程，预检请求会先发送一个 OPTIONS 的请求去测试服务端是否允许跨域。这个时候我们需要注意，我们也需要处理对应接口的 OPTIONS 请求，上面只处理了接口 URL 的 POST 请求，并没有处理 OPTIONS 请求，可以使用 router.use(url, func) 或者加一个 router.options 请求处理</p>\n<pre><code class=\"language-js\">// options 预检请求时允许\nrouter.options(&#39;/corsTest&#39;, ctx =&gt; {\n  ctx.set({\n    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,\n    &#39;Access-Control-Allow-Methods&#39;: &#39;*&#39;,\n    &#39;Access-Control-Allow-Headers&#39;: &#39;*&#39;\n  })\n  ctx.body = {}\n})\n\n// 真实请求\nrouter.post(&#39;/corsTest&#39;, ctx =&gt; {\n  ctx.set({\n    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,\n    &#39;Access-Control-Allow-Methods&#39;: &#39;*&#39;,\n    &#39;Access-Control-Allow-Headers&#39;: &#39;*&#39;\n  })\n  ctx.body = { a: 123 }\n})</code></pre>\n<p>关于请求预检的更多信息参见：<a href=\"http://www.zuo11.com/blog/2020/6/koa_web_cros.html\">CORS跨域资源共享 - 利用koa来彻底理解web前端跨域问题 - 左小白的技术日常</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "设置允许跨域的响应头后，为什么还是不能跨域"
        }
      ],
      "config": {
        "source": "设置允许跨域的响应头后，为什么还是不能跨域.md",
        "staticFileName": "cors-allow.html",
        "author": "guoqzuo",
        "createDate": "2021/01/12",
        "description": "在 post 请求中，设置了允许跨域的响应头，且考虑了 preflight 预检请求，但为什么还是报不能跨域的错误呢？下面来看看下面的例子，POST 请求中设置了允许跨域、允许预检的响应头。我们需要深入了解预检请求的过程，预检请求会先发送一个 OPTIONS 的请求去测试服务端是否允许跨域。这个时候我们需要注意，我们也需要处理对应接口的 OPTIONS 请求，上面只处理了接口 URL 的 POST 请求，并没有处理 OPTIONS 请求，可以使用 router.use(url, func) 或者加一个 router.options 请求处理",
        "keywords": "跨域,cors,请求预检",
        "category": "JavaScript",
        "year": "2021",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"koa-使用-multer-处理文件上传，formdata-数据解析\">koa 使用 multer 处理文件上传，FormData 数据解析</h1>\n<p>一般在 koa 中，post 请求的数据是需要中间件来处理的，koa-bodyparser 可以很好的处理 json、serializer 数据，但 <code>multipart/form-data</code> 的类型无法处理，一般需要引入另外的中间件来处理，一般建议使用 multer 中间件来处理。先来看看前端上传文件代码，这里使用的是 fetch，当然也可以使用 xhr</p>\n<pre><code class=\"language-html\">&lt;!-- &lt;input type=&quot;file&quot; id=&quot;file&quot;&gt; --&gt;\n&lt;input type=&quot;file&quot; id=&quot;file&quot; multiple&gt;\n&lt;script&gt;\n  let fileInput = document.getElementById(&#39;file&#39;)\n\n  fileInput.onchange = (event) =&gt; {\n    let formData = new FormData()\n    // 多个文件上传：使用同一个字段上传\n    console.log(event.target.files) // FileList 类数组对象\n    let files = event.target.files\n    for (let i = 0, len = files.length; i &lt; len; i++) {\n      formData.append(&#39;image&#39;, files[i])\n    }\n    // 单文件上传\n    // formData.append(&#39;image&#39;, files[0])\n    formData.append(&#39;param1&#39;, &#39;abc&#39;)\n    fetch(&#39;/upload&#39;, {\n      method: &#39;POST&#39;,\n      body: formData\n    })\n    .then(console.log)\n    .catch(console.log)\n    //  { param1: &#39;abc&#39; }\n  }\n&lt;/script&gt;</code></pre>\n<p>可以看到在前端需要上传文件时，一般使用 FormData 类型数据。使用一个字段存放文件数据，上面例子中使用的是 &quot;image&quot; 字段。另外在上传文件时，额外添加了一个 param1 字段数据。下面来看看 multer 中间件是如何处理文件上传的，注意以下几点:</p>\n<ul>\n<li>如果是单文件上传，使用 <code>multer().single(&#39;文件字段&#39;)</code>。ctx.file 可以拿到 file 对象</li>\n<li>如果是多文件上传，使用 <code>multer().fields([{ name: &#39;文件字段&#39;, maxCount: &#39;允许最大数&#39;}])</code>。ctx.files 可以拿到文件数据对象 <code>{ 字段1: [ file 数组], 字段2: [file 数组] }</code></li>\n<li>如果非文件上传，仅接收 FormData 类型的文本字段，使用 <code>multer().none()</code></li>\n<li>普通 FormData 字段可以从 ctx.request.body 中获取</li>\n<li>file 对象包含如下属性<ul>\n<li><code>fieldname</code> 前端用于存放文件的字段名，这里例子中使用的是 &#39;image&#39;</li>\n<li><code>originalname</code> 文件名</li>\n<li><code>mimetype</code> 文件 MIMT 类型</li>\n<li><code>buffer</code> 文件二进制数据，可以直接使用 <code>fs.writeFileSync(文件名, buffer)</code> 创建文件</li>\n<li><code>size</code> 文件大小，单位字节</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\">const multer = require(&#39;@koa/multer&#39;)\nconst fs = require(&#39;fs&#39;)\n\n// 文件上传处理\n// 前端 append 文件时使用的是 image 字段\nlet singleFileConfig = multer().single(&#39;image&#39;)\nlet multipleFilesConfig = multer().fields([\n  {\n    name: &#39;image&#39;,\n    maxCount: 5\n  }\n])\nlet isMultiple = true\nlet fileConfig = isMultiple ? multipleFilesConfig : singleFileConfig\nrouter.post(&#39;/upload&#39;, fileConfig ,async ctx =&gt; {\n\n  // 文件外的其他 FormData数据 { param1: &#39;abc&#39; }\n  console.log(&#39;ctx.request.body&#39;, ctx.request.body) \n  console.log(&#39;ctx.files&#39;, ctx.files) // 多文件，返回 { 字段1: [file数组], 字段2: [file数组] }\n  console.log(&#39;ctx.file&#39;, ctx.file) // 单文件，返回 file 对象\n\n  // 如果是单文件取文件内容，如果是多文件，取第一个文件，前端字段传的 image\n  let file = isMultiple ? ctx.files[&#39;image&#39;][0] : ctx.file\n  isMultiple &amp;&amp; console.log(`ctx.files[&#39;image&#39;]`, ctx.files[&#39;image&#39;][0])\n\n  // 在服务端本地创建文件\n  let { originalname, buffer } = file\n  fs.writeFileSync(originalname, buffer)\n  // {\n  //   fieldname: &#39;image&#39;,\n  //   originalname: &#39;截屏2020-12-10 下午8.01.44.png&#39;,\n  //   encoding: &#39;7bit&#39;, \n  //   mimetype: &#39;image/png&#39;,\n  //   buffer: &lt;Buffer 89 50 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52 00 00 03 18 00 00 01 56 08 06 00 00 00 ea b0 3b 51 00 00 0c 64 69 43 43 50 49 43 43 20 50 72 6f 66 69 ... 90135 more bytes&gt;,\n  //   size: 90185\n  // }\n  ctx.body = ctx.request.body \n})</code></pre>\n<p>完整测试代码，参见 <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/JS_ES6/JS%E9%AB%98%E7%A8%8B3/fetch\">fetch 上传文件 前端后代码 | Github</a></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/expressjs/multer\">express/multer &#39;multipart/form-data&#39; | Github</a></li>\n<li><a href=\"https://github.com/koajs/multer\">@koa/multer | Github</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "koa 使用 multer 处理文件上传，FormData 数据解析"
        }
      ],
      "config": {
        "source": "koa 使用 multer 处理文件上传，FormData 数据解析.md",
        "staticFileName": "koa-formdata.html",
        "author": "guoqzuo",
        "createDate": "2021/01/12",
        "description": "一般在 koa 中，post 请求的数据是需要中间件来处理的，koa-bodyparser 可以很好的处理 json、serializer 数据，但 `multipart/form-data` 的类型无法处理，一般需要引入另外的中间件来处理，一般建议使用 multer 中间件来处理。先来看看前端上传文件代码，这里使用的是 fetch，当然也可以使用 xhr",
        "keywords": "multipart/form-data,FormData,文件上传",
        "category": "前端工程化",
        "year": "2021",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"node-koa-怎么获取-post-请求-content-type-为-textplain-的数据\">node koa 怎么获取 POST 请求 Content-Type 为 &quot;text/plain&quot; 的数据</h1>\n<p>在 Beacon API 中，使用 <code>navigator.sendBeacon(url, dataString)</code> 发送的是 POST 请求，Content-Type 是比较少见的 &quot;text/plain;charset=UTF-8&quot; 。它既不是 xhr，也不是 fetch，是一种独立的请求类型。在 koa 中，一般使用 koa-bodyparser 来处理 post 请求数据。但这次发现使用 ctx.request.body 无法接收到数据。之前接收 &quot;application/x-www-form-urlencoded&quot; 和 &quot;application/json&quot; 类型的数据都是正常的。</p>\n<p>查了下文档，发现 koa-bodyparser 默认情况下不支持解析 <code>text/plain</code> 类型的数据，需要设置可配置选项才行。</p>\n<blockquote>\n<p>enableTypes: parser will only parse when request type hits enableTypes, support json/form/text/xml, default is [&#39;json&#39;, &#39;form&#39;].</p>\n</blockquote>\n<pre><code class=\"language-js\">app.use(require(&#39;koa-bodyparser&#39;)({\n  enableTypes: [&#39;json&#39;, &#39;form&#39;, &#39;text&#39;]\n}))\nrouter.post(&#39;/user&#39;, async ctx =&gt; {\n  console.log(ctx.request.body) \n  // { page: &#39;/xxx&#39;, duration: &#39;12s&#39; } \n  ctx.body = {\n    a: 1\n  }\n})</code></pre>\n<p>其他 koa-bodyparser 需要注意的地方</p>\n<ul>\n<li>encoding: requested encoding. Default is utf-8 by co-body.</li>\n<li>formLimit: limit of the urlencoded body. If the body ends up being larger than this limit, a 413 error code is returned. Default is 56kb.</li>\n<li>jsonLimit: limit of the json body. Default is 1mb.</li>\n<li>textLimit: limit of the text body. Default is 1mb.</li>\n<li>xmlLimit: limit of the xml body. Default is 1mb.</li>\n</ul>\n<p>参考 </p>\n<ul>\n<li><a href=\"https://github.com/koajs/bodyparser\">post数据解析 koa-bodyparser</a></li>\n<li><a href=\"http://fe.zuo11.com/js/ad3/js-ad3-24.html#beacon-api\">Beacon API - 20. JavaScript API - JS高程4笔记</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "node koa 怎么获取 POST 请求 Content-Type 为 \"text/plain\" 的数据"
        }
      ],
      "config": {
        "source": "node koa 怎么获取 POST 请求 Content-Type 为 'text-plain' 的数据.md",
        "staticFileName": "text-plain-post.html",
        "author": "guoqzuo",
        "createDate": "2021/01/12",
        "description": "在 Beacon API 中，使用 `navigator.sendBeacon(url, dataString)` 发送的是 POST 请求，Content-Type 是比较少见的 'text/plain;charset=UTF-8' 。它既不是 xhr，也不是 fetch，是一种独立的请求类型。在 koa 中，一般使用 koa-bodyparser 来处理 post 请求数据。但这次发现使用 ctx.request.body 无法接收到数据。之前接收 'application/x-www-form-urlencoded' 和 'application/json' 类型的数据都是正常的。",
        "keywords": "text/plain post,post text/plain数据解析",
        "category": "前端工程化",
        "year": "2021",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"socket-bad-handshake-method-400\">socket &quot;Bad handshake method&quot; 400</h1>\n<p>在使用 socket.io 测试 scoket 功能时，发现之前都运行正常的 demo 突然就无法正常运行了。接口返回 400 Bad Request，响应信息为 { code: 2, message: &quot;Bad handshake method&quot; }</p>\n<p><img src=\"../../../images/blog/js/socket_io_err.png\" alt=\"socket_io_err.png\"></p>\n<p>后来发现是版本的问题，前端页面引入的 socket.io 版本是 <code>2.3.0</code>，通过 npm install 默认安装的 socket.io 版本是 <code>3.0.4</code>，将 koa 里面的 npm 包降到  2.3.0 就正常了</p>\n<pre><code class=\"language-bash\">npm uninstall socket.io --save;\nnpm install socket.io@2.3.0 --save;</code></pre>\n<p><img src=\"../../../images/blog/js/socket_io_err_2.png\" alt=\"socket_io_err_2.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "socket \"Bad handshake method\" 400"
        }
      ],
      "config": {
        "source": "socket 'Bad handshake method' 400.md",
        "staticFileName": "socket-400.html",
        "author": "guoqzuo",
        "createDate": "2021/01/12",
        "description": "在使用 socket.io 测试 scoket 功能时，发现之前都运行正常的 demo 突然就无法正常运行了。接口返回 400 Bad Request，响应信息为 { code: 2, message: 'Bad handshake method' } 后来发现是版本的问题，前端页面引入的 socket.io 版本是 `2.3.0`，通过 npm install 默认安装的 socket.io 版本是 `3.0.4`，将 koa 里面的 npm 包降到  2.3.0 就正常了",
        "keywords": "socket.io 400,Bad handshake method",
        "category": "JavaScript",
        "year": "2021",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"http-301-和-302-状态码的区别以及它们在浏览器和搜索引擎中的处理\">HTTP 301 和 302 状态码的区别以及它们在浏览器和搜索引擎中的处理</h1>\n<p>301 和 302 状态码都是表示页面重定向，它们有两个用处：一是告诉浏览器，访问当前页面时需要跳转到新的页面。二是告诉搜索引擎如何正确的处理页面收录、索引。同样是发送 HTTP 请求，接收响应内容，浏览器对重定向页面的处理流程和普通页面有什么区别呢？一般访问某个页面时，基本流程如下：</p>\n<ol>\n<li><code>客户端（浏览器）发起请求</code> 在浏览器中访问某个页面时，会向该页面资源所在的 URL 发送一个 HTTP 请求。</li>\n<li><code>服务端处理请求并响应</code> 服务器接收到请求后，会将资源的数据响应给前端，一般响应状态码 status 为 200，响应内容为 html 文本。</li>\n<li><code>客户端（浏览器）处理</code> 客户端接收到响应后，看状态码是否是 200 或 304(资源未修改)，如果是就将浏览器返回的 html 内容解析、绘制在浏览器窗口中。</li>\n</ol>\n<p>上面是简化版的普通页面打开流程，301 和 302 重定向的处理一般从第 2 步开始，服务器接收到请求后，我们需要自己加判断逻辑：</p>\n<ul>\n<li>如果访问的 <strong>url 已失效，之后这个 url 可能会无法访问</strong>，需要跳转到新的 url，我们需要告诉浏览器我们的这种想法。可以将响应状态码设置为 <strong>301（Permanently Moved 永久性重定向 <code>[ˈpɜːmənəntli]</code>）</strong>，并将 Location 响应头部设置为需要跳转的新 url。</li>\n<li>如果访问的 <strong>url 没有失效，之后这个 url 还是可以访问</strong>，当前只是希望访问该 url 时临时跳转到一个新的 url。可以将响应状态码设置为 <strong>302（Temporarily Moved 临时性重定向 <code>[ˈtemprərəli]</code>）</strong>，并将 Location 响应头部设置为需要跳转的新 url。</li>\n</ul>\n<p>浏览器接收到响应后，当发现响应状态码 status 为 301 或 302 时，会将页面跳转（重定向）到 Location 响应头里设置的 url。下面是使用 koa 在服务端对 301 的实现，参考 <a href=\"http://www.zuo11.com/blog/2020/7/nginx_koa_301.html\">nginx以及koa实现301跳转：xx.com重定向到www.xx.com - 左小白的技术日常</a></p>\n<pre><code class=\"language-js\">const Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\napp.use((ctx) =&gt; {\n  console.log(ctx.url)\n  if (ctx.url === &#39;/test&#39;) {\n    // 当访问 /test 时 301重定向到 http://www.zuo11.com\n    ctx.status = 301\n    ctx.set({\n      &#39;Location&#39;: &#39;http://www.zuo11.com&#39;\n    })\n    return\n  }\n  // 非 /test 时，页面显示 welcome\n  ctx.body = &#39;welcome&#39;\n})\n\napp.listen(&#39;9000&#39;, () =&gt; { console.log(&#39;服务已开启，9000端口&#39;) }) </code></pre>\n<p>对浏览器来说，301 和 302 都是从一个 url 跳转到另一个新的 url，基本没啥区别。但对搜索引擎来说，如果是 301 永久性重定向，页面会删除失效的 url 收录、索引，并替换为新的 url。对于 302 的情况，搜索引擎会保留原 url 的收录和索引，并新增新 url 的收录、索引，这样更有利于页面的程序化处理。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "HTTP 301 和 302 状态码的区别以及它们在浏览器和搜索引擎中的处理"
        }
      ],
      "config": {
        "source": "HTTP 301 和 302 状态码的区别以及它们在浏览器和搜索引擎中的处理.md",
        "staticFileName": "http-301-302.html",
        "author": "guoqzuo",
        "createDate": "2021/01/12",
        "description": "301 和 302 状态码都是表示页面重定向，它们有两个用处：一是告诉浏览器，访问当前页面时需要跳转到新的页面。二是告诉搜索引擎如何正确的处理页面收录、索引。同样是发送 HTTP 请求，接收响应内容，浏览器对重定向页面的处理流程和普通页面有什么区别呢？一般访问某个页面时，基本流程如下：1. `客户端（浏览器）发起请求` 在浏览器中访问某个页面时，会向该页面资源所在的 URL 发送一个 HTTP 请求。2. `服务端处理请求并响应` 服务器接收到请求后，会将资源的数据响应给前端，一般响应状态码 status 为 200，响应内容为 html 文本。3. `客户端（浏览器）处理` 客户端接收到响应后，看状态码是否是 200 或 304(资源未修改)，如果是就将浏览器返回的 html 内容解析、绘制在浏览器窗口中。",
        "keywords": "301与302区别",
        "category": "http与https",
        "year": "2021",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"什么是-bdd-风格（bdd-style）\">什么是 BDD 风格（BDD style）</h1>\n<blockquote>\n<p>should.js - BDD style shown throughout these docs</p>\n</blockquote>\n<p>在 Mocha 官网的中，介绍 should.js 时，说它是一种 BDD 风格的断言库。而且在 mocha 的源码中，有很多都是以 bdd 命名的。那什么是 BDD 呢？</p>\n<p>BDD 是 Behavior Driven Development 的简写，行为驱动开发，是在测试驱动开发（Test-Driven Development，TDD）基础上发展而来的一种软件开发方法。</p>\n<p>TDD 测试驱动开发只关心代码要怎么写，有如下特点</p>\n<ul>\n<li>写代码的时候要先写测试，反之测试不了的代码就不能写。测试是多种多样的，单元测试是最常见的，还有 UI 自动化测试</li>\n<li>先写测试也有助于你理清代码的调用关系，写出来的逻辑更严谨</li>\n<li>只要你写的每一次代码都有测试可以运行，那你的测试就非常全面了</li>\n</ul>\n<p>BDD 行为驱动开发的本质在于 <strong>尽可能避免在需求描述、用例撰写、代码实现、测试等各环节衔接、转译过程中发生的信息丢失</strong>。和 TDD 不是一个概念。BDD使用 &quot;用户故事&quot; 来描述需求，然后开发人员将这些故事带入具体应用，通过不断迭代添加入真正的业务本质。</p>\n<p><strong>BDD 风格强调使用完整的、描述性的、便于业务用户理解的名称或术语，避免使用技术术语</strong>。BDD 希望类、方法和变量的名称尽可能地反映日常用语。在编写单元测试的时候，尽量使用 BDD 风格为测试命名。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/Abbey/p/4999634.html\">行为驱动开发BDD概要 - 没头脑的老毕 - 博客园</a></li>\n<li><a href=\"https://www.zhihu.com/question/20161970/answer/1341811526\">TDD 与 BDD 仅仅是语言描述上的区别么？- 知乎</a></li>\n<li><a href=\"https://www.cnblogs.com/Leo_wl/p/5300368.html\">行为驱动开发（BDD） - HackerVirus - 博客园</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "什么是 BDD 风格（BDD style）"
        }
      ],
      "config": {
        "source": "什么是 BDD 风格（BDD style）.md",
        "staticFileName": "bdd-style.html",
        "author": "guoqzuo",
        "createDate": "2021/01/12",
        "description": "在 Mocha 官网的中，介绍 should.js 时，说它是一种 BDD 风格的断言库。而且在 mocha 的源码中，有很多都是以 bdd 命名的。那什么是 BDD 呢？BDD 是 Behavior Driven Development 的简写，行为驱动开发，是在测试驱动开发（Test-Driven Development，TDD）基础上发展而来的一种软件开发方法。",
        "keywords": "BDD,TDD,BDD Style",
        "category": "计算机基础与开发工具",
        "year": "2021",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"error-timeout-of-2000ms-exceeded-mocha-超时解决方法\">Error: Timeout of 2000ms exceeded. Mocha 超时解决方法</h1>\n<p>在 mocha 中，默认每个测试时间限制为 2s，如果超过两秒就会抛出异常。对于大于 2s 的异步任务可以使用 mocha 上下文的 timeout() 方法手动指定超时时间。注意不要使用箭头函数，否则无法调用 this.timeout() 方法。</p>\n<ul>\n<li><code>this.timeout(5000)</code> 将超时时间设置为 5s，这样就不会有 2s 的限制了</li>\n<li><code>this.timeout(1000)</code> 对于性能要求较高的场景，可以限制超时时间为 1s</li>\n</ul>\n<pre><code class=\"language-js\">// 耗时 3s 的异步任务\nfunction asyncOptPromise() {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      if (1 === 2) {\n        resolve()\n      } else {\n        reject(&#39;不相等&#39;) // 也可以是 reject(new Error(&#39;不相等&#39;))\n      }\n    }, 3000)\n  })\n}\n\ndescribe(&#39;异步测试&#39;, function () {\n  it(&#39;asyncOpt 正确执行应该返回 true&#39;, async function() {\n    this.timeout(5000); // 设置超时时间为 5s\n    // this.timeout(1000); \n    await asyncOptPromise()\n  })\n})</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Error: Timeout of 2000ms exceeded. Mocha 超时解决方法"
        }
      ],
      "config": {
        "source": "Error: Timeout of 2000ms exceeded. Mocha 超时解决方法.md",
        "staticFileName": "mocha-timeout.html",
        "author": "guoqzuo",
        "createDate": "2021/01/12",
        "description": "在 mocha 中，默认每个测试时间限制为 2s，如果超过两秒就会抛出异常。对于大于 2s 的异步任务可以使用 mocha 上下文的 timeout() 方法手动指定超时时间。注意不要使用箭头函数，否则无法调用 this.timeout() 方法。 - `this.timeout(5000)` 将超时时间设置为 5s，这样就不会有 2s 的限制了 - `this.timeout(1000)` 对于性能要求较高的场景，可以限制超时时间为 1s",
        "keywords": "mocha tiemout,mocha 超时",
        "category": "JavaScript",
        "year": "2021",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"使用-service-worker-接收服务器推送消息并显示通知\">使用 Service Worker 接收服务器推送消息并显示通知</h1>\n<p>推送通知一般需要支持服务器推送，在常规网页中是不可能的。service worker 可以实现该行为</p>\n<ul>\n<li>service worker 可以显示通知</li>\n<li>service worker 可以处理这些通知的交互</li>\n<li>service worker 能够订阅服务器发送的推送通知</li>\n<li>service worker 能够处理推送消息，即使应用没有在前台运行或者根本没打开</li>\n</ul>\n<p><img src=\"../../../images/blog/js/sw-push-img.png\" alt=\"sw-push-img.png\"></p>\n<h2 id=\"1-显示通知\">1. 显示通知</h2>\n<p>在 service worker 中可以使用 ServcieWorkerRegistration 对象支持 showNotifications() 方法来显示通知，可以配置 title 和 options 配置</p>\n<pre><code class=\"language-js\">navigator.serviceWorker.register(&#39;./serviceWorker.js&#39;)\n  .then((registration) =&gt; {\n    Notification.requestPermission()\n      .then(status =&gt; {\n        if (status === &#39;granted&#39;) {\n          registration.showNotification(&#39;title&#39;)\n        }\n      })\n  })</code></pre>\n<p>在 serviceWorker.js 中使用 self.registration 也可以显示通知</p>\n<pre><code class=\"language-js\">// 注意 onactivate 默认只触发一次\nself.onactivate = () =&gt; self.registration.showNotification(&#39;bar&#39;)</code></pre>\n<h2 id=\"2-处理通知事件\">2. 处理通知事件</h2>\n<p>ServiceWorkerRegistration 对象创建的通知会向 service worker 发送 notificationclick 和 notificationclose 事件</p>\n<pre><code class=\"language-js\">self.onnotificationclick = (event) =&gt; {\n  // NotificationEvent {}, Notification {}\n  console.log(&#39;notification click&#39;, event, event.notification)\n  // 点击通知后，在新的 tab 打开网页\n  clients.openWindow(&#39;http://www.zuo11.com&#39;)\n}\nself.onnotificationclose = (event) =&gt; {\n  console.log(&#39;notification close&#39;, event, event.notification)\n}</code></pre>\n<h2 id=\"3订阅推送事件\">3.订阅推送事件</h2>\n<p>使用 registration.pushManager.subscribe() 可以对服务器推送消息发起订阅。注意这个过程中不会发送请求到我们的应用服务器。该函数包含两个参数：</p>\n<ul>\n<li><code>userVisibleOnly</code> 通常被设置为 true，用来表示后续信息是否展示给用户。</li>\n<li><code>applicationServerKey</code> 秘钥，类型为 Uint8Array，用于加密服务端的推送信息，防止中间人攻击，会话被攻击者篡改。测试时，可以通过 <a href=\"https://web-push-codelab.glitch.me/\">web-push-codelab</a> 网站获取秘钥并验证全流程，将该网站随机生产的 Application Server Keys 中的 Public Key 使用 urlBase64ToUint8Array() 转换后即可当做 applicationServerKey 使用</li>\n</ul>\n<p>urlBase64ToUint8Array() 函数代码</p>\n<pre><code class=\"language-js\">function urlBase64ToUint8Array(base64String) {\n  const padding = &#39;=&#39;.repeat((4 - base64String.length % 4) % 4);\n  const base64 = (base64String + padding)\n    .replace(/-/g, &#39;+&#39;)\n    .replace(/_/g, &#39;/&#39;);\n\n  const rawData = window.atob(base64);\n  const outputArray = new Uint8Array(rawData.length);\n\n  for (let i = 0; i &lt; rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n  return outputArray;\n}</code></pre>\n<p><strong>registration.pushManager.subscribe() 函数返回一个 Promise，resolve 为 PushSubscription 对象，该对象包含服务器推送时必要的信息</strong> 不同的浏览器，对应的 endpoint 不一样。Chrome 和 Firefox 会不一样，如下图</p>\n<p><img src=\"../../../images/blog/js/sw_push.png\" alt=\"sw_push.png\"></p>\n<p><strong>如果一直卡在 registration.pushManager.subscribe()，不向下执行，状态一直时 pending，可能是因为 Chrome 浏览器关于推送消息的功能，被墙了，需要科学上网才能正常返回</strong></p>\n<p>订阅代码如下：</p>\n<pre><code class=\"language-js\">// main.js\n(async () =&gt; {\n  try {\n    const registration = await navigator.serviceWorker.register(&quot;sw.js&quot;);\n    const status = await Notification.requestPermission()\n    if (status === &#39;granted&#39;) {\n      const vapidPublicKey = &#39;BF9WWlvQiKSOwziO4gVeBdMeuhDW2HU2aCWAmaSLgXqGCGZK3ho15l30oQ6pdavh8acsc1kiXJNK-DtaqbHaZCQ&#39;;\n      const convertedVapidKey = urlBase64ToUint8Array(vapidPublicKey);\n      // 防止 DOMException: Failed to execute &#39;subscribe&#39; on &#39;PushManager&#39;: Subscription failed - no active Service Worker\n      if (!registration.active) {\n        // 等待变为激活状态\n        await new Promise(r =&gt; setTimeout(r, 500))\n      }\n      const pushSubscription = await registration.pushManager.subscribe({\n        applicationServerKey: convertedVapidKey, // 来自服务器的公钥\n        userVisibleOnly: true\n      });\n      console.log(pushSubscription) // PushSubscription\n      console.log(JSON.stringify(pushSubscription)) // 这个消息可用于服务端发起推送\n      // { \n      //   &quot;endpoint&quot;: &quot;https://fcm.googleapis.com/fcm/send/ecbqKLEnhB8:APA91bGvTW0x3k57bT9gDMLPPVkwLotGJyqJ1kk8yvNHyNAJ8Z0F6O74BuA8QxVNPIsgf1gWlGrUe0bYSs4L6fo-Fl18WkwGyHc3FEo2YvSUXBr5AA7KenaZBkL1D87WuAE7ERl-JCM4&quot;,\n      //   &quot;expirationTime&quot;: null, \n      //   &quot;keys&quot;: { \n      //     &quot;p256dh&quot;: &quot;BIpKDNOPNQcBnfJVmdtZM2eJ0qS-FjicsiZK8jyUU07lGREwM_VZe2ulIWdrdlNlg7RFnHge8vJSe5y6TagW3Oc&quot;,\n      //     &quot;auth&quot;: &quot;IlAite8VLBLWV5ubUXg91w&quot;\n      //   }\n      // }\n    }\n  } catch (err) {\n    console.log(err);\n  }\n})()</code></pre>\n<p>上面的例子中，成功拿到 JSON.stringify(pushSubscription) 后，就可以在服务端使用该信息进行推送通知了。</p>\n<h2 id=\"4处理服务端推送消息\">4.处理服务端推送消息</h2>\n<pre><code class=\"language-js\">// sw.js\n// 当接收到服务端推送的消息时\nself.onpush = pushEvent =&gt; {\n  // 服务器推送的消息文本\n  console.log(pushEvent.data.text())\n  // 保持 service worker 活动到显示通知 resolve\n  pushEvent.waitUntil(\n    // 将服务器推送的消息作为通知显示\n    self.registration.showNotification(pushEvent.data.text())\n  )\n}\n// 点击消息时\nself.onnotificationclick = (event) =&gt; {\n  // NotificationEvent {}, Notification {}\n  console.log(&#39;notification click&#39;, event, event.notification)\n  // 点击通知后，在新的 tab 打开网页\n  clients.openWindow(&#39;http://www.zuo11.com&#39;)\n}</code></pre>\n<p>现在来测试下，上面的例子中，我们使用 <a href=\"https://web-push-codelab.glitch.me/\">web-push-codelab</a> 网站获取了 applicationServerKey 秘钥，我们同样可以在该网站发起服务端消息推送。将之前我们获取的 JSON.stringify(pushSubscription) 字符串拷贝到该网站的 Subscription to Send To 那一栏，然后在 Text to Send 中填写需要推送的消息。再点击 Send Push Message 按钮即可进行服务器推送。</p>\n<p>这样就可以看到通知了。上面只是为了方便测试，如果需要使用程序化的方式来进行服务端推送，那就需要把 JSON.stringify(pushSubscription) 字符串传到后端，以 Node.js 为例，后端可以使用 <a href=\"https://github.com/web-push-libs/web-push\">web-push</a> 来进行服务端推送。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/57225424\">Service Worker学习与实践（三）——消息推送 - 知乎</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_33841722/article/details/88731760\">Service Worker学习与实践（三）——消息推送 - CSDN</a></li>\n<li><a href=\"https://w3c.github.io/push-api/#widl-PushManager-subscribe-Promise-PushSubscription--PushSubscriptionOptions-options\">Push API - W3C Editor&#39;s Draft 07 October 2020</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "使用 Service Worker 接收服务器推送消息并显示通知",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "1. 显示通知"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "2. 处理通知事件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "3.订阅推送事件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "4.处理服务端推送消息"
            }
          ]
        }
      ],
      "config": {
        "source": "使用 Service Worker 接收服务器推送消息并显示通知.md",
        "staticFileName": "sw-notification.html",
        "author": "guoqzuo",
        "createDate": "2021/01/12",
        "description": "推送通知一般需要支持服务器推送，在常规网页中是不可能的。service worker 可以实现该行为 - service worker 可以显示通知 - service worker 可以处理这些通知的交互 - service worker 能够订阅服务器发送的推送通知 - service worker 能够处理推送消息，即使应用没有在前台运行或者根本没打开",
        "keywords": "service worker接收服务器推送消息",
        "category": "JavaScript",
        "year": "2021",
        "month": "1"
      }
    },
    {
      "htmlStr": "<h1 id=\"typescript-error-in-antdmodal-refers-to-a-value-but-is-being-used-as-a-type-here\">TypeScript error in &#39;AntdModal&#39; refers to a value, but is being used as a type here.</h1>\n<p>在 ts + react + ant-design 的项目中，git clone 项目后，npm install 了，但 npm run serve 时一直提示 TypeScript error in &#39;AntdModal&#39; refers to a value, but is being used as a type here. 在这个项目的场景下，npm install 安装的包是不全的</p>\n<p><strong>需要使用 yarn 来安装</strong>，具体命令如下</p>\n<pre><code class=\"language-bash\"># 全局安装 yarn\nsudo npm install yarn -g\n# 在项目下安装所有模块 \nyarn add # 相当于 npm install </code></pre>\n<p>这样安装后，就不会报错了，比较奇怪的一个问题。更多 Yarn 命令用法参考: <a href=\"https://yarn.bootcss.com/docs/cli/\">Yarn CLI 简介</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "TypeScript error in 'AntdModal' refers to a value, but is being used as a type here."
        }
      ],
      "config": {
        "source": "TypeScript error in 'AntdModal' refers to a value, but is being used as a type here.md",
        "staticFileName": "ts_error_yarn.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "在 ts + react + ant-design 的项目中，git clone 项目后，npm install 了，但 npm run serve 时一直提示 TypeScript error in 'AntdModal' refers to a value, but is being used as a type here. 在这个项目的场景下，npm install 安装的包是不全的。需要使用 yarn 来安装，具体命令如下",
        "keywords": "TypeScript error in 'AntModal',refers to a value, but is being used as a type here",
        "category": "TypeScript",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"npm-run-start-为什么可以简写为-npm-start，npm-run-start-与-npm-start-区别\">npm run start 为什么可以简写为 npm start，npm run start 与 npm start 区别</h1>\n<p>在一些项目中发现项目启动命令是 npm start，但一般启动都是 npm run xxx，而 npm start 有点像 npm run start 的简写，于是就想着他们之间有什么关系，其它的命令是否也可以简写。下面来具体看看 npm start 与 npm run start.</p>\n<p>一般在 node 项目中，npm run xxx 会执行 package.json 配置中 &quot;scripts&quot; 字段中对应的命令，可以用于创建某些命令的快捷执行方式。比如在下面的例子中</p>\n<pre><code class=\"language-js\">// package.json\n{\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;node foo.js&quot;,\n    &quot;dev&quot; &quot;node dev.js&quot;,\n    &quot;build&quot;: &quot;vuepress build docs&quot;\n  }\n}</code></pre>\n<p>npm run dev 相当于 node dev.js 命令的快捷方式。另外它还可以<strong>用于在未全局安装某个命令时，项目内局部运行命令</strong>。上面的例子中 vuepress 命令未全局安装，仅项目内安装，要执行 vuepress 命令就需要使用 scripts 快捷方式执行了。</p>\n<p>这里的 npm run build，相当于在项目目录下执行了 <code>./node_modules/.bin/vuepress build docs</code></p>\n<p>知道这些后，再回归我们的主题，npm run start 为什么可以简写为 npm start 呢？是否 npm run xxx，可以直接简写问 npm xxx 呢？</p>\n<p>查阅了 npm 官方文档，发现 npm start 其实是内置的命令。只是巧合，并不是 npm run xxx 可以简写为 npm xxx</p>\n<p>npm start 的运行机制，<code>npm start</code> Description</p>\n<p>This runs a predefined command specified in the &quot;start&quot; property of a package&#39;s &quot;scripts&quot; object.</p>\n<p>If the &quot;scripts&quot; object does not define a &quot;start&quot; property, npm will run node server.js.</p>\n<p>它会执行 scripts 中 &quot;start&quot; 属性预先指定的脚本，如果 &quot;scripts&quot; 中没有设置 &quot;start&quot; 属性，那么就运行 &quot;node server.js&quot; 命令。</p>\n<p>更多 npm 指令、scripts 相关，参考:</p>\n<ul>\n<li><a href=\"https://docs.npmjs.com/cli/v7/commands/npm-run-script\">npm-run-script | npm Docs</a></li>\n<li><a href=\"https://docs.npmjs.com/cli/v7/commands/npm-start\">npm-start | npm Docs</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "npm run start 为什么可以简写为 npm start，npm run start 与 npm start 区别"
        }
      ],
      "config": {
        "source": "npm run start 为什么可以简写为 npm start，npm run start 与 npm start 区别.md",
        "staticFileName": "npm_start.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "在一些项目中发现项目启动命令是 npm start，但一般启动都是 npm run xxx，而 npm start 有点像 npm run start 的简写，于是就想着他们之间有什么关系，其它的命令是否也可以简写。下面来具体看看 npm start 与 npm run start.",
        "keywords": "npm start 与 npm run start 区别,npm start,npm run start",
        "category": "前端工程化",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"npx-create-react-app-my-app-是什么意思？npx-有什么作用？\">npx create-react-app my-app 是什么意思？npx 有什么作用？</h1>\n<p>在 react 官网，介绍 create-react-app 构建工具时，直接使用 npx create-react-app my-app 就可以直接创建一个 react 项目的脚手架，那 npx 命令执行和普通的 create-react-app my-app 有什么区别呢？下面来看看</p>\n<p>在之前介绍 <a href=\"http://www.zuo11.com/blog/2020/11/npm_cmd_part.html\">不全局安装npm包，怎么在项目目录下局部执行对应的命令</a> 中提到过三种方法</p>\n<ul>\n<li>npm run xxx</li>\n<li>npx 命令</li>\n<li>./node_modules/.bin/命令</li>\n</ul>\n<p><strong>npx 命令可以运行当前项目下的局部命令，而不用添加到 &quot;scripts&quot; 配置中</strong>，相当于使用 <code>./node_modules/.bin/xx</code>。</p>\n<p><strong>另外它可以直接从 npm 官方库中远程拉取包，并执行对应的命令</strong>，避免使用命令前需要全局安装或局部安装该命令才能运行。</p>\n<p><code>npx create-react-app my-app</code> 运行时，会将 <code>create-react-app</code> 下载到一个临时的目录，使用该命令执行 <code>create-react-app my-app</code>，完成后再删除 <code>create-react-app</code>。另外 npx 下载包时还可以指定版本，比如</p>\n<pre><code class=\"language-bash\"># 从 npm 拉取 uglify-js 的 3.1.0 版本，并对 main.js 执行混淆压缩，输出到 main.js\nnpx uglify-js@3.1.0 main.js -o ./dist/main.js</code></pre>\n<p>更多 npx 使用方法，参考: <a href=\"http://www.ruanyifeng.com/blog/2019/02/npx.html\">npx 使用教程 - 阮一峰的网络日志</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "npx create-react-app my-app 是什么意思？npx 有什么作用？"
        }
      ],
      "config": {
        "source": "npx create-react-app my-app 是什么意思？npx 有什么作用？.md",
        "staticFileName": "npx_use.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "在 react 官网，介绍 create-react-app 构建工具时，直接使用 npx create-react-app my-app 就可以直接创建一个 react 项目的脚手架，那 npx 命令执行和普通的 create-react-app my-app 有什么区别呢？下面来看看",
        "keywords": "npx 用法,npx 有什么用,npx create-react-app",
        "category": "前端工程化",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"react-declarative-声明式是什么意思？声明式编程与命令式-imperative-编程\">React Declarative 声明式是什么意思？声明式编程与命令式 imperative 编程</h1>\n<p>React 的 Declarative 特性是什么意思？在 React github 的 README.md 中，介绍 react 的特点时，第一个是 Declarative，翻译成中文是声明式，具体要怎么理解呢？下面来看看</p>\n<p>React is a JavaScript library for building user interfaces.</p>\n<ul>\n<li><strong>Declarative</strong>: React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes. Declarative views make your code more predictable, simpler to understand, and easier to debug.</li>\n<li><strong>Component-Based</strong>: ...</li>\n<li><strong>Learn Once, Write Anywhere</strong>: ...</li>\n</ul>\n<p>React 是一个用于构建用户界面的 JS 库</p>\n<ul>\n<li>声明式：React 使创建交互式 UI 变得很轻松。 为应用程序中的每个状态设计简单的视图，当数据更改时，React 将有效地更新和渲染正确的组件。声明式视图使您的代码更具可预测性，更易于理解且易于调试。</li>\n</ul>\n<p>在计算机术语中有 <strong>声明式编程 declarative</strong> 和 <strong>命令式编程 imperative</strong> 两种编程模式</p>\n<ul>\n<li>声明式编程：告诉机器，我要做什么（what），具体怎么做（how）由机器自己决定。</li>\n<li>命令式编程：告诉机器，具体怎么做（how），机器不会管你具体要做什么（what）。</li>\n</ul>\n<p>了解上面的两个概念后，我们再来看 React 的 Declarative 声明式渲染就很好理解了。<strong>使用 React 时，我们只需要修改数据，表达我们想要在网页上修改对应内容的意图即可，具体怎么做（修改 dom），React 内部会帮我们以最优的方式完成。</strong></p>\n<p>参考：<a href=\"https://blog.csdn.net/feicongcong/article/details/79915273\">声明式编程declarative和命令式编程imperative的比较</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "React Declarative 声明式是什么意思？声明式编程与命令式 imperative 编程"
        }
      ],
      "config": {
        "source": "React Declarative 声明式是什么意思？声明式编程与命令式 imperative 编程.md",
        "staticFileName": "react_declarative.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "React 的 Declarative 特性是什么意思？在 React github 的 README.md 中，介绍 react 的特点时，第一个是 Declarative，翻译成中文是声明式，具体要怎么理解呢？下面来看看",
        "keywords": "declarative与imperative,声明式编程,React Declarative; react declarative",
        "category": "React",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"mac-安装-brew-异常-fatal-unable-to-access-httpsgithubcomhomebrewbrew\">mac 安装 brew 异常: fatal: unable to access &#39;<a href=\"https://github.com/Homebrew/brew/&#39;\">https://github.com/Homebrew/brew/&#39;</a></h1>\n<p>为了快速安装 svn, git, nginx 等，我想着先在 macbook 上安装 brew，按照常规的方法修改了 ruby 源，但还是出现安装错误 <code>fatal: unable to access &#39;https://github.com/Homebrew/brew/&#39; LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 Failed during: git fetch --force origin</code> </p>\n<p>意思大概是在 github 上拉取 brew 时，出现 443 错误。我们可以通过替换安装时的 shell 路径来解决，一般我们使用的安装命令如下</p>\n<pre><code class=\"language-js\">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;</code></pre>\n<p><strong>这样可能会出错，不推荐使用，我们可以使用 gitee 上的一个 shell 脚本 进行安装</strong>，命令如下</p>\n<pre><code class=\"language-js\">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</code></pre>\n<p>按照提示安装好，就可以使用 brew install 命令来安装 nginx，svn 等工具了</p>\n<p>一般常规修改 ruby 源的方法</p>\n<pre><code class=\"language-bash\"># 修改源\ngem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/\n# 查看当前源\ngem sources -l\n# *** CURRENT SOURCES ***\n\n# https://gems.ruby-china.com/</code></pre>\n<p>参考: <a href=\"https://www.zhihu.com/question/35928898?sort=created\">mac安装homebrew失败怎么办？- 知乎</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "mac 安装 brew 异常: fatal: unable to access 'https://github.com/Homebrew/brew/'"
        }
      ],
      "config": {
        "source": "mac 安装 brew 异常: fatal: unable to access 'https:--github.com-Homebrew-brew-'.md",
        "staticFileName": "mac_brew_new.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "为了快速安装 svn, git, nginx 等，我想着先在 macbook 上安装 brew，按照常规的方法修改了 ruby 源，但还是出现安装错误 `fatal: unable to access 'https://github.com/Homebrew/brew/' LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 Failed during: git fetch --force origin` ",
        "keywords": "mac安装brew fail,mac 安装 brew,mac homebrew 安装失败",
        "category": "计算机基础与开发工具",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"git-xcrun-error-invalid-active-developer-path\">git xcrun: error: invalid active developer path</h1>\n<p>在 mac 下输入 git 命令，突然提示 xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun，可能是没有安装 xcode，有些功能没有的原因。</p>\n<p>一般可以通过运行 <code>xcode-select --install</code> 命令来解决，按照提示完成安装，就 OK 了</p>\n<pre><code class=\"language-bash\"># 安装一些依赖\nxcode-select --install</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "git xcrun: error: invalid active developer path"
        }
      ],
      "config": {
        "source": "git xcrun: error: invalid active developer path.md",
        "staticFileName": "git_xcrun_error.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "在 mac 下输入 git 命令，突然提示 xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun，可能是没有安装 xcode，有些功能没有的原因。一般可以通过运行 `xcode-select --install` 命令来解决，按照提示完成安装，就 OK 了",
        "keywords": "git xcrun error,invalid active developer path",
        "category": "计算机基础与开发工具",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"vscode-下载太慢，vscode-官网下载太慢解决方法\">vscode 下载太慢，vscode 官网下载太慢解决方法</h1>\n<p>在 vscode 官网下载 vscode 时，发现非常慢，过会儿就下载失败了。如下图</p>\n<p><img src=\"../../../images/blog/devtools/vscode_download_fail.png\" alt=\"vscode_download_fail.png\"></p>\n<p>为了解决这个问题，我们可以在下载中，找到对应的下载链接将 url 前面的域名修改为其他源，这样下载会很快。如下图</p>\n<p><img src=\"../../../images/blog/devtools/vscode_download_fix.png\" alt=\"vscode_download_fix.png\"></p>\n<p>将 vscode 官网默认下载 url 前面的路径改为 <code>vscode.cdn.azure.cn</code> 即可</p>\n<p>参考: <a href=\"https://zhuanlan.zhihu.com/p/112215618\">国内下载vscode速度慢问题解决 - 知乎</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vscode 下载太慢，vscode 官网下载太慢解决方法"
        }
      ],
      "config": {
        "source": "vscode 下载太慢，vscode 官网下载太慢解决方法.md",
        "staticFileName": "vscode_download_slow.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "在 vscode 官网下载 vscode 时，发现非常慢，过会儿就下载失败了。如下图，为了解决这个问题，我们可以在下载中，找到对应的下载链接将 url 前面的域名修改为其他源，这样下载会很快。如下图，将 vscode 官网默认下载 url 前面的路径改为 `vscode.cdn.azure.cn` 即可。参考: [国内下载vscode速度慢问题解决 - 知乎](https://zhuanlan.zhihu.com/p/112215618)",
        "keywords": "vscode下载慢,vscode官网下载慢,vscode download slow",
        "category": "计算机基础与开发工具",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"多个-ssh-怎么配置，github、gitlab、gitee-多个平台配置并测试\">多个 ssh 怎么配置，github、gitlab、gitee 多个平台配置并测试</h1>\n<p>在之前我们有介绍过 <a href=\"http://www.zuo11.com/blog/2020/8/git_ssh.html\">使用ssh方式拉取代码的步骤</a>，仅一个平台时（比如 github）还可以。如果多个 git 平台（比如 github、gitlab、gitee）都需要配置 ssh 时，那怎么配置呢？</p>\n<p>首先我们要在 ~/.ssh/ 目录下新建一个 config 文件，内容如下</p>\n<pre><code class=\"language-bash\"># github 配置\nHost github.com\n    HostName github.com\n    IdentityFile ~/.ssh/id_rsa\n    User guoqzuo@gmail.com\n\n# gitee 配置\nHost gitee.com\n    HostName gitee.com\n    IdentityFile ~/.ssh/gitee/id_rsa_gitee\n    User 916707888@qq.com\n\n# gitlab 配置\nHost gitlab.com\n    HostName gitlab.com\n    IdentityFile ~/.ssh/gitlab/id_rsa_gitlab\n    User i@zuoguoqing.com</code></pre>\n<p>其中 IdentityFile 指定的秘钥文件是需要注意的，需要使用 <code>ssh-keygen -t rsa -C &quot;对应的邮箱&quot;</code> 生成 id_rsa 秘钥对，其中 id_rsa.pub 公钥文件中的内容是需要设置到 github/gitee/gitlab 等平台上的。由于有多个，我们需要指定对应的文件名字，一般以 id_rsa_github 或 id_rsa_gitlab 来与默认的文件名做区别。注意：如果不指定名字，默认会放到 <code>~/.ssh/id_rsa</code>，自定义文件名后，如果没指定目录，会在当前目录生成。建议都放到 <code>~/.ssh/</code> 目录下方便管理。</p>\n<p>测试 ssh key 是否配置成功</p>\n<pre><code class=\"language-bash\"># 测试 gitee ssh 是否配置成功\nssh -T git@gitee.com\n# Hi 左国清! You&#39;ve successfully authenticated, but GITEE.COM does not provide shell access.\n\n# 测试 github ssh 是否配置成功\nssh -T git@github.com\n# Hi zuoxiaobai! You&#39;ve successfully authenticated, but GitHub does not provide shell access.\n\n# 测试 gitlab ssh 是否配置成功\nssh -T git@gitlab.com\n# Welcome to GitLab, @zuoxiaobai!</code></pre>\n<p>如果在测试时，没有提示上面的内容，而是提示 <code>The authenticity of host &#39;github.com (140.82.121.4)&#39; can&#39;t be established. RSA key fingerprint is SHA256:xxxx... Are you sure you want to continue connecting (yes/no/[fingerprint])?</code> 选择 yes 即可，会将对应的 key 添加到 <code>~/.ssh/known_hosts</code> 中，然后就能看到上面的成功信息了。我的 <code>~/.ssh/</code> 目录内容如下</p>\n<pre><code class=\"language-bash\"># 查看 \nls ~/.ssh/\n# config        gitee        gitlab        id_rsa        id_rsa.pub    known_hosts</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "多个 ssh 怎么配置，github、gitlab、gitee 多个平台配置并测试"
        }
      ],
      "config": {
        "source": "多个 ssh 怎么配置，github、gitlab、gitee 多个平台配置并测试.md",
        "staticFileName": "multiple_ssh.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "在之前我们有介绍过使用 ssh 方式拉取代码的步骤，仅一个平台时（比如 github）还可以。如果多个 git 平台（比如 github、gitlab、gitee）都需要配置 ssh 时，那怎么配置呢？首先我们要在 ~/.ssh/ 目录下新建一个 config 文件，内容如下",
        "keywords": "ssh多git平台,多个ssh配置,multiple ssh",
        "category": "运维部署与版本控制",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"vscode-terminal-中-the-term-node-is-not-recognied\">vscode terminal 中 the term &#39;node&#39; is not recognied</h1>\n<p>windows 系统下，在 vscode 的 Terminal 中，运行 npm install 或 node 命令时都会提示 the term node/npm is not recognied... 但是如果打开系统的 terminal 运行命令就是正常的。</p>\n<p>仔细看会发现 vscode 中使用的是 Powershell，而一般默认的 bash。Powershell 中无法执行 node 命令，需要运行下面的命令更新环境变量中的 Path</p>\n<pre><code class=\"language-bash\"># 运行下面的命令，重启系统即可\n$env:path -split &#39;;&#39; | Select-String nodejs</code></pre>\n<blockquote>\n<p>Check the Path in environment variable using script <code>$env:path -split &#39;;&#39; | Select-String nodejs</code> and once you update the Path in environment variable, make sure to restart powershell and also restart explorer.exe. This would resolve the issue.</p>\n</blockquote>\n<p>参考：<a href=\"https://stackoverflow.com/questions/30318628/the-term-node-is-not-recognized-in-powershell\">windows - The term &#39;node&#39; is not recognized... In Powershell - Stack Overflow</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vscode terminal 中 the term 'node' is not recognied"
        }
      ],
      "config": {
        "source": "vscode terminal 中 the term 'node' is not recognied.md",
        "staticFileName": "not_recognied_terminal.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "windows 系统下，在 vscode 的 Terminal 中，运行 npm install 或 node 命令时都会提示 the term node/npm is not recognied... 但是如果打开系统的 terminal 运行命令就是正常的。仔细看会发现 vscode 中使用的是 Powershell，而一般默认的 bash。Powershell 中无法执行 node 命令，需要运行下面的命令更新环境变量中的 Path",
        "keywords": "the term 'node' is not recognied,the term 'npm' is not recognied",
        "category": "计算机基础与开发工具",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"git-clone-输错了密码，怎么重新输入或修改密码\">git clone 输错了密码，怎么重新输入或修改密码</h1>\n<p>在 windows 系统中，如果是第一次拉取代码，而且是使用的 http 方式，涉及到登录的时候，会要求输入 git 相关账号密码，如果账号密码不小心输入错误。后面每次 git clone 都会提示 auth 失败。</p>\n<p>这时我们可以在 <strong>控制面板 - 用户账户 - 凭据管理器</strong> 里修改对应的密码</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "git clone 输错了密码，怎么重新输入或修改密码"
        }
      ],
      "config": {
        "source": "git clone 输错了密码，怎么重新输入或修改密码.md",
        "staticFileName": "git_clone_pw_error.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "在 windows 系统中，如果是第一次拉取代码，而且是使用的 http 方式，涉及到登录的时候，会要求输入 git 相关账号密码，如果账号密码不小心输入错误。后面每次 git clone 都会提示 auth 失败。这时我们可以在 **控制面板 - 用户账户 - 凭据管理器** 里修改对应的密码",
        "keywords": "git clone error,git clone auth fail",
        "category": "运维部署与版本控制",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"vuepress-html-lang-默认为英文，总是弹出-google-翻译怎么解决\">vuepress html lang 默认为英文，总是弹出 google 翻译怎么解决</h1>\n<p>默认情况下，vuepress 生成的网页 html lang 属性为 &quot;en-US&quot;，当在 Chrome 浏览器打开时，总是会弹出翻译的窗口。如下图</p>\n<p><img src=\"../../../images/blog/vue/chrome-translate.png\" alt=\"chrome-translate.png\"></p>\n<p>解决这个问题的方法就是将默认的 lang 设置为中文 &quot;zh-CN&quot; 即可。vuepress 支持国际化功能，我们只需要修改下对应的配置即可。</p>\n<pre><code class=\"language-js\">// .vuepress/config.js\nmodule.exports = {\n  title: &#39;左小白的前端笔记&#39;,\n  // 国际化相关\n  locales: {\n    // 键名是该语言所属的子路径\n    // 作为特例，默认语言可以使用 &#39;/&#39; 作为其路径。\n    &#39;/&#39;: {\n      lang: &#39;zh-CN&#39;, // 将会被设置为 &lt;html&gt; 的 lang 属性\n    }\n  },\n  // ...\n}</code></pre>\n<p>修改后的效果如下图，lang 修改了，就不会弹翻译的窗口了</p>\n<p><img src=\"../../../images/blog/vue/chrome-zhcn.png\" alt=\"chrome-zhcn.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vuepress html lang 默认为英文，总是弹出 google 翻译怎么解决"
        }
      ],
      "config": {
        "source": "vuepress html lang 默认为英文，总是弹出 google 翻译怎么解决.md",
        "staticFileName": "vuepress_lang.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "默认情况下，vuepress 生成的网页 html lang 属性为 'en-US'，当在 Chrome 浏览器打开时，总是会弹出翻译的窗口。如下图，解决这个问题的方法就是将默认的 lang 设置为中文 'zh-CN' 即可。vuepress 支持国际化功能，我们只需要修改下对应的配置即可。",
        "keywords": "总是弹出 google 翻译怎么解决,vuepress 默认 lang 设置",
        "category": "Vue",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"import-出现黄色警告提示，eslint-is-disabled-since-its-execution-has-not-been-approved\">import 出现黄色警告提示，ESLint is disabled since its execution has not been approved</h1>\n<p>在有 ESLint 的项目中，发现 import 都出现了黄色警告，提示 ESLint is disabled since its execution has not been approved or denied yet. Use the light bulb menu to open the approval dialog.eslint</p>\n<p><img src=\"../../../images/blog/devtools/eslint-import-warn.png\" alt=\"eslint-import-warn.png\"></p>\n<p>这是因为初次打开项目，没有 eslint 授权产生的错误提示。点击 vscode 开发工具右下角的 ESLint 就会弹出授权窗口，点击允许即可。</p>\n<p><img src=\"../../../images/blog/devtools/eslint-vscode-auth.png\" alt=\"eslint-vscode-auth.png\"></p>\n<p><img src=\"../../../images/blog/devtools/eslint-vscode-auth2.png\" alt=\"eslint-vscode-auth2.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "import 出现黄色警告提示，ESLint is disabled since its execution has not been approved"
        }
      ],
      "config": {
        "source": "import 出现黄色警告提示，ESLint is disabled since its execution has not been approved.md",
        "staticFileName": "eslint_auth.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "在有 ESLint 的项目中，发现 import 都出现了黄色警告，提示 ESLint is disabled since its execution has not been approved or denied yet. Use the light bulb menu to open the approval dialog.eslint。这是因为初次打开项目，没有 eslint 授权产生的错误提示。点击 vscode 开发工具右下角的 ESLint 就会弹出授权窗口，点击允许即可。",
        "keywords": "ESLint 授权弹窗,eslint auth dialog",
        "category": "计算机基础与开发工具",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"eslint-与-prettier-冲突的问题怎么处理？\">ESLint 与 Prettier 冲突的问题怎么处理？</h1>\n<p>在安装 @vue/cli 后，使用 vue create xx 创建项目，如果选择了 eslint + prettier，可能会出现冲突。比如</p>\n<p>在 .eslintrc.js 的 rules 中设置了强制单引号，而默认情况下 prettier 是双引号。<code>如果有双引号，eslint 会提示 error。如果有单引号 prettier 会警告提示</code>，保存自动 fix 会在单双引号之间来回切换，总是会有异常提示。</p>\n<pre><code class=\"language-js\">// .eslintrc.js\nmodule.exports = {\n  extends: [&quot;plugin:vue/essential&quot;, &quot;eslint:recommended&quot;, &quot;@vue/prettier&quot;],\n  rules: {\n    &quot;no-console&quot;:  &quot;off&quot;,\n    &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,\n    &quot;quotes&quot;: [2, &#39;single&#39;] // 强制单引号， prittier 默认要双引号引号，冲突\n  },\n  // ...\n};</code></pre>\n<p>为了解决冲突，我们可以在 prettier 的配置文件（.prettierrc.js）中加入强制使用单引号的选项，这样就可以了。</p>\n<pre><code class=\"language-js\">// .prettierrc.js\n// 修改后注意可能要关闭 vscode 后再重新打开才生效，另外最好保证该项目没有被多层目录嵌套，直接打开的项目\nmodule.exports = {\n  singleQuote: true, // 使用单引号替代双引号\n  // semi: false, // 行尾自动去掉分号\n  // printWidth: 100, // 最大行宽 100\n  // tabWidth: 2 // tab 2 个空格\n}</code></pre>\n<p>一般建议只在 eslint 或 prettier 配置中选一个做配置，除非有解决不了的冲突，才在两个配置文件中都做配置。</p>\n<p>参考：<a href=\"https://segmentfault.com/q/1010000016953293\">vscode 配置 eslint + prettier冲突问题</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "ESLint 与 Prettier 冲突的问题怎么处理？"
        }
      ],
      "config": {
        "source": "ESLint 与 Prettier 冲突的问题怎么处理？.md",
        "staticFileName": "eslint_prettier_conflict.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "在安装 @vue/cli 后，使用 vue create xx 创建项目，如果选择了 eslint + prettier，可能会出现冲突。比如 在 .eslintrc.js 的 rules 中设置了强制单引号，而默认情况下 prettier 是双引号。`如果有双引号，eslint 会提示 error。如果有单引号 prettier 会警告提示`，保存自动 fix 会在单双引号之间来回切换，总是会有异常提示。",
        "keywords": "eslint prettier conflict,ESLint 与 Prettier 冲突",
        "category": "前端工程化",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-使用-vue-i18n-国际化\">Vue 使用 vue-i18n 国际化</h1>\n<p>在 vue 项目中，可以使用 <a href=\"https://kazupon.github.io/vue-i18n/zh/started.html#html\">vue-i18n</a> 来做国际化。下面来看具体是怎么使用的</p>\n<ol>\n<li><p>安装</p>\n<pre><code class=\"language-bash\">npm install vue-i18n --save</code></pre>\n</li>\n<li><p>在 main.js 引入，并做初始化配置，使用 locale 设置默认语言，使用 messages 对象属性，指定不同语言对应的内容。</p>\n</li>\n</ol>\n<pre><code class=\"language-js\">// main.js\nimport Vue from &#39;vue&#39;\nimport VueI18n from &#39;vue-i18n&#39;\n\nVue.use(VueI18n)\n\nconst i18n = new VueI18n({\n  locale: &#39;ja&#39;, // 设置默认语言环境\n  // 在 vue template 的 {{}} 中，使用 $t(&#39;un&#39;) 即可拿到 un 属性指定的值\n  // 不需要在 data() {} 中设置什么\n  messages: {\n    en: { // 中文\n      un: &#39;hi&#39;,  \n      message: {\n        hello: &#39;hello world&#39;,\n      },\n    },\n    ja: { // 日文\n      un: &#39;ちは&#39;,\n      message: {\n        hello: &#39;こんにちは、世界&#39;,\n      },\n    }\n  },\n})\n\nnew Vue({\n  i18n,\n  router,\n  store,\n  render: (h) =&gt; h(App),\n}).$mount(&#39;#app&#39;)</code></pre>\n<ol start=\"3\">\n<li>在 vue template 中直接使用。如果想动态切换语言，使用 <code>this.$root.$i18n.locale = &#39;en&#39;</code> 即可修改语言</li>\n</ol>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div id=&quot;nav&quot;&gt;\n      &lt;p&gt;{{ $t(&#39;un&#39;) }}&lt;/p&gt;\n      &lt;p&gt;{{ $t(&#39;message.hello&#39;) }}&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;router-view /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data() {\n    return {}\n  },\n  created() {\n    setTimeout(() =&gt; {\n      console.log(&#39;lang change&#39;)\n      this.$root.$i18n.locale = &#39;en&#39; // 5s 后变更默认语言为英文\n    }, 5000)\n  },\n}\n&lt;/script&gt;</code></pre>\n<p>注意如果信息较多，messages 信息的内容，最好模块化，尽量分割成子模块，不要全部写在一起。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue 使用 vue-i18n 国际化"
        }
      ],
      "config": {
        "source": "Vue 使用 vue-i18n 国际化.md",
        "staticFileName": "vue_international.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "在 vue 项目中，可以使用 vue-i18n 来做国际化。下面来看具体是怎么使用的 1. 安装 npm install vue-i18n --save 2. 在 main.js 引入，并做初始化配置，使用 locale 设置默认语言，使用 messages 对象属性，指定不同语言对应的内容。3. 在 vue template 中直接使用。如果想动态切换语言，使用 `this.$root.$i18n.locale = 'en'` 即可修改语言",
        "keywords": "vue 国际化,vue international, vue i18n",
        "category": "Vue",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"import---解构与-export-和-export-defaultmd\">import { } 解构与 export 和 export default.md</h1>\n<p>在封装功能函数时，我们经常需要在 import 时使用解构 {} 来仅导出部分模块功能。在有些情况会发现是无法解构的，下面来看看</p>\n<pre><code class=\"language-js\">// ./modlues/common/index\nexport default {\n  en: {\n    msg: &#39;hello&#39;,\n  },\n  cn: {\n    msg: &#39;你好&#39;,\n  },\n}\n\n// index.js\nimport { en, cn } from &#39;./modlues/common/index&#39;\nconsole.log(en, cn)</code></pre>\n<p><img src=\"../../../images/blog/js/export-warn.png\" alt=\"export-warn.png\"></p>\n<p>这里是无法解构的，提示警告，需要写成这样</p>\n<pre><code class=\"language-js\">import common from &#39;./modlues/common/index&#39;\nlet { en, cn } = common\nconsole.log(en, cn)</code></pre>\n<p>如果是需要在 import 时就能解构，需要使用下面的写法</p>\n<pre><code class=\"language-js\">// ./modlues/common/index\nexport const en = {\n  msg: &#39;hello&#39;,\n}\n\nexport const cn = {\n  msg: &#39;你好&#39;,\n}</code></pre>\n<p>或者</p>\n<pre><code class=\"language-js\">const en = {\n  msg: &#39;hello&#39;,\n}\nconst cn = {\n  msg: &#39;你好&#39;,\n}\nexport { en, cn }</code></pre>\n<ul>\n<li>一般 export default 的内容，需要使用 <code>import xxx from &#39;xx&#39;</code> 直接接收，不能在 import 时解构</li>\n<li>通过 export xx 的内容，需要使用 <code>import { xx, xx } from &#39;xx&#39;</code> 或 <code>import * as xx from &#39;xx&#39;</code> 接收</li>\n</ul>\n<p>参考: <a href=\"https://www.jb51.net/article/162079.htm\">详解ES6 export default 和 import语句中的解构赋值</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "import { } 解构与 export 和 export default.md"
        }
      ],
      "config": {
        "source": "import { } 解构与 export 和 export default.md",
        "staticFileName": "import_export.html",
        "author": "guoqzuo",
        "createDate": "2021/04/03",
        "description": "在封装功能函数时，我们经常需要在 import 时使用解构 {} 来仅导出部分模块功能。在有些情况会发现是无法解构的，下面来看看 - 一般 export default 的内容，需要使用 `import xxx from 'xx'` 直接接收，不能在 import 时解构 - 通过 export xx 的内容，需要使用 `import { xx, xx } from 'xx'` 或 `import * as xx from 'xx'` 接收",
        "keywords": "import {} 与 export default,import {}",
        "category": "JavaScript",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"提示-hints、tips、prompt-以及-message-的区别\">提示 hints、tips、prompt 以及 message 的区别</h1>\n<p>在程序开发中，关于提示组件的命名，有 tips、hints、prompt、message 等，一般怎么使用呢？下面来看看</p>\n<ul>\n<li><p><strong>tips</strong>，n. 小贴士、温馨提示、小窍门。<strong>主要用于文字提示</strong>，比如 tooltip 组件。</p>\n</li>\n<li><p><strong>hints</strong>，n. 暗示、提示，v. 暗示、示意。开发中用的较少，相比于 tips，<strong>它有间接含蓄, 暗示，不直接提示</strong>的意思。</p>\n</li>\n<li><p><strong>prompt</strong>，n. 提示、提词，v. 提示、鼓励、促进。在开发中用的较少，BOM API 中带输入框的提示，使用的就是 prompt <code>window.prompt(&#39;最近还好吗？&#39;)</code></p>\n</li>\n<li><p><strong>message</strong> n. 消息、信息，v. 通知。<strong>主要是全局提示，强调信息、消息</strong>。收到一条通知、消息。常用于 message 消息/信息提示/显示。</p>\n</li>\n</ul>\n<p>另外还有一个 alert，属于 <strong>警告提示</strong>。</p>\n<p>参考: <a href=\"https://zhidao.baidu.com/question/2144372129649021108.html\">英语hints和tips区别？</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "提示 hints、tips、prompt 以及 message 的区别"
        }
      ],
      "config": {
        "source": "提示 hints、tips、prompt 以及 message 的区别.md",
        "staticFileName": "tips_hints.html",
        "author": "guoqzuo",
        "createDate": "2021/04/11",
        "description": "在程序开发中，关于提示组件的命名，有 tips、hints、prompt、message 等，一般怎么使用呢？下面来看看  tips，n. 小贴士、温馨提示、小窍门。主要用于文字提示，比如 tooltip 组件。 hints，n. 暗示、提示，v. 暗示、示意。开发中用的较少，相比于 tips，它有间接含蓄, 暗示，不直接提示的意思。",
        "keywords": "hints和tips区别,提示命名,提示 英文,提示 英语",
        "category": "计算机基础与开发工具",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"小程序代码找回，代码丢失后找回过程记录（反编译、云开发函数恢复）\">小程序代码找回，代码丢失后找回过程记录（反编译、云开发函数恢复）</h1>\n<p>最近想把之前写的一个已上线的小程序开源，发现当时居然没有用 git 管理，换电脑、折腾 mac 双系统后，代码丢失了。尝试用数据恢复软件恢复都没有找回代码，尽管小程序的文件特征很好找，比如 .wxml、project.config.json 等。</p>\n<p>后面在网上找了反编译线上小程序的方法。这样可以拿到 uglify 混淆压缩后的代码，至少比没有强。另外，云函数的代码也是可以恢复的，因为之前开发时上传过，它是可以下载的。</p>\n<blockquote>\n<p>注意：反编译小程序要求必须是已上线的小程序。对于云函数的恢复/下载，需要知道之前开发的 appid，且微信账号拥有对应的管理员/开发权限。</p>\n</blockquote>\n<h2 id=\"为什么小程序可以反编译？\">为什么小程序可以反编译？</h2>\n<p>理论上小程序也是属于前端代码，前端的 js、css、html 一般是可以拿到的。微信在打开小程序时，会先下载对应小程序的包(.wxapkg文件)来执行。只要我们拿到这个文件，就可以通过反编译拿到混淆压缩后的代码。这里反编译使用的是 <a href=\"https://github.com/qwerty472123/wxappUnpacker\">wxappUnpacker</a>，虽然删除了，但点开 fork，有很多之前备份的代码。 </p>\n<h2 id=\"获取小程序的-wxapkg-文件\">获取小程序的 wxapkg 文件</h2>\n<ol>\n<li>下载安装 <a href=\"https://www.yeshen.com/\">夜神模拟器</a>，注意：如果是 mac 系统，打开后一直卡在 99%，可能是因为 VirtualBox 的原因，安装该模拟器时，会自动安装 VirtualBox，可以在 app 中手动打开 VirtualBox 并启动，再打开模拟器。</li>\n<li>下载 <a href=\"http://www.pc6.com/az/56118.html\">RE 文件管理器</a>，文件名为：com.speedsoftware.rootexplorer_999496.apk</li>\n<li>在 模拟器中 安装 RE文件管理器，点击模拟器右侧的 添加 apk 文件图标，选择刚才下好的 apk 文件进行安装。如下图，安装完成后打开该 app，并允许获取权限。</li>\n</ol>\n<p><img src=\"../../../images/blog/mp/wxapkg_1_1.png\" alt=\"wxapkg_1_1.png\"></p>\n<ol start=\"4\">\n<li>在模拟器中搜索 微信，安装好后，运行微信，登录后，打开对应的小程序</li>\n<li>打开小程序后，在文件管理器的 <code>/data/data/com.tencent.mm/MicroMsg/{数字串}/appbrand/pkg/</code> 目录，可以看到对应的 .wxapkg 文件，如下图。注意：如果找不到对应的文件，可以点击右上角的三个点，搜索对应的文件。</li>\n</ol>\n<p><img src=\"../../../images/blog/mp/wxapkg_1_2.png\" alt=\"wxapkg_1_2.png\"></p>\n<ol start=\"6\">\n<li>导出 .wxapkg 文件。鼠标长按对应的文件，多选两个 wxapkg 文件，点击右上角三个点，zip 压缩，压缩后，查看对应的文件，再点击右上角三个点，发送到微信即可。 </li>\n</ol>\n<p><img src=\"../../../images/blog/mp/wxapkg_1_3.png\" alt=\"wxapkg_1_3.png\"></p>\n<h2 id=\"使用-wxappunpacker-反编译-wxapkg-文件\">使用 wxappUnpacker 反编译 wxapkg 文件</h2>\n<p>拿到小程序的 wxapkg 文件后，我们将之前在 fork 仓库中下载好的 wxappUnpacker 在 vscode 中打开，使用 Terminal cd（进入）到对应的目录。运行 npm install 或 yarn add 安装对应的依赖。安装完成后，在当前目录下，运行 <code>node wuWxapkg.js 对应的小程序wxapkg文件</code> 命令，就可以得到反编译后的代码。</p>\n<pre><code class=\"language-bash\"># 安装依赖\nnpm install css-tree cssbeautify escodegen esprima js-beautify uglify-es vm2\n# 还原小程序代码示例\nnode wuWxapkg.js &#39;/Users/zuo/Desktop/test1234/_626200936_1.wxapkg&#39;</code></pre>\n<p>运行后，虽然生成了代码，但是 terminal 出现了下面的错误，css 文件未被还原</p>\n<pre><code class=\"language-js\">/wxappUnpacker-master/node_modules/vm2/lib/main.js:890\n                                throw this._internal.Decontextify.value(e);\n                                ^\nReferenceError [Error]: __vd_version_info__ is not defined</code></pre>\n<p>这里需要修改 wxappUnpacker 项目中 wuWxss.js 中的 runOnce() 函数代码</p>\n<pre><code class=\"language-js\">// wuWxss.js\n// function runOnce(){\n//     for(let name in runList)runVM(name,runList[name]);\n// }\nfunction runOnce() {\n  for (let name in runList) {\n    // console.log(name, runList[name]);\n    var start = `var window = window || {}; var __pageFrameStartTime__ = Date.now(); var __webviewId__; var __wxAppCode__={}; var __mainPageFrameReady__ = function(){}; var __WXML_GLOBAL__={entrys:{},defines:{},modules:{},ops:[],wxs_nf_init:undefined,total_ops:0}; var __vd_version_info__=__vd_version_info__||{};\n\n    $gwx=function(path,global){\n\n    if(typeof global === &#39;undefined&#39;) global={};if(typeof __WXML_GLOBAL__ === &#39;undefined&#39;) {__WXML_GLOBAL__={};\n\n    }__WXML_GLOBAL__.modules = __WXML_GLOBAL__.modules || {};\n\n    }`;\n    runVM(name, start + &quot; \\r\\n&quot; + runList[name]);\n  }\n}</code></pre>\n<p>修改后再次执行就 OK 了，代码大致就恢复了。目录结构如下</p>\n<p><img src=\"../../../images/blog/mp/wxapkg_2_1.png\" alt=\"wxapkg_2_1.png\"></p>\n<h2 id=\"小程序云开发，云函数代码恢复\">小程序云开发，云函数代码恢复</h2>\n<blockquote>\n<p>理论上云开发和小程序 appid，微信号开发权限是相关联的，如果没有权限是无法还原云函数的</p>\n</blockquote>\n<p>这个项目是小程序云开发的项目，而 wxappUnpacker 恢复的只是普通小程序的目录结构。下面是小程序云开发的目录结构</p>\n<p><img src=\"../../../images/blog/mp/wxapkg_2_2.png\" alt=\"wxapkg_2_2.png\"></p>\n<p>我们需要进一步处理</p>\n<ol>\n<li>创建一个新的文件夹，比如 my-app，然后在目录下创建 cloudfunctions 和 miniprogram 文件夹，将恢复的代码，拷贝到 miniprogram 中</li>\n<li>创建 project.config.json 文件，找到之前开发该小程序时，使用的该小程序的 appid，修改 project.config.json 文件</li>\n</ol>\n<pre><code class=\"language-js\">{\n  &quot;miniprogramRoot&quot;: &quot;miniprogram/&quot;,\n  &quot;cloudfunctionRoot&quot;: &quot;cloudfunctions/&quot;,\n  &quot;appid&quot;: &quot;wx45333c9fc02af773&quot;,\n  &quot;projectname&quot;: &quot;my-app&quot;\n}</code></pre>\n<ol start=\"3\">\n<li>打开微信小程序开发工具，选择导入项目，选择 my-app 目录，即可打开项目，如下图</li>\n</ol>\n<p><img src=\"../../../images/blog/mp/wxapkg_3_1.png\" alt=\"wxapkg_3_1.png\"></p>\n<p>由于我们之前创建过云开发环境，因此我们右键 cloudfunctions 目录，可以选择当前环境比如 test。这时 cloudfunctions 是空的，可以右键后，选择同步云函数列表</p>\n<p><img src=\"../../../images/blog/mp/wxapkg_3_2.png\" alt=\"wxapkg_3_2.png\"></p>\n<p>同步后，cloudfunctions 目录下就会创建之前的云函数文件夹，如下图，右键对应的云函数文件夹，选择下载，即可下载对应云函数的代码。</p>\n<p><img src=\"../../../images/blog/mp/wxapkg_3_3.png\" alt=\"wxapkg_3_3.png\"></p>\n<p>云函数代码，不是混淆压缩的，是 100% 还原的，如下图</p>\n<p><img src=\"../../../images/blog/mp/wxapkg_3_4.png\" alt=\"wxapkg_3_4.png\"></p>\n<p>自此，项目就大致还原了。美中不足的是，样式没有恢复完全，另外 js 都是混淆压缩后的代码，需要慢慢修改还原。</p>\n<p>不过项目还是可以跑起来的，比完全丢失了好，还原后的该小程序已开源，后面会慢慢修复还原混淆压缩后的代码。开源地址：<a href=\"https://github.com/ibdlib/remicade-record\">remicade-record - github</a></p>\n<p>参考: </p>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_38822390/article/details/82152004\">小程序源码丢失了怎么在微信平台反编译找回</a></li>\n<li><a href=\"https://www.jianshu.com/p/83b9e7d3ded4\">最新解决小程序反编译$gwx is not defined和<strong>vd_version_info</strong> is not defined</a></li>\n<li><a href=\"https://www.cnblogs.com/yeahwell/p/13546770.html\">2020微信小程序反编译（逆向），仅用于学习请勿商用</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "小程序代码找回，代码丢失后找回过程记录（反编译、云开发函数恢复）",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "为什么小程序可以反编译？"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "获取小程序的 wxapkg 文件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "使用 wxappUnpacker 反编译 wxapkg 文件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "小程序云开发，云函数代码恢复"
            }
          ]
        }
      ],
      "config": {
        "source": "小程序代码找回，代码丢失后找回过程记录（反编译、云开发函数恢复）.md",
        "staticFileName": "miniprogram_code_reverse.html",
        "author": "guoqzuo",
        "createDate": "2021/04/11",
        "description": "小程序代码找回，小程序云开发代码找回，小程序云函数恢复，最近想把之前写的一个已上线的小程序开源，发现当时居然没有用 git 管理，换电脑、折腾 mac 双系统后，代码丢失了。尝试用数据恢复软件恢复都没有找回代码，尽管小程序的文件特征很好找，比如 .wxml、project.config.json 等。后面在网上找了反编译线上小程序的方法。这样可以拿到 uglify 混淆压缩后的代码，至少比没有强。另外，云函数的代码也是可以恢复的，因为之前开发时上传过，它是可以下载的。",
        "keywords": "小程序代码找回,小程序云开发代码找回,小程序云函数恢复",
        "category": "微信开发",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"props-right-hand-side-of-instanceof-is-not-an-object\">props Right-hand side of &#39;instanceof&#39; is not an object</h1>\n<p>在 Vue 中写 props 属性时，一般最简单的方式是使用数组的形式： props: [&#39;属性名1&#39;, &#39;属性名2&#39;]，但这样没有类型校验、默认值。在使用对象的写法时，发现出现 props Right-hand side of &#39;instanceof&#39; is not an object，错误，写法如下</p>\n<pre><code class=\"language-js\">export default {\n  props: {\n    tips: {\n      type: “Array”,\n      default: () =&gt; []\n    }\n  }\n}</code></pre>\n<p>后面发现是 type 属性设置的有问题。限定为数组，Array 类型，直接用 Array 就行，不要加引号，它不是字符串，而是对象 object（类）。</p>\n<pre><code class=\"language-js\">tips: {\n  type: Array,\n  default: () =&gt; []\n}</code></pre>\n<p>参考: <a href=\"https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81\">Prop 验证 — Vue.js</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "props Right-hand side of 'instanceof' is not an object"
        }
      ],
      "config": {
        "source": "props Right-hand side of 'instanceof' is not an object.md",
        "staticFileName": "vue_props_error.html",
        "author": "guoqzuo",
        "createDate": "2021/04/11",
        "description": "在 Vue 中写 props 属性时，一般最简单的方式是使用数组的形式： props: ['属性名1', '属性名2']，但这样没有类型校验、默认值。在使用对象的写法时，发现出现 props Right-hand side of 'instanceof' is not an object，错误，写法如下",
        "keywords": "vue props error",
        "category": "Vue",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"用游戏中的场景理解节流与防抖，最简单的-js-实现\">用游戏中的场景理解节流与防抖，最简单的 js 实现</h1>\n<p>之前对节流(throttle) 和防抖（debounce）的理解有偏差，以为 <del>scroll 或 resize 时，为了减少执行事件函数频率，需要用节流，减少执行次数。而防抖在于点击某个按钮后，多长时间内不允许再次点击。防止多次重复提交表单，或执行下一步函数。</del></p>\n<p>这种理解是反的。我们可以用游戏的中的场景来理解节流和防抖</p>\n<h2 id=\"节流throttle\">节流(throttle)</h2>\n<p>对应 <strong>技能冷却时间</strong>，如果冷却(cooldown/cd)是 5 秒，使用技能后，5秒内，无法再次执行。用于控制事件执行一次后，多长时间内不允许再次执行。一般用于防止按钮多次点击，重复触发事件。</p>\n<p><img src=\"../../../images/blog/js/throttle.gif\" alt=\"throttle.gif\"></p>\n<p>来实现节流的功能，比较好的实现是，创建一个可复用的节流函数，它可以将普通函数转换为增加了节流功能的函数，基本结构如下</p>\n<pre><code class=\"language-js\">/**\n * throttle\n * @param { Function } func 执行函数\n * @param { Interger } time 多长时间内不能第二次执行\n * @returns function 返回经过节流处理的函数\n */\nfunction throttle(func, time) {\n  return function (...args) {\n    // 返回一个可以正常执行的函数\n    func.apply(this, args)\n  }\n}</code></pre>\n<p>在基本的机构中，增加节流控制处理</p>\n<pre><code class=\"language-js\">/**\n * throttle\n * @param { Function } func 执行函数\n * @param { Interger } time 多长时间内不能第二次执行\n * @returns function 返回经过节流处理的函数\n */\nfunction throttle(func, time) {\n  let isLock = false // 是否冷却(cooldown)中\n  // 返回一个经过节流处理的 func\n  return function (...args) {\n    if (isLock) { // 如果是冷却中，不执行函数\n      console.log(&#39;冷却(cd)中...&#39;)\n      return \n    }\n    // 非冷却中\n    func.apply(this, args) // 执行函数\n    isLock = true // 执行函数后设置为冷却中\n    setTimeout(() =&gt; {\n      isLock = false // 经过 time 微秒后，设置为非冷却中\n    }, time);\n  }\n}</code></pre>\n<p>使用示例</p>\n<pre><code class=\"language-html\">&lt;button id=&quot;skillsABtn&quot;&gt;释放技能A&lt;/button&gt;\n&lt;script&gt;\n  let skillsABtn = document.querySelector(&#39;#skillsABtn&#39;)\n  releaseASkills = () =&gt; {\n    console.log(`释放A技能, ${+new Date()}`)\n  }\n  // 技能冷却时间 3 秒\n  skillsABtn.onclick = throttle(releaseASkills, 3000)\n&lt;/script&gt;</code></pre>\n<h2 id=\"防抖去抖动-debounce、de--bounce\">防抖(去抖动 debounce、de + bounce)</h2>\n<p>对应 <strong>回城</strong>，在推塔游戏中，回城等待时间是 8 秒。可以理解为回城时，会开启一个定时任务，8 秒后执行完成回城的函数。</p>\n<p>防抖/去抖动，就是在定时任务等待执行的时间内，如果再次触发发了函数，会取消上一次的定时任务，重新开始一个定时任务。这样可以<strong>将一段时间内连续的多次触发转化为一次触发，单位时间内仅执行最后一次</strong>。一般用于 window 的 scroll、resize 事件、搜索框输入搜索内容后实时查询接口等。</p>\n<pre><code class=\"language-js\">function debounce(func, time) {\n  let timer = null // 定时任务计时器\n  // 返回一个经过防抖处理的 func\n  return function (...args) {\n    if (timer) {\n      // 如果上一次定时任务还在等待执行的过程中，取消定时任务\n      clearTimeout(timer)\n      console.log(&#39;取消上一次的计时任务&#39;)\n    }\n\n    console.log(`重新开启定时任务，${time} 毫秒后真正执行`)\n    timer = setTimeout(() =&gt; {\n      func.apply(this, args)\n    }, time);\n  }\n}</code></pre>\n<p>实例</p>\n<pre><code class=\"language-html\">&lt;button id=&quot;goBackBtn&quot;&gt;回城&lt;/button&gt;\n&lt;script&gt;\n  let goBackBtn = document.querySelector(&#39;#goBackBtn&#39;)\n  goBack = () =&gt; {\n    console.log(`成功回城, ${+new Date()}`)\n  }\n  // 3 秒之后回城\n  goBackBtn.onclick = debounce(goBack, 3000) \n&lt;/script&gt;</code></pre>\n<h2 id=\"代码下载\">代码下载</h2>\n<p>完整 demo 示例代码：<a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/DebugDemo/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%E5%AE%9E%E7%8E%B0\">节流和防抖实现 - fedemo | Github</a>，在线示例 <a href=\"https://zuoxiaobai.github.io/fedemo/src/DebugDemo/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%E5%AE%9E%E7%8E%B0/#/\">节流与防抖简单实现 demo - 需要打开 console 看执行效果</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "用游戏中的场景理解节流与防抖，最简单的 js 实现",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "节流(throttle)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "防抖(去抖动 debounce、de + bounce)"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "代码下载"
            }
          ]
        }
      ],
      "config": {
        "source": "用游戏中的场景理解节流与防抖，最简单的 js 实现.md",
        "staticFileName": "easy_throttle_debounce.html",
        "author": "guoqzuo",
        "createDate": "2021/04/11",
        "description": "节流和防抖，手写节流和防抖，节流(throttle) 对应技能冷却时间，如果冷却(cooldown/cd)是 5 秒，使用技能后，5秒内，无法再次执行。用于控制事件执行一次后，多长时间内不允许再次执行。一般用于防止按钮多次点击，重复触发事件。防抖(去抖动 debounce、de + bounce) 对应 **回城**，在推塔游戏中，回城等待时间是 8 秒。可以理解为回城时，会开启一个定时任务，8 秒后执行完成回城的函数。防抖/去抖动，就是在定时任务等待执行的时间内，如果再次触发发了函数，会取消上一次的定时任务，重新开始一个定时任务。这样可以**将一段时间内连续的多次触发转化为一次触发，单位时间内仅执行最后一次**。一般用于 window 的 scroll、resize 事件、搜索框输入搜索内容后实时查询接口等。",
        "keywords": "节流和防抖,手写节流和防抖,节流和防抖,throttle debounce",
        "category": "JavaScript",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"make-sure-you-configure-your-username-and-useremail-in-git\">Make sure you configure your ‘user.name’ and ‘user.email’ in git</h1>\n<p>在 vscode 中，使用可视化工具，而非命令的方式提交代码时，如果没有配置 git 的 user.name 和 user.email，可能会弹出 Make sure you configure your ‘user.name’ and ‘user.email’ in git 的错误，代码无法提交。这就需要先配置好，再提交了。</p>\n<p>另外，在 github 或 gitlab 等页面中，可能会遇到提交没有绿点或者看不到头像的情况，可能是因为配置的 user.email 发生了变化，和平台的 email 不一致导致的。修改成一致的就正常了。</p>\n<p>下面来看看怎么设置 user.name 和 user.email。git 配置（configure）分两种，一种是全局的，一种是针对单个项目仓库的（项目目录下）。可以使用 git config 来管理管理配置（查看、设置）</p>\n<p><strong>查看配置</strong></p>\n<p>可以使用 git config --list 查看当前配置，如果没有 user.name，和 user.email，就说明还没有配置。</p>\n<pre><code class=\"language-bash\"># 查看当前目录下项目的配置\ngit config --list\n# credential.helper=osxkeychain\n# user.name=zuoxiaobai\n# user.email=guoqzuo@gmail.com\n# remote.origin.url=git@github.com:zuoxiaobai/fenote.git\n# remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*\n# branch.master.remote=origin\n# branch.master.merge=refs/heads/master\n\n# 查看全局配置\ngit config --list --global\n# user.name=zuoxiaobai\n# user.email=guoqzuo@gmail.com\n# core.quotepath=false</code></pre>\n<p><strong>设置（修改配置）</strong> </p>\n<p>可以使用 git config 属性名 属性值，来设置 git 配置，默认是项目内的（局部的），如果需要设置全局的，需要加上 --global，设置完成后，再使用查看配置的命令 git config --list 就可以看到配置生效了。</p>\n<pre><code class=\"language-bash\"># 进入项目目录，单个仓库（项目），局部设置\ngit config user.name &quot;zuoxiaobai&quot; \ngit config user.email &quot;guoqzuo@gmail.com&quot;\n\n# 全局设置\ngit config --global user.name &quot;zuoxiaobai&quot; \ngit config --global user.email &quot;guoqzuo@gmail.com&quot;</code></pre>\n<blockquote>\n<p>注意 git config 属性名 属性值 时，如果属性值没有用双引号 &quot;&quot; 包裹，那么中间不能有空格，比如 git config user.name zuo xiaobai，相当于 git config user.name zuo，会丢弃空格后面的部分</p>\n</blockquote>\n<p>更多用法，可以使用 git config --help 查看帮助，或查看对应的官方文档 <a href=\"https://git-scm.com/docs/git-config\">Git - git-config Documentation</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Make sure you configure your ‘user.name’ and ‘user.email’ in git"
        }
      ],
      "config": {
        "source": "Make sure you configure your ‘user.name’ and ‘user.email’ in git.md",
        "staticFileName": "git_user_email.html",
        "author": "guoqzuo",
        "createDate": "2021/04/11",
        "description": "git 设置 user.name user.email，github 提交没有绿点，github提交没头像，在 vscode 中，使用可视化工具，而非命令的方式提交代码时，如果没有配置 git 的 user.name 和 user.email，可能会弹出 Make sure you configure your ‘user.name’ and ‘user.email’ in git 的错误，代码无法提交。这就需要先配置好，再提交了。另外，在 github 或 gitlab 等页面中，可能会遇到提交没有绿点或者看不到头像的情况，可能是因为配置的 user.email 发生了变化，和平台的 email 不一致导致的。修改成一致的就正常了。",
        "keywords": "git config,git 设置 user.name user.email,github 提交没有绿点,github提交没头像",
        "category": "运维部署与版本控制",
        "year": "2021",
        "month": "4"
      }
    },
    {
      "htmlStr": "<h1 id=\"正则表达式使用--和-match-或-replace-提取-url-路径参数\">正则表达式使用 () 和 match 或 replace 提取 url 路径参数</h1>\n<p>来看一个问题，使用正则表达式从 url 中提取区域、城市id、模块、页数id。url 示例如下</p>\n<ol>\n<li><code>http://www.xx.com/region/gd/module</code></li>\n<li><code>http://www.xx.com/region/gd-c222/module</code></li>\n<li><code>http://www.xx.com/region/gd-c222/module/p2</code></li>\n</ol>\n<p>下面来看看怎么实现</p>\n<p>首先，回顾下正则表达式（Regular Expression）基础。正则表表达式以 <code>/pattern/flags</code> 表示，是 RegExp 对象的实例</p>\n<pre><code class=\"language-js\">/[a-z]*/g instanceof RegExp // true</code></pre>\n<p>pattern 模式由下面的字符组成</p>\n<ul>\n<li><p><code>边界符号(^、$)</code> ^ 以 xx 开头，$ 以 xx 结尾</p>\n<ul>\n<li><code>/^abc/</code> 表示以 abc 开头</li>\n<li><code>/abc$/</code> 表示以 abc 结尾</li>\n</ul>\n</li>\n<li><p><code>字符集合([]、^、-)</code> 一系列的字符集合</p>\n<ul>\n<li><code>[abc]</code> 表示 abc 里面的任意一个字符</li>\n<li><code>[^abc]</code> 表示任意一个非 abc 字符，注意 ^ 在 [] 里面表示非 xx 字符</li>\n<li><code>[a-z0-9]</code> 表示 a 到 z 的字符，0 到 9 字符</li>\n</ul>\n</li>\n<li><p><code>预定义模式字符(.、\\d、\\w、\\s、\\n)</code> 一些常见字符集合的简写</p>\n<ul>\n<li><code>.</code> 表示除 \\r\\n 之外的所有字符</li>\n<li><code>\\d</code> 是 <code>[0-9]</code> 的简写，表示数字</li>\n<li><code>\\D</code> 是 <code>[^0-9]</code> 的简写，表示非数字</li>\n<li><code>\\w</code> 是 <code>[0-9a-zA-Z_]</code> 的简写，表示数字、字母、下划线</li>\n<li><code>\\W</code> 是 <code>[^0-9a-zA-Z_]</code> 的简写，表示非数字、字母、下划线</li>\n<li><code>\\s</code> 是 <code>[ ]</code> 的简写，表示空白符(空格)，<code>&quot;  a  b c   &quot;.replace(/\\s/g, &#39;&#39;) === &quot;abc&quot;</code></li>\n<li><code>\\S</code> 是 <code>[^ ]</code> 的简写，表示非空白符</li>\n<li><code>\\n</code> 表示 换行符</li>\n</ul>\n</li>\n<li><p><code>匹配次数/数量(?、*、+、{})</code></p>\n<ul>\n<li><code>?</code> 匹配前面的模式 0 次或 1 次 {0, 1}</li>\n<li><code>*</code> 匹配前面的模式 0 次或多次 {0, }</li>\n<li><code>+</code> 匹配前面的模式 1 次或多次 {1, }</li>\n<li><code>{n}</code>    匹配前面的模式 n 次</li>\n<li><code>{n,m}</code> 匹配前面的模式 至少 n 次，至多 m 次</li>\n</ul>\n</li>\n<li><p><code>其他 ()、|</code></p>\n<ul>\n<li><code>()</code> 用于匹配字符串中的多个部分，比如 <code>(\\w+)\\s(\\w+)</code> 匹配 <code>aaa bbb</code>，第一部分 $1 为 &#39;aaa&#39;，第二部分 $2 为 &#39;bbb&#39;。可以使用 regExp.exec(str) 返回对象的 index 来获取对应的部分值。或者 replace 时，使用 $1 $2 等格式替代。</li>\n<li><code>|</code> 表示或 <code>/a|b/</code> 表示 a 或者 b </li>\n</ul>\n</li>\n<li><p><code>转义字符* + ? $ ^ . | \\ ( ) { } [ ]</code> 正则表达式保留字符都需要在前面加 <code>\\</code> 进行转义，比如字符 <code>/</code> 需要使用 <code>\\/</code> 表示</p>\n</li>\n</ul>\n<p>flags 标志位：g 不仅仅匹配第一个，全局匹配。i 忽略大小写</p>\n<p>正则表达式中，一个 () 表示一个部分，来看一个例子。</p>\n<pre><code class=\"language-js\">let str = &quot;zuo guoqing&quot;\nlet reg = /(\\w+)\\s(\\w+)/ // 匹配两个部分 &#39;第一部分 第二部分&#39;\nstr.replace(reg, &quot;$2 $1&quot;) // 将两个部分对调，&quot;guoqing zuo&quot;\nstr.match(reg) // { 0: &quot;zuo guoqing&quot;, 1: &quot;zuo&quot;, 2: &quot;guoqing&quot; }\nreg.exec(str) // { 0: &quot;zuo guoqing&quot;, 1: &quot;zuo&quot;, 2: &quot;guoqing&quot; }</code></pre>\n<p>现在我们可以使用 () 来分部分（块）提取 url 中的字符了，将 url 拆解 <code>.com之前的部分\\/区域部分\\/城市以及id部分\\/模块部分\\/页数部分</code></p>\n<pre><code class=\"language-js\">// .com 之前的部分 [\\S]+.com\\/  匹配一个或多个非空白符.com\\/\n// 区域部分 ([\\w]*)\\/ 匹配 0 个 或多个 数字字母下划线\n// 城市及id部分 ([\\w-]*)\\/ 匹配 0 个或多个 数字字母下划线 -\n// 模块部分 ([\\w]*)\\/?\n// 页数部分 ([\\w]*)$\nlet regExp = /[\\S]+.com\\/([\\w]*)\\/([\\w-]*)\\/([\\w]*)\\/?([\\w]*)$/\nlet a = `http://www.xx.com/region/gd/module`\nlet b = `http://www.xx.com/region/gd-c222/module`\nlet c = `http://www.xx.com/region/gd-c222/module/p2`\na.replace(regExp, &#39;$1 $2 $3 $4&#39;) // &quot;region gd module &quot;\nb.replace(regExp, &#39;$1 $2 $3 $4&#39;) // &quot;region gd-c222 module &quot;\nc.replace(regExp, &#39;$1 $2 $3 $4&#39;) // &quot;region gd-c222 module p2&quot;\na.match(regExp) // { 1: &quot;region&quot;, 2: &quot;gd&quot;, 3: &quot;module&quot;, 4: &quot;&quot; }\nc.match(regExp) // { 1: &quot;region&quot;, 2: &quot;gd-c222&quot;, 3: &quot;module&quot;, 4: &quot;p2&quot; }</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "正则表达式使用 () 和 match 或 replace 提取 url 路径参数"
        }
      ],
      "config": {
        "source": "正则表达式使用 () 和 match 或 replace 提取 url 路径参数.md",
        "staticFileName": "regExp_url.html",
        "author": "guoqzuo",
        "createDate": "2021/05/04",
        "description": "正则提取 url 参数，来看一个问题，使用正则表达式从 url 中提取区域、城市id、模块、页数id。url 示例如下 1. `http://www.xx.com/region/gd/module` 2. `http://www.xx.com/region/gd-c222/module` 3. `http://www.xx.com/region/gd-c222/module/p2` 下面来看看怎么实现。首先，回顾下正则表达式（Regular Expression）基础。正则表表达式以 `/pattern/flags` 表示，是 RegExp 对象的实例",
        "keywords": "正则提取 url 参数",
        "category": "JavaScript",
        "year": "2021",
        "month": "5"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-组件封装，通过发布订阅模式和-vue-实例方法实现-js-操作组件\">Vue 组件封装，通过发布订阅模式和 Vue 实例方法实现 js 操作组件</h1>\n<p>以消息组件为例，如果多个组件共用一个全局的消息组件，那怎么优雅的显示消息呢？</p>\n<p>普通的组件 props 传值的方式会受限，因为组件层级是不确定的。</p>\n<p>你可能会想到状态管理，将是否显示消息、消息内容存到状态管理 state 中，如果需要显示就修改 vuex 值即可。</p>\n<p>但这样调用起来会不够方便、简洁。这里我们可以使用发布订阅模式，结合 Vue 实例属性来优雅的实现该功能。下面来看看使用示例</p>\n<pre><code class=\"language-html\">&lt;!-- 先在 main.js 里全局注册 --&gt;\n&lt;!-- \nimport MessageInfo from &quot;./components/message-info/index.js&quot;;\nVue.use(MessageInfo);\n--&gt;\n\n&lt;!-- msgTest 测试页面 --&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=&quot;showMsg&quot;&gt;Show msg&lt;/button&gt;\n    &lt;!-- 消息组件 message-info --&gt;\n    &lt;message-info&gt;\n      &lt;!-- slot --&gt;\n      &lt;button @click=&quot;closeMsg&quot;&gt;手动关闭 message&lt;/button&gt;\n    &lt;/message-info&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  methods: {\n    // 显示弹窗\n    showMsg() {\n      this.$showMsg([&quot;消息1&quot;, &quot;消息2&quot;]);\n    },\n\n    // 手动关闭弹窗\n    closeMsg() {\n      this.$closeMsg();\n    }\n  }\n};\n&lt;/script&gt;\n&lt;style&gt;&lt;/style&gt;</code></pre>\n<p>上面的例子中，我们使用 this.$showMsg() 和 this.$closeMsg() 来轻松实现了消息的显示与关闭。这样做的好处是，<strong>可以在任何子组件中来操作消息的显示和隐藏</strong>，简单方便。</p>\n<p>下面来看 message-info 组件的具体实现，组件目录如下，相比其他组件多了 EventBus.js，MessageInfo.js 主要用于发布订阅事件处理</p>\n<pre><code class=\"language-bash\">├── message-info\n│   ├── src \n│   │   ├── EventBus.js # 发布订阅 bus\n│   │   ├── index.vue # vue 组件\n│   │   └── MessageInfo.js # js 对象\n│   └── index.js # 组件入口文件，Vue.use 时注册全局组件，绑定实例属性</code></pre>\n<p>message-info/index.js 入口文件</p>\n<pre><code class=\"language-js\">import MessageInfo from &quot;./src/index.vue&quot;;\nimport MessageInfoCore from &quot;./src/MessageInfo.js&quot;;\n\nMessageInfo.install = function(Vue) {\n  // 注册全局组件 message-vue\n  Vue.component(MessageInfo.name, MessageInfo);\n\n  // 绑定实例属性\n  Vue.prototype.$showMsg = MessageInfoCore.showMsg;\n  Vue.prototype.$closeMsg = MessageInfoCore.closeMsg;\n};\n\nexport default MessageInfo;</code></pre>\n<p>message-info/src/index.vue 组件代码</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;!-- 父元素遮罩层--&gt;\n  &lt;div class=&quot;msg-info-wrap&quot; v-if=&quot;showMsg&quot; @click=&quot;closeMsg&quot;&gt;\n    &lt;!-- 消息弹窗 --&gt;\n    &lt;div class=&quot;msg-info&quot; @click.stop&gt;\n      &lt;!-- 消息列表 --&gt;\n      &lt;div v-for=&quot;msg in messages&quot; :key=&quot;msg&quot;&gt;{{ msg }}&lt;/div&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport Bus from &quot;./EventBus&quot;;\n\nexport default {\n  name: &quot;MessageInfo&quot;,\n  data() {\n    return {\n      showMsg: false,\n      messages: []\n    };\n  },\n\n  created() {\n    Bus.$on(&quot;showMsg&quot;, msgList =&gt; {\n      this.showMsg = true; // 显示消息\n      this.messages = msgList; // 显示对应的消息列表\n    });\n    Bus.$on(&quot;closeMsg&quot;, this.closeMsg);\n  },\n\n  destroyed() {\n    Bus.$off(&quot;showMsg&quot;);\n    Bus.$off(&quot;closeMsg&quot;);\n  },\n\n  methods: {\n    closeMsg() {\n      this.showMsg = false;\n      this.messages = [];\n    }\n  }\n};\n&lt;/script&gt;\n\n&lt;style lang=&quot;less&quot; scoped&gt;\n.msg-info-wrap {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  width: 100%;\n  background: rgba(0, 0, 0, 0.1);\n  .msg-info {\n    position: absolute;\n    top: 30%;\n    left: 50%;\n    width: 50%;\n    padding: 20px;\n    border-radius: 5px;\n    transform: translate(-50%, -50%);\n    background: #fff;\n  }\n}\n&lt;/style&gt;</code></pre>\n<p>message-info/src/EventBus.js</p>\n<pre><code class=\"language-js\">import Vue from &quot;vue&quot;;\n\nlet Bus = new Vue();\n\nexport default Bus;</code></pre>\n<p>message-info/src/MessageInfo.js</p>\n<pre><code class=\"language-js\">import Bus from &quot;./EventBus&quot;;\n\nclass MessageInfo {\n  static showMsg(...args) {\n    Bus.$emit(&quot;showMsg&quot;, ...args);\n  }\n\n  static closeMsg(...args) {\n    Bus.$emit(&quot;closeMsg&quot;, ...args);\n  }\n}\n\nexport default MessageInfo;</code></pre>\n<p>完整 github 代码地址： <a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/vuecli-demo/src/components/message-info\">message 组件 代码 | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue 组件封装，通过发布订阅模式和 Vue 实例方法实现 js 操作组件"
        }
      ],
      "config": {
        "source": "Vue 组件封装，通过发布订阅模式和 Vue 实例方法实现 js 操作组件.md",
        "staticFileName": "vue_js_comp.html",
        "author": "guoqzuo",
        "createDate": "2021/05/04",
        "description": "以消息组件为例，如果多个组件共用一个全局的消息组件，那怎么优雅的显示消息呢？普通的组件 props 传值的方式会受限，因为组件层级是不确定的。你可能会想到状态管理，将是否显示消息、消息内容存到状态管理 state 中，如果需要显示就修改 vuex 值即可。但这样调用起来会不够方便、简洁。这里我们可以使用发布订阅模式，结合 Vue 实例属性来优雅的实现该功能。下面来看看使用示例",
        "keywords": "vue js 操作组件, vue 组件封装",
        "category": "Vue",
        "year": "2021",
        "month": "5"
      }
    },
    {
      "htmlStr": "<h1 id=\"footer-始终保持在最底部-css-实现与-js-实现优缺点对比\">footer 始终保持在最底部 css 实现与 js 实现优缺点对比</h1>\n<p>让 footer 一直保持在最底部是比较常见的需求，css 和 js 都可以实现，一般推荐使用 css 实现，下面来看看具体实现，以及他们的优缺点</p>\n<p><img src=\"../../../images/blog/css/footer-bottom.gif\" alt=\"footer-bottom.gif\"></p>\n<p>以下面的结构为例</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n &lt;article class=&quot;container&quot;&gt;\n    &lt;header&gt;顶部&lt;/header&gt;\n    &lt;section class=&quot;main&quot;&gt;中间内容部分&lt;/section&gt;\n    &lt;footer&gt;底部&lt;/footer&gt;\n  &lt;/article&gt;\n&lt;/body&gt;</code></pre>\n<p>需要考虑两种情况：</p>\n<ol>\n<li>内容没占满视窗时，footer 在最底部，需要 body 有最小高度，才能撑起来</li>\n<li>内容较多时，滚动到底部才能看到 footer，且不遮挡内容区域</li>\n</ol>\n<h2 id=\"方法-1：css-方式---position-absolute\">方法 1：css 方式 - position: absolute</h2>\n<ol>\n<li>footer 使用 position: absolute; bottom: 0; 保持在底部。</li>\n<li>对于可能遮挡中间内容区域的问题，将 body 设置为 relative，注意不是 container，这样可以让 footer 内容保持在body最底部</li>\n<li>内容较多时，footer position: absolute 会遮挡内容部分，需要将 container 加一个 padding-bottom: footer 高度，来防止遮挡</li>\n</ol>\n<p><a href=\"https://zuoxiaobai.github.io/fedemo/src/DebugDemo/footer%E5%A7%8B%E7%BB%88%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%9C%80%E5%BA%95%E9%83%A8/index-css-absolute.html\">方法 1 - 在线示例</a>、<a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/footer%E5%A7%8B%E7%BB%88%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%9C%80%E5%BA%95%E9%83%A8/index-css-absolute.html\">方法 1 - 代码 | github</a></p>\n<p><strong>优点：css 即可实现</strong></p>\n<p><strong>缺点：需要知道 footer 具体高度。对于 footer 高度不确定的场景，就不合适了。</strong></p>\n<pre><code class=\"language-css\">* { margin: 0; }\nbody {\n  position: relative; /* 当 footer 为 position 为 absolute 时，放置到 body 底部 */\n  min-height: 100vh; /* 最小高度 100% 视窗高度 */\n}\n.container {\n  padding-bottom: 50px; /* 防止内容被 footer 遮挡 */\n}\nfooter { \n  position: absolute; /* 放到页面最底部 */\n  bottom: 0;\n  left: 0;\n  height: 50px;\n  width: 100%;\n  background: yellow;\n}</code></pre>\n<h2 id=\"方法-2：css-方式---中间部分-flex-1\">方法 2：css 方式 - 中间部分 flex: 1</h2>\n<p>使用 flex 纵向布局，中间部分使用 flex: 1，内容不足时自动撑开</p>\n<p><a href=\"https://zuoxiaobai.github.io/fedemo/src/DebugDemo/footer%E5%A7%8B%E7%BB%88%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%9C%80%E5%BA%95%E9%83%A8/index-css-flex1.html\">方法 2 - 在线示例</a>、<a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/footer%E5%A7%8B%E7%BB%88%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%9C%80%E5%BA%95%E9%83%A8/index-css-flex1.html\">方法 2 - 代码 | github</a></p>\n<p><strong>优点：css 即可实现，不需要知道 footer 区域高度</strong></p>\n<p><strong>缺点：需要注意父容器高度，最小高度要占满屏幕，有嵌套时，需要使用 height: 100%；且整体需要使用 flex 布局</strong></p>\n<pre><code class=\"language-css\">* { margin: 0 }\n.container { \n  display: flex; /* 使用 flex 纵向布局 */\n  flex-direction: column;\n  min-height: 100vh;\n  box-sizing: border-box;\n}\n.main {\n  flex: 1; /* 中间内容部分 flex-grow: 1 内容不足时自动撑开 */\n}\nfooter {  /* 不需要知道底部高度 */\n  padding: 10px;\n  background: yellow;\n}</code></pre>\n<h2 id=\"方法-3：js-方式---监听页面整体滚动高度与视窗高度动态设置样式\">方法 3：js 方式 - 监听页面整体滚动高度与视窗高度动态设置样式</h2>\n<p>页面 mounted 后，判断视窗高度 和 整体滚动高度（包含 footer高度），如果小于视窗高度，则添加一个 固定底部的 class，否则去掉该 class</p>\n<p><a href=\"https://zuoxiaobai.github.io/fedemo/src/DebugDemo/footer%E5%A7%8B%E7%BB%88%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%9C%80%E5%BA%95%E9%83%A8/index-js.html\">方法 3 - 在线示例</a>、<a href=\"https://github.com/zuoxiaobai/fedemo/blob/master/src/DebugDemo/footer%E5%A7%8B%E7%BB%88%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%9C%80%E5%BA%95%E9%83%A8/index-js.html\">方法 3 - 代码 | github</a></p>\n<p><strong>优点：无</strong></p>\n<p><strong>缺点：页面不刷新的情况下，动态增加内容，需要重新判断一次，不推荐</strong></p>\n<p>下面是 vue 的实现</p>\n<pre><code class=\"language-js\">// :class=&quot;fixed ? &#39;flexd-bottom&#39; : &#39;&#39;&quot;\n// data: { fixed: false }\n // 处理 footer \nmethods: {\n  handleFooter() {\n    let { clientHeight } = document.documentElement;\n    this.fixed = false \n    this.$nextTick(() =&gt; {\n      let { scrollHeight: pageScrollHeight } = document.querySelector(&#39;.container&#39;)\n      // 如果整体页面高度(包含默认加载的 bottom) &lt; 视窗高度 固定到底部\n      this.fixed = pageScrollHeight &lt; clientHeight\n    })\n  }\n},\nmounted() {\n  this.handleFooter()\n}\n// &amp;.fixed-bottom {\n//   position: absolute;\n//   bottom: 0;\n// }</code></pre>\n<h2 id=\"测试-demo\">测试 demo</h2>\n<pre><code class=\"language-html\">&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;测试 footer&lt;/title&gt;\n  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;style&gt;\n    * { margin: 0 }\n    footer { height: 50px; background: yellow; }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;article id=&quot;app&quot; class=&quot;container&quot;&gt;\n    &lt;header&gt;\n      &lt;h2&gt;foot 始终在顶部测试&lt;/h2&gt;\n    &lt;/header&gt;\n    &lt;section class=&quot;main&quot;&gt;\n      占位数：&lt;button v-for=&quot;item in list&quot; :key=&quot;`btn-${item}`&quot; @click=&quot;changeCount(item)&quot;&gt;{{item}}&lt;/button&gt;\n      &lt;div v-for=&quot;item in count&quot; :key=&quot;`gap-${item}`&quot;&gt;\n        占位 {{item}}\n      &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;footer&gt;\n      Copyright © 2016-2021 zuo11.com. 鄂ICP备16014741号-1\n    &lt;/footer&gt;\n  &lt;/article&gt;\n  &lt;script&gt;\n    let app = new Vue({\n      el: &#39;#app&#39;,\n      data() {\n        return {\n          list: [5, 50, 100],\n          count: 5\n        }\n      },\n      methods: {\n        changeCount(value) {\n          this.count = value\n        }\n      }\n    })\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "footer 始终保持在最底部 css 实现与 js 实现优缺点对比",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "方法 1：css 方式 - position: absolute"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "方法 2：css 方式 - 中间部分 flex: 1"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "方法 3：js 方式 - 监听页面整体滚动高度与视窗高度动态设置样式"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "测试 demo"
            }
          ]
        }
      ],
      "config": {
        "source": "footer 始终保持在最底部 css 实现与 js 实现优缺点对比.md",
        "staticFileName": "footer_bottom.html",
        "author": "guoqzuo",
        "createDate": "2021/05/04",
        "description": "让 footer 一直保持在最底部是比较常见的需求，css 和 js 都可以实现，一般推荐使用 css 实现，下面来看看具体实现，以及他们的优缺点。需要考虑两种情况：1. 内容没占满视窗时，footer 在最底部，需要 body 有最小高度，才能撑起来 2. 内容较多时，滚动到底部才能看到 footer，且不遮挡内容区域",
        "keywords": "footer一直保持到底部怎么实现,footer区域保持在底部,footer固定到底部",
        "category": "CSS",
        "year": "2021",
        "month": "5"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-组件中-css-路径简写--不可用，需要使用-\">Vue 组件中 css 路径简写 @ 不可用，需要使用 ~@</h1>\n<blockquote>\n<p>Vue css src 路径，css @ 不生效，css src 简写@, webpack 解析 css 路径</p>\n</blockquote>\n<p>在 vue-cli 创建的 vue 项目中，可以使用 @ 来表示 src 路径。但在 css 中，图片路径使用 @ 就会出错。那 css 中要怎么使用 src 相对路径呢？</p>\n<p>需要在前面加 ~，也就是 ~@，这样就不必使用相对路径了。</p>\n<pre><code class=\"language-css\">#img {\n  height: 100px;\n  width: 100px;\n  background: url(&quot;~@/assets/logo.png&quot;);\n  background-size: contain;\n}</code></pre>\n<p>为什么呢？可能的原因是 @ 是 css 的保留关键字，在 @import 的时候会用到，为了避免冲突，才使用 ~@ 以示区分。</p>\n<p>webpack 中使用 css-loader 来处理 css，具体逻辑可以看 <a href=\"https://github.com/webpack-contrib/css-loader\">css-loader 源码</a></p>\n<p>参考: </p>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_39148344/article/details/100771356\">webpack对CSS使用alias相对路径 | CSDN</a></li>\n<li><a href=\"https://blog.csdn.net/yusirxiaer/article/details/105661313\">vue项目，webpack中配置src路径别名及使用</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue 组件中 css 路径简写 @ 不可用，需要使用 ~@"
        }
      ],
      "config": {
        "source": "vue 组件中 css 路径简写 @ 不可用，需要使用 ~@.md",
        "staticFileName": "vue_css_src.html",
        "author": "guoqzuo",
        "createDate": "2021/05/04",
        "description": "vue css src 路径，css @ 不生效，css src 简写@, webpack 解析 css 路径，在 vue-cli 创建的 vue 项目中，可以使用 @ 来表示 src 路径。但在 css 中，图片路径使用 @ 就会出错。那 css 中要怎么使用 src 相对路径呢？需要在前面加 ~，也就是 ~@，这样就不必使用相对路径了。",
        "keywords": "vue css src 路径,css @ 不生效,css src 简写@,webpack 解析 css 路径",
        "category": "Vue",
        "year": "2021",
        "month": "5"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-国际化-vue-i18n-相关用法、实践总结\">Vue 国际化 vue-i18n 相关用法、实践总结</h1>\n<p>在 <a href=\"http://www.zuo11.com/blog/2021/4/vue_international.html\">Vue 使用 vue-i18n 国际化 - 左小白的技术日常</a> 中，我们简单介绍了 vue-i18n 的基本使用。如果想将它实际应用到项目中，我们还需要考虑怎么做到更加简洁、优雅、可维护，下面是一些实践总结。</p>\n<h2 id=\"1-i18n-单独放一个目录，避免在-mainjs-中写入太多内容\">1. i18n 单独放一个目录，避免在 main.js 中写入太多内容</h2>\n<p>i18n 相关内容较多，如果都写在 main.js 里，内容会很多，不够优雅，这里可以进行简单封装。在 src 目录下新建一个 i18n 目录，专门用于存放国际化相关内容，使用 index.js 作为入口文件</p>\n<pre><code class=\"language-js\">// src/i18n/index.js\nimport Vue from &quot;vue&quot;;\nimport VueI18n from &quot;vue-i18n&quot;;\n\nVue.use(VueI18n);\n\nconst i18n = new VueI18n({\n  locale: &quot;zh-CN&quot;, // 设置默认语言环境\n  // 在 vue template 的 {{}} 中，使用 $t(&#39;un&#39;) 即可拿到 un 属性指定的值\n  // 不需要在 data() {} 中设置什么\n  messages: {\n    en: {\n      name: &quot;Zhang san&quot;,\n      hello: &quot;hello world&quot;\n    },\n    &quot;zh-CN&quot;: {\n      name: &quot;张三&quot;,\n      hello: &quot;你好，世界&quot;\n    }\n  }\n});\n\nexport default i18n; // 将 i18n 实例导出，用于在 new Vue 时引入</code></pre>\n<p>这样，我们在 main.js 就只需要修改两行就可以了</p>\n<pre><code class=\"language-js\">// main.js\n// ...\nimport i18n from &quot;./i18n/index&quot;; // 引入 src/i18n/index，得到 i18n 实例\n\nnew Vue({\n  i18n, // 在 new Vue() 时加入 i18n\n  router,\n  store,\n  render: h =&gt; h(App)\n}).$mount(&quot;#app&quot;);</code></pre>\n<h2 id=\"2-方便实时测试：语言切换组件\">2. 方便实时测试：语言切换组件</h2>\n<p>在测试国际化时，改代码的方式切国际化语言不够方便。我们可以做一个测试用的语言切换组件，在主页面引入后，会出现在页面右上角，方便调试。相关配置存到 lcoalStorage 中，防止调试时刷新页面后需要再次手动切换语言。</p>\n<p><img src=\"../../../images/blog/vue/i18n-lang-change.gif\" alt=\"i18n-lang-change.gif\"></p>\n<pre><code class=\"language-html\">&lt;!-- BaseLanguageSelect.vue --&gt;\n&lt;template&gt;\n  &lt;div class=&quot;demo-i18n&quot;&gt;\n    国际化测试：\n    &lt;el-select v-model=&quot;lang&quot; @change=&quot;langChange&quot;&gt;\n      &lt;el-option label=&quot;中文&quot; value=&quot;zh-CN&quot;&gt;&lt;/el-option&gt;\n      &lt;el-option label=&quot;英语&quot; value=&quot;en&quot;&gt;&lt;/el-option&gt;\n    &lt;/el-select&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n// 将当前语言存到 localStorage 中的字段，要特殊，防止和其他项目冲突\nconst LANG_NAME = &quot;demo-lang&quot;;\nexport default {\n  data() {\n    return {\n      lang: &quot;en&quot;\n    };\n  },\n  created() {\n    // 从 localStorage 中读取默认语言，便于页面刷新后调试\n    this.lang = localStorage.getItem(LANG_NAME) || &quot;en&quot;;\n    // 设置到 i18n\n    this.$i18n.locale = this.lang;\n  },\n  methods: {\n    // 语言切换后，设置到 i18n、localStorage\n    langChange(value) {\n      this.$i18n.locale = value;\n      localStorage.setItem(LANG_NAME, value);\n    }\n  }\n};\n&lt;/script&gt;\n\n&lt;style lang=&quot;less&quot; scoped&gt;\n.demo-i18n {\n  position: absolute;\n  top: 10px;\n  right: 10px;\n}\n&lt;/style&gt;</code></pre>\n<p>使用示例</p>\n<pre><code class=\"language-html\">&lt;!-- i18nTest.vue --&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;BaseLanguageSelect /&gt;\n    {{ $t(&quot;name&quot;) }}, {{ $t(&quot;hello&quot;) }}\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  components: {\n    BaseLanguageSelect: () =&gt; import(&quot;./BaseLanguageSelect&quot;)\n  }\n};\n&lt;/script&gt;</code></pre>\n<h2 id=\"3-避免单文件过大、混乱：模块化\">3. 避免单文件过大、混乱：模块化</h2>\n<p>当项目较大、国际化内容较多时，如果将全部内容都写在 i18n/index.js 主文件中，有两个缺点：</p>\n<ul>\n<li>i18n/index.js 内容太多，不好查找</li>\n<li>多人同时维护时，容易产生冲突，合并代码一不小心就会合出问题</li>\n</ul>\n<p>这就需要模块化了，怎么优雅的模块化呢？下面是我的一些思考，仅供参考</p>\n<ul>\n<li>按功能模块划分、不同的模块放到不同的目录、不同的语言使用不同的文件</li>\n<li>新增模块和语言时，最小化改动公共文件 i18n/index.js</li>\n</ul>\n<p>目录结构规划如下</p>\n<pre><code class=\"language-bash\">├── i18n\n│   ├── base # 通用模块，想用 common 但是使用时，模块名越短越方便，改为 base \n│   │   ├── en.js\n│   │   └── zh-CN.js \n│   ├── user # 用户模块\n│   │   ├── en.js\n│   │   └── zh-CN.js \n│   ├── xxx # 其他模块\n│   │   ├── en.js\n│   │   └── zh-CN.js \n│   └── index.js # 入口文件、导出 i18n 实例</code></pre>\n<p>这里就需要重构 i18n/index.js 了，利用 import() 动态导入，使用 modules 模块数组，languages 语言数组，自动去合并、整理 messages。后面新增模块或新增语言非常方便、快捷，代码如下</p>\n<pre><code class=\"language-js\">import Vue from &quot;vue&quot;;\nimport VueI18n from &quot;vue-i18n&quot;;\n\nVue.use(VueI18n);\n\n/**\n * @description 根据模块、语言提取 messages\n * @author zuoxiaobai &lt;i@zuoguoqing.com&gt;\n * @param { Array } modules [&quot;base&quot;, &quot;user&quot;]; // 模块数组\n * @param { Array } languages [&quot;en&quot;, &quot;zh-CN&quot;]; // 语言数组\n * @returns { Object} messages\n */\nfunction getMessages(modules, languages) {\n  // 初始化 messages { en: {}, zh-CN: {}}\n  let messages = {};\n  languages.forEach(lang =&gt; {\n    messages[lang] = {};\n  });\n\n  // 遍历模块，将内容添加到 messages.语言.上\n  modules.forEach(moduleName =&gt; {\n    languages.forEach(async lang =&gt; {\n      // 加 try ... catch 防止语言文件缺失 import 报 error，影响执行\n      try {\n        let { default: obj } = await import(&quot;./&quot; + `${moduleName}/${lang}.js`);\n        // { en: { base: { } }, zh-CN: { base: {} }}\n        !messages[lang][moduleName] &amp;&amp; (messages[lang][moduleName] = {});\n        Object.assign(messages[lang][moduleName], obj);\n      } catch (e) {\n        console.warn(e.message);\n      }\n    });\n  });\n  console.log(messages);\n  return messages;\n}\n\nconst modules = [&quot;base&quot;, &quot;user&quot;]; // 模块数组\nconst languages = [&quot;en&quot;, &quot;zh-CN&quot;, &quot;zh-TW&quot;]; // 语言数组\nlet messages = getMessages(modules, languages);\n\nconst i18n = new VueI18n({\n  locale: &quot;zh-CN&quot;, // 设置默认语言环境\n  messages\n  // messages: {\n  //   en: {\n  //     name: &quot;Zhang san&quot;,\n  //     hello: &quot;hello world&quot;\n  //   },\n  //   &quot;zh-CN&quot;: {\n  //     name: &quot;张三&quot;,\n  //     hello: &quot;你好，世界&quot;\n  //   }\n  // }\n});\n\nexport default i18n;</code></pre>\n<p>合并后的效果如下图，不同的模块放到不同的大对象上</p>\n<p><img src=\"../../../images/blog/vue/i18n-modlues.png\" alt=\"i18n-modlues.png\"></p>\n<p>在 vue 组件中使用时，加上模块前缀即可</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;BaseLanguageSelect /&gt;\n    &lt;!-- {{ $t(&quot;name&quot;) }}, {{ $t(&quot;hello&quot;) }} --&gt;\n    {{ $t(&quot;user.name&quot;) }}, {{ $t(&quot;user.hello&quot;) }}\n    {{ $t(&quot;base.year&quot;) }}, {{ $t(&quot;base.month&quot;) }}, {{ $t(&quot;base.time&quot;) }}\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre>\n<h2 id=\"4-列表渲染（code-值）处理：js-取值、过滤器-filter-设计\">4. 列表渲染（code 值）处理：js 取值、过滤器 filter 设计</h2>\n<p>对于列表相关国际化，如果是前端纯展示还好，我们直接遍历即可，以 currency 币种为例，纯展示可以像下面这样写</p>\n<pre><code class=\"language-html\">&lt;!-- currencys: [&quot;RMB&quot;, &quot;USD&quot;, &quot;HKD&quot;] --&gt;\n&lt;!-- currencys: [&quot;人民币&quot;, &quot;美元&quot;, &quot;港币&quot;] --&gt;\n&lt;div v-for=&quot;item in $t(&#39;base.currencys&#39;)&quot; :key=&quot;item&quot;&gt;{{ item }}&lt;/div&gt;</code></pre>\n<p>但如果涉及到表单，就需要一些处理了。比如表单中需要选择币种，一般每个币种会对应不同的 code，我们需要处理两个问题：</p>\n<ol>\n<li>用户选择国际化币种后，表单 v-model 值自动变成 code</li>\n<li>当后端返回币种 code 时，前端可以渲染其国际化币种显示</li>\n</ol>\n<p>可以在国际化中新增一个字段比如 currencysCode，按照字段顺序一一对应，比如 currencyCodes: [&#39;10&#39;, &#39;12&#39;, &#39;15&#39;]，这样根据 index，可以将 code 设置到表单的 value 中，另外知道 code 计算国际化文本时，可以使用 filter，从 this.$i18n 这个变量中，通过 js 来取值，例子如下</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;BaseLanguageSelect /&gt;\n\n    当前币种：{{ currency | currencyText($i18n) }} {{ currency }}\n    &lt;el-select v-model=&quot;currency&quot;&gt;\n      &lt;el-option\n        v-for=&quot;(item, index) in $t(&#39;base.currencys&#39;)&quot;\n        :key=&quot;item&quot;\n        :label=&quot;item&quot;\n        :value=&quot;$t(&#39;base.currencyCodes&#39;)[index]&quot;\n      &gt;&lt;/el-option&gt;\n    &lt;/el-select&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  components: {\n    BaseLanguageSelect: () =&gt; import(&quot;./BaseLanguageSelect&quot;)\n  },\n\n  filters: {\n    currencyText: function(code, i18n) {\n      // filter 中不能使用 this，需要传参数 this.$i18n\n      // console.log(this); // undefined\n      let { currencys, currencyCodes } = i18n.messages[i18n.locale].base;\n      // 根据 code 找到对应的 index\n      let index = currencyCodes.indexOf(code);\n      return currencys[index];\n    }\n  },\n  data() {\n    return {\n      currency: &quot;&quot;\n    };\n  }\n};\n&lt;/script&gt;</code></pre>\n<p>除了在国际化中，加入对应的 code 对应关系字段外，也可以单独用一个 const 文件来保存 code。当语言种类不多的情况下，感觉直接放到国际化字段中会简单一点，操作时不用额外引入文件。</p>\n<p>除了模板语法写法外，我们也可以通过 Vue 的实例属性 this.$i18n. 来操作国际化数据，这样基本就可以处理所有情况了。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue 国际化 vue-i18n 相关用法、实践总结",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "1. i18n 单独放一个目录，避免在 main.js 中写入太多内容"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "2. 方便实时测试：语言切换组件"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "3. 避免单文件过大、混乱：模块化"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "4. 列表渲染（code 值）处理：js 取值、过滤器 filter 设计"
            }
          ]
        }
      ],
      "config": {
        "source": "Vue 国际化 vue-i18n 相关用法、实践总结.md",
        "staticFileName": "vue-i18n_use.html",
        "author": "guoqzuo",
        "createDate": "2021/05/04",
        "description": "vue 国际化, Vue 国际化最佳实践, vue-i18n最佳实践, vue-i18n模块化方案, 在 'Vue 使用 vue-i18n 国际化' 中，我们简单介绍了 vue-i18n 的基本使用。如果想将它实际应用到项目中，我们还需要考虑怎么做到更加简洁、优雅、可维护，下面是一些实践总结。1. i18n 单独放一个目录，避免在 main.js 中写入太多内容 2. 方便实时测试：语言切换组件 3. 避免单文件过大、混乱：模块化 4. 列表渲染（code 值）处理：js 取值、过滤器 filter 设计",
        "keywords": "vue 国际化,Vue 国际化最佳实践,vue-i18n最佳实践,vue-i18n模块化方案",
        "category": "Vue",
        "year": "2021",
        "month": "5"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-filters-中-this-为-undefined，建议使用传参或-method-处理\">Vue filters 中 this 为 undefined，建议使用传参或 method 处理</h1>\n<p>在 i18n 国际化，将 code 转换为国际化文本的场景中，需要使用 this.$i18n 这个变量，但发现 fitlers 中的 this 是 undefined，无法使用，查了下。</p>\n<p>这个是 Vue 设计问题，以下是作者 尤雨溪 在 issue <a href=\"https://github.com/vuejs/vue/issues/5998\">this undefined in filters · Issue #5998 · vuejs/vue</a> 下的回复：</p>\n<p><img src=\"../../../images/blog/vue/filter-this.png\" alt=\"filter-this.png\"></p>\n<p>This is intentional in 2.x. Filters should be pure functions and should not be dependent on this context. If you need this you should use a computed property or just a method e.g. $translate(foo)</p>\n<p>在 2.x 的版本中这个处理是有意的，Fitlers 应该是纯函数，不应该依赖 this 上下文。如果需要依赖 this，那就应该使用 computed 计算属性或 method 方法</p>\n<p><strong>解决方法：在 filters 中我们是可以传参数的，我们可以把需要的值，通过参数传入。如果涉及到多个变量的使用，传参比较冗余，那就使用计算属性或方法</strong>，使用示例：</p>\n<pre><code class=\"language-js\">// {{ currencyCode | currencyText($i18n) }}\nfilters: {\n  currencyText: function(code, i18n) {\n    // filter 中不能使用 this，需要传参数 this.$i18n\n    // console.log(this); // undefined\n    let { currencys, currencyCodes } = i18n.messages[i18n.locale].base;\n    // 根据 code 找到对应的 index\n    let index = currencyCodes.indexOf(code);\n    return currencys[index];\n  }\n},</code></pre>\n<p>参考: <a href=\"https://blog.csdn.net/weixin_40837048/article/details/100691625\">vue中过滤器filters的this指向问题。</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vue filters 中 this 为 undefined，建议使用传参或 method 处理"
        }
      ],
      "config": {
        "source": "Vue filters 中 this 为 undefined，建议使用传参或 method 处理.md",
        "staticFileName": "vue_filters_this.html",
        "author": "guoqzuo",
        "createDate": "2021/05/04",
        "description": "在 i18n 国际化，将 code 转换为国际化文本的场景中，需要使用 this.$i18n 这个变量，但发现 fitlers 中的 this 是 undefined，无法使用，查了下。这个是 Vue 设计问题，以下是作者 尤雨溪 在 issue [this undefined in filters · Issue #5998 · vuejs/vue](https://github.com/vuejs/vue/issues/5998) 下的回复：",
        "keywords": "vue filters this,vue filter this 为空,vue filter 不能使用 this",
        "category": "Vue",
        "year": "2021",
        "month": "5"
      }
    },
    {
      "htmlStr": "<h1 id=\"stringprototypereplace-多个匹配替换时注意要使用正则\">String.prototype.replace 多个匹配替换时注意要使用正则</h1>\n<p>在做字符串替换时可以使用 repalce，但这里要注意，当需要替换多个时，第一个参数不能是字符串，要使用正则表达式</p>\n<p>来看一个例子，将字符串 &quot;1,000,000&quot; 中的 &quot;,&quot; 替换为空字符串 &quot;&quot;</p>\n<pre><code class=\"language-js\">let str = &quot;1,000,000&quot;\nstr.replace(&quot;,&quot;, &quot;&quot;) // &quot;1000,000&quot;</code></pre>\n<p>注意：上面的例子中，如果单纯的字符串替换，只会替换第一个，全局匹配时，第一个参数就要用正则了</p>\n<pre><code class=\"language-js\">let str = &quot;1,000,000&quot;\nstr.replace(/,/g, &quot;&quot;) // &quot;1000000&quot;</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "String.prototype.replace 多个匹配替换时注意要使用正则"
        }
      ],
      "config": {
        "source": "String.prototype.replace 多个匹配替换时注意要使用正则.md",
        "staticFileName": "replace_regExp.html",
        "author": "guoqzuo",
        "createDate": "2021/05/04",
        "description": "在做字符串替换时可以使用 repalce，但这里要注意，当需要替换多个时，第一个参数不能是字符串，要使用正则表达式。来看一个例子，将字符串 '1,000,000' 中的 ',' 替换为空字符串 ''。注意：上面的例子中，如果单纯的字符串替换，只会替换第一个，全局匹配时，第一个参数就要用正则了",
        "keywords": "replace多个匹配时需要使用正则",
        "category": "JavaScript",
        "year": "2021",
        "month": "5"
      }
    },
    {
      "htmlStr": "<h1 id=\"v-model-怎么优雅的绑定-vuex-状态管理中的值，三种方法优缺点\">v-model 怎么优雅的绑定 Vuex 状态管理中的值，三种方法优缺点</h1>\n<p>在需要将 vuex 中的值，直接与表单 v-model 对应时，如果我们按照 vuex 强调的规范，只能通过 mutation 来改变 vuex state，那么会比较麻烦。假设我们脱离规范，关闭严格模式。那么 v-model 可以直接绑定 vuex state 值，会非常方便，但貌似又不合规范，不利于追踪。</p>\n<p>那到底要怎么做合适呢？个人建议是：怎么方便怎么来，只要项目可控即可。下面来看看几种方法对比</p>\n<h2 id=\"1-官方推荐：使用-computed-的-get-和-set\">1. 官方推荐：使用 computed 的 get 和 set</h2>\n<ul>\n<li>优点：遵循 vuex 规范，通过 mutation 更改 state，有利于追踪</li>\n<li>缺点：需要将表单的每个字段都使用 computed 计算属性，对于字段较少的情况，还可以。但当字段较多，且包含逻辑处理时，会比较麻烦不好维护。<pre><code class=\"language-js\">// &lt;input v-model=&quot;message&quot;&gt;\ncomputed: {\nmessage: {\n  get () {\n    return this.$store.state.obj.message\n  },\n  set (value) {\n    // 通过 updateMessage mutation 方法更改值\n    this.$store.commit(&#39;updateMessage&#39;, value)\n  }\n}\n}</code></pre>\n参考：<a href=\"https://vuex.vuejs.org/zh/guide/forms.html\">表单处理 | Vuex</a></li>\n</ul>\n<h2 id=\"2-非严格模式：直接将-state-设置到-v-model\">2. 非严格模式：直接将 state 设置到 v-model</h2>\n<p>关闭严格模式后，直接将 vuex state 当全局变量用，可以任意修改操作</p>\n<pre><code class=\"language-js\">const store = new Vuex.Store({\n  // ...\n  strict: false // 关闭严格模式，或者直接不写这个属性\n  // strict: true // 开启严格模式 \n})</code></pre>\n<ul>\n<li>优点：可以将 obj.message 直接设置到 v-model，值实时更新，而且不用什么额外操作。</li>\n<li>缺点：破坏了 vuex 的规则约束，不利于追踪，可能会造成难以维护的情况。</li>\n</ul>\n<pre><code class=\"language-js\">&lt;input v-model=&quot;obj.message&quot;&gt;</code></pre>\n<h2 id=\"3-中间对象转换：watch-监听-state-改变，更新中间对象，v-model-中间对象\">3. 中间对象转换：watch 监听 state 改变，更新中间对象，v-model 中间对象</h2>\n<ul>\n<li>优点：折中方法，不破坏 vuex 规则约束，操作比一个一个加 computed 要简单</li>\n<li>缺点：需要使用 watch 来初始化或更改值，触发时机需要特别注意</li>\n</ul>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;div&gt;{{ obj }}&lt;/div&gt;\n    &lt;div&gt;{{ objCopy }}&lt;/div&gt;\n    &lt;el-form&gt;\n      &lt;el-input v-model=&quot;objCopy.message&quot; /&gt;\n      &lt;el-button @click=&quot;confirm&quot;&gt;提交&lt;/el-button&gt;\n    &lt;/el-form&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { mapState } from &quot;vuex&quot;;\nexport default {\n  data() {\n    return {\n      objCopy: {\n        message: &quot;&quot;\n      }\n    };\n  },\n\n  computed: {\n    ...mapState([&quot;obj&quot;])\n  },\n\n  watch: {\n    obj: {\n      handler() {\n        this.initData();\n      },\n      deep: true\n    }\n  },\n\n  created() {\n    this.initData();\n  },\n\n  methods: {\n    initData() {\n      Object.assign(this.objCopy, this.obj);\n    },\n    confirm() {\n      this.$store.commit(&quot;updateObj&quot;, JSON.parse(JSON.stringify(this.objCopy)));\n    }\n  }\n};\n&lt;/script&gt;</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "v-model 怎么优雅的绑定 Vuex 状态管理中的值，三种方法优缺点",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "1. 官方推荐：使用 computed 的 get 和 set"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "2. 非严格模式：直接将 state 设置到 v-model"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "3. 中间对象转换：watch 监听 state 改变，更新中间对象，v-model 中间对象"
            }
          ]
        }
      ],
      "config": {
        "source": "v-model 怎么优雅的绑定 Vuex 状态管理中的值，三种方法优缺点.md",
        "staticFileName": "v-model_vuex.html",
        "author": "guoqzuo",
        "createDate": "2021/05/04",
        "description": "在需要将 vuex 中的值，直接与表单 v-model 对应时，如果我们按照 vuex 强调的规范，只能通过 mutation 来改变 vuex state，那么会比较麻烦。假设我们脱离规范，关闭严格模式。那么 v-model 可以直接绑定 vuex state 值，会非常方便，但貌似又不合规范，不利于追踪。那到底要怎么做合适呢？个人建议是：怎么方便怎么来，只要项目可控即可。下面来看看几种方法对比 1. 官方推荐：使用 computed 的 get 和 set",
        "keywords": "v-model 绑定 vuex 中的值",
        "category": "Vue",
        "year": "2021",
        "month": "5"
      }
    },
    {
      "htmlStr": "<h1 id=\"v-if-和-v-show-生命周期钩子函数有什么不同\">v-if 和 v-show 生命周期钩子函数有什么不同</h1>\n<p>在 vue 中我们知道 v-if 和 v-show 都可以用来控制内容的显示与隐藏，他们的区别是</p>\n<ol>\n<li>v-if 是惰性加载，只有为 true 时，才真正渲染，否则页面是不存在该元素的。为 false 时，直接从 dom 移除。</li>\n<li>v-show 是根据 css display 属性来显示和隐藏组件的</li>\n</ol>\n<p><img src=\"../../../images/blog/vue/v-show.gif\" alt=\"v-show.gif\"></p>\n<p>那么他们的生命周期钩子函数有什么区别呢？</p>\n<ol>\n<li>v-show 控制隐藏或显示的组件，一进入就立即加载，执行 beforeCreate、created、beforeMount、mounted，中间切换显示和隐藏不会触发钩子函数</li>\n<li>v-if 只有为 true 时，才会正常执行加载的钩子函数，否则不会加载。当切换时，实时挂载(created/mounted)、卸载组件(destoryed)。</li>\n</ol>\n<p>使用场景：v-if 适合在 true、false 切换不频繁的场景，当为 false 时，可以减少初次渲染时间。如果切换很频繁 v-if 会不断的挂载、卸载组件，会加大开销，这时使用 v-show 就比较好，尽管它的初始开销会大一点。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "v-if 和 v-show 生命周期钩子函数有什么不同"
        }
      ],
      "config": {
        "source": "v-if 和 v-show 生命周期钩子函数有什么不同.md",
        "staticFileName": "v-if_v-show_hooks.html",
        "author": "guoqzuo",
        "createDate": "2021/05/04",
        "description": "在 vue 中我们知道 v-if 和 v-show 都可以用来控制内容的显示与隐藏，他们的区别是 1. v-if 是惰性加载，只有为 true 时，才真正渲染，否则页面是不存在该元素的。为 false 时，直接从 dom 移除。2. v-show 是根据 css display 属性来显示和隐藏组件的。那么他们的生命周期钩子函数有什么区别呢？1. v-show 控制隐藏或显示的组件，一进入就立即加载，执行 beforeCreate、created、beforeMount、mounted，中间切换显示和隐藏不会触发钩子函数 2. v-if 只有为 true 时，才会正常执行加载的钩子函数，否则不会加载。当切换时，实时挂载(created/mounted)、卸载组件(destoryed)。",
        "keywords": "v-if 与 v-show 钩子函数区别,v-if 与 v-show 区别",
        "category": "Vue",
        "year": "2021",
        "month": "5"
      }
    },
    {
      "htmlStr": "<h1 id=\"vscode-live-server-插件-open-with-live-server-没反应，无法打开浏览器\">Vscode Live Server 插件 Open With Live Server 没反应，无法打开浏览器</h1>\n<p>在调试单个 html 文件时，可以使用 Live Server 插件，快速开启 http 服务，并打开当前页面。</p>\n<p><img src=\"../../../images/blog/devtools/live-server.png\" alt=\"live-server.png\"></p>\n<p>但目前这个插件可能会出现没反应，打不开的情况，可以使用 <strong>Preview on Web Server</strong> 来代替</p>\n<p><img src=\"../../../images/blog/devtools/preview-on-server.png\" alt=\"preview-on-server.png\"></p>\n<p>使用方法基本一致，右键可以选择浏览器打开，或者在 vscode 侧边栏预览</p>\n<p><img src=\"../../../images/blog/devtools/launch-on-browser.png\" alt=\"launch-on-browser.png\"></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Vscode Live Server 插件 Open With Live Server 没反应，无法打开浏览器"
        }
      ],
      "config": {
        "source": "Vscode Live Server 插件 Open With Live Server 没反应，无法打开浏览器.md",
        "staticFileName": "live_server_file.html",
        "author": "guoqzuo",
        "createDate": "2021/05/04",
        "description": "在调试单个 html 文件时，可以使用 Live Server 插件，快速开启 http 服务，并打开当前页面。但目前这个插件可能会出现没反应，打不开的情况，可以使用 **Preview on Web Server** 来代替。使用方法基本一致，右键可以选择浏览器打开，或者在 vscode 侧边栏预览",
        "keywords": "live server 没反应,live server 无法打开浏览器",
        "category": "计算机基础与开发工具",
        "year": "2021",
        "month": "5"
      }
    },
    {
      "htmlStr": "<h1 id=\"js-怎么减少-if-else-嵌套-使用函数封装、三元运算符等\">js 怎么减少 if else 嵌套, 使用函数封装、三元运算符等</h1>\n<p>在 if else 或函数嵌套层级较多，代码会逐渐变的难看，不好理解及维护。一般可以通过改变代码组织方式，来减少代码嵌套层级，这里主要介绍下面 5 种方法：</p>\n<ol>\n<li>将代码块按功能块封装成函数，减少函数内代码的嵌套层级</li>\n<li>if 优化，逻辑假时 true，减少 if 中包含大量代码的情况</li>\n<li>使用三元运算符减少 if 层级</li>\n<li>使用逻辑运算符减少 if 层级</li>\n<li>使用策略模式减少 if、else 层级</li>\n</ol>\n<p>来看一个简单的例子，在 vue 实例中，watch 深度监听 userInfo 对象，里面的处理函数中有 if，有数组遍历函数，层级会比较深</p>\n<pre><code class=\"language-html\">&lt;script&gt;\nexport default {\n  data() {\n    return {\n      userInfo: {}\n    };\n  },\n  watch: {\n    userInfo: {\n      handler(value) {\n        if (value.name) {\n          let indexMap = this.arrList.reduce(() =&gt; {\n            console.log(&quot;test1&quot;);\n            // 可能存在 if 或函数嵌套\n          });\n\n          this.list.forEach(item =&gt; {\n            if (indexMap[item.index]) {\n              console.log(&quot;test2&quot;);\n            }\n          });\n        }\n      },\n      deep: true\n    }\n  }\n};\n&lt;/script&gt;</code></pre>\n<p>下面来具体看减少代码嵌套层级的几种思路：</p>\n<h2 id=\"1将代码块按功能块封装成函数\">1.将代码块按功能块封装成函数</h2>\n<pre><code class=\"language-js\">if (condition) {\n  let indexMap = this.arrList.reduce(() =&gt; {\n    console.log(&quot;test1&quot;);\n    // 可能存在的 if 或函数嵌套\n  });\n}\n\n// 可以优化为下面这种，这样就避免了函数代码直接嵌套在 reduce 方法内部\nif (condition) {\n  const reduceFunc = () =&gt; {\n    console.log(&quot;test1&quot;);\n    // 可能存在的 if 或函数嵌套\n  }\n  let indexMap = this.arrList.reduce(reduceFunc);\n}</code></pre>\n<h2 id=\"2-if-优化，逻辑假时-true，减少-if-中包含大量代码的情况\">2. if 优化，逻辑假时 true，减少 if 中包含大量代码的情况</h2>\n<pre><code class=\"language-js\">function func() {\n  if (condition) {\n    // 一大段代码\n    // 可能存在 if 等嵌套层级的代码\n  }\n}\n// 可以优化为下面这种，这样可以将一大段代码从 if (condition) 嵌套中解放出来\nfunction func() {\n  if (!condition) {\n    return false // 条件不满足时结束函数\n  }\n  // 一大段代码\n  // 可能存在 if 等嵌套层级的代码\n}</code></pre>\n<h2 id=\"3-三元运算符\">3. 三元运算符</h2>\n<pre><code class=\"language-js\">function func() {\n  let a = &#39;1&#39;\n  if (b) {\n    a = &#39;2&#39;\n  }\n}\n// 可以优化为\nfunction func() {\n  let a = b ? &#39;2&#39; : &#39;1&#39;\n}</code></pre>\n<h2 id=\"4-逻辑运算符\">4. 逻辑运算符</h2>\n<pre><code class=\"language-js\">function func() {\n  if (callback) {\n    callback()\n  }\n}\n// 可以优化为\nfunction func() {\n  callback &amp;&amp; callback()\n}</code></pre>\n<h2 id=\"5-策略模式\">5. 策略模式</h2>\n<pre><code class=\"language-js\">function func() {\n  if (type === &#39;a&#39;) {\n    // 执行内容 1\n  } else if (type === &#39;b&#39;) {\n    // 执行内容 2\n  } else if (type === &#39;c&#39;) {\n    // 执行内容 3\n  }\n  // 后续代码\n}\n\n// 使用策略模式优化\nfunction func() {\n  let handlerA = () =&gt; { console.log(&#39;执行内容1&#39;) }\n  let handlerB = () =&gt; { console.log(&#39;执行内容2&#39;) }\n  let handlerC = () =&gt; { console.log(&#39;执行内容3&#39;) }\n  let handlerMap = {\n    a: handlerA,\n    b: handlerB,\n    c: handlerC\n  }\n  handlerMap[type] &amp;&amp; handlerMap[type]()\n  // 后续代码\n}</code></pre>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "js 怎么减少 if else 嵌套, 使用函数封装、三元运算符等",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "1.将代码块按功能块封装成函数"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "2. if 优化，逻辑假时 true，减少 if 中包含大量代码的情况"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "3. 三元运算符"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "4. 逻辑运算符"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "5. 策略模式"
            }
          ]
        }
      ],
      "config": {
        "source": "js 怎么减少 if else 嵌套, 使用函数封装、三元运算符等.md",
        "staticFileName": "reduce_if_else.html",
        "author": "guoqzuo",
        "createDate": "2021/09/09",
        "description": "在 if else 或函数嵌套层级较多，代码会逐渐变的难看，不好理解及维护。一般可以通过改变代码组织方式，来减少代码嵌套层级，这里主要介绍下面 5 种方法：1.将代码块按功能块封装成函数，减少函数内代码的嵌套层级 2. if 优化，逻辑假时 true，减少 if 中包含大量代码的情况 3...",
        "keywords": "js 怎么减少 if else 嵌套,js 怎么减少 if 嵌套,js 怎么减少函数嵌套,js 中 if else 替代写法",
        "category": "JavaScript",
        "year": "2021",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"mac-其他文件怎么清理，使用免费的腾讯柠檬清理代替-cleanmymac\">mac 其他文件怎么清理，使用免费的腾讯柠檬清理代替 CleanMyMac</h1>\n<p>mac 存储空间里面的其他文件占用较多，它主要是一些碎片文件、缓存等，一般不通过工具软件很难清理。如下图：</p>\n<p><img src=\"../../../images/blog/others/macos_disk_other.png\" alt=\"macos_disk_other.png\"></p>\n<p>mac 清理工具中，CleanMyMac 算是比较知名的一个，但它是收费的，这里介绍一款国产免费的清理工具 - <a href=\"https://lemon.qq.com/\">腾讯柠檬清理</a></p>\n<p><img src=\"../../../images/blog/others/ningmeng_clear.png\" alt=\"ningmeng_clear.png.png\"></p>\n<p>关于柠檬清理与其他同类产品的对比，官方写了一遍总结，可以看看 <a href=\"https://lemon.qq.com/blog/articles/004-lemon-vs-cleanmymac.html\">腾讯柠檬清理，真的比CleanMyMac好用么？</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "mac 其他文件怎么清理，使用免费的腾讯柠檬清理代替 CleanMyMac"
        }
      ],
      "config": {
        "source": "mac 其他文件怎么清理，使用免费的腾讯柠檬清理代替 CleanMyMac.md",
        "staticFileName": "mac_clean.html",
        "author": "guoqzuo",
        "createDate": "2021/09/09",
        "description": "mac 存储空间里面的其他文件占用较多，它主要是一些碎片文件、缓存等，一般不通过工具软件很难清理。如下图：mac 清理工具中，CleanMyMac 算是比较知名的一个，但它是收费的，这里介绍一款国产免费的清理工具 - 腾讯柠檬清理，关于柠檬清理与其他同类产品的对比，官方写了一遍总结，可以看看",
        "keywords": "mac others clean,mac clean, mac 其他清理,mac 其他文件清理,mac 其他文件怎么清理,mac 垃圾清理软件",
        "category": "计算机基础与开发工具",
        "year": "2021",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"vue-data-中以下划线开头的变量为-undefined-eslint-提示-keys-starting-with-_-are-reserved\">vue data 中以下划线开头的变量为 undefined, eslint 提示 Keys starting with &#39;_&#39; are reserved</h1>\n<p>在 vue 中，如果 data 中定义了以下划线开头的变量名，是无法获取到值的，一直是 undefined，为什么会这样呢？如果你安装了 eslint，会自动提示 Keys starting with &#39;_&#39; are reserved in &#39;_test&#39; group(vue/no-reserved-keys). </p>\n<p>在官方文档 API 中有搜索 data 可以查到: <strong>以 _ 或 <code>$</code> 开头的 property 不会被 Vue 实例代理，因为它们可能和 Vue 内置的 property、API 方法冲突</strong></p>\n<p><img src=\"../../../images/blog/vue/vue_data_property.png\" alt=\"vue_data_property.png\"></p>\n<p>另外，如果项目中开启了 ESLint 会自动提示该错误 &quot;vue/no-reserved-keys&quot; 不能使用保留关键字，如下图：</p>\n<p><img src=\"../../../images/blog/vue/data_reserved_eslint.png\" alt=\"data_reserved_eslint.png\"></p>\n<p>因此 ESLint 比我们想象的更加实用，它不仅仅只是单纯的 JS 语法检查。</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "vue data 中以下划线开头的变量为 undefined, eslint 提示 Keys starting with '_' are reserved"
        }
      ],
      "config": {
        "source": "vue data 中以下划线开头的变量为 undefined, eslint 提示 Keys starting with '_' are reserved.md",
        "staticFileName": "vue_data_underline.html",
        "author": "guoqzuo",
        "createDate": "2021/09/09",
        "description": "在 vue 中，如果 data 中定义了以下划线开头的变量名，是无法获取到值的，一直是 undefined，为什么会这样呢？如果你安装了 eslint，会自动提示 Keys starting with '_' are reserved in '_test' group(vue/no-reserved-keys). 在官方文档 API 中有搜索 data 可以查到: 以 _ 或 $ 开头的 property 不会被 Vue 实例代理，因为它们可能和 Vue 内置的 property、API 方法冲突",
        "keywords": "vue data 中 _ 开头的变量为 undefined,data 下划线开头的变量,vue _ 开头的变量,vue  Keys starting with '_' are reserved",
        "category": "Vue",
        "year": "2021",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"spring-boot-怎么解决跨域问题-使用注解-完整测试-demo-已传-github\">Spring Boot 怎么解决跨域问题: 使用注解, 完整测试 demo 已传 github</h1>\n<p>根据 Spring 官网 <a href=\"https://spring.io/guides/gs/rest-service/\">Building a RESTful Web Service</a> 写了一个测试接口，在使用时，需要让该接口支持跨域，理论上只要设置好对应的响应头、处理好 Options 请求预检就可以，但发现貌似没有处理 OPTIONS 请求的注解。需要一些特殊设置处理。</p>\n<p>后面发现有一个非常简单的方法来允许跨域，就是使用  <code>@CrossOrigin</code> 注解，使用方法如下</p>\n<pre><code class=\"language-java\">package com.zuo11.demo;\n\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\n\n@RestController\npublic class GreetingController {\n\n    private static final String template = &quot;Hello, %s!&quot;;\n  private static final String templatePost = &quot;Post, %s!&quot;;\n    private final AtomicLong counter = new AtomicLong();\n\n    @GetMapping(&quot;/greeting&quot;)\n    public Greeting greeting(@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;) String name) {\n        return new Greeting(counter.incrementAndGet(), String.format(template, name));\n    } \n\n  // @PostMapping(&quot;/greeting&quot;) // @RequestBody \n    // public Greeting greetingPost(@RequestBody Greeting newGreeting) {\n    //     return new Greeting(counter.incrementAndGet(), String.format(templatePost, newGreeting.getContent()));\n    // }\n\n  @CrossOrigin(origins = &quot;*&quot;,maxAge = 3600) // 跨域注解\n  @PostMapping(&quot;/greeting&quot;) // @RequestBody \n    public ResponseEntity&lt;Greeting&gt; greetingPost(@RequestBody Greeting newGreeting) {\n        Greeting greeting = new Greeting(counter.incrementAndGet(), String.format(templatePost, newGreeting.getContent()));\n\n    HttpHeaders responseHeaders = new HttpHeaders();\n    // responseHeaders.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n    // responseHeaders.set(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;);\n    // responseHeaders.set(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);\n\n    return new ResponseEntity&lt;&gt;(greeting, responseHeaders, HttpStatus.OK);\n    }\n}</code></pre>\n<h2 id=\"接口\">接口</h2>\n<ul>\n<li>GET <code>http://localhost:9900/greeting</code><ul>\n<li>query 参数: name=string</li>\n<li>response JSON: { id: 自增id,  &quot;content&quot;: &quot;Hello, ${name}!&quot; }</li>\n</ul>\n</li>\n<li>POST <code>http://localhost:9900/greeting</code><ul>\n<li>参数 application/json，{ id: &#39;&#39;,  &quot;content&quot;: &quot;kevin&quot; }</li>\n<li>response JSON: { id: 自增id,  &quot;content&quot;: &quot;Hello, ${content}!&quot; }</li>\n</ul>\n</li>\n</ul>\n<p>允许跨域、前端请求</p>\n<pre><code class=\"language-html\">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n  axios.post(&#39;http://localhost:9900/greeting&#39;, {\n    &quot;id&quot;: 1,\n    &quot;content&quot;: &quot;测试&quot;\n  }).then((res) =&gt; {\n    console.log(&#39;请求成功，&#39;, res)\n  }, (err) =&gt; {\n    console.log(&#39;请求发生了错误,&#39;, err)\n  })\n&lt;/script&gt;</code></pre>\n<p>完整 demo 参见：<a href=\"https://github.com/zuoxiaobai/springboot-demo\">springboot-demo | github</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "Spring Boot 怎么解决跨域问题: 使用注解, 完整测试 demo 已传 github",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "接口"
            }
          ]
        }
      ],
      "config": {
        "source": "Spring Boot 怎么解决跨域问题: 使用注解, 完整测试 demo 已传 github.md",
        "staticFileName": "spring_boot_allow_cross.html",
        "author": "guoqzuo",
        "createDate": "2021/09/09",
        "description": "根据 Spring 官网 Building a RESTful Web Service (opens new window) 写了一个测试接口，在使用时，需要让该接口支持跨域，理论上只要设置好对应的响应头、处理好 Options 请求预检就可以，但发现貌似没有处理 OPTIONS 请求的注解。需要一些特殊设置处理。后面发现有一个非常简单的方法来允许跨域，就是使用 @CrossOrigin 注解，使用方法如下",
        "keywords": "spring boot 解决跨域, spring boot 允许跨域, spring boot 通过注解允许跨域",
        "category": "后端数据库等",
        "year": "2021",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"什么是-mvc-什么是-mvvm-怎么理解-mvc-与-mvvm，mvc-和-mvvm-有什么区别？\">什么是 mvc, 什么是 mvvm, 怎么理解 mvc 与 mvvm，mvc 和 mvvm 有什么区别？</h1>\n<p>每个新技术的出现都有其历史原因，MVVM 也是如此。Vue 就是基于 MVVM 模式。那什么是 MVVM 构架模式，和 MVC 模式有什么区别呢？</p>\n<p>在介绍 MVVM 之前，我们先需要了解什么是 MVC 模式</p>\n<p>在 ajax 技术没有出现之前，<strong>html 页面中发送 http 请求会刷新整个页面</strong>。页面内容强依赖后端接口响应的内容，于是催生了 jsp、php、asp 等前后端都耦合在一起的技术。下面来看一个实例</p>\n<pre><code class=\"language-html\">&lt;!-- login 页面 --&gt;\n&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;\n  &lt;input type=&quot;text&quot; name=&quot;um&quot; placeholder=&quot;请输入账号&quot;/&gt;\n  &lt;input type=&quot;password&quot; name=&quot;pw&quot; placeholder=&quot;请输入密码&quot;/&gt;\n  &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;\n&lt;/form&gt;</code></pre>\n<p>登录页面中，点击登录，页面会重定向到 /login 发送 post 请求给后端，后端处理好后，返回登录成功后的 html 文本，浏览器拿到 html 文本渲染页面，这就完成了登录功能。</p>\n<p>为了更好的组织代码、解耦各个部分，MVC 模式被引入到 web 开发，比如 Struts、Spring MVC</p>\n<p><img src=\"../../../images/blog/vue/mvc.png\" alt=\"mvc.png\"></p>\n<p>MVC 是一种经典的设计模式，是 Model-View-Controller 的缩写，即模型-视图-控制器。</p>\n<ul>\n<li>Model 模型 对应数据 Java 类</li>\n<li>View 视图 对应 JSP 页面显示（服务端渲染）</li>\n<li>Controller 控制器 Servlet，用于处理客户端 HTTP 请求、加工模型数据、再响应对应的视图(html)给客户端</li>\n</ul>\n<p><img src=\"../../../images/blog/vue/structs_mvc.png\" alt=\"structs_mvc.png\"></p>\n<p>MVC 在不同的平台有不同的实现，比如 iOS MVC、ASP.NET MVC、Spring MVC 等，细节参考：<a href=\"https://draveness.me/mvx/\">浅谈 MVC、MVP 和 MVVM 架构模式</a>，这种构架模式的出现主要是为了解耦模块，将不同的功能模块分散到合适的位置中，提高开发维护效率。</p>\n<p>假设前端有 MVC 模式，M 对应数据 js 对象、V 对应视图 html。如果遵循 MVC 模式，C 用来解耦 M、V。那 C (控制器)负责的事情就比较多，主要是处理事件流</p>\n<ul>\n<li>绑定 UI 表单交互事件</li>\n<li>接收到事件后处理业务逻辑</li>\n<li>业务逻辑可能会请求接口获取/操作 M 数据</li>\n<li>根据需要操作 dom 更新 V</li>\n</ul>\n<p>由于 JS DOM API 在使用复杂度、兼容性方面需要较多的处理，像 jQuery 这种易于绑定事件，操作 dom 的框架开始流行起来，使用 jQuery 你不需要考虑 DOM API 兼容性、且操作 dom 简单，ajax 请求简单，提升了开发效率。</p>\n<p>后面随着 ajax、移动端、小程序等多平台的兴起，前后端分离的概念出现了，写一套接口各个平台适用，而不是单纯的写接口渲染 web 页面。MVC 在后端 View 这一层不再是 UI，而是改为返回 JSON 模型数据，多端兼容。</p>\n<p>当然前后端分离也有缺点，不利于 SEO，这也催生了服务端渲染 SSR 框架的产生。</p>\n<p>MVVM 设计模式是 Model-View-ViewModel 的缩写，模型-视图-视图模型，是 MVC 的一种发展</p>\n<p><img src=\"../../../images/blog/vue/mvvm.png\" alt=\"mvvm.png\"></p>\n<p>viewModel 主要实现了双向绑定，一般在框架内部实现：</p>\n<ul>\n<li>数据模型 M 和视图 V 通过 viewModel 绑定，只要修改了 数据模型 M ，viewModel 会自动帮你操作 dom 更新 视图。</li>\n<li>视图 V 表单输入变化，viewModel 会自动将输入内容同步到 M 数据模型中</li>\n</ul>\n<p>Vue 是类似 MVVM 模式的一种实现，使用 Vue 后，无需再手动操作 dom，只需改变数据即可。这样极大提升了开发效率，可以抽出更多的时间来关注业务逻辑。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\">MVC，MVP 和 MVVM 的图示 - 阮一峰的网络日志</a></li>\n<li><a href=\"https://baijiahao.baidu.com/s?id=1596277899370862119&amp;wfr=spider&amp;for=pc\">什么是MVVM，MVC和MVVM的区别，MVVM框架VUE实现原理</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\">Model–view–controller - Wikipedia</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel\">Model–view–viewmodel - Wikipedia</a></li>\n</ul>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "什么是 mvc, 什么是 mvvm, 怎么理解 mvc 与 mvvm，mvc 和 mvvm 有什么区别？"
        }
      ],
      "config": {
        "source": "什么是 mvc, 什么是 mvvm, 怎么理解 mvc 与 mvvm，mvc 和 mvvm 有什么区别？.md",
        "staticFileName": "mvc_vs_mvvm.html",
        "author": "guoqzuo",
        "createDate": "2021/09/09",
        "description": "每个新技术的出现都有其历史原因，MVVM 也是如此。Vue 就是基于 MVVM 模式。那什么是 MVVM 构架模式，和 MVC 模式有什么区别呢？在介绍 MVVM 之前，我们先需要了解什么是 MVC 模式。在 ajax 技术没有出现之前，html 页面中发送 http 请求会刷新整个页面。页面内容强依赖后端接口响应的内容，于是催生了 jsp、php、asp 等前后端都耦合在一起的技术。下面来看一个实例",
        "keywords": "什么是 mvc,什么是 mvvm,怎么理解 mvc, mvc 与 mvvm 的区别,mvc,mvvm",
        "category": "Vue",
        "year": "2021",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"nginx-emerg-bind-to-000080-failed-10013-80-端口被占用\">nginx emerg bind to 0.0.0.0:80 failed &lt;10013, 80 端口被占用</h1>\n<p>最近由于服务器非常卡顿，于是重启了服务器，重启后发现开启 nginx 时，报错 nginx emerg bind to 0.0.0.0:80 failed &lt;10013:，<strong>这个错误一般是 80 端口被占用的问题，访问 <a href=\"http://127.0.0.1\">http://127.0.0.1</a> 看看 80 端口的情况</strong>，发现是 Java 服务，检查后发现 tomcat 开了，它占用了 80 端口，关掉 tomcat，再次运行就可以了。</p>\n<p><img src=\"../../../images/blog/ops/80_port.png\" alt=\"80_port.png\"></p>\n<p>参考：<a href=\"https://blog.csdn.net/zero_295813128/article/details/50914233\">Nginx 错误处理方法: bind() to 0.0.0.0:80 failed</a></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "nginx emerg bind to 0.0.0.0:80 failed <10013, 80 端口被占用"
        }
      ],
      "config": {
        "source": "nginx emerg bind to 0.0.0.0:80 failed <10013, 80 端口被占用.md",
        "staticFileName": "mginx_80_port.html",
        "author": "guoqzuo",
        "createDate": "2021/09/09",
        "description": "重启服务器后发现开启 nginx 时，报错 nginx emerg bind to 0.0.0.0:80 failed <10013:，这个错误一般是 80 端口被占用的问题，访问 http://127.0.0.1 看看 80 端口的情况，发现是 Java 服务，检查后发现 tomcat 开了，它占用了 80 端口，关掉 tomcat，再次运行就可以了。",
        "keywords": "nginx 80 端口被占用,emerg bind to 0.0.0.0:80 failed",
        "category": "运维部署与版本控制",
        "year": "2021",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"js-点击按钮复制内容的实现-使用-eleselect-加-documentexeccommandcopy\">js 点击按钮复制内容的实现, 使用 ele.select 加 document.execCommand(&#39;copy&#39;)</h1>\n<p>点击按钮复制链接、复制代码在前端是比较常见的需求，这里介绍一种比较简单的实现：</p>\n<ol>\n<li>先借用 input 等可以选中文本的元素，调用 element.select() 选中文本内容</li>\n<li>再执行 document.execCommand(&quot;copy&quot;) 对选中内容进行复制</li>\n</ol>\n<p>我们可以通过下面的例子来了解这个过程，<a href=\"https://zuoxiaobai.github.io/fedemo/src/DebugDemo/%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E5%A4%8D%E5%88%B6%E9%93%BE%E6%8E%A5/\">点击按钮复制内容 - 在线演示</a></p>\n<pre><code class=\"language-html\">&lt;body&gt;\n  &lt;input id=&quot;inputText&quot; value=&quot;abcde&quot;&gt;\n  &lt;button onclick=&quot;execCopy()&quot;&gt;点击按钮复制内容&lt;/button&gt;\n  &lt;script&gt;\n    function execCopy() {\n      let element = document.querySelector(&quot;#inputText&quot;);\n      element.select();\n      document.execCommand(&quot;copy&quot;);\n    }\n  &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p>实际使用中，我们需要清楚两点：</p>\n<ol>\n<li>我们设置的内容是动态的，需要动态设置 input 内容</li>\n<li>我们不需要在页面上显示 input 内容，需要动态创建元素，并隐藏元素</li>\n</ol>\n<p>我们可以将该功能封装成一个可复用的函数，如下</p>\n<pre><code class=\"language-js\">// 复制内容\nfunction copyContent(text) {\n    // 动态创建 input 元素，设置内容\n    let element = document.createElement(&#39;input&#39;)\n    element.setAttribute(&#39;value&#39;, text)\n    // 隐藏 input\n    element.style.position = &#39;absolute&#39;\n    element.style.top = &#39;-1000px&#39;\n    element.style.display = &#39;block&#39;\n    // 挂载到 body\n    document.body.appendChild(element)\n    // 复制\n    element.select()\n    document.execCommand(&quot;Copy&quot;);\n    // 复制完成后从 body 移除\n    document.body.removeChild(element)\n}</code></pre>\n<p>实际使用示例</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n  &lt;button onclick=&quot;execCopy()&quot;&gt;点击按钮复制内容&lt;/button&gt;\n  &lt;p id=&quot;randomText&quot;&gt;&lt;/p&gt;\n  &lt;textarea&gt;&lt;/textarea&gt;\n  &lt;script&gt;\n    // 复制内容\n    function copyContent(text) {\n      // 动态创建 input 元素，设置内容\n      let element = document.createElement(&#39;input&#39;)\n      element.setAttribute(&#39;value&#39;, text)\n      // 隐藏 input\n      element.style.position = &#39;absolute&#39;\n      element.style.top = &#39;-1000px&#39;\n      element.style.display = &#39;block&#39;\n      // 挂载到 body\n      document.body.appendChild(element)\n      // 复制\n      element.select()\n      document.execCommand(&quot;Copy&quot;);\n      // 复制完成后从 body 移除\n      document.body.removeChild(element)\n    }\n\n    // 生成 len 长度的随机字符串\n    function getRandomStr(len) {\n      // ascii 编码转 字符串，String.fromCharCode(65)  65 &quot;A&quot;, 97 &quot;a&quot;, 48 &quot;0&quot;\n      // 字符串转 ascii 编码, &quot;a&quot;.charCodeAt(0)\n      let result = &#39;&#39;\n      for (let i = 0; i &lt; len; i++) {\n        result += String.fromCharCode(97 + Math.random() * 25 + 1) // 0 ~ 25\n      }\n      return result\n    }\n\n    function execCopy() {\n      // 生成随机字符串\n      let text = getRandomStr(10)\n      document.querySelector(&#39;#randomText&#39;).innerHTML = text\n      copyContent(text) // 复制内容\n    }\n  &lt;/script&gt;\n&lt;/body&gt;</code></pre>\n<p>完整代码参见：<a href=\"https://github.com/zuoxiaobai/fedemo/tree/master/src/DebugDemo/%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E5%A4%8D%E5%88%B6%E9%93%BE%E6%8E%A5\">点击按钮复制内容 - demo</a>，如果觉得有用，可以帮忙 star、fork，谢谢啦！</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "js 点击按钮复制内容的实现, 使用 ele.select 加 document.execCommand('copy')"
        }
      ],
      "config": {
        "source": "js 点击按钮复制内容的实现, 使用 ele.select 加 document.execCommand('copy').md",
        "staticFileName": "js_copy.html",
        "author": "guoqzuo",
        "createDate": "2021/09/09",
        "description": "点击按钮复制链接、复制代码在前端是比较常见的需求，这里介绍一种比较简单的实现：1.先借用 input 等可以选中文本的元素，调用 element.select() 选中文本内容 2.再执行 document.execCommand('copy') 对选中内容进行复制 我们可以通过下面的例子来了解这个过程，点击按钮复制内容 - 在线演示",
        "keywords": "js 点击按钮复制内容实现,js 向粘贴板写入内容,js copy text",
        "category": "JavaScript",
        "year": "2021",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"js-iftrue-代码块中函数和变量同名时作用域提升问题，chrome-devtools-snippets-断点调试\">js if(true) 代码块中函数和变量同名时作用域提升问题，Chrome Devtools Snippets 断点调试</h1>\n<p>在 JS 代码块中变量和函数同名，作用域怎么提升的问题是比较难以理解的，对于不同的浏览器还有不同的结果，下面来看几个例子：</p>\n<p>我们可以通过 Chrome 浏览器中的 DevTools - Sources - Snippets 中利用断点调试的功能来看浏览器是如何一步步执行的。</p>\n<p><img src=\"../../../images/blog/js/chrome_snippets_debug.png\" alt=\"chrome_snippets_debug.png\"></p>\n<h2 id=\"示例-1\">示例 1</h2>\n<p>下面的例子中，里面的 a 为 21 是没有争议的，主要是为什么外面的 a 值会为 1(chrome) 或 21(safari)，用上面的方法来进行 Chrome 断点调试</p>\n<pre><code class=\"language-js\">var a = 0;\nif (true) { // global 作用域  a 为 0，\n  // 执行到这里时，函数会被提升 block 块级作用域中 a 为 function () {}\n    a = 1;\n  // 上面的 a = 1 执行后，block 作用域中 a 为 1 可以理解，但奇怪的是 global 作用域 a 也被设置为了 1\n    function a() { }\n    a = 21; // 这一句执行后 block 作用域中 a 为 21，全局 global 为 1\n    console.log(`里面:${a}`)\n}\nconsole.log(`外面:${a}`)</code></pre>\n<p>Chrome 版本 91.0.4472.114 / Firefox 89.0 (64 位) 结果</p>\n<pre><code class=\"language-js\">里面:21 \n外面:1</code></pre>\n<p>Safari 14.0.3 (16610.4.3.1.7) 结果</p>\n<pre><code class=\"language-js\">里面:21\n外面:21</code></pre>\n<h2 id=\"示例-2\">示例 2</h2>\n<pre><code class=\"language-js\">{\n    function a() {};\n    a = 50;\n}\nconsole.log(a); // ƒ a() {}\n{\n    b = 50;\n    function b() {};\n}\nconsole.log(b); // 50</code></pre>\n<p>总结：这种问题，我们一般会陷入一个误区，就是通过 chrome 的结果来倒推，可能是怎么执行的。</p>\n<p>但你会发现可能还是比较难理解。<strong>这种问题基本是没有意义的，正常情况下，不会有变量和函数同名，也不会这样使用</strong>，除非去研究 Chrome v8 引擎的源码，看看是怎么执行的，不然对于非专家级别的开发者来说，是没必要深入到这一步的。</p>\n<p><strong>如果不是从内核源码来剖析，瞎猜没有任何说服力。</strong></p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "js if(true) 代码块中函数和变量同名时作用域提升问题，Chrome Devtools Snippets 断点调试",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "示例 1"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "示例 2"
            }
          ]
        }
      ],
      "config": {
        "source": "js if(true) 代码块中函数和变量同名时作用域提升问题，Chrome Devtools Snippets 断点调试.md",
        "staticFileName": "js_hoisting.html",
        "author": "guoqzuo",
        "createDate": "2021/09/09",
        "description": "在 JS 代码块中变量和函数同名，作用域怎么提升的问题是比较难以理解的，对于不同的浏览器还有不同的结果，下面来看几个例子，我们可以通过 Chrome 浏览器中的 DevTools - Sources - Snippets 中利用断点调试的功能来看浏览器是如何一步步执行的。",
        "keywords": "js hoisting,js 函数提升,js 变量提升,Chrome Devtools Snippets 断点调试",
        "category": "JavaScript",
        "year": "2021",
        "month": "9"
      }
    },
    {
      "htmlStr": "<h1 id=\"node-自动化部署、持续集成的核心原理-node-可以执行-shell-脚本--可以监听请求\">node 自动化部署、持续集成的核心原理: node 可以执行 shell 脚本 + 可以监听请求</h1>\n<p>node 可以用来支撑实现自动化部署、持续集成，核心原理是：</p>\n<ol>\n<li>node 可以执行 shell 脚本，而部署流程一般都是写在 shell 脚本中的。</li>\n<li>node 可以作为服务器 server, 当接收到请求后，根据条件判断是否执行部署的 shell 脚本。</li>\n</ol>\n<p>我们这里结合 github webhooks 来实现持续集成，自动化部署，关键细节在于：</p>\n<ol>\n<li>github 对应仓库 Settings - Webhooks，配置当仓库发生变化时（比如 push 操作）请求一个自定义接口地址</li>\n<li>github 请求这个接口地址时，我们需要做一些校验，github-webhook-handler npm 包帮我们做好了，直接使用即可，当接收到 main 分支 push 请求时，使用 node 的 child_process.spawn 可以执行 shell 脚本进行部署。</li>\n</ol>\n<p>整个过程概要</p>\n<ol>\n<li>提交新的内容到 github 仓库，github 仓库接收到 push 事件，触发对应的 webhooks 事件，向设置的一个 URL 发送 POST 请求。</li>\n<li>我们专门用一个 node 接口来接收该请求。接收到请求后，如果是 main 分支的 push 事件，用 node 执行 shell 脚本（.sh 文件）</li>\n<li>本地 shell 脚本用于 git pull 最新代码，并重启服务运行最新代码（比如使用 docker-compose up 部署最新代码）</li>\n</ol>\n<p>下面来看具体怎么操作</p>\n<h2 id=\"配置github-webhooks\">配置github webhooks</h2>\n<p>将项目文件放到 github 仓库，然后在对应的仓库，setting、选择 webhooks，添加 webhooks，如下图</p>\n<p><img src=\"../../../images/blog/node/github_webhooks_1.png\" alt=\"github_webhooks_1.png\"></p>\n<p>新建一个 webhooks，有下面几个字段</p>\n<ul>\n<li>Payload URL: <code>http://www.xxx.com:8800/docker_deploy</code> ，发送post请求的地址，你自己的服务器要处理该请求。测试时可以用 IP 地址</li>\n<li>Content type: application/json，发送数据类型，一般选json，方便处理</li>\n<li>secret: xxx  秘钥，做验证用，接口处理是需要使用</li>\n<li>which events would you like to trigger this webhook? 触发该接口的时机我们选择仅 push 时触发 </li>\n</ul>\n<p><img src=\"../../../images/blog/node/github_webhooks_2.png\" alt=\"github_webhooks_2.png\"></p>\n<p>新增 webhooks 后，可以发测试请求，点击 redeliver 弹窗提示后再点击确认，这样就可以调试接口了。如下图</p>\n<p><img src=\"../../../images/blog/node/github_webhooks_3.png\" alt=\"github_webhooks_3.png\"></p>\n<h2 id=\"写-node-接口来处理-webhooks-请求\">写 node 接口来处理 webhooks 请求</h2>\n<p>我们用一个简单的 nodejs 文件，在 8800 端口新建一个接口来处理 github webhooks 的请求，先写一个简单的测试 js</p>\n<pre><code class=\"language-js\">// webhook.js\nconst http = require(&#39;http&#39;)\nconst createHandler = require(&#39;github-webhook-handler&#39;)\nconst handler = createHandler({\n  path:&#39;/docker_deploy&#39;,\n  secret:&#39;xxx&#39; // 之间设置的秘钥\n})\n\nhttp.createServer((req,res) =&gt; {\n  handler(req,res,err =&gt; {\n    res.statusCode = 404\n    res.end(&#39;no such location&#39;)\n  })\n}).listen(8800, () =&gt; {\n  console.log(&#39;Webhook listen at 8800&#39;)\n})\n\nhandler.on(&#39;error&#39;,err =&gt; {\n  console.error(&#39;Error&#39;,err.message)\n})\n\n// 接收所有事件(包括push事件)打印日志\nhandler.on(&#39;*&#39;,event =&gt; {\n  console.log(&#39;Received * &#39;,event.payload)\n})</code></pre>\n<p>我们要在服务器跑起这个服务需要先在 ubuntu 系统上安装 node/npm</p>\n<pre><code class=\"language-bash\"># 默认安装方法\nsudo apt-get install -y nodejs\nsudo apt install npm\n\n# ubuntu 安装node版本过低，怎么解决\nnode -v # v8.10.0\nnpm -v # 3.5.2\n\n# 将node升级到最新稳定版\nsudo npm cache clean -f\nsudo npm install -g n\nsudo n stable\nPATH=&quot;$PATH&quot; # 立即在终端生效\n\n# 再查看版本就是最新稳定版了\nnode -v # v12.18.4\nnpm -v # 6.14.6</code></pre>\n<p>参考：<a href=\"https://blog.csdn.net/skylark0924/article/details/79306999\">使用apt-get install安装node.js导致安装成低版本的解决方案 | CSDN</a></p>\n<p>注意 npm init 一个 package.json，并安装 github-webhook-handler 模块，再 <code>nodemon webhook.js</code> 开启服务，也可以把 nodemon webhook.js 使用 pm2 来管理。然后再在 github webhooks 里触发测试请求，当看到 Received * log，即表示接收成功，如下图：</p>\n<p><img src=\"../../../images/blog/node/github_webhooks_4.png\" alt=\"github_webhooks_4.png\"></p>\n<h2 id=\"sh脚本：拉取最新代码，重新部署\">sh脚本：拉取最新代码，重新部署</h2>\n<p>这里已经知道如何接收事件了，我们再在 webhook.js 里加入执行 shell 脚本的代码</p>\n<pre><code class=\"language-js\">// 使用子进程执行命令\nfunction run_cmd(cmd, args, callback) {\n  var spawn = require(&#39;child_process&#39;).spawn;\n  var child = spawn(cmd, args);\n  var resp = &quot;&quot;;\n  child.stdout.on(&#39;data&#39;, function (buffer) { resp += buffer.toString(); });\n  child.stdout.on(&#39;end&#39;, function () { callback(resp) });\n}\n\n// 接收到 push 事件时，执行 sh ./deploy-master.sh\nhandler.on(&#39;push&#39;, function (event) {\n  console.log(&#39;Received a push event for %s to %s&#39;, event.payload.repository.name, event.payload.ref);\n  // 分支判断，如果是master，已改名 main\n  if(event.payload.ref === &#39;refs/heads/main&#39;){\n    console.log(&#39;deploy main..&#39;)\n    run_cmd(&#39;sh&#39;, [&#39;./deploy-master.sh&#39;], function(text){ console.log(text) });\n  }\n})</code></pre>\n<p>在当前目录新建一个 deploy-master.sh 文件，内容先只有 <code>ls</code>，用于测试，修改代码后，再次测试，如下图，ls执行成功过即表示代码正常。</p>\n<p><strong>注意，1. 模拟请求可能会拿不到 event.payload.ref 的值，需要出发真实的 push 请求才有 2.如果 deploy-master.sh 没有可执行权限，那么就需要执行 chmod +x 文件名，来给他加可执行权限</strong></p>\n<p><img src=\"../../../images/blog/node/github_webhooks_5.png\" alt=\"github_webhooks_5.png\"></p>\n<p>修改部署脚本</p>\n<pre><code class=\"language-bash\"># 测试\n# ls\n\n# deploy-master.sh\necho &quot;Start Deploy&quot;\n\n# 获取最新版代码\ngit pull\n\n# 停止原先的镜像实例(容器)\ndocker-compose down\n# 重新build，创建实例化镜像(容器)\ndocker-compose up -d --force-recreate --build</code></pre>\n<p>这里要注意 git pull 的问题。我们这里要放弃之间 vscode 插件部署的方法，要使用 git pull 的方式来更新部署代码，这样才不会有冲突。</p>\n<p>这里我们要先在 ubuntu 系统里 git clone github的仓库，建议使用 ssh 的方法， 使用 <code>ssh-keygen -t rsa -C &quot;xxx@qq.com&quot;</code> 生成公钥私钥，然后再把公钥配置到 github 个人账号 setting 里的 ssh keys里面。就可以使用 ssh 地址正常拉取了。</p>\n<p>这样就可以实现提交代码到 main 分支就自动部署最新代码了</p>\n",
      "outline": [
        {
          "type": "heading",
          "depth": 1,
          "text": "node 自动化部署、持续集成的核心原理: node 可以执行 shell 脚本 + 可以监听请求",
          "children": [
            {
              "type": "heading",
              "depth": 2,
              "text": "配置github webhooks"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "写 node 接口来处理 webhooks 请求"
            },
            {
              "type": "heading",
              "depth": 2,
              "text": "sh脚本：拉取最新代码，重新部署"
            }
          ]
        }
      ],
      "config": {
        "source": "node 自动化部署、持续集成的核心原理: node 可以执行 shell 脚本 + 可以监听请求.md",
        "staticFileName": "node_ci_cd.html",
        "author": "guoqzuo",
        "createDate": "2021/09/09",
        "description": "node 可以用来支撑实现自动化部署、持续集成，核心原理是：1. node 可以执行 shell 脚本，而部署流程一般都是写在 shell 脚本中的。2. node 可以作为服务器 server, 当接收到请求后，根据条件判断是否执行部署的 shell 脚本。我们这里结合 github webhooks 来实现持续集成，自动化部署",
        "keywords": "node 自动化部署,node持续集成,node ci,node cd,node webhooks,github webhooks",
        "category": "运维部署与版本控制",
        "year": "2021",
        "month": "9"
      }
    }
  ],
  "count": 434,
  "config": {
    "title": "左小白的技术日常",
    "isAddBaiduTongji": true,
    "baiduTongjiId": "183281668cc3440449274d1f93c04de6",
    "indexConfig": {
      "author": "guoqzuo",
      "description": "左小白的技术日常，主要记录和分享web前端领域相关的理解、总结、观点。偶尔会进行一些扩展：比如网站建设、服务器运维、后台数据库等",
      "keywords": "左小白,左小白的技术日常,zuo11.com",
      "linkList": [
        {
          "name": "博客",
          "href": "/blog/category.html"
        },
        {
          "name": "我的笔记",
          "href": "http://fe.zuo11.com",
          "target": "_black"
        },
        {
          "name": "Github",
          "href": "https://github.com/zuoxiaobai",
          "target": "_black"
        }
      ]
    },
    "topRightLink": [
      {
        "name": "我的笔记",
        "href": "http://fe.zuo11.com",
        "target": "_black"
      },
      {
        "name": "Github",
        "href": "https://github.com/zuoxiaobai",
        "target": "_black"
      }
    ],
    "footer": {
      "left": "Copyright © 2016-2021 zuo11.com. <a href='http://beian.miit.gov.cn/'>鄂ICP备16014741号-1</a>",
      "right": "Powered by <a href='https://github.com/zuoxiaobai/zuo-blog' target='_black'>zuo-blog</a>"
    },
    "categorySequence": [
      "Vue",
      "JavaScript",
      "CSS",
      "http与https",
      "前端工程化",
      "React",
      "运维部署与版本控制",
      "计算机基础与开发工具",
      "图表可视化",
      "网站建设与SEO",
      "TypeScript",
      "微信开发",
      "移动端混合开发",
      "后端数据库等",
      "iOS",
      "C与APUE"
    ],
    "asideTopHtml": "<ins class='adsbygoogle' style='display:block;width:300px;height:250px;' data-ad-client='ca-pub-9527676606416641' data-ad-slot='9476232907'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>",
    "commentTopHtml": "<ins class='adsbygoogle' style='display:block;margin-top:1em;margin-bottom:0' data-ad-format='fluid' data-ad-layout-key='-gw-3+1f-3d+2z' data-ad-client='ca-pub-9527676606416641' data-ad-slot='8870245163'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>",
    "articleTopHtml": "<ins class='adsbygoogle' style='display:block; text-align:center;' data-ad-layout='in-article' data-ad-format='fluid' data-ad-client='ca-pub-9527676606416641' data-ad-slot='5125924359'></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>",
    "_isGlobalJsFileExists": true,
    "_isGlobalCssFileExists": true,
    "bodyFragment": "<!-- Global site tag (gtag.js) - Google Analytics -->\n<!-- <script async src=\"https://www.googletagmanager.com/gtag/js?id=UA-178732583-1\"></script> -->\n<script>\n  // window.dataLayer = window.dataLayer || [];\n  // function gtag(){dataLayer.push(arguments);}\n  // gtag('js', new Date());\n  // gtag('config', 'UA-178732583-1');\n\n  window.onload = function() {\n    setTimeout(function() {\n      let script = document.createElement(\"script\");\n      script.setAttribute(\"data-ad-client\", \"ca-pub-9527676606416641\");\n      script.setAttribute(\"async\", \"\");\n      script.src = \"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\";\n      document.body.appendChild(script);\n    }, 200);\n  }\n</script>\n"
  }
}